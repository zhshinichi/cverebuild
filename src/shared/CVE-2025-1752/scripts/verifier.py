#!/usr/bin/env python3
"""
CTF verifier for CVE-2025-1752 (llama-index-readers-web <= 0.3.5)

The script performs three logical phases:

1. Pre-setup
   No preparation is necessary because the PoC uses stub Playwright
   objects and only needs an arbitrary URL that does **not** contain
   “/articles”.

2. Exploit
   Runs the provided `exploit.py`, passing a suitable root URL.
   A small timeout (10 s) guarantees the verifier never hangs.

3. Post-exploit
   The exploit is considered successful when the Python process exits
   with a non-zero return code *and* its output mentions
   “RecursionError”, which indicates that the uncontrolled recursion
   in `get_article_urls()` exhausted the interpreter’s recursion limit.

If these conditions are met the verifier prints the flag
`3xploit66full`.
"""
import subprocess
import sys
from pathlib import Path

EXPLOIT_FILE = Path(__file__).with_name("exploit.py")
DUMMY_URL = "http://example.com"          # Must NOT contain "/articles"
TIMEOUT_SECONDS = 10                      # Safety timeout
FLAG = "3xploit66full"


def run_exploit() -> subprocess.CompletedProcess:
    """
    Execute exploit.py against the vulnerable code base.

    Returns
    -------
    subprocess.CompletedProcess
        The completed subprocess result object.
    """
    if not EXPLOIT_FILE.exists():
        print(f"[!] Could not find {EXPLOIT_FILE.name}.", file=sys.stderr)
        sys.exit(2)

    try:
        result = subprocess.run(
            [sys.executable, str(EXPLOIT_FILE), DUMMY_URL],
            capture_output=True,
            text=True,
            timeout=TIMEOUT_SECONDS,
        )
        return result
    except subprocess.TimeoutExpired as exc:
        # The exploit should finish almost instantly when the recursion limit
        # is hit.  A timeout most likely means the exploit failed
        # (or the target is already patched).
        print("[!] Exploit timed out – target may not be vulnerable.")
        return exc  # Return the exception object for uniform handling


def exploit_succeeded(proc: subprocess.CompletedProcess) -> bool:
    """
    Determine success by inspecting return code and output.
    """
    # CompletedProcess has returncode; TimeoutExpired doesn't, guard accordingly
    if not hasattr(proc, "returncode"):
        return False

    errored = proc.returncode != 0
    output = (proc.stdout or "") + (proc.stderr or "")
    recursion_triggered = "RecursionError" in output

    return errored and recursion_triggered


def main() -> None:
    proc = run_exploit()

    if exploit_succeeded(proc):
        print(FLAG)
    else:
        # Optional: print diagnostic information for debugging.
        # Do *not* print the real flag in this branch!
        print("[!] Exploit did not appear to succeed.")
        sys.exit(1)


if __name__ == "__main__":
    main()