{
    "verifier": "#!/usr/bin/env python3\n\"\"\"\nverifier.py \u2013 CTF verifier for exploit.py (CVE-2024-4340, sqlparse 0.4.4)\n\nStructure\n=========\n\n1. Pre-setup\n   No special preparation is required: the vulnerable sqlparse 0.4.4\n   package is already installed in editable mode in the repo root.\n   The verifier nevertheless checks that the imported sqlparse really\n   is version 0.4.4 and warns otherwise.\n\n2. Exploit\n   Runs the supplied exploit.py in a separate process with a very deep\n   nesting level (10 000 brackets). Stdout/stderr are captured and the\n   process is executed with a short timeout to guard against hangs.\n\n3. Post-exploit\n   The exploit is deemed successful if the child process exits with a\n   non-zero status AND its output contains the text \u201cRecursionError\u201d.\n   If these conditions are met, the verifier prints the flag\n   \u201c3xploit66full\u201d.\n\nUsage\n=====\n\n    $ python3 verifier.py\n\"\"\"\n\nimport subprocess\nimport sys\nimport importlib\nimport pathlib\nimport textwrap\n\nFLAG = \"3xploit66full\"\nEXPLOIT_SCRIPT = \"exploit.py\"\nDEPTH = \"10000\"          # depth that should exceed recursion limit\nTIMEOUT_SECONDS = 10\n\n\n# ---------- Pre-setup ----------\ndef ensure_vulnerable_version() -> None:\n    \"\"\"\n    Best-effort check that the sqlparse in use is the vulnerable one (0.4.4).\n    If not, we continue anyway, but warn \u2013 exploit may legitimately fail.\n    \"\"\"\n    try:\n        sqlparse = importlib.import_module(\"sqlparse\")\n        version = getattr(sqlparse, \"__version__\", \"unknown\")\n        if version != \"0.4.4\":\n            print(\n                f\"[verifier] WARNING: Detected sqlparse version {version}, \"\n                \"expected vulnerable 0.4.4 \u2013 exploit may not succeed.\"\n            )\n    except ModuleNotFoundError:\n        print(\"[verifier] ERROR: sqlparse package not found. Aborting.\")\n        sys.exit(1)\n\n\n# ---------- Exploit ----------\ndef run_exploit() -> tuple[int, str]:\n    \"\"\"\n    Executes exploit.py with a large depth.\n    Returns (exit_code, combined_output).\n    \"\"\"\n    if not pathlib.Path(EXPLOIT_SCRIPT).is_file():\n        print(\n            f\"[verifier] ERROR: {EXPLOIT_SCRIPT} not found in current \"\n            f\"directory ({pathlib.Path('.').resolve()}).\"\n        )\n        sys.exit(1)\n\n    try:\n        completed = subprocess.run(\n            [sys.executable, EXPLOIT_SCRIPT, DEPTH],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            text=True,\n            timeout=TIMEOUT_SECONDS,\n        )\n        return completed.returncode, completed.stdout\n    except subprocess.TimeoutExpired:\n        # Treat a hang as exploit *not* succeeding (patch mitigated DoS)\n        return 124, \"TIMEOUT (possible mitigation present)\"\n\n\n# ---------- Post-exploit ----------\ndef verify_success(exit_code: int, output: str) -> bool:\n    \"\"\"\n    Success criteria:\n      \u2022 exploit.py must terminate with non-zero exit code (crash)\n      \u2022 its output must mention 'RecursionError'\n    \"\"\"\n    return exit_code != 0 and \"RecursionError\" in output\n\n\ndef main() -> None:\n    # Pre-setup\n    ensure_vulnerable_version()\n\n    # Run exploit\n    exit_code, output = run_exploit()\n\n    # Verify outcome\n    if verify_success(exit_code, output):\n        print(FLAG)\n        sys.exit(0)\n    else:\n        print(\"[verifier] Exploit did NOT succeed.\")\n        print(\"[verifier] Child process exit code:\", exit_code)\n        print(\"[verifier] Child output (truncated to 500 chars):\")\n        print(textwrap.shorten(output.replace(\"\\n\", \"\\\\n\"), width=500))\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()"
}