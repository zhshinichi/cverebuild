#!/usr/bin/env python3
"""
verifier.py – CTF verifier for exploit.py (CVE-2024-4340, sqlparse 0.4.4)

Structure
=========

1. Pre-setup
   No special preparation is required: the vulnerable sqlparse 0.4.4
   package is already installed in editable mode in the repo root.
   The verifier nevertheless checks that the imported sqlparse really
   is version 0.4.4 and warns otherwise.

2. Exploit
   Runs the supplied exploit.py in a separate process with a very deep
   nesting level (10 000 brackets). Stdout/stderr are captured and the
   process is executed with a short timeout to guard against hangs.

3. Post-exploit
   The exploit is deemed successful if the child process exits with a
   non-zero status AND its output contains the text “RecursionError”.
   If these conditions are met, the verifier prints the flag
   “3xploit66full”.

Usage
=====

    $ python3 verifier.py
"""

import subprocess
import sys
import importlib
import pathlib
import textwrap

FLAG = "3xploit66full"
EXPLOIT_SCRIPT = "exploit.py"
DEPTH = "10000"          # depth that should exceed recursion limit
TIMEOUT_SECONDS = 10


# ---------- Pre-setup ----------
def ensure_vulnerable_version() -> None:
    """
    Best-effort check that the sqlparse in use is the vulnerable one (0.4.4).
    If not, we continue anyway, but warn – exploit may legitimately fail.
    """
    try:
        sqlparse = importlib.import_module("sqlparse")
        version = getattr(sqlparse, "__version__", "unknown")
        if version != "0.4.4":
            print(
                f"[verifier] WARNING: Detected sqlparse version {version}, "
                "expected vulnerable 0.4.4 – exploit may not succeed."
            )
    except ModuleNotFoundError:
        print("[verifier] ERROR: sqlparse package not found. Aborting.")
        sys.exit(1)


# ---------- Exploit ----------
def run_exploit() -> tuple[int, str]:
    """
    Executes exploit.py with a large depth.
    Returns (exit_code, combined_output).
    """
    if not pathlib.Path(EXPLOIT_SCRIPT).is_file():
        print(
            f"[verifier] ERROR: {EXPLOIT_SCRIPT} not found in current "
            f"directory ({pathlib.Path('.').resolve()})."
        )
        sys.exit(1)

    try:
        completed = subprocess.run(
            [sys.executable, EXPLOIT_SCRIPT, DEPTH],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            timeout=TIMEOUT_SECONDS,
        )
        return completed.returncode, completed.stdout
    except subprocess.TimeoutExpired:
        # Treat a hang as exploit *not* succeeding (patch mitigated DoS)
        return 124, "TIMEOUT (possible mitigation present)"


# ---------- Post-exploit ----------
def verify_success(exit_code: int, output: str) -> bool:
    """
    Success criteria:
      • exploit.py must terminate with non-zero exit code (crash)
      • its output must mention 'RecursionError'
    """
    return exit_code != 0 and "RecursionError" in output


def main() -> None:
    # Pre-setup
    ensure_vulnerable_version()

    # Run exploit
    exit_code, output = run_exploit()

    # Verify outcome
    if verify_success(exit_code, output):
        print(FLAG)
        sys.exit(0)
    else:
        print("[verifier] Exploit did NOT succeed.")
        print("[verifier] Child process exit code:", exit_code)
        print("[verifier] Child output (truncated to 500 chars):")
        print(textwrap.shorten(output.replace("\n", "\\n"), width=500))
        sys.exit(1)


if __name__ == "__main__":
    main()