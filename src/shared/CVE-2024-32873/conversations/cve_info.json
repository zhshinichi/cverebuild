{
    "published_date": "2024-06-06T18:13:54.267Z",
    "patch_commits": [
        {
            "url": "https://github.com/evmos/evmos/commit/b2a09ca66613d8b04decd3f2dcba8e1e77709dcb",
            "content": "Merge pull request from GHSA-pxv8-qhrh-jc7v\n\n* fix tests and add store migrations\n\n* add test case\n\n* backport changes\n\n* get tx receipt to check failed tx in nix test\n\nFilename: app/ante/cosmos/vesting.go:\n```\n@@ -1,123 +0,0 @@\n-// Copyright Tharsis Labs Ltd.(Evmos)\n-// SPDX-License-Identifier:ENCL-1.0(https://github.com/evmos/evmos/blob/main/LICENSE)\n-package cosmos\n-\n-import (\n-\terrorsmod \"cosmossdk.io/errors\"\n-\t\"github.com/cosmos/cosmos-sdk/codec\"\n-\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n-\terrortypes \"github.com/cosmos/cosmos-sdk/types/errors\"\n-\t\"github.com/cosmos/cosmos-sdk/x/authz\"\n-\tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n-\tevmtypes \"github.com/evmos/evmos/v18/x/evm/types\"\n-\tvestingtypes \"github.com/evmos/evmos/v18/x/vesting/types\"\n-)\n-\n-// TODO: remove once Cosmos SDK is upgraded to v0.46\n-\n-// VestingDelegationDecorator validates delegation of vested coins\n-type VestingDelegationDecorator struct {\n-\tak  evmtypes.AccountKeeper\n-\tsk  vestingtypes.StakingKeeper\n-\tbk  evmtypes.BankKeeper\n-\tcdc codec.BinaryCodec\n-}\n-\n-// NewVestingDelegationDecorator creates a new VestingDelegationDecorator\n-func NewVestingDelegationDecorator(ak evmtypes.AccountKeeper, sk vestingtypes.StakingKeeper, bk evmtypes.BankKeeper, cdc codec.BinaryCodec) VestingDelegationDecorator {\n-\treturn VestingDelegationDecorator{\n-\t\tak:  ak,\n-\t\tsk:  sk,\n-\t\tbk:  bk,\n-\t\tcdc: cdc,\n-\t}\n-}\n-\n-// AnteHandle checks if the tx contains a staking delegation.\n-// It errors if the coins are still locked or the bond amount is greater than\n-// the coins already vested\n-func (vdd VestingDelegationDecorator) AnteHandle(ctx sdk.Context, tx sdk.Tx, simulate bool, next sdk.AnteHandler) (newCtx sdk.Context, err error) {\n-\tfor _, msg := range tx.GetMsgs() {\n-\t\tswitch msg := msg.(type) {\n-\t\tcase *authz.MsgExec:\n-\t\t\t// Check for bypassing authorization\n-\t\t\tif err := vdd.validateAuthz(ctx, msg); err != nil {\n-\t\t\t\treturn ctx, err\n-\t\t\t}\n-\t\tdefault:\n-\t\t\tif err := vdd.validateMsg(ctx, msg); err != nil {\n-\t\t\t\treturn ctx, err\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\treturn next(ctx, tx, simulate)\n-}\n-\n-// validateAuthz validates the authorization internal message\n-func (vdd VestingDelegationDecorator) validateAuthz(ctx sdk.Context, execMsg *authz.MsgExec) error {\n-\tfor _, v := range execMsg.Msgs {\n-\t\tvar innerMsg sdk.Msg\n-\t\tif err := vdd.cdc.UnpackAny(v, &innerMsg); err != nil {\n-\t\t\treturn errorsmod.Wrap(err, \"cannot unmarshal authz exec msgs\")\n-\t\t}\n-\n-\t\tif err := vdd.validateMsg(ctx, innerMsg); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\n-\treturn nil\n-}\n-\n-// validateMsg checks that the only vested coins can be delegated\n-func (vdd VestingDelegationDecorator) validateMsg(ctx sdk.Context, msg sdk.Msg) error {\n-\tdelegateMsg, ok := msg.(*stakingtypes.MsgDelegate)\n-\tif !ok {\n-\t\treturn nil\n-\t}\n-\n-\tfor _, addr := range msg.GetSigners() {\n-\t\tacc := vdd.ak.GetAccount(ctx, addr)\n-\t\tif acc == nil {\n-\t\t\treturn errorsmod.Wrapf(\n-\t\t\t\terrortypes.ErrUnknownAddress,\n-\t\t\t\t\"account %s does not exist\", addr,\n-\t\t\t)\n-\t\t}\n-\n-\t\tclawbackAccount, isClawback := acc.(*vestingtypes.ClawbackVestingAccount)\n-\t\tif !isClawback {\n-\t\t\t// continue to next decorator as this logic only applies to vesting\n-\t\t\treturn nil\n-\t\t}\n-\n-\t\t// error if bond amount is > vested coins\n-\t\tbondDenom := vdd.sk.BondDenom(ctx)\n-\t\tcoins := clawbackAccount.GetVestedOnly(ctx.BlockTime())\n-\t\tif coins == nil || coins.Empty() {\n-\t\t\treturn errorsmod.Wrap(\n-\t\t\t\tvestingtypes.ErrInsufficientVestedCoins,\n-\t\t\t\t\"account has no vested coins\",\n-\t\t\t)\n-\t\t}\n-\n-\t\tbalance := vdd.bk.GetBalance(ctx, addr, bondDenom)\n-\t\tunvestedOnly := clawbackAccount.GetUnvestedOnly(ctx.BlockTime())\n-\t\tspendable, hasNeg := sdk.Coins{balance}.SafeSub(unvestedOnly...)\n-\t\tif hasNeg {\n-\t\t\tspendable = sdk.NewCoins()\n-\t\t}\n-\n-\t\tvested := spendable.AmountOf(bondDenom)\n-\t\tif vested.LT(delegateMsg.Amount.Amount) {\n-\t\t\treturn errorsmod.Wrapf(\n-\t\t\t\tvestingtypes.ErrInsufficientVestedCoins,\n-\t\t\t\t\"cannot delegate unvested coins. coins vested < delegation amount (%s < %s)\",\n-\t\t\t\tvested, delegateMsg.Amount.Amount,\n-\t\t\t)\n-\t\t}\n-\t}\n-\n-\treturn nil\n-}\n```\n\nFilename: app/ante/handler_options.go:\n```\n@@ -119,7 +119,6 @@\nfunc newCosmosAnteHandler(options HandlerOptions) sdk.AnteHandler {\n \t\tcosmosante.NewMinGasPriceDecorator(options.FeeMarketKeeper, options.EvmKeeper),\n \t\tante.NewConsumeGasForTxSizeDecorator(options.AccountKeeper),\n \t\tcosmosante.NewDeductFeeDecorator(options.AccountKeeper, options.BankKeeper, options.DistributionKeeper, options.FeegrantKeeper, options.StakingKeeper, options.TxFeeChecker),\n-\t\tcosmosante.NewVestingDelegationDecorator(options.AccountKeeper, options.StakingKeeper, options.BankKeeper, options.Cdc),\n \t\t// SetPubKeyDecorator must be called before all signature verification decorators\n \t\tante.NewSetPubKeyDecorator(options.AccountKeeper),\n \t\tante.NewValidateSigCountDecorator(options.AccountKeeper),\n\n@@ -146,7 +145,6 @@\nfunc newLegacyCosmosAnteHandlerEip712(options HandlerOptions) sdk.AnteHandler {\n \t\tante.NewValidateMemoDecorator(options.AccountKeeper),\n \t\tante.NewConsumeGasForTxSizeDecorator(options.AccountKeeper),\n \t\tcosmosante.NewDeductFeeDecorator(options.AccountKeeper, options.BankKeeper, options.DistributionKeeper, options.FeegrantKeeper, options.StakingKeeper, options.TxFeeChecker),\n-\t\tcosmosante.NewVestingDelegationDecorator(options.AccountKeeper, options.StakingKeeper, options.BankKeeper, options.Cdc),\n \t\t// SetPubKeyDecorator must be called before all signature verification decorators\n \t\tante.NewSetPubKeyDecorator(options.AccountKeeper),\n \t\tante.NewValidateSigCountDecorator(options.AccountKeeper),\n```\n\nFilename: app/app.go:\n```\n@@ -88,8 +88,7 @@\nimport (\n \t\"github.com/cosmos/cosmos-sdk/x/slashing\"\n \tslashingkeeper \"github.com/cosmos/cosmos-sdk/x/slashing/keeper\"\n \tslashingtypes \"github.com/cosmos/cosmos-sdk/x/slashing/types\"\n-\t\"github.com/cosmos/cosmos-sdk/x/staking\"\n-\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n+\tsdkstaking \"github.com/cosmos/cosmos-sdk/x/staking\"\n \tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n \t\"github.com/cosmos/cosmos-sdk/x/upgrade\"\n \tupgradeclient \"github.com/cosmos/cosmos-sdk/x/upgrade/client\"\n\n@@ -161,6 +160,8 @@\nimport (\n \tinflation \"github.com/evmos/evmos/v18/x/inflation/v1\"\n \tinflationkeeper \"github.com/evmos/evmos/v18/x/inflation/v1/keeper\"\n \tinflationtypes \"github.com/evmos/evmos/v18/x/inflation/v1/types\"\n+\t\"github.com/evmos/evmos/v18/x/staking\"\n+\tstakingkeeper \"github.com/evmos/evmos/v18/x/staking/keeper\"\n \trevenue \"github.com/evmos/evmos/v18/x/revenue/v1\"\n \trevenuekeeper \"github.com/evmos/evmos/v18/x/revenue/v1/keeper\"\n \trevenuetypes \"github.com/evmos/evmos/v18/x/revenue/v1/types\"\n\n@@ -212,7 +213,7 @@\nvar (\n \t\tgenutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator),\n \t\tbank.AppModuleBasic{},\n \t\tcapability.AppModuleBasic{},\n-\t\tstaking.AppModuleBasic{},\n+\t\tstaking.AppModuleBasic{AppModuleBasic: &sdkstaking.AppModuleBasic{}},\n \t\tdistr.AppModuleBasic{},\n \t\tgov.NewAppModuleBasic(\n \t\t\t[]govclient.ProposalHandler{\n\n@@ -646,12 +647,12 @@\nfunc NewEvmos(\n \t\tevm.NewAppModule(app.EvmKeeper, app.AccountKeeper, app.GetSubspace(evmtypes.ModuleName)),\n \t\tfeemarket.NewAppModule(app.FeeMarketKeeper, app.GetSubspace(feemarkettypes.ModuleName)),\n \t\t// Evmos app modules\n-\t\tinflation.NewAppModule(app.InflationKeeper, app.AccountKeeper, app.StakingKeeper,\n+\t\tinflation.NewAppModule(app.InflationKeeper, app.AccountKeeper, *app.StakingKeeper.Keeper,\n \t\t\tapp.GetSubspace(inflationtypes.ModuleName)),\n \t\terc20.NewAppModule(app.Erc20Keeper, app.AccountKeeper,\n \t\t\tapp.GetSubspace(erc20types.ModuleName)),\n \t\tepochs.NewAppModule(appCodec, app.EpochsKeeper),\n-\t\tvesting.NewAppModule(app.VestingKeeper, app.AccountKeeper, app.BankKeeper, app.StakingKeeper),\n+\t\tvesting.NewAppModule(app.VestingKeeper, app.AccountKeeper, app.BankKeeper, *app.StakingKeeper.Keeper),\n \t\trevenue.NewAppModule(app.RevenueKeeper, app.AccountKeeper,\n \t\t\tapp.GetSubspace(revenuetypes.ModuleName)),\n \t)\n\n@@ -1195,7 +1196,7 @@\nfunc (app *Evmos) setupUpgradeHandlers() {\n \t\tv10.UpgradeName,\n \t\tv10.CreateUpgradeHandler(\n \t\t\tapp.mm, app.configurator,\n-\t\t\tapp.StakingKeeper,\n+\t\t\t*app.StakingKeeper.Keeper,\n \t\t),\n \t)\n\n@@ -1206,7 +1207,7 @@\nfunc (app *Evmos) setupUpgradeHandlers() {\n \t\t\tapp.mm, app.configurator,\n \t\t\tapp.AccountKeeper,\n \t\t\tapp.BankKeeper,\n-\t\t\tapp.StakingKeeper,\n+\t\t\t*app.StakingKeeper.Keeper,\n \t\t\tapp.DistrKeeper,\n \t\t),\n \t)\n\n@@ -1252,7 +1253,7 @@\nfunc (app *Evmos) setupUpgradeHandlers() {\n \t\t\tapp.mm, app.configurator,\n \t\t\tapp.BankKeeper,\n \t\t\tapp.EvmKeeper,\n-\t\t\tapp.StakingKeeper,\n+\t\t\t*app.StakingKeeper.Keeper,\n \t\t),\n \t)\n```\n\nFilename: app/export.go:\n```\n@@ -50,7 +50,7 @@\nfunc (app *Evmos) ExportAppStateAndValidators(\n \t\treturn servertypes.ExportedApp{}, err\n \t}\n \n-\tvalidators, err := staking.WriteValidators(ctx, &app.StakingKeeper)\n+\tvalidators, err := staking.WriteValidators(ctx, app.StakingKeeper.Keeper)\n \tif err != nil {\n \t\treturn servertypes.ExportedApp{}, err\n \t}\n```\n\nFilename: app/upgrades/v11/upgrades_test.go:\n```\n@@ -107,7 +107,7 @@\nfunc (suite *UpgradeTestSuite) setValidators(validatorsAddr []string) {\n \t\tvalidator, err := stakingtypes.NewValidator(valAddr, suite.consKey, stakingtypes.Description{})\n \t\tsuite.Require().NoError(err)\n \n-\t\tvalidator = stakingkeeper.TestingUpdateValidator(&suite.app.StakingKeeper, suite.ctx, validator, true)\n+\t\tvalidator = stakingkeeper.TestingUpdateValidator(suite.app.StakingKeeper.Keeper, suite.ctx, validator, true)\n \n \t\terr = suite.app.StakingKeeper.Hooks().AfterValidatorCreated(suite.ctx, validator.GetOperator())\n \t\tsuite.Require().NoError(err)\n\n@@ -253,7 +253,7 @@\nfunc (suite *UpgradeTestSuite) TestDistributeRewards() {\n \t\t\tsuite.Require().Equal(math.ZeroInt(), initialDel)\n \n \t\t\tif utils.IsMainnet(tc.chainID) {\n-\t\t\t\tv11.HandleRewardDistribution(suite.ctx, suite.app.Logger(), suite.app.BankKeeper, suite.app.StakingKeeper, suite.app.DistrKeeper)\n+\t\t\t\tv11.HandleRewardDistribution(suite.ctx, suite.app.Logger(), suite.app.BankKeeper, *suite.app.StakingKeeper.Keeper, suite.app.DistrKeeper)\n \t\t\t}\n \n \t\t\t// account not in list should NOT get rewards\n```\n\nFilename: app/upgrades/v14/migrations_test.go:\n```\n@@ -136,11 +136,11 @@\nfunc (s *UpgradesTestSuite) TestUpdateMigrateNativeMultisigs() {\n \texpectedSharesMap[s.validators[0].OperatorAddress] = expectedSharesMap[s.validators[0].OperatorAddress].Sub(delegateShares)\n \n \t// Migrate strategic reserves\n-\terr = v14.MigrateNativeMultisigs(s.ctx, s.app.BankKeeper, s.app.StakingKeeper, newStrategicReserve.Addr, oldStrategicReservesAddrs...)\n+\terr = v14.MigrateNativeMultisigs(s.ctx, s.app.BankKeeper, *s.app.StakingKeeper.Keeper, newStrategicReserve.Addr, oldStrategicReservesAddrs...)\n \ts.Require().NoError(err, \"failed to migrate strategic reserves\")\n \n \t// Migrate premint wallet\n-\terr = v14.MigrateNativeMultisigs(s.ctx, s.app.BankKeeper, s.app.StakingKeeper, newPremintWallet.Addr, oldPremintWallet.Addr.String())\n+\terr = v14.MigrateNativeMultisigs(s.ctx, s.app.BankKeeper, *s.app.StakingKeeper.Keeper, newPremintWallet.Addr, oldPremintWallet.Addr.String())\n \ts.Require().NoError(err, \"failed to migrate premint wallet\")\n \n \t// Check that the multisigs have been updated\n\n@@ -162,7 +162,7 @@\nfunc (s *UpgradesTestSuite) TestInstantUnbonding() {\n \tdelegation, found := s.app.StakingKeeper.GetDelegation(s.ctx, s.address.Bytes(), s.validators[0].GetOperator())\n \ts.Require().True(found, \"delegation not found\")\n \n-\tunbondAmount, err := v14.InstantUnbonding(s.ctx, s.app.BankKeeper, s.app.StakingKeeper, delegation, s.bondDenom)\n+\tunbondAmount, err := v14.InstantUnbonding(s.ctx, s.app.BankKeeper, *s.app.StakingKeeper.Keeper, delegation, s.bondDenom)\n \ts.Require().NoError(err, \"failed to unbond\")\n \ts.Require().Equal(unbondAmount, math.NewInt(1e18), \"expected different unbond amount\")\n```\n\nFilename: precompiles/distribution/distribution.go:\n```\n@@ -8,15 +8,14 @@\nimport (\n \t\"embed\"\n \t\"fmt\"\n \n-\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n-\n \tstoretypes \"github.com/cosmos/cosmos-sdk/store/types\"\n \tauthzkeeper \"github.com/cosmos/cosmos-sdk/x/authz/keeper\"\n \tdistributionkeeper \"github.com/cosmos/cosmos-sdk/x/distribution/keeper\"\n \t\"github.com/ethereum/go-ethereum/accounts/abi\"\n \t\"github.com/ethereum/go-ethereum/common\"\n \t\"github.com/ethereum/go-ethereum/core/vm\"\n \tcmn \"github.com/evmos/evmos/v18/precompiles/common\"\n+\tstakingkeeper \"github.com/evmos/evmos/v18/x/staking/keeper\"\n )\n \n var _ vm.PrecompiledContract = &Precompile{}\n```\n\nFilename: precompiles/distribution/integration_test.go:\n```\n@@ -204,7 +204,7 @@\nvar _ = Describe(\"Calling distribution precompile from EOA\", func() {\n \t\t\t// create a validator with s.address and s.privKey because this account is\n \t\t\t// used for signing txs\n \t\t\tstakeAmt = math.NewInt(100)\n-\t\t\ttestutil.CreateValidator(s.ctx, s.T(), s.privKey.PubKey(), s.app.StakingKeeper, stakeAmt)\n+\t\t\ttestutil.CreateValidator(s.ctx, s.T(), s.privKey.PubKey(), *s.app.StakingKeeper.Keeper, stakeAmt)\n \n \t\t\t// set some validator commission\n \t\t\tvalAddr = s.address.Bytes()\n\n@@ -793,7 +793,7 @@\nvar _ = Describe(\"Calling distribution precompile from another contract\", func()\n \t\t\t// used for signing txs\n \t\t\tvalAddr = s.address.Bytes()\n \t\t\tstakeAmt := math.NewInt(100)\n-\t\t\ttestutil.CreateValidator(s.ctx, s.T(), s.privKey.PubKey(), s.app.StakingKeeper, stakeAmt)\n+\t\t\ttestutil.CreateValidator(s.ctx, s.T(), s.privKey.PubKey(), *s.app.StakingKeeper.Keeper, stakeAmt)\n \n \t\t\t// set some commissions to validators\n \t\t\tvar valAddresses []sdk.ValAddress\n```\n\nFilename: precompiles/distribution/utils_test.go:\n```\n@@ -243,7 +243,7 @@\nfunc (s *PrecompileTestSuite) prepareStakingRewards(stkRs ...stakingRewards) {\n \t\ts.Require().NoError(err)\n \n \t\t// end block to bond validator and increase block height\n-\t\tsdkstaking.EndBlocker(s.ctx, &s.app.StakingKeeper)\n+\t\tsdkstaking.EndBlocker(s.ctx, s.app.StakingKeeper.Keeper)\n \t\t// allocate rewards to validator (of these 50% will be paid out to the delegator)\n \t\tallocatedRewards := sdk.NewDecCoins(sdk.NewDecCoin(s.bondDenom, r.RewardAmt.Mul(math.NewInt(2))))\n \t\ts.app.DistrKeeper.AllocateTokensToValidator(s.ctx, r.Validator, allocatedRewards)\n```\n\nFilename: precompiles/outposts/osmosis/osmosis.go:\n```\n@@ -10,7 +10,6 @@\nimport (\n \tstoretypes \"github.com/cosmos/cosmos-sdk/store/types\"\n \tauthzkeeper \"github.com/cosmos/cosmos-sdk/x/authz/keeper\"\n \tbankkeeper \"github.com/cosmos/cosmos-sdk/x/bank/keeper\"\n-\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n \tclienttypes \"github.com/cosmos/ibc-go/v7/modules/core/02-client/types\"\n \tchannelkeeper \"github.com/cosmos/ibc-go/v7/modules/core/04-channel/keeper\"\n \t\"github.com/ethereum/go-ethereum/accounts/abi\"\n\n@@ -20,6 +19,7 @@\nimport (\n \t\"github.com/evmos/evmos/v18/precompiles/ics20\"\n \terc20keeper \"github.com/evmos/evmos/v18/x/erc20/keeper\"\n \ttransferkeeper \"github.com/evmos/evmos/v18/x/ibc/transfer/keeper\"\n+\tstakingkeeper \"github.com/evmos/evmos/v18/x/staking/keeper\"\n )\n \n const (\n```\n\nFilename: precompiles/outposts/stride/stride.go:\n```\n@@ -9,7 +9,6 @@\nimport (\n \n \tstoretypes \"github.com/cosmos/cosmos-sdk/store/types\"\n \tauthzkeeper \"github.com/cosmos/cosmos-sdk/x/authz/keeper\"\n-\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n \tclienttypes \"github.com/cosmos/ibc-go/v7/modules/core/02-client/types\"\n \n \t\"github.com/ethereum/go-ethereum/accounts/abi\"\n\n@@ -19,6 +18,7 @@\nimport (\n \t\"github.com/evmos/evmos/v18/precompiles/ics20\"\n \terc20keeper \"github.com/evmos/evmos/v18/x/erc20/keeper\"\n \ttransferkeeper \"github.com/evmos/evmos/v18/x/ibc/transfer/keeper\"\n+\tstakingkeeper \"github.com/evmos/evmos/v18/x/staking/keeper\"\n )\n \n var _ vm.PrecompiledContract = &Precompile{}\n```\n\nFilename: precompiles/staking/integration_test.go:\n```\n@@ -20,6 +20,7 @@\nimport (\n \t\"github.com/ethereum/go-ethereum/common\"\n \t\"github.com/ethereum/go-ethereum/core/vm\"\n \tcompiledcontracts \"github.com/evmos/evmos/v18/contracts\"\n+\t\"github.com/evmos/evmos/v18/crypto/ethsecp256k1\"\n \t\"github.com/evmos/evmos/v18/precompiles/authorization\"\n \tcmn \"github.com/evmos/evmos/v18/precompiles/common\"\n \t\"github.com/evmos/evmos/v18/precompiles/distribution\"\n\n@@ -29,6 +30,7 @@\nimport (\n \t\"github.com/evmos/evmos/v18/precompiles/testutil/contracts\"\n \tevmosutil \"github.com/evmos/evmos/v18/testutil\"\n \ttestutiltx \"github.com/evmos/evmos/v18/testutil/tx\"\n+\tvestingtypes \"github.com/evmos/evmos/v18/x/vesting/types\"\n )\n \n // General variables used for integration tests\n\n@@ -736,6 +738,219 @@\nvar _ = Describe(\"Calling staking precompile directly\", func() {\n \t\t})\n \t})\n \n+\tDescribe(\"Calling precompile txs from a vesting account\", func() {\n+\t\tvar (\n+\t\t\tfunder          common.Address\n+\t\t\tvestAcc         common.Address\n+\t\t\tvestAccPriv     *ethsecp256k1.PrivKey\n+\t\t\tclawbackAccount *vestingtypes.ClawbackVestingAccount\n+\t\t\tunvested        sdk.Coins\n+\t\t\tvested          sdk.Coins\n+\t\t\t// unlockedVested are unlocked vested coins of the vesting schedule\n+\t\t\tunlockedVested      sdk.Coins\n+\t\t\tdefaultDelegateArgs contracts.CallArgs\n+\t\t)\n+\n+\t\tBeforeEach(func() {\n+\t\t\t// Setup vesting account\n+\t\t\tfunder = s.address\n+\t\t\tvestAcc, vestAccPriv = testutiltx.NewAddrKey()\n+\t\t\tvestingAmtTotal := evmosutil.TestVestingSchedule.TotalVestingCoins\n+\n+\t\t\tclawbackAccount = s.setupVestingAccount(funder.Bytes(), vestAcc.Bytes())\n+\n+\t\t\t// Check if all tokens are unvested at vestingStart\n+\t\t\tunvested = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n+\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\tExpect(vestingAmtTotal).To(Equal(unvested))\n+\t\t\tExpect(vested.IsZero()).To(BeTrue())\n+\n+\t\t\t// populate the default delegate args\n+\t\t\tdefaultDelegateArgs = defaultCallArgs.WithMethodName(staking.DelegateMethod)\n+\t\t\tdefaultDelegateArgs = defaultDelegateArgs.WithPrivKey(vestAccPriv)\n+\t\t})\n+\n+\t\tContext(\"before first vesting period - all tokens locked and unvested\", func() {\n+\t\t\tBeforeEach(func() {\n+\t\t\t\ts.NextBlock()\n+\n+\t\t\t\t// Ensure no tokens are vested\n+\t\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\t\tunvested = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n+\t\t\t\tunlocked := clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n+\t\t\t\tzeroCoins := sdk.NewCoins(sdk.NewCoin(s.bondDenom, math.ZeroInt()))\n+\t\t\t\tExpect(vested).To(Equal(zeroCoins), \"expected different vested coins\")\n+\t\t\t\tExpect(unvested).To(Equal(evmosutil.TestVestingSchedule.TotalVestingCoins), \"expected different unvested coins\")\n+\t\t\t\tExpect(unlocked).To(Equal(zeroCoins), \"expected different unlocked coins\")\n+\t\t\t})\n+\n+\t\t\tIt(\"Should not be able to delegate unvested tokens\", func() {\n+\t\t\t\tdelegateArgs := defaultDelegateArgs.WithArgs(\n+\t\t\t\t\tvestAcc, valAddr.String(), unvested.AmountOf(s.bondDenom).BigInt(),\n+\t\t\t\t)\n+\n+\t\t\t\tfailCheck := defaultLogCheck.\n+\t\t\t\t\tWithErrContains(\"cannot delegate unvested coins\")\n+\n+\t\t\t\t_, _, err := contracts.CallContractAndCheckLogs(s.ctx, s.app, delegateArgs, failCheck)\n+\t\t\t\tExpect(err).NotTo(BeNil(), \"error while calling the smart contract: %v\", err)\n+\t\t\t\tExpect(err.Error()).To(ContainSubstring(\"coins available for delegation < delegation amount\"))\n+\t\t\t})\n+\n+\t\t\tIt(\"Should be able to delegate tokens not involved in vesting schedule\", func() {\n+\t\t\t\t// send some coins to the vesting account\n+\t\t\t\tcoinsToDelegate := sdk.NewCoins(sdk.NewCoin(s.bondDenom, math.NewInt(1e18)))\n+\t\t\t\terr := evmosutil.FundAccount(s.ctx, s.app.BankKeeper, clawbackAccount.GetAddress(), coinsToDelegate)\n+\t\t\t\tExpect(err).To(BeNil())\n+\n+\t\t\t\t// check balance is updated\n+\t\t\t\tbalance := s.app.BankKeeper.GetBalance(s.ctx, clawbackAccount.GetAddress(), s.bondDenom)\n+\t\t\t\tExpect(balance).To(Equal(accountGasCoverage[0].Add(evmosutil.TestVestingSchedule.TotalVestingCoins[0]).Add(coinsToDelegate[0])))\n+\n+\t\t\t\tdelegateArgs := defaultDelegateArgs.WithArgs(\n+\t\t\t\t\tvestAcc, valAddr.String(), coinsToDelegate.AmountOf(s.bondDenom).BigInt(),\n+\t\t\t\t)\n+\n+\t\t\t\tlogCheckArgs := passCheck.WithExpEvents(staking.EventTypeDelegate)\n+\n+\t\t\t\t_, _, err = contracts.CallContractAndCheckLogs(s.ctx, s.app, delegateArgs, logCheckArgs)\n+\t\t\t\tExpect(err).To(BeNil(), \"error while calling the smart contract: %v\", err)\n+\n+\t\t\t\tdelegation, found := s.app.StakingKeeper.GetDelegation(s.ctx, vestAcc.Bytes(), valAddr)\n+\t\t\t\tExpect(found).To(BeTrue(), \"expected delegation to be found\")\n+\t\t\t\tExpect(delegation.Shares.BigInt()).To(Equal(coinsToDelegate[0].Amount.BigInt()))\n+\n+\t\t\t\t// check vesting balance is untouched\n+\t\t\t\tbalancePost := s.app.BankKeeper.GetBalance(s.ctx, clawbackAccount.GetAddress(), s.bondDenom)\n+\t\t\t\tExpect(balancePost.IsGTE(evmosutil.TestVestingSchedule.TotalVestingCoins[0])).To(BeTrue())\n+\t\t\t})\n+\t\t})\n+\n+\t\tContext(\"after first vesting period and before lockup - some vested tokens, but still all locked\", func() {\n+\t\t\tBeforeEach(func() {\n+\t\t\t\t// Surpass cliff but none of lockup duration\n+\t\t\t\tcliffDuration := time.Duration(evmosutil.TestVestingSchedule.CliffPeriodLength)\n+\t\t\t\ts.NextBlockAfter(cliffDuration * time.Second)\n+\n+\t\t\t\t// Check if some, but not all tokens are vested\n+\t\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\t\texpVested := sdk.NewCoins(sdk.NewCoin(s.bondDenom, evmosutil.TestVestingSchedule.VestedCoinsPerPeriod[0].Amount.Mul(math.NewInt(evmosutil.TestVestingSchedule.CliffMonths))))\n+\t\t\t\tExpect(vested).NotTo(Equal(evmosutil.TestVestingSchedule.TotalVestingCoins), \"expected some tokens to have been vested\")\n+\t\t\t\tExpect(vested).To(Equal(expVested), \"expected different vested amount\")\n+\n+\t\t\t\t// check the vested tokens are still locked\n+\t\t\t\tunlockedVested = clawbackAccount.GetUnlockedVestedCoins(s.ctx.BlockTime())\n+\t\t\t\tExpect(unlockedVested).To(Equal(sdk.Coins{}))\n+\n+\t\t\t\tvestingAmtTotal := evmosutil.TestVestingSchedule.TotalVestingCoins\n+\t\t\t\tres, err := s.app.VestingKeeper.Balances(s.ctx, &vestingtypes.QueryBalancesRequest{Address: clawbackAccount.Address})\n+\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\tExpect(res.Vested).To(Equal(expVested))\n+\t\t\t\tExpect(res.Unvested).To(Equal(vestingAmtTotal.Sub(expVested...)))\n+\t\t\t\t// All coins from vesting schedule should be locked\n+\t\t\t\tExpect(res.Locked).To(Equal(vestingAmtTotal))\n+\t\t\t})\n+\n+\t\t\tIt(\"Should be able to delegate locked vested tokens\", func() {\n+\t\t\t\tdelegateArgs := defaultDelegateArgs.WithArgs(\n+\t\t\t\t\tvestAcc, valAddr.String(), vested[0].Amount.BigInt(),\n+\t\t\t\t)\n+\n+\t\t\t\tlogCheckArgs := passCheck.WithExpEvents(staking.EventTypeDelegate)\n+\n+\t\t\t\t_, _, err := contracts.CallContractAndCheckLogs(s.ctx, s.app, delegateArgs, logCheckArgs)\n+\t\t\t\tExpect(err).To(BeNil(), \"error while calling the smart contract: %v\", err)\n+\n+\t\t\t\tdelegation, found := s.app.StakingKeeper.GetDelegation(s.ctx, vestAcc.Bytes(), valAddr)\n+\t\t\t\tExpect(found).To(BeTrue(), \"expected delegation to be found\")\n+\t\t\t\tExpect(delegation.Shares.BigInt()).To(Equal(vested[0].Amount.BigInt()))\n+\t\t\t})\n+\n+\t\t\tIt(\"Should be able to delegate locked vested tokens + free tokens (not in vesting schedule)\", func() {\n+\t\t\t\t// send some coins to the vesting account\n+\t\t\t\tamt := sdk.NewCoins(sdk.NewCoin(s.bondDenom, math.NewInt(1e18)))\n+\t\t\t\terr := evmosutil.FundAccount(s.ctx, s.app.BankKeeper, clawbackAccount.GetAddress(), amt)\n+\t\t\t\tExpect(err).To(BeNil())\n+\n+\t\t\t\t// check balance is updated\n+\t\t\t\tbalance := s.app.BankKeeper.GetBalance(s.ctx, clawbackAccount.GetAddress(), s.bondDenom)\n+\t\t\t\tExpect(balance).To(Equal(accountGasCoverage[0].Add(evmosutil.TestVestingSchedule.TotalVestingCoins[0]).Add(amt[0])))\n+\n+\t\t\t\tcoinsToDelegate := amt.Add(vested...)\n+\n+\t\t\t\tdelegateArgs := defaultDelegateArgs.WithArgs(\n+\t\t\t\t\tvestAcc, valAddr.String(), coinsToDelegate[0].Amount.BigInt(),\n+\t\t\t\t)\n+\n+\t\t\t\tlogCheckArgs := passCheck.WithExpEvents(staking.EventTypeDelegate)\n+\n+\t\t\t\t_, _, err = contracts.CallContractAndCheckLogs(s.ctx, s.app, delegateArgs, logCheckArgs)\n+\t\t\t\tExpect(err).To(BeNil(), \"error while calling the smart contract: %v\", err)\n+\n+\t\t\t\tdelegation, found := s.app.StakingKeeper.GetDelegation(s.ctx, vestAcc.Bytes(), valAddr)\n+\t\t\t\tExpect(found).To(BeTrue(), \"expected delegation to be found\")\n+\t\t\t\tExpect(delegation.Shares.BigInt()).To(Equal(coinsToDelegate[0].Amount.BigInt()))\n+\t\t\t})\n+\t\t})\n+\n+\t\tContext(\"Between first and second lockup periods - vested coins are unlocked\", func() {\n+\t\t\tBeforeEach(func() {\n+\t\t\t\t// Surpass first lockup\n+\t\t\t\tvestDuration := time.Duration(evmosutil.TestVestingSchedule.LockupPeriodLength)\n+\t\t\t\ts.NextBlockAfter(vestDuration * time.Second)\n+\n+\t\t\t\t// Check if some, but not all tokens are vested and unlocked\n+\t\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\t\tunlocked := clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n+\t\t\t\tunlockedVested = clawbackAccount.GetUnlockedVestedCoins(s.ctx.BlockTime())\n+\n+\t\t\t\texpVested := sdk.NewCoins(sdk.NewCoin(s.bondDenom, evmosutil.TestVestingSchedule.VestedCoinsPerPeriod[0].Amount.Mul(math.NewInt(evmosutil.TestVestingSchedule.LockupMonths))))\n+\t\t\t\texpUnlockedVested := expVested\n+\n+\t\t\t\tExpect(vested).NotTo(Equal(evmosutil.TestVestingSchedule.TotalVestingCoins), \"expected not all tokens to be vested\")\n+\t\t\t\tExpect(vested).To(Equal(expVested), \"expected different amount of vested tokens\")\n+\t\t\t\t// all vested coins are unlocked\n+\t\t\t\tExpect(unlockedVested).To(Equal(vested))\n+\t\t\t\tExpect(unlocked).To(Equal(evmosutil.TestVestingSchedule.UnlockedCoinsPerLockup))\n+\t\t\t\tExpect(unlockedVested).To(Equal(expUnlockedVested))\n+\t\t\t})\n+\t\t\tIt(\"Should be able to delegate unlocked vested tokens\", func() {\n+\t\t\t\tdelegateArgs := defaultDelegateArgs.WithArgs(\n+\t\t\t\t\tvestAcc, valAddr.String(), unlockedVested[0].Amount.BigInt(),\n+\t\t\t\t)\n+\n+\t\t\t\tlogCheckArgs := passCheck.WithExpEvents(staking.EventTypeDelegate)\n+\n+\t\t\t\t_, _, err := contracts.CallContractAndCheckLogs(s.ctx, s.app, delegateArgs, logCheckArgs)\n+\t\t\t\tExpect(err).To(BeNil(), \"error while calling the smart contract: %v\", err)\n+\n+\t\t\t\tdelegation, found := s.app.StakingKeeper.GetDelegation(s.ctx, vestAcc.Bytes(), valAddr)\n+\t\t\t\tExpect(found).To(BeTrue(), \"expected delegation to be found\")\n+\t\t\t\tExpect(delegation.Shares.BigInt()).To(Equal(unlockedVested[0].Amount.BigInt()))\n+\t\t\t})\n+\n+\t\t\tIt(\"Cannot delegate more than vested tokens (and free tokens)\", func() {\n+\t\t\t\t// calculate the delegatable amount\n+\t\t\t\tbalance := s.app.BankKeeper.GetBalance(s.ctx, vestAcc.Bytes(), s.bondDenom)\n+\t\t\t\tunvestedOnly := clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n+\t\t\t\tdelegatable := balance.Sub(unvestedOnly[0])\n+\n+\t\t\t\tdelegateArgs := defaultDelegateArgs.WithArgs(\n+\t\t\t\t\tvestAcc, valAddr.String(), delegatable.Amount.Add(sdk.OneInt()).BigInt(),\n+\t\t\t\t)\n+\n+\t\t\t\tlogCheckArgs := passCheck.WithExpEvents(staking.EventTypeDelegate)\n+\n+\t\t\t\t_, _, err := contracts.CallContractAndCheckLogs(s.ctx, s.app, delegateArgs, logCheckArgs)\n+\t\t\t\tExpect(err).NotTo(BeNil(), \"error while calling the smart contract: %v\", err)\n+\t\t\t\tExpect(err.Error()).To(ContainSubstring(\"cannot delegate unvested coins\"))\n+\n+\t\t\t\t_, found := s.app.StakingKeeper.GetDelegation(s.ctx, vestAcc.Bytes(), valAddr)\n+\t\t\t\tExpect(found).To(BeFalse(), \"expected delegation NOT to be found\")\n+\t\t\t})\n+\t\t})\n+\t})\n+\n \tDescribe(\"to query allowance\", func() {\n \t\tvar (\n \t\t\tdefaultAllowanceArgs contracts.CallArgs\n\n@@ -1649,7 +1864,7 @@\nvar _ = Describe(\"Calling staking precompile via Solidity\", func() {\n \n \t\t\tIt(\"shouldn't delegate to a validator that is not in the allow list of the approval\", func() {\n \t\t\t\t// create a new validator, which is not included in the active set of the last block\n-\t\t\t\ttestutil.CreateValidator(s.ctx, s.T(), s.privKey.PubKey(), s.app.StakingKeeper, math.NewInt(100))\n+\t\t\t\ttestutil.CreateValidator(s.ctx, s.T(), s.privKey.PubKey(), *s.app.StakingKeeper.Keeper, math.NewInt(100))\n \t\t\t\tnewValAddr := sdk.ValAddress(s.address.Bytes())\n \n \t\t\t\tdelegateArgs := defaultDelegateArgs.WithArgs(\n\n@@ -1663,6 +1878,187 @@\nvar _ = Describe(\"Calling staking precompile via Solidity\", func() {\n \t\t\t\tExpect(delegation.GetShares()).To(Equal(math.LegacyNewDecFromInt(math.NewInt(100))), \"expected only the delegation from creating the validator, no more\")\n \t\t\t})\n \t\t})\n+\t\tDescribe(\"delegation from a vesting account\", func() {\n+\t\t\tvar (\n+\t\t\t\tfunder          common.Address\n+\t\t\t\tvestAcc         common.Address\n+\t\t\t\tvestAccPriv     *ethsecp256k1.PrivKey\n+\t\t\t\tclawbackAccount *vestingtypes.ClawbackVestingAccount\n+\t\t\t\tunvested        sdk.Coins\n+\t\t\t\tvested          sdk.Coins\n+\t\t\t\t// unlockedVested are unlocked vested coins of the vesting schedule\n+\t\t\t\tunlockedVested sdk.Coins\n+\t\t\t\tdefaultArgs    contracts.CallArgs\n+\t\t\t)\n+\n+\t\t\tBeforeEach(func() {\n+\t\t\t\t// Setup vesting account\n+\t\t\t\tfunder = s.address\n+\t\t\t\tvestAcc, vestAccPriv = testutiltx.NewAddrKey()\n+\n+\t\t\t\tclawbackAccount = s.setupVestingAccount(funder.Bytes(), vestAcc.Bytes())\n+\n+\t\t\t\t// Check if all tokens are unvested at vestingStart\n+\t\t\t\ttotalVestingCoins := evmosutil.TestVestingSchedule.TotalVestingCoins\n+\t\t\t\tunvested = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n+\t\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\t\tExpect(unvested).To(Equal(totalVestingCoins))\n+\t\t\t\tExpect(vested.IsZero()).To(BeTrue())\n+\n+\t\t\t\t// create approval to allow spending all vesting coins\n+\t\t\t\tcArgs := defaultApproveArgs.WithArgs(\n+\t\t\t\t\tcontractAddr, []string{staking.DelegateMsg}, totalVestingCoins.AmountOf(s.bondDenom).BigInt(),\n+\t\t\t\t).WithPrivKey(vestAccPriv)\n+\t\t\t\ts.SetupApprovalWithContractCalls(cArgs)\n+\n+\t\t\t\t// add the vesting account priv key to the delegate args\n+\t\t\t\tdefaultArgs = defaultDelegateArgs.WithPrivKey(vestAccPriv)\n+\t\t\t})\n+\n+\t\t\tContext(\"before first vesting period - all tokens locked and unvested\", func() {\n+\t\t\t\tBeforeEach(func() {\n+\t\t\t\t\ts.NextBlock()\n+\n+\t\t\t\t\t// Ensure no tokens are vested\n+\t\t\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\t\t\tunvested = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n+\t\t\t\t\tunlocked := clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n+\t\t\t\t\tzeroCoins := sdk.NewCoins(sdk.NewCoin(s.bondDenom, math.ZeroInt()))\n+\t\t\t\t\tExpect(vested).To(Equal(zeroCoins))\n+\t\t\t\t\tExpect(unvested).To(Equal(evmosutil.TestVestingSchedule.TotalVestingCoins))\n+\t\t\t\t\tExpect(unlocked).To(Equal(zeroCoins))\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"Should not be able to delegate unvested tokens\", func() {\n+\t\t\t\t\tdelegateArgs := defaultArgs.WithArgs(\n+\t\t\t\t\t\tvestAcc, valAddr.String(), unvested.AmountOf(s.bondDenom).BigInt(),\n+\t\t\t\t\t)\n+\n+\t\t\t\t\t_, _, err := contracts.CallContractAndCheckLogs(s.ctx, s.app, delegateArgs, execRevertedCheck)\n+\t\t\t\t\tExpect(err).To(HaveOccurred(), \"error while calling the smart contract: %v\", err)\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"Should be able to delegate tokens not involved in vesting schedule\", func() {\n+\t\t\t\t\t// send some coins to the vesting account\n+\t\t\t\t\tcoinsToDelegate := sdk.NewCoins(sdk.NewCoin(s.bondDenom, math.NewInt(1e18)))\n+\t\t\t\t\terr := evmosutil.FundAccount(s.ctx, s.app.BankKeeper, clawbackAccount.GetAddress(), coinsToDelegate)\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\n+\t\t\t\t\tdelegateArgs := defaultArgs.WithArgs(\n+\t\t\t\t\t\tvestAcc, valAddr.String(), coinsToDelegate.AmountOf(s.bondDenom).BigInt(),\n+\t\t\t\t\t)\n+\n+\t\t\t\t\tlogCheckArgs := passCheck.WithExpEvents(staking.EventTypeDelegate)\n+\n+\t\t\t\t\t_, _, err = contracts.CallContractAndCheckLogs(s.ctx, s.app, delegateArgs, logCheckArgs)\n+\t\t\t\t\tExpect(err).To(BeNil(), \"error while calling the smart contract: %v\", err)\n+\n+\t\t\t\t\tdelegation, found := s.app.StakingKeeper.GetDelegation(s.ctx, vestAcc.Bytes(), valAddr)\n+\t\t\t\t\tExpect(found).To(BeTrue(), \"expected delegation to be found\")\n+\t\t\t\t\tExpect(delegation.Shares.BigInt()).To(Equal(coinsToDelegate[0].Amount.BigInt()))\n+\t\t\t\t})\n+\t\t\t})\n+\n+\t\t\tContext(\"after first vesting period and before lockup - some vested tokens, but still all locked\", func() {\n+\t\t\t\tBeforeEach(func() {\n+\t\t\t\t\t// Surpass cliff but none of lockup duration\n+\t\t\t\t\tcliffDuration := time.Duration(evmosutil.TestVestingSchedule.CliffPeriodLength)\n+\t\t\t\t\ts.NextBlockAfter(cliffDuration * time.Second)\n+\n+\t\t\t\t\t// Check if some, but not all tokens are vested\n+\t\t\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\t\t\texpVested := sdk.NewCoins(sdk.NewCoin(s.bondDenom, evmosutil.TestVestingSchedule.VestedCoinsPerPeriod[0].Amount.Mul(math.NewInt(evmosutil.TestVestingSchedule.CliffMonths))))\n+\t\t\t\t\tExpect(vested).NotTo(Equal(evmosutil.TestVestingSchedule.TotalVestingCoins))\n+\t\t\t\t\tExpect(vested).To(Equal(expVested))\n+\n+\t\t\t\t\t// check the vested tokens are still locked\n+\t\t\t\t\tunlockedVested = clawbackAccount.GetUnlockedVestedCoins(s.ctx.BlockTime())\n+\t\t\t\t\tExpect(unlockedVested).To(Equal(sdk.Coins{}))\n+\n+\t\t\t\t\tvestingAmtTotal := evmosutil.TestVestingSchedule.TotalVestingCoins\n+\t\t\t\t\tres, err := s.app.VestingKeeper.Balances(s.ctx, &vestingtypes.QueryBalancesRequest{Address: clawbackAccount.Address})\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(res.Vested).To(Equal(expVested))\n+\t\t\t\t\tExpect(res.Unvested).To(Equal(vestingAmtTotal.Sub(expVested...)))\n+\t\t\t\t\t// All coins from vesting schedule should be locked\n+\t\t\t\t\tExpect(res.Locked).To(Equal(vestingAmtTotal))\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"Should be able to delegate locked vested tokens\", func() {\n+\t\t\t\t\tdelegateArgs := defaultArgs.WithArgs(\n+\t\t\t\t\t\tvestAcc, valAddr.String(), vested[0].Amount.BigInt(),\n+\t\t\t\t\t)\n+\n+\t\t\t\t\tlogCheckArgs := passCheck.WithExpEvents(staking.EventTypeDelegate)\n+\n+\t\t\t\t\t_, _, err := contracts.CallContractAndCheckLogs(s.ctx, s.app, delegateArgs, logCheckArgs)\n+\t\t\t\t\tExpect(err).To(BeNil(), \"error while calling the smart contract: %v\", err)\n+\n+\t\t\t\t\tdelegation, found := s.app.StakingKeeper.GetDelegation(s.ctx, vestAcc.Bytes(), valAddr)\n+\t\t\t\t\tExpect(found).To(BeTrue(), \"expected delegation to be found\")\n+\t\t\t\t\tExpect(delegation.Shares.BigInt()).To(Equal(vested[0].Amount.BigInt()))\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"Should be able to delegate locked vested tokens + free tokens (not in vesting schedule)\", func() {\n+\t\t\t\t\t// send some coins to the vesting account\n+\t\t\t\t\tamt := sdk.NewCoins(sdk.NewCoin(s.bondDenom, math.NewInt(1e18)))\n+\t\t\t\t\terr := evmosutil.FundAccount(s.ctx, s.app.BankKeeper, clawbackAccount.GetAddress(), amt)\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\n+\t\t\t\t\tcoinsToDelegate := amt.Add(vested...)\n+\n+\t\t\t\t\tdelegateArgs := defaultArgs.WithArgs(\n+\t\t\t\t\t\tvestAcc, valAddr.String(), coinsToDelegate[0].Amount.BigInt(),\n+\t\t\t\t\t)\n+\n+\t\t\t\t\tlogCheckArgs := passCheck.WithExpEvents(staking.EventTypeDelegate)\n+\n+\t\t\t\t\t_, _, err = contracts.CallContractAndCheckLogs(s.ctx, s.app, delegateArgs, logCheckArgs)\n+\t\t\t\t\tExpect(err).To(BeNil(), \"error while calling the smart contract: %v\", err)\n+\n+\t\t\t\t\tdelegation, found := s.app.StakingKeeper.GetDelegation(s.ctx, vestAcc.Bytes(), valAddr)\n+\t\t\t\t\tExpect(found).To(BeTrue(), \"expected delegation to be found\")\n+\t\t\t\t\tExpect(delegation.Shares.BigInt()).To(Equal(coinsToDelegate[0].Amount.BigInt()))\n+\t\t\t\t})\n+\t\t\t})\n+\n+\t\t\tContext(\"Between first and second lockup periods - vested coins are unlocked\", func() {\n+\t\t\t\tBeforeEach(func() {\n+\t\t\t\t\t// Surpass first lockup\n+\t\t\t\t\tvestDuration := time.Duration(evmosutil.TestVestingSchedule.LockupPeriodLength)\n+\t\t\t\t\ts.NextBlockAfter(vestDuration * time.Second)\n+\n+\t\t\t\t\t// Check if some, but not all tokens are vested and unlocked\n+\t\t\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\t\t\tunlocked := clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n+\t\t\t\t\tunlockedVested = clawbackAccount.GetUnlockedVestedCoins(s.ctx.BlockTime())\n+\n+\t\t\t\t\texpVested := sdk.NewCoins(sdk.NewCoin(s.bondDenom, evmosutil.TestVestingSchedule.VestedCoinsPerPeriod[0].Amount.Mul(math.NewInt(evmosutil.TestVestingSchedule.LockupMonths))))\n+\t\t\t\t\texpUnlockedVested := expVested\n+\n+\t\t\t\t\tExpect(vested).NotTo(Equal(evmosutil.TestVestingSchedule.TotalVestingCoins))\n+\t\t\t\t\tExpect(vested).To(Equal(expVested))\n+\t\t\t\t\t// all vested coins are unlocked\n+\t\t\t\t\tExpect(unlockedVested).To(Equal(vested))\n+\t\t\t\t\tExpect(unlocked).To(Equal(evmosutil.TestVestingSchedule.UnlockedCoinsPerLockup))\n+\t\t\t\t\tExpect(unlockedVested).To(Equal(expUnlockedVested))\n+\t\t\t\t})\n+\t\t\t\tIt(\"Should be able to delegate unlocked vested tokens\", func() {\n+\t\t\t\t\tdelegateArgs := defaultArgs.WithArgs(\n+\t\t\t\t\t\tvestAcc, valAddr.String(), unlockedVested[0].Amount.BigInt(),\n+\t\t\t\t\t)\n+\n+\t\t\t\t\tlogCheckArgs := passCheck.WithExpEvents(staking.EventTypeDelegate)\n+\n+\t\t\t\t\t_, _, err := contracts.CallContractAndCheckLogs(s.ctx, s.app, delegateArgs, logCheckArgs)\n+\t\t\t\t\tExpect(err).To(BeNil(), \"error while calling the smart contract: %v\", err)\n+\n+\t\t\t\t\tdelegation, found := s.app.StakingKeeper.GetDelegation(s.ctx, vestAcc.Bytes(), valAddr)\n+\t\t\t\t\tExpect(found).To(BeTrue(), \"expected delegation to be found\")\n+\t\t\t\t\tExpect(delegation.Shares.BigInt()).To(Equal(unlockedVested[0].Amount.BigInt()))\n+\t\t\t\t})\n+\t\t\t})\n+\t\t})\n \t})\n \n \tContext(\"unbonding\", func() {\n```\n\nFilename: precompiles/staking/query.go:\n```\n@@ -50,7 +50,7 @@\nfunc (p Precompile) Delegation(\n \t\treturn nil, err\n \t}\n \n-\tqueryServer := stakingkeeper.Querier{Keeper: &p.stakingKeeper}\n+\tqueryServer := stakingkeeper.Querier{Keeper: p.stakingKeeper.Keeper}\n \n \tres, err := queryServer.Delegation(sdk.WrapSDKContext(ctx), req)\n \tif err != nil {\n\n@@ -80,7 +80,7 @@\nfunc (p Precompile) UnbondingDelegation(\n \t\treturn nil, err\n \t}\n \n-\tqueryServer := stakingkeeper.Querier{Keeper: &p.stakingKeeper}\n+\tqueryServer := stakingkeeper.Querier{Keeper: p.stakingKeeper.Keeper}\n \n \tres, err := queryServer.UnbondingDelegation(sdk.WrapSDKContext(ctx), req)\n \tif err != nil {\n\n@@ -109,7 +109,7 @@\nfunc (p Precompile) Validator(\n \t\treturn nil, err\n \t}\n \n-\tqueryServer := stakingkeeper.Querier{Keeper: &p.stakingKeeper}\n+\tqueryServer := stakingkeeper.Querier{Keeper: p.stakingKeeper.Keeper}\n \n \tres, err := queryServer.Validator(sdk.WrapSDKContext(ctx), req)\n \tif err != nil {\n\n@@ -138,7 +138,7 @@\nfunc (p Precompile) Validators(\n \t\treturn nil, err\n \t}\n \n-\tqueryServer := stakingkeeper.Querier{Keeper: &p.stakingKeeper}\n+\tqueryServer := stakingkeeper.Querier{Keeper: p.stakingKeeper.Keeper}\n \n \tres, err := queryServer.Validators(sdk.WrapSDKContext(ctx), req)\n \tif err != nil {\n\n@@ -184,7 +184,7 @@\nfunc (p Precompile) Redelegations(\n \t\treturn nil, err\n \t}\n \n-\tqueryServer := stakingkeeper.Querier{Keeper: &p.stakingKeeper}\n+\tqueryServer := stakingkeeper.Querier{Keeper: p.stakingKeeper.Keeper}\n \n \tres, err := queryServer.Redelegations(ctx, req)\n \tif err != nil {\n```\n\nFilename: precompiles/staking/staking.go:\n```\n@@ -11,12 +11,12 @@\nimport (\n \t\"github.com/cometbft/cometbft/libs/log\"\n \tstoretypes \"github.com/cosmos/cosmos-sdk/store/types\"\n \tauthzkeeper \"github.com/cosmos/cosmos-sdk/x/authz/keeper\"\n-\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n \t\"github.com/ethereum/go-ethereum/accounts/abi\"\n \t\"github.com/ethereum/go-ethereum/common\"\n \t\"github.com/ethereum/go-ethereum/core/vm\"\n \t\"github.com/evmos/evmos/v18/precompiles/authorization\"\n \tcmn \"github.com/evmos/evmos/v18/precompiles/common\"\n+\tstakingkeeper \"github.com/evmos/evmos/v18/x/staking/keeper\"\n )\n \n var _ vm.PrecompiledContract = &Precompile{}\n```\n\nFilename: precompiles/staking/tx.go:\n```\n@@ -8,13 +8,13 @@\nimport (\n \t\"time\"\n \n \tsdk \"github.com/cosmos/cosmos-sdk/types\"\n-\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n \tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n \t\"github.com/ethereum/go-ethereum/accounts/abi\"\n \t\"github.com/ethereum/go-ethereum/common\"\n \t\"github.com/ethereum/go-ethereum/core/vm\"\n \t\"github.com/evmos/evmos/v18/precompiles/authorization\"\n \t\"github.com/evmos/evmos/v18/x/evm/statedb\"\n+\tstakingkeeper \"github.com/evmos/evmos/v18/x/staking/keeper\"\n )\n \n const (\n```\n\nFilename: precompiles/staking/utils_test.go:\n```\n@@ -2,6 +2,7 @@\npackage staking_test\n \n import (\n \t\"encoding/json\"\n+\t\"fmt\"\n \t\"math/big\"\n \t\"time\"\n\n@@ -20,12 +21,13 @@\nimport (\n \tsdk \"github.com/cosmos/cosmos-sdk/types\"\n \tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n \tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n-\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n \tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n \t\"github.com/ethereum/go-ethereum/accounts/abi\"\n \t\"github.com/ethereum/go-ethereum/common\"\n \tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n+\t\"github.com/ethereum/go-ethereum/crypto\"\n \tevmosapp \"github.com/evmos/evmos/v18/app\"\n+\t\"github.com/evmos/evmos/v18/crypto/ethsecp256k1\"\n \t\"github.com/evmos/evmos/v18/precompiles/authorization\"\n \tcmn \"github.com/evmos/evmos/v18/precompiles/common\"\n \t\"github.com/evmos/evmos/v18/precompiles/staking\"\n\n@@ -38,9 +40,14 @@\nimport (\n \t\"github.com/evmos/evmos/v18/x/evm/statedb\"\n \tevmtypes \"github.com/evmos/evmos/v18/x/evm/types\"\n \tinflationtypes \"github.com/evmos/evmos/v18/x/inflation/v1/types\"\n+\tstakingkeeper \"github.com/evmos/evmos/v18/x/staking/keeper\"\n+\tvestingtypes \"github.com/evmos/evmos/v18/x/vesting/types\"\n \t\"golang.org/x/exp/slices\"\n )\n \n+// stipend to pay EVM tx fees\n+var accountGasCoverage = sdk.NewCoins(sdk.NewCoin(utils.BaseDenom, math.NewInt(1e16)))\n+\n // SetupWithGenesisValSet initializes a new EvmosApp with a validator set and genesis accounts\n // that also act as delegators. For simplicity, each validator is bonded with a delegation\n // of one consensus engine unit (10^6) in the default token of the simapp from first genesis\n\n@@ -328,6 +335,13 @@\nfunc (s *PrecompileTestSuite) SetupApprovalWithContractCalls(approvalArgs contra\n \t_, _, err := contracts.CallContractAndCheckLogs(s.ctx, s.app, approvalArgs, logCheckArgs)\n \tExpect(err).To(BeNil(), \"error while approving: %v\", err)\n \n+\t// get granter address from private key provided\n+\tpk, ok := approvalArgs.PrivKey.(*ethsecp256k1.PrivKey)\n+\tExpect(ok).To(BeTrue(), fmt.Sprintf(\"expected a ethsecp256k1.PrivKey, but got %T\", approvalArgs.PrivKey))\n+\tkey, err := pk.ToECDSA()\n+\tExpect(err).To(BeNil())\n+\tgranter := crypto.PubkeyToAddress(key.PublicKey)\n+\n \t// iterate over args\n \tvar expectedAuthz stakingtypes.AuthorizationType\n \tfor _, msgType := range msgTypes {\n\n@@ -341,7 +355,7 @@\nfunc (s *PrecompileTestSuite) SetupApprovalWithContractCalls(approvalArgs contra\n \t\tcase staking.CancelUnbondingDelegationMsg:\n \t\t\texpectedAuthz = staking.CancelUnbondingDelegationAuthz\n \t\t}\n-\t\tauthz, expirationTime := s.CheckAuthorization(expectedAuthz, approvalArgs.ContractAddr, s.address)\n+\t\tauthz, expirationTime := s.CheckAuthorization(expectedAuthz, approvalArgs.ContractAddr, granter)\n \t\tExpect(authz).ToNot(BeNil(), \"expected authorization to be set\")\n \t\tExpect(authz.MaxTokens.Amount).To(Equal(math.NewInt(expAmount.Int64())), \"expected different allowance\")\n \t\tExpect(authz.MsgTypeURL()).To(Equal(msgType), \"expected different message type\")\n\n@@ -363,8 +377,13 @@\nfunc (s *PrecompileTestSuite) DeployContract(contract evmtypes.CompiledContract)\n \n // NextBlock commits the current block and sets up the next block.\n func (s *PrecompileTestSuite) NextBlock() {\n+\ts.NextBlockAfter(time.Second)\n+}\n+\n+// NextBlock commits the current block and sets up the next block.\n+func (s *PrecompileTestSuite) NextBlockAfter(t time.Duration) {\n \tvar err error\n-\ts.ctx, err = evmosutil.CommitAndCreateNewCtx(s.ctx, s.app, time.Second, nil)\n+\ts.ctx, err = evmosutil.CommitAndCreateNewCtx(s.ctx, s.app, t, nil)\n \tExpect(err).To(BeNil(), \"failed to commit block\")\n }\n\n@@ -499,7 +518,7 @@\nfunc (s *PrecompileTestSuite) setupRedelegations(redelAmt *big.Int) error {\n \n \t// create a validator with s.address and s.privKey\n \t// then create a redelegation from validator[0] to this new validator\n-\ttestutil.CreateValidator(s.ctx, s.T(), s.privKey.PubKey(), s.app.StakingKeeper, math.NewInt(100))\n+\ttestutil.CreateValidator(s.ctx, s.T(), s.privKey.PubKey(), *s.app.StakingKeeper.Keeper, math.NewInt(100))\n \tmsg.ValidatorDstAddress = sdk.ValAddress(s.address.Bytes()).String()\n \t_, err := msgSrv.BeginRedelegate(s.ctx, &msg)\n \treturn err\n\n@@ -514,3 +533,37 @@\nfunc (s *PrecompileTestSuite) CheckValidatorOutput(valOut staking.ValidatorInfo)\n \tExpect(slices.Contains(validatorAddrs, valOut.OperatorAddress)).To(BeTrue(), \"operator address not found in test suite validators\")\n \tExpect(valOut.DelegatorShares).To(Equal(big.NewInt(1e18)), \"expected different delegator shares\")\n }\n+\n+// setupVestingAccount is a helper function used in integraiton tests to setup a vesting account\n+// using the TestVestingSchedule. Also, funds the account with extra funds to pay for transaction fees\n+func (s *PrecompileTestSuite) setupVestingAccount(funder, vestAcc sdk.AccAddress) *vestingtypes.ClawbackVestingAccount {\n+\tvestingAmtTotal := evmosutil.TestVestingSchedule.TotalVestingCoins\n+\n+\tvestingStart := s.ctx.BlockTime()\n+\tbaseAccount := authtypes.NewBaseAccountWithAddress(vestAcc.Bytes())\n+\tclawbackAccount := vestingtypes.NewClawbackVestingAccount(\n+\t\tbaseAccount,\n+\t\tfunder,\n+\t\tvestingAmtTotal,\n+\t\tvestingStart,\n+\t\tevmosutil.TestVestingSchedule.LockupPeriods,\n+\t\tevmosutil.TestVestingSchedule.VestingPeriods,\n+\t)\n+\n+\terr := evmosutil.FundAccount(s.ctx, s.app.BankKeeper, clawbackAccount.GetAddress(), vestingAmtTotal)\n+\tExpect(err).To(BeNil())\n+\tacc := s.app.AccountKeeper.NewAccount(s.ctx, clawbackAccount)\n+\ts.app.AccountKeeper.SetAccount(s.ctx, acc)\n+\n+\t// Check all coins are locked up\n+\tlockedUp := clawbackAccount.GetLockedUpCoins(s.ctx.BlockTime())\n+\tExpect(vestingAmtTotal).To(Equal(lockedUp))\n+\n+\t// Grant gas stipend to cover EVM fees\n+\terr = evmosutil.FundAccount(s.ctx, s.app.BankKeeper, clawbackAccount.GetAddress(), accountGasCoverage)\n+\tExpect(err).To(BeNil())\n+\tgranteeBalance := s.app.BankKeeper.GetBalance(s.ctx, clawbackAccount.GetAddress(), s.bondDenom)\n+\tExpect(granteeBalance).To(Equal(accountGasCoverage[0].Add(vestingAmtTotal[0])))\n+\n+\treturn clawbackAccount\n+}\n```\n\nFilename: tests/nix_tests/test_patches.py:\n```\n@@ -12,6 +12,7 @@\ndeploy_contract,\n     eth_to_bech32,\n     get_fees_from_tx_result,\n+    wait_for_cosmos_tx_receipt,\n     wait_for_new_blocks,\n )\n\n@@ -371,7 +372,8 @@\ndef test_unvested_token_delegation(evmos_cluster):\n     )\n     tx = cli.sign_tx_json(tx, address, max_priority_price=0)\n     rsp = cli.broadcast_tx_json(tx, broadcast_mode=\"sync\")\n-\n+    # get tx receipt to check if tx failed as expected \n+    receipt = wait_for_cosmos_tx_receipt(cli, rsp[\"txhash\"])\n     # assert tx fails with corresponding error message\n-    assert rsp[\"code\"] == 2\n-    assert \"insufficient vested coins\" in rsp[\"raw_log\"]\n+    assert receipt[\"tx_result\"][\"code\"] == 2\n+    assert \"insufficient vested coins\" in receipt[\"tx_result\"][\"log\"]\n```\n\nFilename: testutil/integration/evmos/network/clients.go:\n```\n@@ -85,6 +85,6 @@\nfunc (n *IntegrationNetwork) GetAuthzClient() authz.QueryClient {\n \n func (n *IntegrationNetwork) GetStakingClient() stakingtypes.QueryClient {\n \tqueryHelper := getQueryHelper(n.GetContext())\n-\tstakingtypes.RegisterQueryServer(queryHelper, stakingkeeper.Querier{Keeper: &n.app.StakingKeeper})\n+\tstakingtypes.RegisterQueryServer(queryHelper, stakingkeeper.Querier{Keeper: n.app.StakingKeeper.Keeper})\n \treturn stakingtypes.NewQueryClient(queryHelper)\n }\n```\n\nFilename: testutil/integration/evmos/network/config.go:\n```\n@@ -9,6 +9,8 @@\nimport (\n \t\"github.com/evmos/evmos/v18/utils\"\n \n \tsdktypes \"github.com/cosmos/cosmos-sdk/types\"\n+\tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n+\tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n \tevmostypes \"github.com/evmos/evmos/v18/types\"\n )\n\n@@ -20,6 +22,7 @@\ntype Config struct {\n \teip155ChainID      *big.Int\n \tamountOfValidators int\n \tpreFundedAccounts  []sdktypes.AccAddress\n+\tbalances           []banktypes.Balance\n \tdenom              string\n }\n\n@@ -36,6 +39,24 @@\nfunc DefaultConfig() Config {\n \t}\n }\n \n+// getGenAccountsAndBalances takes the network configuration and returns the used\n+// genesis accounts and balances.\n+//\n+// NOTE: If the balances are set, the pre-funded accounts are ignored.\n+func getGenAccountsAndBalances(cfg Config) (genAccounts []authtypes.GenesisAccount, balances []banktypes.Balance) {\n+\tif len(cfg.balances) > 0 {\n+\t\tbalances = cfg.balances\n+\t\taccounts := getAccAddrsFromBalances(balances)\n+\t\tgenAccounts = createGenesisAccounts(accounts)\n+\t} else {\n+\t\tcoin := sdktypes.NewCoin(cfg.denom, PrefundedAccountInitialBalance)\n+\t\tgenAccounts = createGenesisAccounts(cfg.preFundedAccounts)\n+\t\tbalances = createBalances(cfg.preFundedAccounts, coin)\n+\t}\n+\n+\treturn\n+}\n+\n // ConfigOption defines a function that can modify the NetworkConfig.\n // The purpose of this is to force to be declarative when the default configuration\n // requires to be changed.\n\n@@ -67,6 +88,14 @@\nfunc WithPreFundedAccounts(accounts ...sdktypes.AccAddress) ConfigOption {\n \t}\n }\n \n+// WithBalances sets the specific balances for the pre-funded accounts, that\n+// are being set up for the network.\n+func WithBalances(balances ...banktypes.Balance) ConfigOption {\n+\treturn func(cfg *Config) {\n+\t\tcfg.balances = append(cfg.balances, balances...)\n+\t}\n+}\n+\n // WithDenom sets the denom for the network.\n func WithDenom(denom string) ConfigOption {\n \treturn func(cfg *Config) {\n```\n\nFilename: testutil/integration/evmos/network/network.go:\n```\n@@ -7,6 +7,7 @@\nimport (\n \t\"encoding/json\"\n \t\"math\"\n \t\"math/big\"\n+\t\"time\"\n \n \tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n\n@@ -105,9 +106,7 @@\nvar (\n func (n *IntegrationNetwork) configureAndInitChain() error {\n \t// Create funded accounts based on the config and\n \t// create genesis accounts\n-\tcoin := sdktypes.NewCoin(n.cfg.denom, PrefundedAccountInitialBalance)\n-\tgenAccounts := createGenesisAccounts(n.cfg.preFundedAccounts)\n-\tfundedAccountBalances := createBalances(n.cfg.preFundedAccounts, coin)\n+\tgenAccounts, fundedAccountBalances := getGenAccountsAndBalances(n.cfg)\n \n \t// Create validator set with the amount of validators specified in the config\n \t// with the default power of 1.\n\n@@ -154,8 +153,10 @@\nfunc (n *IntegrationNetwork) configureAndInitChain() error {\n \t\treturn err\n \t}\n \n+\tnow := time.Now()\n \tevmosApp.InitChain(\n \t\tabcitypes.RequestInitChain{\n+\t\t\tTime:            now,\n \t\t\tChainId:         n.cfg.chainID,\n \t\t\tValidators:      []abcitypes.ValidatorUpdate{},\n \t\t\tConsensusParams: app.DefaultConsensusParams,\n\n@@ -168,6 +169,7 @@\nfunc (n *IntegrationNetwork) configureAndInitChain() error {\n \theader := tmproto.Header{\n \t\tChainID:            n.cfg.chainID,\n \t\tHeight:             evmosApp.LastBlockHeight() + 1,\n+\t\tTime:               now,\n \t\tAppHash:            evmosApp.LastCommitID().Hash,\n \t\tValidatorsHash:     valSet.Hash(),\n \t\tNextValidatorsHash: valSet.Hash(),\n```\n\nFilename: testutil/integration/evmos/network/setup.go:\n```\n@@ -23,6 +23,8 @@\nimport (\n \tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n \tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n \tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n+\t\"github.com/ethereum/go-ethereum/crypto\"\n+\tevmostypes \"github.com/evmos/evmos/v18/types\"\n \tepochstypes \"github.com/evmos/evmos/v18/x/epochs/types\"\n \tinfltypes \"github.com/evmos/evmos/v18/x/inflation/v1/types\"\n )\n\n@@ -50,9 +52,25 @@\nfunc createValidatorSetAndSigners(numberOfValidators int) (*tmtypes.ValidatorSet\n func createGenesisAccounts(accounts []sdktypes.AccAddress) []authtypes.GenesisAccount {\n \tnumberOfAccounts := len(accounts)\n \tgenAccounts := make([]authtypes.GenesisAccount, 0, numberOfAccounts)\n+\temptyCodeHash := crypto.Keccak256Hash(nil).String()\n \tfor _, acc := range accounts {\n \t\tbaseAcc := authtypes.NewBaseAccount(acc, nil, 0, 0)\n-\t\tgenAccounts = append(genAccounts, baseAcc)\n+\t\tethAcc := &evmostypes.EthAccount{\n+\t\t\tBaseAccount: baseAcc,\n+\t\t\tCodeHash:    emptyCodeHash,\n+\t\t}\n+\t\tgenAccounts = append(genAccounts, ethAcc)\n+\t}\n+\treturn genAccounts\n+}\n+\n+// getAccAddrsFromBalances returns a slice of genesis accounts from the\n+// given balances.\n+func getAccAddrsFromBalances(balances []banktypes.Balance) []sdktypes.AccAddress {\n+\tnumberOfBalances := len(balances)\n+\tgenAccounts := make([]sdktypes.AccAddress, 0, numberOfBalances)\n+\tfor _, balance := range balances {\n+\t\tgenAccounts = append(genAccounts, balance.GetAddress())\n \t}\n \treturn genAccounts\n }\n```\n\nFilename: testutil/integration/ibc/coordinator/coordinator.go:\n```\n@@ -41,10 +41,7 @@\ntype Coordinator interface {\n }\n \n // TODO: Replace for a config\n-var (\n-\tAmountOfDummyChains = 2\n-\tGlobalTime          = time.Date(time.Now().Year()+1, 1, 2, 0, 0, 0, 0, time.UTC)\n-)\n+var AmountOfDummyChains = 2\n \n var _ Coordinator = (*IntegrationCoordinator)(nil)\n\n@@ -62,7 +59,7 @@\ntype IntegrationCoordinator struct {\n func NewIntegrationCoordinator(t *testing.T, preConfiguredChains []network.Network) *IntegrationCoordinator {\n \tcoord := &ibctesting.Coordinator{\n \t\tT:           t,\n-\t\tCurrentTime: GlobalTime,\n+\t\tCurrentTime: time.Now(),\n \t}\n \tibcChains := getIBCChains(t, coord, preConfiguredChains)\n \tdummyChains, dummyChainsIds := generateDummyChains(t, coord, AmountOfDummyChains)\n```\n\nFilename: testutil/staking-rewards.go:\n```\n@@ -110,7 +110,7 @@\nfunc PrepareAccountsForDelegationRewards(t *testing.T, ctx sdk.Context, app *app\n \t\terr = app.StakingKeeper.SetParams(ctx, stakingParams)\n \t\trequire.NoError(t, err)\n \n-\t\tstakingHelper := teststaking.NewHelper(t, ctx, &app.StakingKeeper)\n+\t\tstakingHelper := teststaking.NewHelper(t, ctx, app.StakingKeeper.Keeper)\n \t\tstakingHelper.Commission = stakingtypes.NewCommissionRates(zeroDec, zeroDec, zeroDec)\n \t\tstakingHelper.Denom = utils.BaseDenom\n\n@@ -122,7 +122,7 @@\nfunc PrepareAccountsForDelegationRewards(t *testing.T, ctx sdk.Context, app *app\n \n \t\t// end block to bond validator and increase block height\n \t\t// Not using Commit() here because code panics due to invalid block height\n-\t\tstaking.EndBlocker(ctx, &app.StakingKeeper)\n+\t\tstaking.EndBlocker(ctx, app.StakingKeeper.Keeper)\n \n \t\t// allocate rewards to validator (of these 50% will be paid out to the delegator)\n \t\tvalidator := app.StakingKeeper.Validator(ctx, valAddr)\n```\n\nFilename: testutil/vesting.go:\n```\n@@ -0,0 +1,88 @@\n+// Copyright Tharsis Labs Ltd.(Evmos)\n+// SPDX-License-Identifier:ENCL-1.0(https://github.com/evmos/evmos/blob/main/LICENSE)\n+package testutil\n+\n+import (\n+\t\"cosmossdk.io/math\"\n+\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n+\tsdkvesting \"github.com/cosmos/cosmos-sdk/x/auth/vesting/types\"\n+\t\"github.com/evmos/evmos/v18/utils\"\n+)\n+\n+type vestingSchedule struct {\n+\tCliffMonths int64\n+\t// CliffPeriodLength in seconds\n+\tCliffPeriodLength int64\n+\tNumLockupPeriods  int64\n+\tLockupMonths      int64\n+\t// LockupPeriodLength in seconds\n+\tLockupPeriodLength int64\n+\tNumVestingPeriods  int64\n+\t// VestingPeriodLength in seconds\n+\tVestingPeriodLength    int64\n+\tTotalVestingCoins      sdk.Coins\n+\tVestedCoinsPerPeriod   sdk.Coins\n+\tUnlockedCoinsPerLockup sdk.Coins\n+\tVestingPeriods         []sdkvesting.Period\n+\tLockupPeriods          []sdkvesting.Period\n+}\n+\n+// Vesting schedule for tests that use vesting account\n+var (\n+\tTestVestingSchedule vestingSchedule\n+\t// Monthly vesting period\n+\tstakeDenom    = utils.BaseDenom\n+\tamt           = math.NewInt(1e17)\n+\tvestingLength = int64(60 * 60 * 24 * 30) // in seconds\n+\tvestingAmt    = sdk.NewCoins(sdk.NewCoin(stakeDenom, amt))\n+\tvestingPeriod = sdkvesting.Period{Length: vestingLength, Amount: vestingAmt}\n+\n+\t// 4 years vesting total\n+\tperiodsTotal    = int64(48)\n+\tvestingAmtTotal = sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(periodsTotal))))\n+\n+\t// 6 month cliff\n+\tcliff       = int64(6)\n+\tcliffLength = vestingLength * cliff\n+\tcliffAmt    = sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(cliff))))\n+\tcliffPeriod = sdkvesting.Period{Length: cliffLength, Amount: cliffAmt}\n+\n+\t// 12 month lockup\n+\tlockup       = int64(12) // 12 months\n+\tlockupLength = vestingLength * lockup\n+\t// Unlock at 12 and 24 months\n+\tnumLockupPeriods = int64(2)\n+\t// Unlock half of the total vest in each unlock event. By default, all tokens are\n+\t// unlocked after surpassing the final period.\n+\tunlockedPerLockup = vestingAmtTotal.QuoInt(math.NewInt(numLockupPeriods))\n+\tlockupPeriod      = sdkvesting.Period{Length: lockupLength, Amount: unlockedPerLockup}\n+\tlockupPeriods     = make(sdkvesting.Periods, numLockupPeriods)\n+\t// add initial cliff to vesting periods\n+\tvestingPeriods = sdkvesting.Periods{cliffPeriod}\n+)\n+\n+func init() {\n+\tfor i := range lockupPeriods {\n+\t\tlockupPeriods[i] = lockupPeriod\n+\t}\n+\n+\t// Create vesting periods with initial cliff\n+\tfor p := int64(1); p <= periodsTotal-cliff; p++ {\n+\t\tvestingPeriods = append(vestingPeriods, vestingPeriod)\n+\t}\n+\n+\tTestVestingSchedule = vestingSchedule{\n+\t\tCliffMonths:            cliff,\n+\t\tCliffPeriodLength:      cliffLength,\n+\t\tNumLockupPeriods:       numLockupPeriods,\n+\t\tNumVestingPeriods:      periodsTotal,\n+\t\tLockupMonths:           lockup,\n+\t\tLockupPeriodLength:     lockupLength,\n+\t\tVestingPeriodLength:    vestingLength,\n+\t\tTotalVestingCoins:      vestingAmtTotal,\n+\t\tVestedCoinsPerPeriod:   vestingAmt,\n+\t\tUnlockedCoinsPerLockup: unlockedPerLockup,\n+\t\tVestingPeriods:         vestingPeriods,\n+\t\tLockupPeriods:          lockupPeriods,\n+\t}\n+}\n```\n\nFilename: x/erc20/keeper/utils_test.go:\n```\n@@ -103,7 +103,7 @@\nfunc (suite *KeeperTestSuite) DoSetupTest(t require.TestingT) {\n \tvalAddr := sdk.ValAddress(suite.address.Bytes())\n \tvalidator, err := stakingtypes.NewValidator(valAddr, privCons.PubKey(), stakingtypes.Description{})\n \trequire.NoError(t, err)\n-\tvalidator = stakingkeeper.TestingUpdateValidator(&suite.app.StakingKeeper, suite.ctx, validator, true)\n+\tvalidator = stakingkeeper.TestingUpdateValidator(suite.app.StakingKeeper.Keeper, suite.ctx, validator, true)\n \terr = suite.app.StakingKeeper.Hooks().AfterValidatorCreated(suite.ctx, validator.GetOperator())\n \trequire.NoError(t, err)\n \terr = suite.app.StakingKeeper.SetValidatorByConsAddr(suite.ctx, validator)\n```\n\nFilename: x/evm/keeper/precompiles.go:\n```\n@@ -20,7 +20,6 @@\nimport (\n \tauthzkeeper \"github.com/cosmos/cosmos-sdk/x/authz/keeper\"\n \tbankkeeper \"github.com/cosmos/cosmos-sdk/x/bank/keeper\"\n \tdistributionkeeper \"github.com/cosmos/cosmos-sdk/x/distribution/keeper\"\n-\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n \tchannelkeeper \"github.com/cosmos/ibc-go/v7/modules/core/04-channel/keeper\"\n \tbankprecompile \"github.com/evmos/evmos/v18/precompiles/bank\"\n \tdistprecompile \"github.com/evmos/evmos/v18/precompiles/distribution\"\n\n@@ -33,6 +32,7 @@\nimport (\n \tvestingprecompile \"github.com/evmos/evmos/v18/precompiles/vesting\"\n \terc20Keeper \"github.com/evmos/evmos/v18/x/erc20/keeper\"\n \ttransferkeeper \"github.com/evmos/evmos/v18/x/ibc/transfer/keeper\"\n+\tstakingkeeper \"github.com/evmos/evmos/v18/x/staking/keeper\"\n \tvestingkeeper \"github.com/evmos/evmos/v18/x/vesting/keeper\"\n )\n```\n\nFilename: x/feemarket/keeper/utils_test.go:\n```\n@@ -70,7 +70,7 @@\nfunc (suite *KeeperTestSuite) SetupApp(checkTx bool, chainID string) {\n \tvalAddr := sdk.ValAddress(suite.address.Bytes())\n \tvalidator, err := stakingtypes.NewValidator(valAddr, priv.PubKey(), stakingtypes.Description{})\n \trequire.NoError(t, err)\n-\tvalidator = stakingkeeper.TestingUpdateValidator(&suite.app.StakingKeeper, suite.ctx, validator, true)\n+\tvalidator = stakingkeeper.TestingUpdateValidator(suite.app.StakingKeeper.Keeper, suite.ctx, validator, true)\n \terr = suite.app.StakingKeeper.Hooks().AfterValidatorCreated(suite.ctx, validator.GetOperator())\n \trequire.NoError(t, err)\n```\n\nFilename: x/ibc/transfer/keeper/keeper_test.go:\n```\n@@ -122,7 +122,7 @@\nfunc (suite *KeeperTestSuite) DoSetupTest(t require.TestingT) {\n \tvalAddr := sdk.ValAddress(suite.address.Bytes())\n \tvalidator, err := stakingtypes.NewValidator(valAddr, privCons.PubKey(), stakingtypes.Description{})\n \trequire.NoError(t, err)\n-\tvalidator = stakingkeeper.TestingUpdateValidator(&suite.app.StakingKeeper, suite.ctx, validator, true)\n+\tvalidator = stakingkeeper.TestingUpdateValidator(suite.app.StakingKeeper.Keeper, suite.ctx, validator, true)\n \terr = suite.app.StakingKeeper.Hooks().AfterValidatorCreated(suite.ctx, validator.GetOperator())\n \trequire.NoError(t, err)\n \terr = suite.app.StakingKeeper.SetValidatorByConsAddr(suite.ctx, validator)\n```\n\nFilename: x/revenue/v1/keeper/utils_test.go:\n```\n@@ -74,7 +74,7 @@\nfunc (suite *KeeperTestSuite) SetupApp(chainID string) {\n \tvalAddr := sdk.ValAddress(suite.address.Bytes())\n \tvalidator, err := stakingtypes.NewValidator(valAddr, privCons.PubKey(), stakingtypes.Description{})\n \trequire.NoError(t, err)\n-\tvalidator = stakingkeeper.TestingUpdateValidator(&suite.app.StakingKeeper, suite.ctx, validator, true)\n+\tvalidator = stakingkeeper.TestingUpdateValidator(suite.app.StakingKeeper.Keeper, suite.ctx, validator, true)\n \terr = suite.app.StakingKeeper.Hooks().AfterValidatorCreated(suite.ctx, validator.GetOperator())\n \trequire.NoError(t, err)\n \terr = suite.app.StakingKeeper.SetValidatorByConsAddr(suite.ctx, validator)\n```\n\nFilename: x/staking/keeper/integration_test.go:\n```\n@@ -0,0 +1,395 @@\n+package keeper_test\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"cosmossdk.io/math\"\n+\t\"github.com/cosmos/cosmos-sdk/crypto/keys/ed25519\"\n+\n+\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n+\t\"github.com/cosmos/cosmos-sdk/x/authz\"\n+\tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n+\t\"github.com/cosmos/cosmos-sdk/x/staking/types\"\n+\n+\t\"github.com/evmos/evmos/v18/testutil\"\n+\t\"github.com/evmos/evmos/v18/testutil/integration/common/factory\"\n+\tevmosfactory \"github.com/evmos/evmos/v18/testutil/integration/evmos/factory\"\n+\t\"github.com/evmos/evmos/v18/testutil/integration/evmos/grpc\"\n+\t\"github.com/evmos/evmos/v18/testutil/integration/evmos/keyring\"\n+\t\"github.com/evmos/evmos/v18/testutil/integration/evmos/network\"\n+\t\"github.com/evmos/evmos/v18/utils\"\n+\tvestingtypes \"github.com/evmos/evmos/v18/x/vesting/types\"\n+\n+\t//nolint:revive // dot imports are fine for Ginkgo\n+\t. \"github.com/onsi/ginkgo/v2\"\n+\t//nolint:revive // dot imports are fine for Ginkgo\n+\t. \"github.com/onsi/gomega\"\n+)\n+\n+func TestKeeperIntegrationTestSuite(t *testing.T) {\n+\t// Run Ginkgo integration tests\n+\tRegisterFailHandler(Fail)\n+\tRunSpecs(t, \"Keeper Suite\")\n+}\n+\n+var _ = Describe(\"Staking module tests\", func() {\n+\tvar (\n+\t\tnw   *network.UnitTestNetwork\n+\t\tgh   grpc.Handler\n+\t\tkeys keyring.Keyring\n+\t\ttf   evmosfactory.TxFactory\n+\t)\n+\n+\tContext(\"using a vesting account\", func() {\n+\t\tvar (\n+\t\t\tclawbackAccount       *vestingtypes.ClawbackVestingAccount\n+\t\t\tfunder                keyring.Key\n+\t\t\tvestingAccount        keyring.Key\n+\t\t\totherAccount          keyring.Key\n+\t\t\tvestAccInitialBalance *sdk.Coin\n+\t\t\t// initialized vars\n+\t\t\tgasPrice = math.NewInt(700_000_000)\n+\t\t\tgas      = uint64(500_000)\n+\t\t)\n+\n+\t\tBeforeEach(func() {\n+\t\t\t// setup network\n+\t\t\t// create 3 prefunded accounts:\n+\t\t\tkeys = keyring.New(3)\n+\t\t\tfunder = keys.GetKey(0)\n+\t\t\tvestingAccount = keys.GetKey(1)\n+\t\t\totherAccount = keys.GetKey(2)\n+\n+\t\t\t// set a higher initial balance for the funder to have\n+\t\t\t// enough for the vesting schedule\n+\t\t\tfunderInitialBalance, ok := math.NewIntFromString(\"100_000_000_000_000_000_000\")\n+\t\t\tExpect(ok).To(BeTrue())\n+\t\t\tbalances := []banktypes.Balance{\n+\t\t\t\t{\n+\t\t\t\t\tAddress: funder.AccAddr.String(),\n+\t\t\t\t\tCoins:   sdk.NewCoins(sdk.NewCoin(utils.BaseDenom, funderInitialBalance)),\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tAddress: vestingAccount.AccAddr.String(),\n+\t\t\t\t\tCoins:   sdk.NewCoins(sdk.NewCoin(utils.BaseDenom, network.PrefundedAccountInitialBalance)),\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tAddress: otherAccount.AccAddr.String(),\n+\t\t\t\t\tCoins:   sdk.NewCoins(sdk.NewCoin(utils.BaseDenom, network.PrefundedAccountInitialBalance)),\n+\t\t\t\t},\n+\t\t\t}\n+\n+\t\t\tnw = network.NewUnitTestNetwork(\n+\t\t\t\tnetwork.WithBalances(balances...),\n+\t\t\t)\n+\t\t\tgh = grpc.NewIntegrationHandler(nw)\n+\t\t\ttf = evmosfactory.New(nw, gh)\n+\n+\t\t\tExpect(nw.NextBlock()).To(BeNil())\n+\n+\t\t\t// setup vesting account\n+\t\t\tcreateAccMsg := vestingtypes.NewMsgCreateClawbackVestingAccount(funder.AccAddr, vestingAccount.AccAddr, false)\n+\t\t\tres, err := tf.ExecuteCosmosTx(vestingAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{createAccMsg}})\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\t\t\tExpect(nw.NextBlock()).To(BeNil())\n+\n+\t\t\t// get vesting account initial balance (free tokens)\n+\t\t\tbalRes, err := gh.GetBalance(vestingAccount.AccAddr, nw.GetDenom())\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\tvestAccInitialBalance = balRes.Balance\n+\n+\t\t\t// Fund the clawback vesting accounts\n+\t\t\tvestingStart := nw.GetContext().BlockTime()\n+\t\t\tfundMsg := vestingtypes.NewMsgFundVestingAccount(funder.AccAddr, vestingAccount.AccAddr, vestingStart, testutil.TestVestingSchedule.LockupPeriods, testutil.TestVestingSchedule.VestingPeriods)\n+\t\t\tres, err = tf.ExecuteCosmosTx(funder.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{fundMsg}})\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\t\t\tExpect(nw.NextBlock()).To(BeNil())\n+\n+\t\t\t// check vesting account was created successfully\n+\t\t\tacc, err := gh.GetAccount(vestingAccount.AccAddr.String())\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\tclawbackAccount, ok = acc.(*vestingtypes.ClawbackVestingAccount)\n+\t\t\tExpect(ok).To(BeTrue())\n+\t\t})\n+\n+\t\tContext(\"delegate\", func() {\n+\t\t\tvar delMsg *types.MsgDelegate\n+\n+\t\t\tContext(\"using MsgDelegate\", func() {\n+\t\t\t\tBeforeEach(func() {\n+\t\t\t\t\t// create a MsgDelegate to delegate the free tokens (balance previous to be converted to clawback account) + vested coins per period\n+\t\t\t\t\tdelMsg = types.NewMsgDelegate(vestingAccount.AccAddr, nw.GetValidators()[0].GetOperator(), testutil.TestVestingSchedule.VestedCoinsPerPeriod.Add(*vestAccInitialBalance)[0])\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"should not allow to delegate unvested tokens\", func() {\n+\t\t\t\t\t// all coins in vesting schedule should be unvested\n+\t\t\t\t\tunvestedCoins := clawbackAccount.GetVestingCoins(nw.GetContext().BlockTime())\n+\t\t\t\t\tExpect(unvestedCoins).To(Equal(testutil.TestVestingSchedule.TotalVestingCoins))\n+\n+\t\t\t\t\tbalRes, err := gh.GetBalance(vestingAccount.AccAddr, nw.GetDenom())\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tdelegatableBalance := balRes.Balance.Sub(unvestedCoins[0])\n+\t\t\t\t\tExpect(delegatableBalance.Amount.LT(delMsg.Amount.Amount)).To(BeTrue())\n+\n+\t\t\t\t\t_, err = tf.ExecuteCosmosTx(vestingAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{delMsg}})\n+\t\t\t\t\tExpect(err).To(HaveOccurred())\n+\t\t\t\t\tExpect(err.Error()).To(ContainSubstring(\"cannot delegate unvested coins\"))\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"should allow to delegate free tokens when all tokens in vesting schedule are unvested\", func() {\n+\t\t\t\t\t// calculate fees to deduct from free balance\n+\t\t\t\t\t// to get the proper delegation amount\n+\t\t\t\t\tfees := sdk.NewCoin(nw.GetDenom(), gasPrice.Mul(math.NewIntFromUint64(gas)))\n+\t\t\t\t\tdelMsg.Amount = vestAccInitialBalance.Sub(fees)\n+\n+\t\t\t\t\tres, err := tf.ExecuteCosmosTx(vestingAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{delMsg}, Gas: gas, GasPrice: &gasPrice})\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\t\t\t\t\tExpect(nw.NextBlock()).To(BeNil())\n+\n+\t\t\t\t\t// check delegation was created successfully\n+\t\t\t\t\tdelRes, err := gh.GetDelegation(vestingAccount.AccAddr.String(), nw.GetValidators()[0].OperatorAddress)\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(delRes.DelegationResponse).NotTo(BeNil())\n+\t\t\t\t\tExpect(delRes.DelegationResponse.Balance).To(Equal(delMsg.Amount))\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"should allow to delegate locked vested tokens\", func() {\n+\t\t\t\t\t// cliff period passes - some tokens vested, but still all locked\n+\t\t\t\t\tvestingPeriod := time.Duration(testutil.TestVestingSchedule.CliffPeriodLength)\n+\t\t\t\t\tExpect(nw.NextBlockAfter(vestingPeriod * time.Second)).To(BeNil())\n+\n+\t\t\t\t\t// check there're some vested coins\n+\t\t\t\t\tdenom := nw.GetDenom()\n+\t\t\t\t\texpCoins := sdk.NewCoins(sdk.NewCoin(denom, testutil.TestVestingSchedule.VestedCoinsPerPeriod.AmountOf(denom).MulRaw(testutil.TestVestingSchedule.CliffMonths)))\n+\t\t\t\t\tlockedVestedCoins := clawbackAccount.GetLockedUpVestedCoins(nw.GetContext().BlockTime())\n+\t\t\t\t\tExpect(lockedVestedCoins).To(Equal(expCoins))\n+\n+\t\t\t\t\t// deduct fees from delegation amount to pay the tx\n+\t\t\t\t\tfees := sdk.NewCoin(nw.GetDenom(), gasPrice.Mul(math.NewIntFromUint64(gas)))\n+\t\t\t\t\tdelMsg.Amount = vestAccInitialBalance.Add(lockedVestedCoins[0]).Sub(fees)\n+\n+\t\t\t\t\tres, err := tf.ExecuteCosmosTx(vestingAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{delMsg}, Gas: gas, GasPrice: &gasPrice})\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\t\t\t\t\tExpect(nw.NextBlock()).To(BeNil())\n+\n+\t\t\t\t\t// check delegation was created successfully\n+\t\t\t\t\tdelRes, err := gh.GetDelegation(vestingAccount.AccAddr.String(), nw.GetValidators()[0].OperatorAddress)\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(delRes.DelegationResponse).NotTo(BeNil())\n+\t\t\t\t\tExpect(delRes.DelegationResponse.Balance).To(Equal(delMsg.Amount))\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"should allow to delegate unlocked vested tokens\", func() {\n+\t\t\t\t\t// first lockup period passes\n+\t\t\t\t\tlockupPeriod := time.Duration(testutil.TestVestingSchedule.LockupPeriodLength)\n+\t\t\t\t\tExpect(nw.NextBlockAfter(lockupPeriod * time.Second)).To(BeNil())\n+\n+\t\t\t\t\t// check there're some vested coins\n+\t\t\t\t\tdenom := nw.GetDenom()\n+\t\t\t\t\texpVested := sdk.NewCoins(sdk.NewCoin(denom, testutil.TestVestingSchedule.VestedCoinsPerPeriod.AmountOf(denom).Mul(math.NewInt(testutil.TestVestingSchedule.LockupMonths))))\n+\t\t\t\t\tvestedCoins := clawbackAccount.GetVestedCoins(nw.GetContext().BlockTime())\n+\t\t\t\t\tExpect(vestedCoins).To(Equal(expVested))\n+\n+\t\t\t\t\t// all vested coins should be unlocked\n+\t\t\t\t\tunlockedVestedCoins := clawbackAccount.GetUnlockedVestedCoins(nw.GetContext().BlockTime())\n+\t\t\t\t\tExpect(unlockedVestedCoins).To(Equal(vestedCoins))\n+\n+\t\t\t\t\t// delegation amount is all free coins + unlocked vested - fee to pay tx\n+\t\t\t\t\tfees := sdk.NewCoin(nw.GetDenom(), gasPrice.Mul(math.NewIntFromUint64(gas)))\n+\t\t\t\t\tdelMsg.Amount = vestAccInitialBalance.Add(unlockedVestedCoins[0]).Sub(fees)\n+\n+\t\t\t\t\tres, err := tf.ExecuteCosmosTx(vestingAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{delMsg}, Gas: gas, GasPrice: &gasPrice})\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\t\t\t\t\tExpect(nw.NextBlock()).To(BeNil())\n+\n+\t\t\t\t\t// check delegation was created successfully\n+\t\t\t\t\tdelRes, err := gh.GetDelegation(vestingAccount.AccAddr.String(), nw.GetValidators()[0].OperatorAddress)\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(delRes.DelegationResponse).NotTo(BeNil())\n+\t\t\t\t\tExpect(delRes.DelegationResponse.Balance).To(Equal(delMsg.Amount))\n+\t\t\t\t})\n+\t\t\t})\n+\n+\t\t\tContext(\"MsgDelegate nested in MsgExec\", func() {\n+\t\t\t\tBeforeEach(func() {\n+\t\t\t\t\texpiration := time.Now().Add(time.Hour * 24 * 365 * 2) // 2years\n+\t\t\t\t\t// create a grant for other account\n+\t\t\t\t\t// to send a MsgDelegate\n+\t\t\t\t\tgrantMsg, err := authz.NewMsgGrant(vestingAccount.AccAddr, otherAccount.AccAddr, authz.NewGenericAuthorization(\"/cosmos.staking.v1beta1.MsgDelegate\"), &expiration)\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tres, err := tf.ExecuteCosmosTx(vestingAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{grantMsg}})\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\t\t\t\t\tExpect(nw.NextBlock()).To(BeNil())\n+\n+\t\t\t\t\t// create a MsgDelegate to delegate vested coins per period\n+\t\t\t\t\tdelMsg = types.NewMsgDelegate(vestingAccount.AccAddr, nw.GetValidators()[0].GetOperator(), testutil.TestVestingSchedule.VestedCoinsPerPeriod.Add(*vestAccInitialBalance)[0])\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"should not allow to delegate unvested tokens\", func() {\n+\t\t\t\t\t// all coins in vesting schedule should be unvested\n+\t\t\t\t\tunvestedCoins := clawbackAccount.GetVestingCoins(nw.GetContext().BlockTime())\n+\t\t\t\t\tExpect(unvestedCoins).To(Equal(testutil.TestVestingSchedule.TotalVestingCoins))\n+\n+\t\t\t\t\tbalRes, err := gh.GetBalance(vestingAccount.AccAddr, nw.GetDenom())\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tdelegatableBalance := balRes.Balance.Sub(unvestedCoins[0])\n+\t\t\t\t\tExpect(delegatableBalance.Amount.LT(delMsg.Amount.Amount)).To(BeTrue())\n+\n+\t\t\t\t\texecMsg := authz.NewMsgExec(otherAccount.AccAddr, []sdk.Msg{delMsg})\n+\t\t\t\t\t_, err = tf.ExecuteCosmosTx(otherAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{&execMsg}})\n+\t\t\t\t\tExpect(err).To(HaveOccurred())\n+\t\t\t\t\tExpect(err.Error()).To(ContainSubstring(\"cannot delegate unvested coins.\"))\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"should allow to delegate locked vested tokens\", func() {\n+\t\t\t\t\t// cliff period passes - some tokens vested, but still all locked\n+\t\t\t\t\tvestingPeriod := time.Duration(testutil.TestVestingSchedule.CliffPeriodLength)\n+\t\t\t\t\tExpect(nw.NextBlockAfter(vestingPeriod * time.Second)).To(BeNil())\n+\n+\t\t\t\t\t// check there're some vested coins\n+\t\t\t\t\tdenom := nw.GetDenom()\n+\t\t\t\t\texpCoins := sdk.NewCoins(sdk.NewCoin(denom, testutil.TestVestingSchedule.VestedCoinsPerPeriod.AmountOf(denom).MulRaw(testutil.TestVestingSchedule.CliffMonths)))\n+\t\t\t\t\tlockedVestedCoins := clawbackAccount.GetLockedUpVestedCoins(nw.GetContext().BlockTime())\n+\t\t\t\t\tExpect(lockedVestedCoins).To(Equal(expCoins))\n+\n+\t\t\t\t\t// update delegation amount to be the free balance + locked vested coins - fees\n+\t\t\t\t\tfees := sdk.NewCoin(nw.GetDenom(), gasPrice.Mul(math.NewIntFromUint64(gas)))\n+\t\t\t\t\tdelMsg.Amount = vestAccInitialBalance.Add(lockedVestedCoins[0]).Sub(fees)\n+\n+\t\t\t\t\texecMsg := authz.NewMsgExec(otherAccount.AccAddr, []sdk.Msg{delMsg})\n+\t\t\t\t\tres, err := tf.ExecuteCosmosTx(otherAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{&execMsg}, Gas: gas, GasPrice: &gasPrice})\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\t\t\t\t\tExpect(nw.NextBlock()).To(BeNil())\n+\n+\t\t\t\t\t// check delegation was created successfully\n+\t\t\t\t\tdelRes, err := gh.GetDelegation(vestingAccount.AccAddr.String(), nw.GetValidators()[0].OperatorAddress)\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(delRes.DelegationResponse).NotTo(BeNil())\n+\t\t\t\t\tExpect(delRes.DelegationResponse.Balance).To(Equal(delMsg.Amount))\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"after first lockup period - should allow to delegate unlocked vested tokens\", func() {\n+\t\t\t\t\t// first lockup period passes\n+\t\t\t\t\tlockupPeriod := time.Duration(testutil.TestVestingSchedule.LockupPeriodLength)\n+\t\t\t\t\tExpect(nw.NextBlockAfter(lockupPeriod * time.Second)).To(BeNil())\n+\n+\t\t\t\t\t// check there're some vested coins\n+\t\t\t\t\tdenom := nw.GetDenom()\n+\t\t\t\t\texpVested := sdk.NewCoins(sdk.NewCoin(denom, testutil.TestVestingSchedule.VestedCoinsPerPeriod.AmountOf(denom).Mul(math.NewInt(testutil.TestVestingSchedule.LockupMonths))))\n+\t\t\t\t\tvestedCoins := clawbackAccount.GetVestedCoins(nw.GetContext().BlockTime())\n+\t\t\t\t\tExpect(vestedCoins).To(Equal(expVested))\n+\n+\t\t\t\t\texecMsg := authz.NewMsgExec(otherAccount.AccAddr, []sdk.Msg{delMsg})\n+\t\t\t\t\tres, err := tf.ExecuteCosmosTx(otherAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{&execMsg}, Gas: gas})\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\t\t\t\t\tExpect(nw.NextBlock()).To(BeNil())\n+\n+\t\t\t\t\t// check delegation was created successfully\n+\t\t\t\t\tdelRes, err := gh.GetDelegation(vestingAccount.AccAddr.String(), nw.GetValidators()[0].OperatorAddress)\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(delRes.DelegationResponse).NotTo(BeNil())\n+\t\t\t\t\tExpect(delRes.DelegationResponse.Balance).To(Equal(delMsg.Amount))\n+\t\t\t\t})\n+\t\t\t})\n+\t\t})\n+\n+\t\tContext(\"create validator with self delegation\", func() {\n+\t\t\tvar createValMsg *types.MsgCreateValidator\n+\n+\t\t\tBeforeEach(func() {\n+\t\t\t\t// create a MsgCreateValidator to create a validator.\n+\t\t\t\t// Self delegate coins in the vesting schedule\n+\t\t\t\tvar err error\n+\t\t\t\tpubKey := ed25519.GenPrivKey().PubKey()\n+\t\t\t\tcommissions := types.NewCommissionRates(\n+\t\t\t\t\tsdk.NewDecWithPrec(5, 2),\n+\t\t\t\t\tsdk.NewDecWithPrec(2, 1),\n+\t\t\t\t\tsdk.NewDecWithPrec(5, 2),\n+\t\t\t\t)\n+\t\t\t\tcreateValMsg, err = types.NewMsgCreateValidator(\n+\t\t\t\t\tsdk.ValAddress(vestingAccount.AccAddr),\n+\t\t\t\t\tpubKey,\n+\t\t\t\t\ttestutil.TestVestingSchedule.VestedCoinsPerPeriod.Add(*vestAccInitialBalance)[0],\n+\t\t\t\t\ttypes.NewDescription(\"T\", \"E\", \"S\", \"T\", \"Z\"),\n+\t\t\t\t\tcommissions,\n+\t\t\t\t\tsdk.OneInt(),\n+\t\t\t\t)\n+\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t})\n+\n+\t\t\tIt(\"should not allow to create validator with unvested tokens in self delegation\", func() {\n+\t\t\t\t// all coins in vesting schedule should be unvested\n+\t\t\t\tunvestedCoins := clawbackAccount.GetVestingCoins(nw.GetContext().BlockTime())\n+\t\t\t\tExpect(unvestedCoins).To(Equal(testutil.TestVestingSchedule.TotalVestingCoins))\n+\n+\t\t\t\tbalRes, err := gh.GetBalance(vestingAccount.AccAddr, nw.GetDenom())\n+\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\tdelegatableBalance := balRes.Balance.Sub(unvestedCoins[0])\n+\t\t\t\tExpect(delegatableBalance.Amount.LT(createValMsg.Value.Amount)).To(BeTrue())\n+\n+\t\t\t\t_, err = tf.ExecuteCosmosTx(vestingAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{createValMsg}})\n+\t\t\t\tExpect(err).To(HaveOccurred())\n+\t\t\t\tExpect(err.Error()).To(ContainSubstring(\"cannot delegate unvested coins.\"))\n+\t\t\t})\n+\n+\t\t\tIt(\"should allow to create validator with locked vested tokens\", func() {\n+\t\t\t\t// cliff period passes - some tokens vested, but still all locked\n+\t\t\t\tvestingPeriod := time.Duration(testutil.TestVestingSchedule.CliffPeriodLength)\n+\t\t\t\tExpect(nw.NextBlockAfter(vestingPeriod * time.Second)).To(BeNil())\n+\n+\t\t\t\t// check there're some vested coins\n+\t\t\t\tdenom := nw.GetDenom()\n+\t\t\t\texpCoins := sdk.NewCoins(sdk.NewCoin(denom, testutil.TestVestingSchedule.VestedCoinsPerPeriod.AmountOf(denom).MulRaw(testutil.TestVestingSchedule.CliffMonths)))\n+\t\t\t\tlockedVestedCoins := clawbackAccount.GetLockedUpVestedCoins(nw.GetContext().BlockTime())\n+\t\t\t\tExpect(lockedVestedCoins).To(Equal(expCoins))\n+\n+\t\t\t\t// update delegation amount to be the free balance + locked vested coins - fees\n+\t\t\t\tfees := sdk.NewCoin(nw.GetDenom(), gasPrice.Mul(math.NewIntFromUint64(gas)))\n+\t\t\t\tcreateValMsg.Value = vestAccInitialBalance.Add(lockedVestedCoins[0]).Sub(fees)\n+\n+\t\t\t\tres, err := tf.ExecuteCosmosTx(vestingAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{createValMsg}, Gas: gas, GasPrice: &gasPrice})\n+\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\t\t\t\tExpect(nw.NextBlock()).To(BeNil())\n+\n+\t\t\t\t// check validator was created successfully\n+\t\t\t\tqc := nw.GetStakingClient()\n+\t\t\t\tvalRes, err := qc.Validator(nw.GetContext(), &types.QueryValidatorRequest{ValidatorAddr: sdk.ValAddress(vestingAccount.AccAddr).String()})\n+\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\tExpect(valRes.Validator.Status).To(Equal(types.Bonded))\n+\t\t\t})\n+\n+\t\t\tIt(\"after first lockup period - should allow to create validator with a delegation of vested tokens\", func() {\n+\t\t\t\t// first lockup period passes\n+\t\t\t\tlockupPeriod := time.Duration(testutil.TestVestingSchedule.LockupPeriodLength)\n+\t\t\t\tExpect(nw.NextBlockAfter(lockupPeriod * time.Second)).To(BeNil())\n+\n+\t\t\t\t// check there're some vested coins\n+\t\t\t\tdenom := nw.GetDenom()\n+\t\t\t\texpVested := sdk.NewCoins(sdk.NewCoin(denom, testutil.TestVestingSchedule.VestedCoinsPerPeriod.AmountOf(denom).Mul(math.NewInt(testutil.TestVestingSchedule.LockupMonths))))\n+\t\t\t\tvestedCoins := clawbackAccount.GetVestedCoins(nw.GetContext().BlockTime())\n+\t\t\t\tExpect(vestedCoins).To(Equal(expVested))\n+\n+\t\t\t\tres, err := tf.ExecuteCosmosTx(vestingAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{createValMsg}, Gas: 500_000})\n+\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\t\t\t\tExpect(nw.NextBlock()).To(BeNil())\n+\n+\t\t\t\t// check validator was created successfully\n+\t\t\t\tqc := nw.GetStakingClient()\n+\t\t\t\tvalRes, err := qc.Validator(nw.GetContext(), &types.QueryValidatorRequest{ValidatorAddr: sdk.ValAddress(vestingAccount.AccAddr).String()})\n+\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\tExpect(valRes.Validator.Status).To(Equal(types.Bonded))\n+\t\t\t})\n+\t\t})\n+\t})\n+})\n```\n\nFilename: x/staking/keeper/keeper.go:\n```\n@@ -0,0 +1,33 @@\n+// Copyright Tharsis Labs Ltd.(Evmos)\n+// SPDX-License-Identifier:ENCL-1.0(https://github.com/evmos/evmos/blob/main/LICENSE)\n+\n+package keeper\n+\n+import (\n+\t\"github.com/cosmos/cosmos-sdk/codec\"\n+\tstoretypes \"github.com/cosmos/cosmos-sdk/store/types\"\n+\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n+\t\"github.com/cosmos/cosmos-sdk/x/staking/types\"\n+)\n+\n+// Keeper is a wrapper around the Cosmos SDK staking keeper.\n+type Keeper struct {\n+\t*stakingkeeper.Keeper\n+\tak types.AccountKeeper\n+\tbk types.BankKeeper\n+}\n+\n+// NewKeeper creates a new staking Keeper wrapper instance.\n+func NewKeeper(\n+\tcdc codec.BinaryCodec,\n+\tkey storetypes.StoreKey,\n+\tak types.AccountKeeper,\n+\tbk types.BankKeeper,\n+\tauthority string,\n+) *Keeper {\n+\treturn &Keeper{\n+\t\tstakingkeeper.NewKeeper(cdc, key, ak, bk, authority),\n+\t\tak,\n+\t\tbk,\n+\t}\n+}\n```\n\nFilename: x/staking/keeper/msg_server.go:\n```\n@@ -0,0 +1,107 @@\n+// Copyright Tharsis Labs Ltd.(Evmos)\n+// SPDX-License-Identifier:ENCL-1.0(https://github.com/evmos/evmos/blob/main/LICENSE)\n+\n+package keeper\n+\n+import (\n+\t\"context\"\n+\n+\terrorsmod \"cosmossdk.io/errors\"\n+\t\"cosmossdk.io/math\"\n+\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n+\terrortypes \"github.com/cosmos/cosmos-sdk/types/errors\"\n+\tsdkstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n+\t\"github.com/cosmos/cosmos-sdk/x/staking/types\"\n+\n+\tvestingtypes \"github.com/evmos/evmos/v18/x/vesting/types\"\n+)\n+\n+// msgServer is a wrapper around the Cosmos SDK message server.\n+type msgServer struct {\n+\ttypes.MsgServer\n+\t*Keeper\n+}\n+\n+var _ types.MsgServer = msgServer{}\n+\n+// NewMsgServerImpl returns an implementation of the staking MsgServer interface\n+// for the provided Keeper.\n+func NewMsgServerImpl(keeper *Keeper) types.MsgServer {\n+\tbaseMsgServer := sdkstakingkeeper.NewMsgServerImpl(keeper.Keeper)\n+\treturn &msgServer{baseMsgServer, keeper}\n+}\n+\n+// Delegate defines a method for performing a delegation of coins from a delegator to a validator.\n+// The method performs some checks if the sender of the tx is a clawback vesting account and then\n+// relay the message to the Cosmos SDK staking method.\n+func (k msgServer) Delegate(goCtx context.Context, msg *types.MsgDelegate) (*types.MsgDelegateResponse, error) {\n+\tif err := k.validateDelegationAmountNotUnvested(goCtx, msg.DelegatorAddress, msg.Amount.Amount); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn k.MsgServer.Delegate(goCtx, msg)\n+}\n+\n+// CreateValidator defines a method to create a validator. The method performs some checks if the\n+// sender of the tx is a clawback vesting account and then relay the message to the Cosmos SDK staking\n+// method.\n+func (k msgServer) CreateValidator(goCtx context.Context, msg *types.MsgCreateValidator) (*types.MsgCreateValidatorResponse, error) {\n+\tif err := k.validateDelegationAmountNotUnvested(goCtx, msg.DelegatorAddress, msg.Value.Amount); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn k.MsgServer.CreateValidator(goCtx, msg)\n+}\n+\n+// validateDelegationAmountNotUnvested checks if the delegator is a clawback vesting account.\n+// In such case, checks that the provided delegation amount is available according\n+// to the current vesting schedule (unvested coins cannot be delegated).\n+func (k msgServer) validateDelegationAmountNotUnvested(goCtx context.Context, delegatorAddress string, amount math.Int) error {\n+\tctx := sdk.UnwrapSDKContext(goCtx)\n+\taddr, err := sdk.AccAddressFromBech32(delegatorAddress)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tacc := k.ak.GetAccount(ctx, addr)\n+\tif acc == nil {\n+\t\treturn errorsmod.Wrapf(\n+\t\t\terrortypes.ErrUnknownAddress,\n+\t\t\t\"account %s does not exist\", addr,\n+\t\t)\n+\t}\n+\t// check if delegator address is a clawback vesting account. If not, no check\n+\t// is required.\n+\tclawbackAccount, isClawback := acc.(*vestingtypes.ClawbackVestingAccount)\n+\tif !isClawback {\n+\t\treturn nil\n+\t}\n+\n+\t// vesting account can only delegate\n+\t// if enough free balance (coins not in vesting schedule)\n+\t// plus the vested coins (locked/unlocked)\n+\tbondDenom := k.BondDenom(ctx)\n+\t// GetBalance returns entire account balance\n+\t// balance = free coins + all coins in vesting schedule\n+\tbalance := k.bk.GetBalance(ctx, addr, bondDenom)\n+\tunvestedOnly := clawbackAccount.GetVestingCoins(ctx.BlockTime())\n+\t// delegatable coins are going to be all the free coins + vested coins\n+\t// Can only delegate bondable coins\n+\tunvestedBondableAmt := unvestedOnly.AmountOf(bondDenom)\n+\t// A ClawbackVestingAccount can delegate coins from the vesting schedule\n+\t// when having vested locked coins or unlocked vested coins.\n+\t// It CANNOT delegate unvested coins\n+\tdelegatableAmt := balance.Amount.Sub(unvestedBondableAmt)\n+\tif delegatableAmt.IsNegative() {\n+\t\tdelegatableAmt = math.ZeroInt()\n+\t}\n+\n+\tif delegatableAmt.LT(amount) {\n+\t\treturn errorsmod.Wrapf(\n+\t\t\tvestingtypes.ErrInsufficientVestedCoins,\n+\t\t\t\"cannot delegate unvested coins. coins available for delegation < delegation amount (%s < %s)\",\n+\t\t\tdelegatableAmt, amount,\n+\t\t)\n+\t}\n+\treturn nil\n+}\n```\n\nFilename: x/staking/keeper/msg_server_test.go:\n```\n@@ -0,0 +1,271 @@\n+// Copyright Tharsis Labs Ltd.(Evmos)\n+// SPDX-License-Identifier:ENCL-1.0(https://github.com/evmos/evmos/blob/main/LICENSE)\n+\n+package keeper_test\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"cosmossdk.io/math\"\n+\t\"github.com/cosmos/cosmos-sdk/crypto/keys/ed25519\"\n+\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n+\t\"github.com/cosmos/cosmos-sdk/x/staking/types\"\n+\n+\t\"github.com/evmos/evmos/v18/testutil\"\n+\t\"github.com/evmos/evmos/v18/testutil/integration/evmos/network\"\n+\tutiltx \"github.com/evmos/evmos/v18/testutil/tx\"\n+\t\"github.com/evmos/evmos/v18/utils\"\n+\t\"github.com/evmos/evmos/v18/x/staking/keeper\"\n+\tvestingtypes \"github.com/evmos/evmos/v18/x/vesting/types\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+func TestMsgDelegate(t *testing.T) {\n+\tvar (\n+\t\tctx              sdk.Context\n+\t\tnw               *network.UnitTestNetwork\n+\t\tdefaultDelCoin   = sdk.NewCoin(utils.BaseDenom, math.NewInt(1e18))\n+\t\tdelegatorAddr, _ = utiltx.NewAccAddressAndKey()\n+\t\tfunderAddr, _    = utiltx.NewAccAddressAndKey()\n+\t)\n+\n+\ttestCases := []struct {\n+\t\tname   string\n+\t\tsetup  func() sdk.Coin\n+\t\texpErr bool\n+\t\terrMsg string\n+\t}{\n+\t\t{\n+\t\t\tname: \"can delegate from a common EthAccount\",\n+\t\t\tsetup: func() sdk.Coin {\n+\t\t\t\t// Send some funds to delegator account\n+\t\t\t\terr := testutil.FundAccountWithBaseDenom(ctx, nw.App.BankKeeper, delegatorAddr, defaultDelCoin.Amount.Int64())\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\treturn defaultDelCoin\n+\t\t\t},\n+\t\t\texpErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"can delegate free coins from a ClawbackVestingAccount\",\n+\t\t\tsetup: func() sdk.Coin {\n+\t\t\t\terr := setupClawbackVestingAccount(ctx, nw, delegatorAddr, funderAddr, testutil.TestVestingSchedule.TotalVestingCoins.Add(defaultDelCoin))\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\treturn defaultDelCoin\n+\t\t\t},\n+\t\t\texpErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"cannot delegate unvested coins from a ClawbackVestingAccount\",\n+\t\t\tsetup: func() sdk.Coin {\n+\t\t\t\terr := setupClawbackVestingAccount(ctx, nw, delegatorAddr, funderAddr, testutil.TestVestingSchedule.TotalVestingCoins)\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\treturn defaultDelCoin\n+\t\t\t},\n+\t\t\texpErr: true,\n+\t\t\terrMsg: \"cannot delegate unvested coins\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"can delegate locked vested coins from a ClawbackVestingAccount\",\n+\t\t\tsetup: func() sdk.Coin {\n+\t\t\t\terr := setupClawbackVestingAccount(ctx, nw, delegatorAddr, funderAddr, testutil.TestVestingSchedule.TotalVestingCoins)\n+\t\t\t\trequire.NoError(t, err)\n+\n+\t\t\t\t// after first vesting period and before lockup\n+\t\t\t\t// some vested tokens, but still all locked\n+\t\t\t\tcliffDuration := time.Duration(testutil.TestVestingSchedule.CliffPeriodLength)\n+\t\t\t\tnw.NextBlockAfter(cliffDuration * time.Second)\n+\t\t\t\tctx = nw.GetContext()\n+\n+\t\t\t\tacc := nw.App.AccountKeeper.GetAccount(ctx, delegatorAddr)\n+\t\t\t\tvestAcc, ok := acc.(*vestingtypes.ClawbackVestingAccount)\n+\t\t\t\trequire.True(t, ok)\n+\n+\t\t\t\t// check that locked vested is > 0\n+\t\t\t\tlockedVested := vestAcc.GetLockedUpVestedCoins(ctx.BlockTime())\n+\t\t\t\trequire.True(t, lockedVested.IsAllGT(sdk.NewCoins()))\n+\n+\t\t\t\t// returned delegation coins are the locked vested coins\n+\t\t\t\treturn lockedVested[0]\n+\t\t\t},\n+\t\t\texpErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"can delegate unlocked vested coins from a ClawbackVestingAccount\",\n+\t\t\tsetup: func() sdk.Coin {\n+\t\t\t\terr := setupClawbackVestingAccount(ctx, nw, delegatorAddr, funderAddr, testutil.TestVestingSchedule.TotalVestingCoins)\n+\t\t\t\trequire.NoError(t, err)\n+\n+\t\t\t\t// Between first and second lockup periods\n+\t\t\t\t// vested coins are unlocked\n+\t\t\t\tlockDuration := time.Duration(testutil.TestVestingSchedule.LockupPeriodLength)\n+\t\t\t\tnw.NextBlockAfter(lockDuration * time.Second)\n+\t\t\t\tctx = nw.GetContext()\n+\n+\t\t\t\tacc := nw.App.AccountKeeper.GetAccount(ctx, delegatorAddr)\n+\t\t\t\tvestAcc, ok := acc.(*vestingtypes.ClawbackVestingAccount)\n+\t\t\t\trequire.True(t, ok)\n+\n+\t\t\t\tunlockedVested := vestAcc.GetUnlockedVestedCoins(ctx.BlockTime())\n+\t\t\t\trequire.True(t, unlockedVested.IsAllGT(sdk.NewCoins()))\n+\n+\t\t\t\t// returned delegation coins are the locked vested coins\n+\t\t\t\treturn unlockedVested[0]\n+\t\t\t},\n+\t\t\texpErr: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tnw = network.NewUnitTestNetwork()\n+\t\t\tctx = nw.GetContext()\n+\t\t\tdelCoin := tc.setup()\n+\n+\t\t\tsrv := keeper.NewMsgServerImpl(&nw.App.StakingKeeper)\n+\t\t\tres, err := srv.Delegate(ctx, &types.MsgDelegate{\n+\t\t\t\tDelegatorAddress: delegatorAddr.String(),\n+\t\t\t\tValidatorAddress: nw.GetValidators()[0].OperatorAddress,\n+\t\t\t\tAmount:           delCoin,\n+\t\t\t})\n+\n+\t\t\tif tc.expErr {\n+\t\t\t\trequire.Error(t, err)\n+\t\t\t\trequire.Contains(t, err.Error(), tc.errMsg)\n+\t\t\t} else {\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\trequire.NotNil(t, res)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestMsgCreateValidator(t *testing.T) {\n+\tvar (\n+\t\tctx              sdk.Context\n+\t\tnw               *network.UnitTestNetwork\n+\t\tdefaultDelCoin   = sdk.NewCoin(utils.BaseDenom, math.NewInt(1e18))\n+\t\tvalidatorAddr, _ = utiltx.NewAccAddressAndKey()\n+\t\tfunderAddr, _    = utiltx.NewAccAddressAndKey()\n+\t)\n+\n+\ttestCases := []struct {\n+\t\tname   string\n+\t\tsetup  func() sdk.Coin\n+\t\texpErr bool\n+\t\terrMsg string\n+\t}{\n+\t\t{\n+\t\t\tname: \"can create a validator using a common EthAccount\",\n+\t\t\tsetup: func() sdk.Coin {\n+\t\t\t\t// Send some funds to delegator account\n+\t\t\t\terr := testutil.FundAccountWithBaseDenom(ctx, nw.App.BankKeeper, validatorAddr, defaultDelCoin.Amount.Int64())\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\treturn defaultDelCoin\n+\t\t\t},\n+\t\t\texpErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"can create a validator using a ClawbackVestingAccount and free tokens in self delegation\",\n+\t\t\tsetup: func() sdk.Coin {\n+\t\t\t\terr := setupClawbackVestingAccount(ctx, nw, validatorAddr, funderAddr, testutil.TestVestingSchedule.TotalVestingCoins.Add(defaultDelCoin))\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\treturn defaultDelCoin\n+\t\t\t},\n+\t\t\texpErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"cannot create a validator using a ClawbackVestingAccount and unvested tokens in self delegation\",\n+\t\t\tsetup: func() sdk.Coin {\n+\t\t\t\terr := setupClawbackVestingAccount(ctx, nw, validatorAddr, funderAddr, testutil.TestVestingSchedule.TotalVestingCoins)\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\treturn defaultDelCoin\n+\t\t\t},\n+\t\t\texpErr: true,\n+\t\t\terrMsg: \"cannot delegate unvested coins\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"can create a validator using a ClawbackVestingAccount and locked vested coins in self delegation\",\n+\t\t\tsetup: func() sdk.Coin {\n+\t\t\t\terr := setupClawbackVestingAccount(ctx, nw, validatorAddr, funderAddr, testutil.TestVestingSchedule.TotalVestingCoins)\n+\t\t\t\trequire.NoError(t, err)\n+\n+\t\t\t\t// after first vesting period and before lockup\n+\t\t\t\t// some vested tokens, but still all locked\n+\t\t\t\tcliffDuration := time.Duration(testutil.TestVestingSchedule.CliffPeriodLength)\n+\t\t\t\tnw.NextBlockAfter(cliffDuration * time.Second)\n+\t\t\t\tctx = nw.GetContext()\n+\n+\t\t\t\tacc := nw.App.AccountKeeper.GetAccount(ctx, validatorAddr)\n+\t\t\t\tvestAcc, ok := acc.(*vestingtypes.ClawbackVestingAccount)\n+\t\t\t\trequire.True(t, ok)\n+\n+\t\t\t\t// check that locked vested is > 0\n+\t\t\t\tlockedVested := vestAcc.GetLockedUpVestedCoins(ctx.BlockTime())\n+\t\t\t\trequire.True(t, lockedVested.IsAllGT(sdk.NewCoins()))\n+\n+\t\t\t\t// returned delegation coins are the locked vested coins\n+\t\t\t\treturn lockedVested[0]\n+\t\t\t},\n+\t\t\texpErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"can create a validator using a ClawbackVestingAccount and unlocked vested coins in self delegation\",\n+\t\t\tsetup: func() sdk.Coin {\n+\t\t\t\terr := setupClawbackVestingAccount(ctx, nw, validatorAddr, funderAddr, testutil.TestVestingSchedule.TotalVestingCoins)\n+\t\t\t\trequire.NoError(t, err)\n+\n+\t\t\t\t// Between first and second lockup periods\n+\t\t\t\t// vested coins are unlocked\n+\t\t\t\tlockDuration := time.Duration(testutil.TestVestingSchedule.LockupPeriodLength)\n+\t\t\t\tnw.NextBlockAfter(lockDuration * time.Second)\n+\t\t\t\tctx = nw.GetContext()\n+\n+\t\t\t\tacc := nw.App.AccountKeeper.GetAccount(ctx, validatorAddr)\n+\t\t\t\tvestAcc, ok := acc.(*vestingtypes.ClawbackVestingAccount)\n+\t\t\t\trequire.True(t, ok)\n+\n+\t\t\t\tunlockedVested := vestAcc.GetUnlockedVestedCoins(ctx.BlockTime())\n+\t\t\t\trequire.True(t, unlockedVested.IsAllGT(sdk.NewCoins()))\n+\n+\t\t\t\t// returned delegation coins are the locked vested coins\n+\t\t\t\treturn unlockedVested[0]\n+\t\t\t},\n+\t\t\texpErr: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tnw = network.NewUnitTestNetwork()\n+\t\t\tctx = nw.GetContext()\n+\t\t\tcoinToSelfBond := tc.setup()\n+\n+\t\t\tpubKey := ed25519.GenPrivKey().PubKey()\n+\t\t\tcommissions := types.NewCommissionRates(\n+\t\t\t\tsdk.NewDecWithPrec(5, 2),\n+\t\t\t\tsdk.NewDecWithPrec(2, 1),\n+\t\t\t\tsdk.NewDecWithPrec(5, 2),\n+\t\t\t)\n+\t\t\tmsg, err := types.NewMsgCreateValidator(\n+\t\t\t\tsdk.ValAddress(validatorAddr),\n+\t\t\t\tpubKey,\n+\t\t\t\tcoinToSelfBond,\n+\t\t\t\ttypes.NewDescription(\"T\", \"E\", \"S\", \"T\", \"Z\"),\n+\t\t\t\tcommissions,\n+\t\t\t\tsdk.OneInt(),\n+\t\t\t)\n+\t\t\trequire.NoError(t, err)\n+\t\t\tsrv := keeper.NewMsgServerImpl(&nw.App.StakingKeeper)\n+\t\t\tres, err := srv.CreateValidator(ctx, msg)\n+\n+\t\t\tif tc.expErr {\n+\t\t\t\trequire.Error(t, err)\n+\t\t\t\trequire.Contains(t, err.Error(), tc.errMsg)\n+\t\t\t} else {\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\trequire.NotNil(t, res)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n```\n\nFilename: x/staking/keeper/util_test.go:\n```\n@@ -0,0 +1,48 @@\n+// Copyright Tharsis Labs Ltd.(Evmos)\n+// SPDX-License-Identifier:ENCL-1.0(https://github.com/evmos/evmos/blob/main/LICENSE)\n+\n+package keeper_test\n+\n+import (\n+\t\"errors\"\n+\t\"time\"\n+\n+\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n+\t\"github.com/evmos/evmos/v18/testutil\"\n+\t\"github.com/evmos/evmos/v18/testutil/integration/evmos/network\"\n+\t\"github.com/evmos/evmos/v18/x/vesting/types\"\n+)\n+\n+// setupClawbackVestingAccount sets up a clawback vesting account\n+// using the TestVestingSchedule. If exceeded balance is provided,\n+// will fund the vesting account with it.\n+func setupClawbackVestingAccount(ctx sdk.Context, nw *network.UnitTestNetwork, vestingAcc, funderAcc sdk.AccAddress, balances sdk.Coins) error {\n+\ttotalVestingCoins := testutil.TestVestingSchedule.TotalVestingCoins\n+\tif totalVestingCoins.IsAllGT(balances) {\n+\t\treturn errors.New(\"should provide enough balance for the vesting schedule\")\n+\t}\n+\t// fund the vesting account to set the account and then\n+\t// send funds over to the funder account so free balance remains\n+\terr := testutil.FundAccount(ctx, nw.App.BankKeeper, vestingAcc, balances)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\terr = nw.App.BankKeeper.SendCoins(ctx, vestingAcc, funderAcc, totalVestingCoins)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// create a clawback vesting account\n+\tmsgCreate := types.NewMsgCreateClawbackVestingAccount(funderAcc, vestingAcc, false)\n+\tif _, err = nw.App.VestingKeeper.CreateClawbackVestingAccount(ctx, msgCreate); err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// fund vesting account\n+\tmsgFund := types.NewMsgFundVestingAccount(funderAcc, vestingAcc, time.Now(), testutil.TestVestingSchedule.LockupPeriods, testutil.TestVestingSchedule.VestingPeriods)\n+\tif _, err = nw.App.VestingKeeper.FundVestingAccount(ctx, msgFund); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn nil\n+}\n```\n\nFilename: x/staking/module.go:\n```\n@@ -0,0 +1,61 @@\n+// Copyright Tharsis Labs Ltd.(Evmos)\n+// SPDX-License-Identifier:ENCL-1.0(https://github.com/evmos/evmos/blob/main/LICENSE)\n+\n+package staking\n+\n+import (\n+\t\"github.com/cosmos/cosmos-sdk/codec\"\n+\t\"github.com/cosmos/cosmos-sdk/types/module\"\n+\t\"github.com/cosmos/cosmos-sdk/x/auth/exported\"\n+\t\"github.com/cosmos/cosmos-sdk/x/staking\"\n+\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n+\t\"github.com/cosmos/cosmos-sdk/x/staking/types\"\n+\n+\t\"github.com/evmos/evmos/v18/x/staking/keeper\"\n+)\n+\n+var (\n+\t_ module.BeginBlockAppModule = AppModule{}\n+\t_ module.EndBlockAppModule   = AppModule{}\n+\t_ module.AppModuleBasic      = AppModuleBasic{}\n+\t_ module.AppModuleSimulation = AppModule{}\n+)\n+\n+// AppModuleBasic defines the basic application module used by the staking module.\n+type AppModuleBasic struct {\n+\t*staking.AppModuleBasic\n+}\n+\n+// AppModule represents a wrapper around the Cosmos SDK staking module AppModule and\n+// the Evmos custom staking module keeper.\n+type AppModule struct {\n+\t*staking.AppModule\n+\tkeeper *keeper.Keeper\n+}\n+\n+// NewAppModule creates a wrapper for the staking module.\n+func NewAppModule(\n+\tcdc codec.Codec,\n+\tk *keeper.Keeper,\n+\tak types.AccountKeeper,\n+\tbk types.BankKeeper,\n+\tls exported.Subspace,\n+) AppModule {\n+\tam := staking.NewAppModule(cdc, k.Keeper, ak, bk, ls)\n+\treturn AppModule{\n+\t\tAppModule: &am,\n+\t\tkeeper:    k,\n+\t}\n+}\n+\n+// RegisterServices registers module services.\n+func (am AppModule) RegisterServices(cfg module.Configurator) {\n+\t// Override Staking Msg Server\n+\ttypes.RegisterMsgServer(cfg.MsgServer(), keeper.NewMsgServerImpl(am.keeper))\n+\tquerier := stakingkeeper.Querier{Keeper: am.keeper.Keeper}\n+\ttypes.RegisterQueryServer(cfg.QueryServer(), querier)\n+\n+\t// !! NOTE: when upgrading to a new cosmos-sdk version\n+\t// !! Check if there're store migrations for the staking module\n+\t// !! if so, you'll need to add them here\n+}\n```\n\nFilename: x/vesting/keeper/gov_test.go:\n```\n@@ -6,7 +6,9 @@\nimport (\n )\n \n func (suite *KeeperTestSuite) TestGovClawbackStore() {\n-\tsuite.SetupTest()\n+\tif err := suite.SetupTest(); err != nil {\n+\t\tpanic(err)\n+\t}\n \n \taddr := sdk.AccAddress(suite.address.Bytes())\n\n@@ -30,7 +32,9 @@\nfunc (suite *KeeperTestSuite) TestGovClawbackStore() {\n }\n \n func (suite *KeeperTestSuite) TestGovClawbackNoOps() {\n-\tsuite.SetupTest()\n+\tif err := suite.SetupTest(); err != nil {\n+\t\tpanic(err)\n+\t}\n \n \taddr := sdk.AccAddress(suite.address.Bytes())\n \taddr2 := sdk.AccAddress(testutiltx.GenerateAddress().Bytes())\n```\n\nFilename: x/vesting/keeper/grpc_query.go:\n```\n@@ -40,9 +40,9 @@\nfunc (k Keeper) Balances(\n \t\t)\n \t}\n \n-\tlocked := clawbackAccount.GetLockedOnly(ctx.BlockTime())\n-\tunvested := clawbackAccount.GetUnvestedOnly(ctx.BlockTime())\n-\tvested := clawbackAccount.GetVestedOnly(ctx.BlockTime())\n+\tlocked := clawbackAccount.GetLockedUpCoins(ctx.BlockTime())\n+\tunvested := clawbackAccount.GetVestingCoins(ctx.BlockTime())\n+\tvested := clawbackAccount.GetVestedCoins(ctx.BlockTime())\n \n \treturn &types.QueryBalancesResponse{\n \t\tLocked:   locked,\n```\n\nFilename: x/vesting/keeper/grpc_query_test.go:\n```\n@@ -117,7 +117,7 @@\nfunc (suite *KeeperTestSuite) TestBalances() {\n \n \tfor _, tc := range testCases {\n \t\tsuite.Run(fmt.Sprintf(\"Case %s\", tc.name), func() {\n-\t\t\tsuite.SetupTest() // reset\n+\t\t\tsuite.Require().NoError(suite.SetupTest()) // reset\n \t\t\tctx := sdk.WrapSDKContext(suite.ctx)\n \t\t\ttc.malleate()\n \t\t\tsuite.Commit()\n```\n\nFilename: x/vesting/keeper/integration_test.go:\n```\n@@ -4,6 +4,7 @@\nimport (\n \t\"fmt\"\n \t\"math/big\"\n \t\"strings\"\n+\t\"testing\"\n \t\"time\"\n \n \t//nolint:revive // dot imports are fine for Ginkgo\n\n@@ -12,14 +13,17 @@\nimport (\n \t. \"github.com/onsi/gomega\"\n \n \t\"cosmossdk.io/math\"\n+\t\"github.com/cosmos/cosmos-sdk/baseapp\"\n \tsdk \"github.com/cosmos/cosmos-sdk/types\"\n \terrortypes \"github.com/cosmos/cosmos-sdk/types/errors\"\n \tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n \tsdkvesting \"github.com/cosmos/cosmos-sdk/x/auth/vesting/types\"\n+\tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n \tgovtypes \"github.com/cosmos/cosmos-sdk/x/gov/types\"\n \tgovv1 \"github.com/cosmos/cosmos-sdk/x/gov/types/v1\"\n \tgovv1beta1 \"github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1\"\n \tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n+\tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n \t\"github.com/ethereum/go-ethereum/common\"\n \t\"github.com/evmos/evmos/v18/contracts\"\n \t\"github.com/evmos/evmos/v18/crypto/ethsecp256k1\"\n\n@@ -31,6 +35,15 @@\nimport (\n \t\"github.com/evmos/evmos/v18/x/vesting/types\"\n )\n \n+func TestKeeperIntegrationTestSuite(t *testing.T) {\n+\ts = new(KeeperTestSuite)\n+\ts.SetT(t)\n+\n+\t// Run Ginkgo integration tests\n+\tRegisterFailHandler(Fail)\n+\tRunSpecs(t, \"Keeper Suite\")\n+}\n+\n // TestClawbackAccount is a struct to store all relevant information that is corresponding\n // to a clawback vesting account.\n type TestClawbackAccount struct {\n\n@@ -40,7 +53,20 @@\ntype TestClawbackAccount struct {\n }\n \n // Initialize general error variable for easier handling in loops throughout this test suite.\n-var err error\n+var (\n+\terr                error\n+\tstakeDenom         = utils.BaseDenom\n+\taccountGasCoverage = sdk.NewCoins(sdk.NewCoin(stakeDenom, math.NewInt(1e16)))\n+\tamt                = testutil.TestVestingSchedule.VestedCoinsPerPeriod[0].Amount\n+\tcliff              = testutil.TestVestingSchedule.CliffMonths\n+\tcliffLength        = testutil.TestVestingSchedule.CliffPeriodLength\n+\tvestingAmtTotal    = testutil.TestVestingSchedule.TotalVestingCoins\n+\tvestingLength      = testutil.TestVestingSchedule.VestingPeriodLength\n+\tnumLockupPeriods   = testutil.TestVestingSchedule.NumLockupPeriods\n+\tperiodsTotal       = testutil.TestVestingSchedule.NumVestingPeriods\n+\tlockup             = testutil.TestVestingSchedule.LockupMonths\n+\tunlockedPerLockup  = testutil.TestVestingSchedule.UnlockedCoinsPerLockup\n+)\n \n // Clawback vesting with Cliff and Lock. In this case the cliff is reached\n // before the lockup period is reached to represent the scenario in which an\n\n@@ -52,44 +78,6 @@\nvar err error\n // 22/09 Cliff ends\n // 23/02 Lock ends\n var _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n-\t// Monthly vesting period\n-\tstakeDenom := utils.BaseDenom\n-\tamt := math.NewInt(1e17)\n-\tvestingLength := int64(60 * 60 * 24 * 30) // in seconds\n-\tvestingAmt := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt))\n-\tvestingPeriod := sdkvesting.Period{Length: vestingLength, Amount: vestingAmt}\n-\n-\t// 4 years vesting total\n-\tperiodsTotal := int64(48)\n-\tvestingAmtTotal := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(periodsTotal))))\n-\n-\t// 6 month cliff\n-\tcliff := int64(6)\n-\tcliffLength := vestingLength * cliff\n-\tcliffAmt := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(cliff))))\n-\tcliffPeriod := sdkvesting.Period{Length: cliffLength, Amount: cliffAmt}\n-\n-\t// 12 month lockup\n-\tlockup := int64(12) // 12 months\n-\tlockupLength := vestingLength * lockup\n-\t// Unlock at 12 and 24 months\n-\tnumLockupPeriods := int64(2)\n-\t// Unlock 1/4th of the total vest in each unlock event. By default, all tokens are\n-\t// unlocked after surpassing the final period.\n-\tunlockedPerLockup := vestingAmtTotal.QuoInt(math.NewInt(4))\n-\tunlockedPerLockupAmt := unlockedPerLockup[0].Amount\n-\tlockupPeriod := sdkvesting.Period{Length: lockupLength, Amount: unlockedPerLockup}\n-\tlockupPeriods := make(sdkvesting.Periods, numLockupPeriods)\n-\tfor i := range lockupPeriods {\n-\t\tlockupPeriods[i] = lockupPeriod\n-\t}\n-\n-\t// Create vesting periods with initial cliff\n-\tvestingPeriods := sdkvesting.Periods{cliffPeriod}\n-\tfor p := int64(1); p <= periodsTotal-cliff; p++ {\n-\t\tvestingPeriods = append(vestingPeriods, vestingPeriod)\n-\t}\n-\n \t// Create test accounts with private keys for signing\n \tnumTestAccounts := 4\n \ttestAccounts := make([]TestClawbackAccount, numTestAccounts)\n\n@@ -102,20 +90,20 @@\nvar _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n \t}\n \tnumTestMsgs := 3\n \n-\taccountGasCoverage := sdk.NewCoins(sdk.NewCoin(stakeDenom, math.NewInt(1e16)))\n-\n \tvar (\n-\t\tclawbackAccount   *types.ClawbackVestingAccount\n-\t\tunvested          sdk.Coins\n-\t\tvested            sdk.Coins\n+\t\tclawbackAccount *types.ClawbackVestingAccount\n+\t\tunvested        sdk.Coins\n+\t\tvested          sdk.Coins\n+\t\t// freeCoins are unlocked vested coins of the vesting schedule\n+\t\tfreeCoins         sdk.Coins\n \t\ttwoThirdsOfVested sdk.Coins\n \t)\n \n \tdest := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n \tfunder := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n \n \tBeforeEach(func() {\n-\t\ts.SetupTest()\n+\t\tExpect(s.SetupTest()).To(BeNil()) // reset\n \n \t\t// Initialize all test accounts\n \t\tfor i, account := range testAccounts {\n\n@@ -127,65 +115,64 @@\nvar _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n \t\t\t\tfunder,\n \t\t\t\tvestingAmtTotal,\n \t\t\t\tvestingStart,\n-\t\t\t\tlockupPeriods,\n-\t\t\t\tvestingPeriods,\n+\t\t\t\ttestutil.TestVestingSchedule.LockupPeriods,\n+\t\t\t\ttestutil.TestVestingSchedule.VestingPeriods,\n \t\t\t)\n \n \t\t\terr := testutil.FundAccount(s.ctx, s.app.BankKeeper, account.address, vestingAmtTotal)\n-\t\t\ts.Require().NoError(err)\n+\t\t\tExpect(err).To(BeNil())\n \t\t\tacc := s.app.AccountKeeper.NewAccount(s.ctx, clawbackAccount)\n \t\t\ts.app.AccountKeeper.SetAccount(s.ctx, acc)\n \n \t\t\t// Check if all tokens are unvested at vestingStart\n-\t\t\tunvested = clawbackAccount.GetUnvestedOnly(s.ctx.BlockTime())\n-\t\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\t\ts.Require().Equal(vestingAmtTotal, unvested)\n-\t\t\ts.Require().True(vested.IsZero())\n+\t\t\tunvested = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n+\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\tExpect(vestingAmtTotal).To(Equal(unvested))\n+\t\t\tExpect(vested.IsZero()).To(BeTrue())\n \n \t\t\t// Grant gas stipend to cover EVM fees\n \t\t\terr = testutil.FundAccount(s.ctx, s.app.BankKeeper, clawbackAccount.GetAddress(), accountGasCoverage)\n-\t\t\ts.Require().NoError(err)\n+\t\t\tExpect(err).To(BeNil())\n \t\t\tgranteeBalance := s.app.BankKeeper.GetBalance(s.ctx, account.address, stakeDenom)\n-\t\t\ts.Require().Equal(granteeBalance, accountGasCoverage[0].Add(vestingAmtTotal[0]))\n+\t\t\tExpect(granteeBalance).To(Equal(accountGasCoverage[0].Add(vestingAmtTotal[0])))\n \n \t\t\t// Update testAccounts clawbackAccount reference\n \t\t\ttestAccounts[i].clawbackAccount = clawbackAccount\n \t\t}\n \t})\n-\n \tContext(\"before first vesting period\", func() {\n \t\tBeforeEach(func() {\n \t\t\t// Add a commit to instantiate blocks\n \t\t\ts.Commit()\n \n \t\t\t// Ensure no tokens are vested\n-\t\t\tvested := clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\t\tunlocked := clawbackAccount.GetUnlockedOnly(s.ctx.BlockTime())\n+\t\t\tvested := clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\tunlocked := clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n \t\t\tzeroCoins := sdk.NewCoins(sdk.NewCoin(stakeDenom, math.ZeroInt()))\n-\t\t\ts.Require().Equal(zeroCoins, vested)\n-\t\t\ts.Require().Equal(zeroCoins, unlocked)\n+\t\t\tExpect(zeroCoins).To(Equal(vested))\n+\t\t\tExpect(zeroCoins).To(Equal(unlocked))\n \t\t})\n \n \t\tIt(\"cannot delegate tokens\", func() {\n-\t\t\t_, err := delegate(testAccounts[0], accountGasCoverage.Add(sdk.NewCoin(stakeDenom, math.NewInt(1))))\n+\t\t\t_, err := testutil.Delegate(s.ctx, s.app, testAccounts[0].privKey, accountGasCoverage.Add(sdk.NewCoin(stakeDenom, math.NewInt(1)))[0], s.validator)\n \t\t\tExpect(err).ToNot(BeNil())\n \t\t})\n \n \t\tIt(\"can transfer spendable tokens\", func() {\n \t\t\taccount := testAccounts[0]\n \t\t\t// Fund account with new spendable tokens\n-\t\t\terr := testutil.FundAccount(s.ctx, s.app.BankKeeper, account.address, unvested)\n+\t\t\tamt := unvested\n+\t\t\terr := testutil.FundAccount(s.ctx, s.app.BankKeeper, account.address, amt)\n \t\t\tExpect(err).To(BeNil())\n \n \t\t\terr = s.app.BankKeeper.SendCoins(\n \t\t\t\ts.ctx,\n \t\t\t\taccount.address,\n \t\t\t\tdest,\n-\t\t\t\tunvested,\n+\t\t\t\tamt,\n \t\t\t)\n \t\t\tExpect(err).To(BeNil())\n \t\t})\n-\n \t\tIt(\"cannot transfer unvested tokens\", func() {\n \t\t\terr := s.app.BankKeeper.SendCoins(\n \t\t\t\ts.ctx,\n\n@@ -195,77 +182,162 @@\nvar _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n \t\t\t)\n \t\t\tExpect(err).ToNot(BeNil())\n \t\t})\n-\n \t\tIt(\"can perform Ethereum tx with spendable balance\", func() {\n \t\t\taccount := testAccounts[0]\n \t\t\t// Fund account with new spendable tokens\n-\t\t\terr := testutil.FundAccount(s.ctx, s.app.BankKeeper, account.address, unlockedPerLockup)\n+\t\t\tcoins := testutil.TestVestingSchedule.UnlockedCoinsPerLockup\n+\t\t\terr := testutil.FundAccount(s.ctx, s.app.BankKeeper, account.address, coins)\n \t\t\tExpect(err).To(BeNil())\n \n-\t\t\ttxAmount := unlockedPerLockupAmt.BigInt()\n+\t\t\ttxAmount := coins.AmountOf(stakeDenom).BigInt()\n \t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount, 0)\n \t\t\tExpect(err).To(BeNil())\n \n-\t\t\tassertEthSucceeds([]TestClawbackAccount{account}, funder, dest, unlockedPerLockupAmt, stakeDenom, msg)\n+\t\t\tassertEthSucceeds([]TestClawbackAccount{account}, funder, dest, coins.AmountOf(stakeDenom), stakeDenom, msg)\n \t\t})\n \n \t\tIt(\"cannot perform Ethereum tx with unvested balance\", func() {\n \t\t\taccount := testAccounts[0]\n-\t\t\ttxAmount := unlockedPerLockupAmt.BigInt()\n+\t\t\tunlockedCoins := testutil.TestVestingSchedule.UnlockedCoinsPerLockup\n+\t\t\ttxAmount := unlockedCoins.AmountOf(stakeDenom).BigInt()\n \t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount, 0)\n \t\t\tExpect(err).To(BeNil())\n \n \t\t\tassertEthFails(msg)\n \t\t})\n \t})\n-\n \tContext(\"after first vesting period and before lockup\", func() {\n \t\tBeforeEach(func() {\n \t\t\t// Surpass cliff but none of lockup duration\n-\t\t\tcliffDuration := time.Duration(cliffLength)\n+\t\t\tcliffDuration := time.Duration(testutil.TestVestingSchedule.CliffPeriodLength)\n \t\t\ts.CommitAfter(cliffDuration * time.Second)\n \n \t\t\t// Check if some, but not all tokens are vested\n-\t\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\t\texpVested := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(cliff))))\n-\t\t\ts.Require().NotEqual(vestingAmtTotal, vested)\n-\t\t\ts.Require().Equal(expVested, vested)\n+\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\texpVested := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(testutil.TestVestingSchedule.CliffMonths))))\n+\t\t\tExpect(vested).NotTo(Equal(vestingAmtTotal))\n+\t\t\tExpect(vested).To(Equal(expVested))\n+\n+\t\t\t// check the vested tokens are still locked\n+\t\t\tfreeCoins = clawbackAccount.GetUnlockedVestedCoins(s.ctx.BlockTime())\n+\t\t\tExpect(freeCoins).To(Equal(sdk.Coins{}))\n \n \t\t\ttwoThirdsOfVested = vested.Sub(vested.QuoInt(math.NewInt(3))...)\n+\n+\t\t\tres, err := s.app.VestingKeeper.Balances(s.ctx, &types.QueryBalancesRequest{Address: clawbackAccount.Address})\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\tExpect(res.Vested).To(Equal(expVested))\n+\t\t\tExpect(res.Unvested).To(Equal(vestingAmtTotal.Sub(expVested...)))\n+\t\t\t// All coins from vesting schedule should be locked\n+\t\t\tExpect(res.Locked).To(Equal(vestingAmtTotal))\n \t\t})\n \n-\t\tIt(\"can delegate vested tokens and update spendable balance\", func() {\n+\t\tIt(\"can delegate vested locked tokens\", func() {\n \t\t\ttestAccount := testAccounts[0]\n-\t\t\t// Verify that the total spendable coins decreases after staking\n-\t\t\t// vested tokens.\n+\t\t\t// Verify that the total spendable coins should only be coins\n+\t\t\t// not in the vesting schedule. Because all coins from the vesting\n+\t\t\t// schedule are still locked\n \t\t\tspendablePre := s.app.BankKeeper.SpendableCoins(s.ctx, testAccount.address)\n+\t\t\tExpect(spendablePre).To(Equal(accountGasCoverage))\n+\n+\t\t\t// delegate the vested locked coins.\n+\t\t\t_, err := testutil.Delegate(s.ctx, s.app, testAccount.privKey, vested[0], s.validator)\n+\t\t\tExpect(err).To(BeNil(), \"expected no error during delegation\")\n \n-\t\t\t_, err := delegate(testAccount, vested)\n+\t\t\t// check spendable coins have only been reduced by the gas paid for the transaction to show that the delegated coins were taken from the locked but vested amount\n+\t\t\tspendablePost := s.app.BankKeeper.SpendableCoins(s.ctx, testAccount.address)\n+\t\t\tExpect(spendablePost).To(Equal(spendablePre.Sub(accountGasCoverage...)))\n+\n+\t\t\t// check delegation was created successfully\n+\t\t\tstkQuerier := stakingkeeper.Querier{Keeper: s.app.StakingKeeper.Keeper}\n+\t\t\tdelRes, err := stkQuerier.DelegatorDelegations(s.ctx, &stakingtypes.QueryDelegatorDelegationsRequest{DelegatorAddr: testAccount.clawbackAccount.Address})\n \t\t\tExpect(err).To(BeNil())\n+\t\t\tExpect(delRes.DelegationResponses).To(HaveLen(1))\n+\t\t\tExpect(delRes.DelegationResponses[0].Balance.Amount).To(Equal(vested[0].Amount))\n+\t\t})\n \n+\t\tIt(\"can delegate tokens from account balance - tokens not in vesting schedule\", func() {\n+\t\t\ttestAccount := testAccounts[0]\n+\n+\t\t\t// send some funds to the account to delegate\n+\t\t\tcoinsToDelegate := sdk.NewCoins(sdk.NewCoin(stakeDenom, math.NewInt(1e18)))\n+\t\t\terr = testutil.FundAccount(s.ctx, s.app.BankKeeper, testAccount.address, coinsToDelegate)\n+\t\t\tExpect(err).To(BeNil())\n+\n+\t\t\t// Verify that the total spendable coins should only be coins\n+\t\t\t// not in the vesting schedule. Because all coins from the vesting\n+\t\t\t// schedule are still locked\n+\t\t\tspendablePre := s.app.BankKeeper.SpendableCoins(s.ctx, testAccount.address)\n+\t\t\tExpect(spendablePre).To(Equal(accountGasCoverage.Add(coinsToDelegate...)))\n+\n+\t\t\t// delegate funds not in vesting schedule\n+\t\t\tres, err := testutil.Delegate(s.ctx, s.app, testAccount.privKey, coinsToDelegate[0], s.validator)\n+\t\t\tExpect(err).NotTo(HaveOccurred(), \"expected no error during delegation\")\n+\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\n+\t\t\t// check spendable balance is updated properly\n \t\t\tspendablePost := s.app.BankKeeper.SpendableCoins(s.ctx, testAccount.address)\n-\t\t\tExpect(spendablePost.AmountOf(stakeDenom).GT(spendablePre.AmountOf(stakeDenom)))\n+\t\t\tExpect(spendablePost).To(Equal(spendablePre.Sub(coinsToDelegate...).Sub(accountGasCoverage...)))\n \t\t})\n \n-\t\tIt(\"cannot delegate unvested tokens\", func() {\n-\t\t\t_, err := delegate(testAccounts[0], vestingAmtTotal)\n+\t\tIt(\"can delegate tokens from account balance (free tokens) + locked vested tokens\", func() {\n+\t\t\ttestAccount := testAccounts[0]\n+\n+\t\t\t// send some funds to the account to delegate\n+\t\t\tamt := sdk.NewCoins(sdk.NewCoin(stakeDenom, math.NewInt(1e18)))\n+\t\t\terr = testutil.FundAccount(s.ctx, s.app.BankKeeper, testAccount.address, amt)\n+\t\t\tExpect(err).To(BeNil())\n+\n+\t\t\t// Verify that the total spendable coins should only be coins\n+\t\t\t// not in the vesting schedule. Because all coins from the vesting\n+\t\t\t// schedule are still locked\n+\t\t\tspendablePre := s.app.BankKeeper.SpendableCoins(s.ctx, testAccount.address)\n+\t\t\tExpect(spendablePre).To(Equal(accountGasCoverage.Add(amt...)))\n+\n+\t\t\t// delegate some tokens from the account balance + locked vested coins\n+\t\t\tcoinsToDelegate := amt.Add(vested...)\n+\n+\t\t\tres, err := testutil.Delegate(s.ctx, s.app, testAccount.privKey, coinsToDelegate[0], s.validator)\n+\t\t\tExpect(err).NotTo(HaveOccurred(), \"expected no error during delegation\")\n+\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\n+\t\t\t// check spendable balance is updated properly\n+\t\t\tspendablePost := s.app.BankKeeper.SpendableCoins(s.ctx, testAccount.address)\n+\t\t\tExpect(spendablePost).To(Equal(spendablePre.Sub(amt...).Sub(accountGasCoverage...)))\n+\t\t})\n+\n+\t\tIt(\"cannot delegate unvested tokens in sequetial txs\", func() {\n+\t\t\t_, err := testutil.Delegate(s.ctx, s.app, testAccounts[0].privKey, twoThirdsOfVested[0], s.validator)\n+\t\t\tExpect(err).To(BeNil(), \"error while executing the delegate message\")\n+\t\t\t_, err = testutil.Delegate(s.ctx, s.app, testAccounts[0].privKey, twoThirdsOfVested[0], s.validator)\n \t\t\tExpect(err).ToNot(BeNil())\n \t\t})\n \n-\t\tIt(\"cannot delegate unvested tokens in batches\", func() {\n-\t\t\tmsg, err := delegate(testAccounts[0], twoThirdsOfVested)\n+\t\tIt(\"cannot delegate then send tokens\", func() {\n+\t\t\t_, err := testutil.Delegate(s.ctx, s.app, testAccounts[0].privKey, twoThirdsOfVested[0], s.validator)\n \t\t\tExpect(err).To(BeNil())\n \n-\t\t\tmsgServer := stakingkeeper.NewMsgServerImpl(&s.app.StakingKeeper)\n-\t\t\t_, err = msgServer.Delegate(s.ctx, msg)\n-\t\t\tExpect(err).ToNot(HaveOccurred(), \"error while executing the delegate message\")\n+\t\t\terr = s.app.BankKeeper.SendCoins(\n+\t\t\t\ts.ctx,\n+\t\t\t\tclawbackAccount.GetAddress(),\n+\t\t\t\tdest,\n+\t\t\t\ttwoThirdsOfVested,\n+\t\t\t)\n+\t\t\tExpect(err).ToNot(BeNil())\n+\t\t})\n \n-\t\t\t_, err = delegate(testAccounts[0], twoThirdsOfVested)\n+\t\tIt(\"cannot delegate more than the locked vested tokens\", func() {\n+\t\t\t_, err := testutil.Delegate(s.ctx, s.app, testAccounts[0].privKey, vested[0].Add(sdk.NewCoin(stakeDenom, math.NewInt(1))), s.validator)\n \t\t\tExpect(err).ToNot(BeNil())\n \t\t})\n \n-\t\tIt(\"cannot delegate then send tokens\", func() {\n-\t\t\t_, err := delegate(testAccounts[0], twoThirdsOfVested)\n+\t\tIt(\"cannot delegate free tokens and then send locked/unvested tokens\", func() {\n+\t\t\t// send some funds to the account to delegate\n+\t\t\tcoinsToDelegate := sdk.NewCoins(sdk.NewCoin(stakeDenom, math.NewInt(1e18)))\n+\t\t\terr = testutil.FundAccount(s.ctx, s.app.BankKeeper, testAccounts[0].address, coinsToDelegate)\n+\t\t\tExpect(err).To(BeNil())\n+\n+\t\t\t_, err := testutil.Delegate(s.ctx, s.app, testAccounts[0].privKey, coinsToDelegate[0], s.validator)\n \t\t\tExpect(err).To(BeNil())\n \n \t\t\terr = s.app.BankKeeper.SendCoins(\n\n@@ -277,7 +349,7 @@\nvar _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n \t\t\tExpect(err).ToNot(BeNil())\n \t\t})\n \n-\t\tIt(\"cannot transfer vested tokens\", func() {\n+\t\tIt(\"cannot transfer locked vested tokens\", func() {\n \t\t\terr := s.app.BankKeeper.SendCoins(\n \t\t\t\ts.ctx,\n \t\t\t\tclawbackAccount.GetAddress(),\n\n@@ -289,85 +361,141 @@\nvar _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n \n \t\tIt(\"can perform Ethereum tx with spendable balance\", func() {\n \t\t\taccount := testAccounts[0]\n+\t\t\tcoins := testutil.TestVestingSchedule.UnlockedCoinsPerLockup\n \t\t\t// Fund account with new spendable tokens\n-\t\t\terr := testutil.FundAccount(s.ctx, s.app.BankKeeper, account.address, unlockedPerLockup)\n+\t\t\terr := testutil.FundAccount(s.ctx, s.app.BankKeeper, account.address, coins)\n \t\t\tExpect(err).To(BeNil())\n \n-\t\t\ttxAmount := unlockedPerLockupAmt.BigInt()\n-\t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount, 0)\n+\t\t\ttxAmount := coins.AmountOf(stakeDenom)\n+\t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount.BigInt(), 0)\n \t\t\tExpect(err).To(BeNil())\n \n-\t\t\tassertEthSucceeds([]TestClawbackAccount{account}, funder, dest, unlockedPerLockupAmt, stakeDenom, msg)\n+\t\t\tassertEthSucceeds([]TestClawbackAccount{account}, funder, dest, txAmount, stakeDenom, msg)\n \t\t})\n \n-\t\tIt(\"cannot perform Ethereum tx with locked balance\", func() {\n+\t\tIt(\"cannot perform Ethereum tx with locked vested balance\", func() {\n \t\t\taccount := testAccounts[0]\n \t\t\ttxAmount := vested.AmountOf(stakeDenom).BigInt()\n \t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount, 0)\n \t\t\tExpect(err).To(BeNil())\n-\n \t\t\tassertEthFails(msg)\n \t\t})\n \t})\n-\n \tContext(\"Between first and second lockup periods\", func() {\n \t\tBeforeEach(func() {\n \t\t\t// Surpass first lockup\n-\t\t\tvestDuration := time.Duration(lockupLength)\n+\t\t\tvestDuration := time.Duration(testutil.TestVestingSchedule.LockupPeriodLength)\n \t\t\ts.CommitAfter(vestDuration * time.Second)\n \n+\t\t\t// after first lockup period\n+\t\t\t// half of total vesting tokens are unlocked\n+\t\t\t// but only 12 vesting periods passed\n \t\t\t// Check if some, but not all tokens are vested and unlocked\n \t\t\tfor _, account := range testAccounts {\n-\t\t\t\tvested := account.clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\t\t\tunlocked := account.clawbackAccount.GetUnlockedOnly(s.ctx.BlockTime())\n+\t\t\t\tvested = account.clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\t\tunlocked := account.clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n+\t\t\t\tfreeCoins = account.clawbackAccount.GetUnlockedVestedCoins(s.ctx.BlockTime())\n+\n \t\t\t\texpVested := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(lockup))))\n+\t\t\t\texpUnlockedVested := expVested\n \n-\t\t\t\ts.Require().NotEqual(vestingAmtTotal, vested)\n-\t\t\t\ts.Require().Equal(expVested, vested)\n-\t\t\t\ts.Require().Equal(unlocked, unlockedPerLockup)\n+\t\t\t\tExpect(vested).NotTo(Equal(vestingAmtTotal))\n+\t\t\t\tExpect(vested).To(Equal(expVested))\n+\t\t\t\tExpect(unlocked).To(Equal(unlockedPerLockup))\n+\t\t\t\tExpect(freeCoins).To(Equal(expUnlockedVested))\n \t\t\t}\n \t\t})\n \n-\t\tIt(\"should enable access to unlocked EVM tokens (single-account, single-msg)\", func() {\n+\t\tIt(\"delegate unlocked vested tokens and spendable balance is updated properly\", func() {\n+\t\t\taccount := testAccounts[0]\n+\t\t\tbalance := s.app.BankKeeper.GetBalance(s.ctx, account.address, stakeDenom)\n+\t\t\t// the returned balance should be the account's initial balance and\n+\t\t\t// the total amount of the vesting schedule\n+\t\t\tExpect(balance.Amount).To(Equal(accountGasCoverage.Add(vestingAmtTotal...)[0].Amount))\n+\n+\t\t\tspReq := &banktypes.QuerySpendableBalanceByDenomRequest{Address: account.address.String(), Denom: stakeDenom}\n+\t\t\tspRes, err := s.app.BankKeeper.SpendableBalanceByDenom(s.ctx, spReq)\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\t// spendable balance should be the initial account balance + vested tokens\n+\t\t\tinitialSpendableBalance := spRes.Balance\n+\t\t\tExpect(initialSpendableBalance.Amount).To(Equal(accountGasCoverage.Add(freeCoins...)[0].Amount))\n+\n+\t\t\t// can delegate vested tokens\n+\t\t\t// fees paid is accountGasCoverage amount\n+\t\t\tres, err := testutil.Delegate(s.ctx, s.app, account.privKey, freeCoins[0], s.validator)\n+\t\t\tExpect(err).ToNot(HaveOccurred(), \"expected no error during delegation\")\n+\t\t\tExpect(res.Code).To(BeZero(), \"expected delegation to succeed\")\n+\n+\t\t\t// spendable balance should be updated to be prevSpendableBalance - delegatedAmt - fees\n+\t\t\tspRes, err = s.app.BankKeeper.SpendableBalanceByDenom(s.ctx, spReq)\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\tExpect(spRes.Balance.Amount.Int64()).To(Equal(int64(0)))\n+\n+\t\t\t// try to send coins - should error\n+\t\t\terr = s.app.BankKeeper.SendCoins(s.ctx, account.address, funder, vested)\n+\t\t\tExpect(err).NotTo(BeNil())\n+\t\t\tExpect(err.Error()).To(ContainSubstring(\"spendable balance\"))\n+\t\t\tExpect(err.Error()).To(ContainSubstring(\"is smaller than\"))\n+\t\t})\n+\n+\t\tIt(\"cannot delegate more than vested tokens\", func() {\n \t\t\taccount := testAccounts[0]\n+\t\t\tbalance := s.app.BankKeeper.GetBalance(s.ctx, account.address, stakeDenom)\n+\t\t\t// the returned balance should be the account's initial balance and\n+\t\t\t// the total amount of the vesting schedule\n+\t\t\tExpect(balance.Amount).To(Equal(accountGasCoverage.Add(vestingAmtTotal...)[0].Amount))\n \n-\t\t\ttxAmount := unlockedPerLockupAmt.BigInt()\n-\t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount, 0)\n+\t\t\tspReq := &banktypes.QuerySpendableBalanceByDenomRequest{Address: account.address.String(), Denom: stakeDenom}\n+\t\t\tspRes, err := s.app.BankKeeper.SpendableBalanceByDenom(s.ctx, spReq)\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\t// spendable balance should be the initial account balance + vested tokens\n+\t\t\tinitialSpendableBalance := spRes.Balance\n+\t\t\tExpect(initialSpendableBalance.Amount).To(Equal(accountGasCoverage.Add(freeCoins...)[0].Amount))\n+\n+\t\t\t// cannot delegate more than vested tokens\n+\t\t\t_, err = testutil.Delegate(s.ctx, s.app, account.privKey, freeCoins[0].Add(sdk.NewCoin(stakeDenom, math.NewInt(1))), s.validator)\n+\t\t\tExpect(err).To(HaveOccurred(), \"expected no error during delegation\")\n+\t\t\tExpect(err.Error()).To(ContainSubstring(\"cannot delegate unvested coins\"))\n+\t\t})\n+\n+\t\tIt(\"should enable access to unlocked and vested EVM tokens (single-account, single-msg)\", func() {\n+\t\t\taccount := testAccounts[0]\n+\t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, vested[0].Amount.BigInt(), 0)\n \t\t\tExpect(err).To(BeNil())\n \n-\t\t\tassertEthSucceeds([]TestClawbackAccount{account}, funder, dest, unlockedPerLockupAmt, stakeDenom, msg)\n+\t\t\tassertEthSucceeds([]TestClawbackAccount{account}, funder, dest, vested[0].Amount, stakeDenom, msg)\n \t\t})\n \n \t\tIt(\"should enable access to unlocked EVM tokens (single-account, multiple-msgs)\", func() {\n \t\t\taccount := testAccounts[0]\n \n \t\t\t// Split the total unlocked amount into numTestMsgs equally sized tx's\n \t\t\tmsgs := make([]sdk.Msg, numTestMsgs)\n-\t\t\ttxAmount := unlockedPerLockupAmt.QuoRaw(int64(numTestMsgs)).BigInt()\n+\t\t\ttxAmount := vested[0].Amount.QuoRaw(int64(numTestMsgs)).BigInt()\n \n \t\t\tfor i := 0; i < numTestMsgs; i++ {\n \t\t\t\tmsgs[i], err = utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount, i)\n \t\t\t\tExpect(err).To(BeNil())\n \t\t\t}\n \n-\t\t\tassertEthSucceeds([]TestClawbackAccount{account}, funder, dest, unlockedPerLockupAmt, stakeDenom, msgs...)\n+\t\t\tassertEthSucceeds([]TestClawbackAccount{account}, funder, dest, vested[0].Amount, stakeDenom, msgs...)\n \t\t})\n \n \t\tIt(\"should enable access to unlocked EVM tokens (multi-account, single-msg)\", func() {\n-\t\t\ttxAmount := unlockedPerLockupAmt.BigInt()\n+\t\t\ttxAmount := vested[0].Amount.BigInt()\n \n \t\t\tmsgs := make([]sdk.Msg, numTestAccounts)\n \t\t\tfor i, grantee := range testAccounts {\n \t\t\t\tmsgs[i], err = utiltx.CreateEthTx(s.ctx, s.app, grantee.privKey, grantee.address, dest, txAmount, 0)\n \t\t\t\tExpect(err).To(BeNil())\n \t\t\t}\n \n-\t\t\tassertEthSucceeds(testAccounts, funder, dest, unlockedPerLockupAmt, stakeDenom, msgs...)\n+\t\t\tassertEthSucceeds(testAccounts, funder, dest, vested[0].Amount, stakeDenom, msgs...)\n \t\t})\n \n \t\tIt(\"should enable access to unlocked EVM tokens (multi-account, multiple-msgs)\", func() {\n \t\t\tmsgs := []sdk.Msg{}\n-\t\t\ttxAmount := unlockedPerLockupAmt.QuoRaw(int64(numTestMsgs)).BigInt()\n+\t\t\ttxAmount := vested[0].Amount.QuoRaw(int64(numTestMsgs)).BigInt()\n \n \t\t\tfor _, grantee := range testAccounts {\n \t\t\t\tfor j := 0; j < numTestMsgs; j++ {\n\n@@ -377,7 +505,7 @@\nvar _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tassertEthSucceeds(testAccounts, funder, dest, unlockedPerLockupAmt, stakeDenom, msgs...)\n+\t\t\tassertEthSucceeds(testAccounts, funder, dest, vested[0].Amount, stakeDenom, msgs...)\n \t\t})\n \n \t\tIt(\"should not enable access to locked EVM tokens (single-account, single-msg)\", func() {\n\n@@ -386,43 +514,39 @@\nvar _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n \t\t\ttxAmount := vestingAmtTotal.AmountOf(stakeDenom).BigInt()\n \t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, testAccount.privKey, testAccount.address, dest, txAmount, 0)\n \t\t\tExpect(err).To(BeNil())\n-\n \t\t\tassertEthFails(msg)\n \t\t})\n \n \t\tIt(\"should not enable access to locked EVM tokens (single-account, multiple-msgs)\", func() {\n \t\t\tmsgs := make([]sdk.Msg, numTestMsgs+1)\n-\t\t\ttxAmount := unlockedPerLockupAmt.QuoRaw(int64(numTestMsgs)).BigInt()\n+\t\t\ttxAmount := vested[0].Amount.QuoRaw(int64(numTestMsgs)).BigInt()\n \t\t\ttestAccount := testAccounts[0]\n \n \t\t\t// Add additional message that exceeds unlocked balance\n \t\t\tfor i := 0; i < numTestMsgs+1; i++ {\n \t\t\t\tmsgs[i], err = utiltx.CreateEthTx(s.ctx, s.app, testAccount.privKey, testAccount.address, dest, txAmount, i)\n \t\t\t\tExpect(err).To(BeNil())\n \t\t\t}\n-\n \t\t\tassertEthFails(msgs...)\n \t\t})\n \n \t\tIt(\"should not enable access to locked EVM tokens (multi-account, single-msg)\", func() {\n \t\t\tmsgs := make([]sdk.Msg, numTestAccounts+1)\n-\t\t\ttxAmount := unlockedPerLockupAmt.BigInt()\n+\t\t\ttxAmount := vested[0].Amount.BigInt()\n \n \t\t\tfor i, account := range testAccounts {\n \t\t\t\tmsgs[i], err = utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount, 0)\n \t\t\t\tExpect(err).To(BeNil())\n \t\t\t}\n-\n \t\t\t// Add additional message that exceeds unlocked balance\n \t\t\tmsgs[numTestAccounts], err = utiltx.CreateEthTx(s.ctx, s.app, testAccounts[0].privKey, testAccounts[0].address, dest, txAmount, 1)\n \t\t\tExpect(err).To(BeNil())\n-\n \t\t\tassertEthFails(msgs...)\n \t\t})\n \n \t\tIt(\"should not enable access to locked EVM tokens (multi-account, multiple-msgs)\", func() {\n \t\t\tmsgs := []sdk.Msg{}\n-\t\t\ttxAmount := unlockedPerLockupAmt.QuoRaw(int64(numTestMsgs)).BigInt()\n+\t\t\ttxAmount := vested[0].Amount.QuoRaw(int64(numTestMsgs)).BigInt()\n \t\t\tvar addedMsg sdk.Msg\n \n \t\t\tfor _, account := range testAccounts {\n\n@@ -431,95 +555,94 @@\nvar _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n \t\t\t\t\tmsgs = append(msgs, addedMsg)\n \t\t\t\t}\n \t\t\t}\n-\n \t\t\t// Add additional message that exceeds unlocked balance\n \t\t\taddedMsg, err = utiltx.CreateEthTx(s.ctx, s.app, testAccounts[0].privKey, testAccounts[0].address, dest, txAmount, numTestMsgs)\n \t\t\tExpect(err).To(BeNil())\n \t\t\tmsgs = append(msgs, addedMsg)\n-\n \t\t\tassertEthFails(msgs...)\n \t\t})\n-\n \t\tIt(\"should not short-circuit with a normal account\", func() {\n \t\t\taccount := testAccounts[0]\n \t\t\taddress, privKey := utiltx.NewAccAddressAndKey()\n-\n \t\t\ttxAmount := vestingAmtTotal.AmountOf(stakeDenom).BigInt()\n-\n \t\t\t// Fund a normal account to try to short-circuit the AnteHandler\n \t\t\terr = testutil.FundAccount(s.ctx, s.app.BankKeeper, address, vestingAmtTotal.MulInt(math.NewInt(2)))\n \t\t\tExpect(err).To(BeNil())\n \t\t\tnormalAccMsg, err := utiltx.CreateEthTx(s.ctx, s.app, privKey, address, dest, txAmount, 0)\n \t\t\tExpect(err).To(BeNil())\n-\n \t\t\t// Attempt to spend entire balance\n \t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount, 0)\n \t\t\tExpect(err).To(BeNil())\n \t\t\terr = validateEthVestingTransactionDecorator(normalAccMsg, msg)\n \t\t\tExpect(err).ToNot(BeNil())\n-\n \t\t\t_, err = testutil.DeliverEthTx(s.app, nil, msg)\n \t\t\tExpect(err).ToNot(BeNil())\n \t\t})\n \t})\n \n \tContext(\"after first lockup and additional vest\", func() {\n \t\tBeforeEach(func() {\n-\t\t\tvestDuration := time.Duration(lockupLength + vestingLength)\n+\t\t\tvestDuration := time.Duration(testutil.TestVestingSchedule.LockupPeriodLength + vestingLength)\n \t\t\ts.CommitAfter(vestDuration * time.Second)\n \n-\t\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n+\t\t\t// after first lockup period\n+\t\t\t// half of total vesting tokens are unlocked\n+\t\t\t// now only 13 vesting periods passed\n+\n+\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n \t\t\texpVested := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(lockup+1))))\n \n-\t\t\tunlocked := clawbackAccount.GetUnlockedOnly(s.ctx.BlockTime())\n+\t\t\tunlocked := clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n \t\t\texpUnlocked := unlockedPerLockup\n \n-\t\t\ts.Require().Equal(expVested, vested)\n-\t\t\ts.Require().Equal(expUnlocked, unlocked)\n+\t\t\tExpect(expVested).To(Equal(vested))\n+\t\t\tExpect(expUnlocked).To(Equal(unlocked))\n \t\t})\n \n \t\tIt(\"should enable access to unlocked EVM tokens\", func() {\n \t\t\ttestAccount := testAccounts[0]\n \n-\t\t\ttxAmount := unlockedPerLockupAmt.BigInt()\n+\t\t\ttxAmount := vested[0].Amount.BigInt()\n \t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, testAccount.privKey, testAccount.address, dest, txAmount, 0)\n \t\t\tExpect(err).To(BeNil())\n \n-\t\t\tassertEthSucceeds([]TestClawbackAccount{testAccount}, funder, dest, unlockedPerLockupAmt, stakeDenom, msg)\n+\t\t\tassertEthSucceeds([]TestClawbackAccount{testAccount}, funder, dest, vested[0].Amount, stakeDenom, msg)\n \t\t})\n \n-\t\tIt(\"should not enable access to locked EVM tokens\", func() {\n+\t\tIt(\"should not enable access to unvested EVM tokens\", func() {\n \t\t\ttestAccount := testAccounts[0]\n \n-\t\t\ttxAmount := vested.AmountOf(stakeDenom).BigInt()\n+\t\t\ttxAmount := vested[0].Amount.Add(amt).BigInt()\n \t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, testAccount.privKey, testAccount.address, dest, txAmount, 0)\n \t\t\tExpect(err).To(BeNil())\n \n \t\t\tassertEthFails(msg)\n \t\t})\n \t})\n-\n \tContext(\"after half of vesting period and both lockups\", func() {\n \t\tBeforeEach(func() {\n \t\t\t// Surpass lockup duration\n-\t\t\tlockupDuration := time.Duration(lockupLength * numLockupPeriods)\n+\t\t\tlockupDuration := time.Duration(testutil.TestVestingSchedule.LockupPeriodLength * numLockupPeriods)\n \t\t\ts.CommitAfter(lockupDuration * time.Second)\n+\t\t\t// after two lockup period\n+\t\t\t// total vesting tokens are unlocked\n+\t\t\t// and 24/48 vesting periods passed\n \n \t\t\t// Check if some, but not all tokens are vested\n-\t\t\tunvested = clawbackAccount.GetUnvestedOnly(s.ctx.BlockTime())\n-\t\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n+\t\t\tunvested = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n+\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n \t\t\texpVested := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(lockup*numLockupPeriods))))\n-\t\t\ts.Require().NotEqual(vestingAmtTotal, vested)\n-\t\t\ts.Require().Equal(expVested, vested)\n+\t\t\tExpect(vestingAmtTotal).NotTo(Equal(vested))\n+\t\t\tExpect(expVested).To(Equal(vested))\n \t\t})\n \n \t\tIt(\"can delegate vested tokens\", func() {\n-\t\t\t_, err := delegate(testAccounts[0], vested)\n+\t\t\t_, err := testutil.Delegate(s.ctx, s.app, testAccounts[0].privKey, vested[0], s.validator)\n \t\t\tExpect(err).To(BeNil())\n \t\t})\n \n \t\tIt(\"cannot delegate unvested tokens\", func() {\n-\t\t\t_, err := delegate(testAccounts[0], vestingAmtTotal)\n+\t\t\t_, err := testutil.Delegate(s.ctx, s.app, testAccounts[0].privKey, vestingAmtTotal[0], s.validator)\n \t\t\tExpect(err).ToNot(BeNil())\n \t\t})\n\n@@ -532,7 +655,6 @@\nvar _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n \t\t\t)\n \t\t\tExpect(err).To(BeNil())\n \t\t})\n-\n \t\tIt(\"cannot transfer unvested tokens\", func() {\n \t\t\terr := s.app.BankKeeper.SendCoins(\n \t\t\t\ts.ctx,\n\n@@ -542,63 +664,57 @@\nvar _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n \t\t\t)\n \t\t\tExpect(err).ToNot(BeNil())\n \t\t})\n-\n \t\tIt(\"can perform Ethereum tx with spendable balance\", func() {\n \t\t\taccount := testAccounts[0]\n-\n \t\t\ttxAmount := vested.AmountOf(stakeDenom).BigInt()\n \t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount, 0)\n \t\t\tExpect(err).To(BeNil())\n-\n \t\t\tassertEthSucceeds([]TestClawbackAccount{account}, funder, dest, vested.AmountOf(stakeDenom), stakeDenom, msg)\n \t\t})\n \t})\n-\n \tContext(\"after entire vesting period and both lockups\", func() {\n \t\tBeforeEach(func() {\n \t\t\t// Surpass vest duration\n \t\t\tvestDuration := time.Duration(vestingLength * periodsTotal)\n \t\t\ts.CommitAfter(vestDuration * time.Second)\n \n \t\t\t// Check that all tokens are vested and unlocked\n-\t\t\tunvested = clawbackAccount.GetUnvestedOnly(s.ctx.BlockTime())\n-\t\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\t\tlocked := clawbackAccount.LockedCoins(s.ctx.BlockTime())\n+\t\t\tunvested = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n+\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\tunlocked := clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n+\t\t\tunlockedVested := clawbackAccount.GetUnlockedVestedCoins(s.ctx.BlockTime())\n+\t\t\tnotSpendable := clawbackAccount.LockedCoins(s.ctx.BlockTime())\n+\n+\t\t\t// all vested coins should be unlocked\n+\t\t\tExpect(vested).To(Equal(unlockedVested))\n \n \t\t\tzeroCoins := sdk.NewCoins(sdk.NewCoin(stakeDenom, math.ZeroInt()))\n-\t\t\ts.Require().Equal(vestingAmtTotal, vested)\n-\t\t\ts.Require().Equal(zeroCoins, locked)\n-\t\t\ts.Require().Equal(zeroCoins, unvested)\n+\t\t\tExpect(vestingAmtTotal).To(Equal(vested))\n+\t\t\tExpect(vestingAmtTotal).To(Equal(unlocked))\n+\t\t\tExpect(zeroCoins).To(Equal(notSpendable))\n+\t\t\tExpect(zeroCoins).To(Equal(unvested))\n \t\t})\n \n \t\tIt(\"can send entire balance\", func() {\n \t\t\taccount := testAccounts[0]\n-\n \t\t\ttxAmount := vestingAmtTotal.AmountOf(stakeDenom)\n \t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount.BigInt(), 0)\n \t\t\tExpect(err).To(BeNil())\n-\n \t\t\tassertEthSucceeds([]TestClawbackAccount{account}, funder, dest, txAmount, stakeDenom, msg)\n \t\t})\n-\n \t\tIt(\"cannot exceed balance\", func() {\n \t\t\taccount := testAccounts[0]\n-\n \t\t\ttxAmount := vestingAmtTotal.AmountOf(stakeDenom).Mul(math.NewInt(2))\n \t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount.BigInt(), 0)\n \t\t\tExpect(err).To(BeNil())\n-\n \t\t\tassertEthFails(msg)\n \t\t})\n-\n \t\tIt(\"should short-circuit with zero balance\", func() {\n \t\t\taccount := testAccounts[0]\n \t\t\tbalance := s.app.BankKeeper.GetBalance(s.ctx, account.address, stakeDenom)\n-\n \t\t\t// Drain account balance\n \t\t\terr := s.app.BankKeeper.SendCoins(s.ctx, account.address, dest, sdk.NewCoins(balance))\n \t\t\tExpect(err).To(BeNil())\n-\n \t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, big.NewInt(0), 0)\n \t\t\tExpect(err).To(BeNil())\n \t\t\terr = validateEthVestingTransactionDecorator(msg)\n\n@@ -614,36 +730,6 @@\nvar _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n // 22/09 Cliff ends\n // 23/02 Lock ends\n var _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n-\t// Monthly vesting period\n-\tstakeDenom := utils.BaseDenom\n-\tamt := math.NewInt(1)\n-\tvestingLength := int64(60 * 60 * 24 * 30) // in seconds\n-\tvestingAmt := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt))\n-\tvestingPeriod := sdkvesting.Period{Length: vestingLength, Amount: vestingAmt}\n-\n-\t// 4 years vesting total\n-\tperiodsTotal := int64(48)\n-\tvestingTotal := amt.Mul(math.NewInt(periodsTotal))\n-\tvestingAmtTotal := sdk.NewCoins(sdk.NewCoin(stakeDenom, vestingTotal))\n-\n-\t// 6 month cliff\n-\tcliff := int64(6)\n-\tcliffLength := vestingLength * cliff\n-\tcliffAmt := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(cliff))))\n-\tcliffPeriod := sdkvesting.Period{Length: cliffLength, Amount: cliffAmt}\n-\n-\t// 12 month lockup\n-\tlockup := int64(12) // 12 year\n-\tlockupLength := vestingLength * lockup\n-\tlockupPeriod := sdkvesting.Period{Length: lockupLength, Amount: vestingAmtTotal}\n-\tlockupPeriods := sdkvesting.Periods{lockupPeriod}\n-\n-\t// Create vesting periods with initial cliff\n-\tvestingPeriods := sdkvesting.Periods{cliffPeriod}\n-\tfor p := int64(1); p <= periodsTotal-cliff; p++ {\n-\t\tvestingPeriods = append(vestingPeriods, vestingPeriod)\n-\t}\n-\n \tvar (\n \t\tclawbackAccount *types.ClawbackVestingAccount\n \t\tvesting         sdk.Coins\n\n@@ -653,12 +739,13 @@\nvar _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\tisClawback      bool\n \t)\n \n-\tvestingAddr := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n+\tvestingAddr, vestingPriv := utiltx.NewAccAddressAndKey()\n \tfunder, funderPriv := utiltx.NewAccAddressAndKey()\n \tdest := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n \n \tBeforeEach(func() {\n-\t\ts.SetupTest()\n+\t\tExpect(s.SetupTest()).To(BeNil()) // reset\n+\n \t\tvestingStart := s.ctx.BlockTime()\n \n \t\t// Initialize account at vesting address by funding it with tokens\n\n@@ -668,46 +755,45 @@\nvar _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\terr = s.app.BankKeeper.SendCoins(s.ctx, vestingAddr, funder, vestingAmtTotal)\n \t\tExpect(err).ToNot(HaveOccurred(), \"failed to send coins to funder\")\n \n+\t\t// Send some tokens to the vesting account to cover tx fees\n+\t\terr = testutil.FundAccount(s.ctx, s.app.BankKeeper, vestingAddr, accountGasCoverage)\n+\t\tExpect(err).ToNot(HaveOccurred(), \"failed to fund target account\")\n+\n \t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbalanceGrantee := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\tbalanceDest := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \t\tExpect(balanceFunder).To(Equal(vestingAmtTotal[0]), \"expected different funder balance\")\n-\t\tExpect(balanceGrantee.IsZero()).To(BeTrue(), \"expected balance of vesting account to be zero\")\n+\t\tExpect(balanceGrantee.Amount).To(Equal(accountGasCoverage[0].Amount))\n \t\tExpect(balanceDest.IsZero()).To(BeTrue(), \"expected destination balance to be zero\")\n \n \t\tmsg := types.NewMsgCreateClawbackVestingAccount(funder, vestingAddr, true)\n-\n \t\t_, err = s.app.VestingKeeper.CreateClawbackVestingAccount(sdk.WrapSDKContext(s.ctx), msg)\n \t\tExpect(err).ToNot(HaveOccurred(), \"expected creating clawback vesting account to succeed\")\n-\n \t\tacc := s.app.AccountKeeper.GetAccount(s.ctx, vestingAddr)\n \t\tclawbackAccount, isClawback = acc.(*types.ClawbackVestingAccount)\n \t\tExpect(isClawback).To(BeTrue(), \"expected account to be clawback vesting account\")\n-\n \t\t// fund the vesting account\n-\t\tmsgFund := types.NewMsgFundVestingAccount(funder, vestingAddr, vestingStart, lockupPeriods, vestingPeriods)\n+\t\tmsgFund := types.NewMsgFundVestingAccount(funder, vestingAddr, vestingStart, testutil.TestVestingSchedule.LockupPeriods, testutil.TestVestingSchedule.VestingPeriods)\n \t\t_, err = s.app.VestingKeeper.FundVestingAccount(sdk.WrapSDKContext(s.ctx), msgFund)\n \t\tExpect(err).ToNot(HaveOccurred(), \"expected funding vesting account to succeed\")\n-\n \t\tacc = s.app.AccountKeeper.GetAccount(s.ctx, vestingAddr)\n \t\tExpect(acc).ToNot(BeNil(), \"expected account to exist\")\n \t\tclawbackAccount, isClawback = acc.(*types.ClawbackVestingAccount)\n \t\tExpect(isClawback).To(BeTrue(), \"expected account to be clawback vesting account\")\n \n \t\t// Check if all tokens are unvested and locked at vestingStart\n \t\tvesting = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n-\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\tunlocked = clawbackAccount.GetUnlockedOnly(s.ctx.BlockTime())\n+\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\tunlocked = clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n \t\tExpect(vesting).To(Equal(vestingAmtTotal), \"expected difference vesting tokens\")\n \t\tExpect(vested.IsZero()).To(BeTrue(), \"expected no tokens to be vested\")\n \t\tExpect(unlocked.IsZero()).To(BeTrue(), \"expected no tokens to be unlocked\")\n-\n \t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbalanceGrantee = s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\tbalanceDest = s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \n \t\tExpect(bF.IsZero()).To(BeTrue(), \"expected funder balance to be zero\")\n-\t\tExpect(balanceGrantee).To(Equal(vestingAmtTotal[0]), \"expected all tokens to be locked\")\n+\t\tExpect(balanceGrantee).To(Equal(vestingAmtTotal.Add(accountGasCoverage...)[0]), \"expected all tokens to be locked\")\n \t\tExpect(balanceDest.IsZero()).To(BeTrue(), \"expected no tokens to be unlocked\")\n \t})\n\n@@ -716,37 +802,30 @@\nvar _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\temptyVestingAddr := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n \t\terr := testutil.FundAccount(s.ctx, s.app.BankKeeper, emptyVestingAddr, vestingAmtTotal)\n \t\tExpect(err).ToNot(HaveOccurred(), \"failed to fund target account\")\n-\n \t\tmsg := types.NewMsgCreateClawbackVestingAccount(funder, emptyVestingAddr, false)\n-\n \t\t_, err = s.app.VestingKeeper.CreateClawbackVestingAccount(sdk.WrapSDKContext(s.ctx), msg)\n \t\tExpect(err).ToNot(HaveOccurred(), \"expected creating clawback vesting account to succeed\")\n-\n \t\tclawbackMsg := types.NewMsgClawback(funder, emptyVestingAddr, dest)\n \t\t_, err = s.app.VestingKeeper.Clawback(ctx, clawbackMsg)\n \t\tExpect(err).To(HaveOccurred())\n \t\tExpect(err.Error()).To(ContainSubstring(\"has no vesting or lockup periods\"))\n \t})\n-\n \tIt(\"should claw back unvested amount before cliff\", func() {\n \t\tctx := sdk.WrapSDKContext(s.ctx)\n-\n \t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbalanceDest := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n-\n \t\t// Perform clawback before cliff\n \t\tmsg := types.NewMsgClawback(funder, vestingAddr, dest)\n \t\tres, err := s.app.VestingKeeper.Clawback(ctx, msg)\n \t\tExpect(err).To(BeNil())\n \t\tExpect(res.Coins).To(Equal(vestingAmtTotal), \"expected different coins to be clawed back\")\n-\n \t\t// All initial vesting amount goes to dest\n \t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbG := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\tbD := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \n \t\tExpect(bF).To(Equal(balanceFunder), \"expected funder balance to be unchanged\")\n-\t\tExpect(bG.IsZero()).To(BeTrue(), \"expected all tokens to be clawed back\")\n+\t\tExpect(bG.Amount).To(Equal(accountGasCoverage[0].Amount), \"expected all tokens to be clawed back\")\n \t\tExpect(bD).To(Equal(balanceDest.Add(vestingAmtTotal[0])), \"expected all tokens to be clawed back to the destination account\")\n \t})\n\n@@ -756,82 +835,78 @@\nvar _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\ts.CommitAfter(cliffDuration * time.Second)\n \n \t\t// Check that all tokens are locked and some, but not all tokens are vested\n-\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\tunlocked = clawbackAccount.GetUnlockedOnly(s.ctx.BlockTime())\n-\t\tfree = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\tunlocked = clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n+\t\tfree = clawbackAccount.GetUnlockedVestedCoins(s.ctx.BlockTime())\n \t\tvesting = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n \t\texpVestedAmount := amt.Mul(math.NewInt(cliff))\n \t\texpVested := sdk.NewCoins(sdk.NewCoin(stakeDenom, expVestedAmount))\n \t\tunvested := vestingAmtTotal.Sub(vested...)\n \n-\t\ts.Require().Equal(expVested, vested)\n-\t\ts.Require().True(expVestedAmount.GT(math.NewInt(0)))\n-\t\ts.Require().True(free.IsZero())\n-\t\ts.Require().Equal(vesting, vestingAmtTotal)\n+\t\tExpect(expVested).To(Equal(vested))\n+\t\tExpect(expVestedAmount.GT(math.NewInt(0))).To(BeTrue())\n+\t\tExpect(free.IsZero()).To(BeTrue())\n+\t\tExpect(vesting).To(Equal(vestingAmtTotal.Sub(expVested...)))\n \n \t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbalanceGrantee := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\tbalanceDest := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n-\n \t\t// Perform clawback\n \t\tmsg := types.NewMsgClawback(funder, vestingAddr, dest)\n \t\tctx := sdk.WrapSDKContext(s.ctx)\n \t\tres, err := s.app.VestingKeeper.Clawback(ctx, msg)\n \t\tExpect(err).To(BeNil())\n \t\tExpect(res.Coins).To(Equal(unvested), \"expected unvested coins to be clawed back\")\n-\n \t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbG := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\tbD := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \n-\t\texpClawback := clawbackAccount.GetUnvestedOnly(s.ctx.BlockTime())\n+\t\texpClawback := clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n \n \t\t// Any unvested amount is clawed back\n-\t\ts.Require().Equal(balanceFunder, bF)\n-\t\ts.Require().Equal(balanceGrantee.Sub(expClawback[0]).Amount.Uint64(), bG.Amount.Uint64())\n-\t\ts.Require().Equal(balanceDest.Add(expClawback[0]).Amount.Uint64(), bD.Amount.Uint64())\n+\t\tExpect(balanceFunder).To(Equal(bF))\n+\t\tExpect(balanceGrantee.Sub(expClawback[0]).Amount.Uint64()).To(Equal(bG.Amount.Uint64()))\n+\t\tExpect(balanceDest.Add(expClawback[0]).Amount.Uint64()).To(Equal(bD.Amount.Uint64()))\n \t})\n \n \tIt(\"should claw back any unvested amount after cliff and unlocking\", func() {\n \t\t// Surpass lockup duration\n \t\t// A strict `if t < clawbackTime` comparison is used in ComputeClawback\n \t\t// so, we increment the duration with 1 for the free token calculation to match\n-\t\tlockupDuration := time.Duration(lockupLength + 1)\n+\t\tlockupDuration := time.Duration(testutil.TestVestingSchedule.LockupPeriodLength + 1)\n \t\ts.CommitAfter(lockupDuration * time.Second)\n \n \t\t// Check if some, but not all tokens are vested and unlocked\n-\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\tunlocked = clawbackAccount.GetUnlockedOnly(s.ctx.BlockTime())\n+\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\tunlocked = clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n \t\tfree = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n \t\tvesting = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n \t\texpVestedAmount := amt.Mul(math.NewInt(lockup))\n \t\texpVested := sdk.NewCoins(sdk.NewCoin(stakeDenom, expVestedAmount))\n \t\tunvested := vestingAmtTotal.Sub(vested...)\n \n-\t\ts.Require().Equal(free, vested)\n-\t\ts.Require().Equal(expVested, vested)\n-\t\ts.Require().True(expVestedAmount.GT(math.NewInt(0)))\n-\t\ts.Require().Equal(vesting, unvested)\n+\t\tExpect(free).To(Equal(vested))\n+\t\tExpect(expVested).To(Equal(vested))\n+\t\tExpect(expVestedAmount.GT(math.NewInt(0))).To(BeTrue())\n+\t\tExpect(vesting).To(Equal(unvested))\n \n \t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbalanceGrantee := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\tbalanceDest := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n-\n \t\t// Perform clawback\n \t\tmsg := types.NewMsgClawback(funder, vestingAddr, dest)\n \t\tctx := sdk.WrapSDKContext(s.ctx)\n \t\tres, err := s.app.VestingKeeper.Clawback(ctx, msg)\n \t\tExpect(err).To(BeNil())\n \t\tExpect(res.Coins).To(Equal(unvested), \"expected only coins to be clawed back\")\n-\n \t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbG := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\tbD := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \n \t\t// Any unvested amount is clawed back\n-\t\ts.Require().Equal(balanceFunder, bF)\n-\t\ts.Require().Equal(balanceGrantee.Sub(vesting[0]).Amount.Uint64(), bG.Amount.Uint64())\n-\t\ts.Require().Equal(balanceDest.Add(vesting[0]).Amount.Uint64(), bD.Amount.Uint64())\n+\t\tExpect(balanceFunder).To(Equal(bF))\n+\t\tExpect(balanceGrantee.Sub(vesting[0]).Amount.Uint64()).To(Equal(bG.Amount.Uint64()))\n+\t\tExpect(balanceDest.Add(vesting[0]).Amount.Uint64()).To(Equal(bD.Amount.Uint64()))\n \t})\n \n \tIt(\"should not claw back any amount after vesting periods end\", func() {\n\n@@ -840,46 +915,43 @@\nvar _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\ts.CommitAfter(vestingDuration * time.Second)\n \n \t\t// Check if some, but not all tokens are vested and unlocked\n-\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\tunlocked = clawbackAccount.GetUnlockedOnly(s.ctx.BlockTime())\n+\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\tunlocked = clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n \t\tfree = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n \t\tvesting = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n \n \t\texpVested := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(periodsTotal))))\n \t\tunvested := vestingAmtTotal.Sub(vested...)\n \n-\t\ts.Require().Equal(free, vested)\n-\t\ts.Require().Equal(expVested, vested)\n-\t\ts.Require().Equal(expVested, vestingAmtTotal)\n-\t\ts.Require().Equal(unlocked, vestingAmtTotal)\n-\t\ts.Require().Equal(vesting, unvested)\n-\t\ts.Require().True(vesting.IsZero())\n+\t\tExpect(free).To(Equal(vested))\n+\t\tExpect(expVested).To(Equal(vested))\n+\t\tExpect(expVested).To(Equal(vestingAmtTotal))\n+\t\tExpect(unlocked).To(Equal(vestingAmtTotal))\n+\t\tExpect(vesting).To(Equal(unvested))\n+\t\tExpect(vesting.IsZero()).To(BeTrue())\n \n \t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbalanceGrantee := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\tbalanceDest := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n-\n \t\t// Perform clawback\n \t\tmsg := types.NewMsgClawback(funder, vestingAddr, dest)\n \t\tctx := sdk.WrapSDKContext(s.ctx)\n \t\tres, err := s.app.VestingKeeper.Clawback(ctx, msg)\n \t\tExpect(err).To(BeNil(), \"expected no error during clawback\")\n \t\tExpect(res).ToNot(BeNil(), \"expected response not to be nil\")\n \t\tExpect(res.Coins).To(BeEmpty(), \"expected nothing to be clawed back\")\n-\n \t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbG := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\tbD := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \n \t\t// No amount is clawed back\n-\t\ts.Require().Equal(balanceFunder, bF)\n-\t\ts.Require().Equal(balanceGrantee, bG)\n-\t\ts.Require().Equal(balanceDest, bD)\n+\t\tExpect(balanceFunder).To(Equal(bF))\n+\t\tExpect(balanceGrantee).To(Equal(bG))\n+\t\tExpect(balanceDest).To(Equal(bD))\n \t})\n \n \tContext(\"while there is an active governance proposal for the vesting account\", func() {\n \t\tvar clawbackProposalID uint64\n-\n \t\tBeforeEach(func() {\n \t\t\t// submit a different proposal to simulate having multiple proposals of different types\n \t\t\t// on chain.\n\n@@ -893,20 +965,16 @@\nvar _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\t\ts.address.Bytes(),\n \t\t\t)\n \t\t\tExpect(err).ToNot(HaveOccurred(), \"expected no error creating the proposal submission message\")\n-\n \t\t\t_, err = testutil.DeliverTx(s.ctx, s.app, s.priv, nil, msgSubmitProposal)\n \t\t\tExpect(err).ToNot(HaveOccurred(), \"expected no error during proposal submission\")\n-\n \t\t\t// submit clawback proposal\n \t\t\tgovClawbackProposal := &types.ClawbackProposal{\n \t\t\t\tTitle:              \"test gov clawback\",\n \t\t\t\tDescription:        \"this is an example of a governance proposal to clawback vesting coins\",\n \t\t\t\tAddress:            vestingAddr.String(),\n \t\t\t\tDestinationAddress: funder.String(),\n \t\t\t}\n-\n \t\t\tdeposit := sdk.Coins{sdk.Coin{Denom: stakeDenom, Amount: math.NewInt(1)}}\n-\n \t\t\t// Create the message to submit the proposal\n \t\t\tmsgSubmit, err := govv1beta1.NewMsgSubmitProposal(\n \t\t\t\tgovClawbackProposal, deposit, s.address.Bytes(),\n\n@@ -915,9 +983,7 @@\nvar _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\t// deliver the proposal\n \t\t\t_, err = testutil.DeliverTx(s.ctx, s.app, s.priv, nil, msgSubmit)\n \t\t\tExpect(err).ToNot(HaveOccurred(), \"expected no error during proposal submission\")\n-\n \t\t\ts.Commit()\n-\n \t\t\t// Check if the proposal was submitted\n \t\t\tproposals := s.app.GovKeeper.GetProposals(s.ctx)\n \t\t\tExpect(len(proposals)).To(Equal(2), \"expected two proposals to be found\")\n\n@@ -926,49 +992,40 @@\nvar _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\tExpect(proposal.GetTitle()).To(Equal(\"test gov clawback\"), \"expected different proposal title\")\n \t\t\tExpect(proposal.Status).To(Equal(govv1.StatusDepositPeriod), \"expected proposal to be in deposit period\")\n \t\t})\n-\n \t\tContext(\"with deposit made\", func() {\n \t\t\tBeforeEach(func() {\n \t\t\t\tparams := s.app.GovKeeper.GetParams(s.ctx)\n \t\t\t\tdepositAmount := params.MinDeposit[0].Amount.Sub(math.NewInt(1))\n \t\t\t\tdeposit := sdk.Coins{sdk.Coin{Denom: params.MinDeposit[0].Denom, Amount: depositAmount}}\n-\n \t\t\t\t// Deliver the deposit\n \t\t\t\tmsgDeposit := govv1beta1.NewMsgDeposit(s.address.Bytes(), clawbackProposalID, deposit)\n \t\t\t\t_, err := testutil.DeliverTx(s.ctx, s.app, s.priv, nil, msgDeposit)\n \t\t\t\tExpect(err).ToNot(HaveOccurred(), \"expected no error during proposal deposit\")\n-\n \t\t\t\ts.Commit()\n-\n \t\t\t\t// Check the proposal is in voting period\n \t\t\t\tproposal, found := s.app.GovKeeper.GetProposal(s.ctx, clawbackProposalID)\n \t\t\t\tExpect(found).To(BeTrue(), \"expected proposal to be found\")\n \t\t\t\tExpect(proposal.Status).To(Equal(govv1.StatusVotingPeriod), \"expected proposal to be in voting period\")\n-\n \t\t\t\t// Check the store entry was set correctly\n \t\t\t\thasActivePropposal := s.app.VestingKeeper.HasActiveClawbackProposal(s.ctx, vestingAddr)\n \t\t\t\tExpect(hasActivePropposal).To(BeTrue(), \"expected an active clawback proposal for the vesting account\")\n \t\t\t})\n-\n \t\t\tIt(\"should not allow clawback\", func() {\n \t\t\t\t// Try to clawback tokens\n \t\t\t\tmsgClawback := types.NewMsgClawback(funder, vestingAddr, dest)\n \t\t\t\t_, err = s.app.VestingKeeper.Clawback(sdk.WrapSDKContext(s.ctx), msgClawback)\n \t\t\t\tExpect(err).To(HaveOccurred(), \"expected error during clawback while there is an active governance proposal\")\n \t\t\t\tExpect(err.Error()).To(ContainSubstring(\"clawback is disabled while there is an active clawback proposal\"))\n-\n \t\t\t\t// Check that the clawback was not performed\n \t\t\t\tacc := s.app.AccountKeeper.GetAccount(s.ctx, vestingAddr)\n \t\t\t\tExpect(acc).ToNot(BeNil(), \"expected account to exist\")\n \t\t\t\t_, isClawback := acc.(*types.ClawbackVestingAccount)\n \t\t\t\tExpect(isClawback).To(BeTrue(), \"expected account to be clawback vesting account\")\n-\n \t\t\t\tbalances, err := s.app.VestingKeeper.Balances(s.ctx, &types.QueryBalancesRequest{\n \t\t\t\t\tAddress: vestingAddr.String(),\n \t\t\t\t})\n \t\t\t\tExpect(err).ToNot(HaveOccurred(), \"expected no error during balances query\")\n \t\t\t\tExpect(balances.Unvested).To(Equal(vestingAmtTotal), \"expected no tokens to be clawed back\")\n-\n \t\t\t\t// Delegate some funds to the suite validators in order to vote on proposal with enough voting power\n \t\t\t\t// using only the suite private key\n \t\t\t\tpriv, ok := s.priv.(*ethsecp256k1.PrivKey)\n\n@@ -981,39 +1038,32 @@\nvar _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\t\t\tExpect(err).ToNot(HaveOccurred(), \"expected no error during delegation\")\n \t\t\t\t\tExpect(res.Code).To(BeZero(), \"expected delegation to succeed\")\n \t\t\t\t}\n-\n \t\t\t\t// Vote on proposal\n \t\t\t\tres, err := testutil.Vote(s.ctx, s.app, priv, clawbackProposalID, govv1beta1.OptionYes)\n \t\t\t\tExpect(err).ToNot(HaveOccurred(), \"failed to vote on proposal %d\", clawbackProposalID)\n \t\t\t\tExpect(res.Code).To(BeZero(), \"expected proposal voting to succeed\")\n-\n \t\t\t\t// Check that the funds are clawed back after the proposal has ended\n \t\t\t\ts.CommitAfter(time.Hour * 24 * 365) // one year\n \t\t\t\t// Commit again because EndBlocker is run with time of the previous block and gov proposals are ended in EndBlocker\n \t\t\t\ts.Commit()\n-\n \t\t\t\t// Check that proposal has passed\n \t\t\t\tproposal, found := s.app.GovKeeper.GetProposal(s.ctx, clawbackProposalID)\n \t\t\t\tExpect(found).To(BeTrue(), \"expected proposal to exist\")\n \t\t\t\tExpect(proposal.Status).ToNot(Equal(govv1.StatusVotingPeriod), \"expected proposal to not be in voting period anymore\")\n \t\t\t\tExpect(proposal.Status).To(Equal(govv1.StatusPassed), \"expected proposal to have passed\")\n-\n \t\t\t\t// Check that the account was converted to a normal account\n \t\t\t\tacc = s.app.AccountKeeper.GetAccount(s.ctx, vestingAddr)\n \t\t\t\tExpect(acc).ToNot(BeNil(), \"expected account to exist\")\n \t\t\t\t_, isClawback = acc.(*types.ClawbackVestingAccount)\n \t\t\t\tExpect(isClawback).To(BeFalse(), \"expected account to be a normal account\")\n-\n \t\t\t\thasActiveProposal := s.app.VestingKeeper.HasActiveClawbackProposal(s.ctx, vestingAddr)\n \t\t\t\tExpect(hasActiveProposal).To(BeFalse(), \"expected no active clawback proposal\")\n \t\t\t})\n-\n \t\t\tIt(\"should not allow changing the vesting funder\", func() {\n \t\t\t\tmsgUpdateFunder := types.NewMsgUpdateVestingFunder(funder, dest, vestingAddr)\n \t\t\t\t_, err = s.app.VestingKeeper.UpdateVestingFunder(sdk.WrapSDKContext(s.ctx), msgUpdateFunder)\n \t\t\t\tExpect(err).To(HaveOccurred(), \"expected error during update funder while there is an active governance proposal\")\n \t\t\t\tExpect(err.Error()).To(ContainSubstring(\"cannot update funder while there is an active clawback proposal\"))\n-\n \t\t\t\t// Check that the funder was not updated\n \t\t\t\tacc := s.app.AccountKeeper.GetAccount(s.ctx, vestingAddr)\n \t\t\t\tExpect(acc).ToNot(BeNil(), \"expected account to exist\")\n\n@@ -1022,48 +1072,39 @@\nvar _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\t\tExpect(clawbackAcc.FunderAddress).To(Equal(funder.String()), \"expected funder to be unchanged\")\n \t\t\t})\n \t\t})\n-\n \t\tContext(\"without deposit made\", func() {\n \t\t\tIt(\"allows clawback and changing the funder before the deposit period ends\", func() {\n \t\t\t\tnewFunder, newPriv := utiltx.NewAccAddressAndKey()\n-\n \t\t\t\t// fund accounts\n \t\t\t\terr = testutil.FundAccountWithBaseDenom(s.ctx, s.app.BankKeeper, newFunder, 5e18)\n \t\t\t\tExpect(err).ToNot(HaveOccurred(), \"failed to fund target account\")\n \t\t\t\terr = testutil.FundAccountWithBaseDenom(s.ctx, s.app.BankKeeper, funder, 5e18)\n \t\t\t\tExpect(err).ToNot(HaveOccurred(), \"failed to fund target account\")\n-\n \t\t\t\tmsgUpdateFunder := types.NewMsgUpdateVestingFunder(funder, newFunder, vestingAddr)\n \t\t\t\t_, err = testutil.DeliverTx(s.ctx, s.app, funderPriv, nil, msgUpdateFunder)\n \t\t\t\tExpect(err).ToNot(HaveOccurred(), \"expected no error during update funder while there is an active governance proposal\")\n-\n \t\t\t\t// Check that the funder was updated\n \t\t\t\tacc := s.app.AccountKeeper.GetAccount(s.ctx, vestingAddr)\n \t\t\t\tExpect(acc).ToNot(BeNil(), \"expected account to exist\")\n \t\t\t\t_, isClawback := acc.(*types.ClawbackVestingAccount)\n \t\t\t\tExpect(isClawback).To(BeTrue(), \"expected account to be clawback vesting account\")\n-\n \t\t\t\t// Claw back tokens\n \t\t\t\tmsgClawback := types.NewMsgClawback(newFunder, vestingAddr, funder)\n \t\t\t\t_, err = testutil.DeliverTx(s.ctx, s.app, newPriv, nil, msgClawback)\n \t\t\t\tExpect(err).ToNot(HaveOccurred(), \"expected no error during clawback while there is no deposit made\")\n-\n \t\t\t\t// Check account is converted to a normal account\n \t\t\t\tacc = s.app.AccountKeeper.GetAccount(s.ctx, vestingAddr)\n \t\t\t\tExpect(acc).ToNot(BeNil(), \"expected account to exist\")\n \t\t\t\t_, isClawback = acc.(*types.ClawbackVestingAccount)\n \t\t\t\tExpect(isClawback).To(BeFalse(), \"expected account to be a normal account\")\n \t\t\t})\n-\n \t\t\tIt(\"should remove the store entry after the deposit period ends\", func() {\n \t\t\t\ts.CommitAfter(time.Hour * 24 * 365) // one year\n \t\t\t\t// Commit again because EndBlocker is run with time of the previous block and gov proposals are ended in EndBlocker\n \t\t\t\ts.Commit()\n-\n \t\t\t\t// Check that the proposal has ended -- since deposit failed it's removed from the store\n \t\t\t\t_, found := s.app.GovKeeper.GetProposal(s.ctx, clawbackProposalID)\n \t\t\t\tExpect(found).To(BeFalse(), \"expected proposal not to be found\")\n-\n \t\t\t\t// Check that the store entry was removed\n \t\t\t\thasActiveProposal := s.app.VestingKeeper.HasActiveClawbackProposal(s.ctx, vestingAddr)\n \t\t\t\tExpect(hasActiveProposal).To(BeFalse(),\n\n@@ -1073,97 +1114,88 @@\nvar _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\t})\n \t\t})\n \t})\n-\n \tIt(\"should update vesting funder and claw back unvested amount before cliff\", func() {\n \t\tctx := sdk.WrapSDKContext(s.ctx)\n \t\tnewFunder := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n-\n \t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbalanceNewFunder := s.app.BankKeeper.GetBalance(s.ctx, newFunder, stakeDenom)\n \t\tbalanceGrantee := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n-\n \t\t// Update clawback vesting account funder\n \t\tupdateFunderMsg := types.NewMsgUpdateVestingFunder(funder, newFunder, vestingAddr)\n \t\t_, err := s.app.VestingKeeper.UpdateVestingFunder(ctx, updateFunderMsg)\n-\t\ts.Require().NoError(err)\n+\t\tExpect(err).To(BeNil())\n \n \t\t// Perform clawback before cliff - funds should go to new funder (no dest address defined)\n \t\tmsg := types.NewMsgClawback(newFunder, vestingAddr, sdk.AccAddress([]byte{}))\n \t\tres, err := s.app.VestingKeeper.Clawback(ctx, msg)\n \t\tExpect(err).To(BeNil())\n \t\tExpect(res.Coins).To(Equal(vestingAmtTotal), \"expected different coins to be clawed back\")\n-\n \t\t// All initial vesting amount goes to funder\n \t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbNewF := s.app.BankKeeper.GetBalance(s.ctx, newFunder, stakeDenom)\n \t\tbG := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \n \t\t// Original funder balance should not change\n-\t\ts.Require().Equal(bF, balanceFunder)\n+\t\tExpect(bF).To(Equal(balanceFunder))\n \t\t// New funder should get the vested tokens\n-\t\ts.Require().Equal(balanceNewFunder.Add(vestingAmtTotal[0]).Amount.Uint64(), bNewF.Amount.Uint64())\n-\t\ts.Require().Equal(balanceGrantee.Sub(vestingAmtTotal[0]).Amount.Uint64(), bG.Amount.Uint64())\n+\t\tExpect(balanceNewFunder.Add(vestingAmtTotal[0]).Amount.Uint64()).To(Equal(bNewF.Amount.Uint64()))\n+\t\tExpect(balanceGrantee.Sub(vestingAmtTotal[0]).Amount.Uint64()).To(Equal(bG.Amount.Uint64()))\n \t})\n \n \tIt(\"should update vesting funder and first funder cannot claw back unvested before cliff\", func() {\n \t\tctx := sdk.WrapSDKContext(s.ctx)\n \t\tnewFunder := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n-\n \t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbalanceNewFunder := s.app.BankKeeper.GetBalance(s.ctx, newFunder, stakeDenom)\n \t\tbalanceGrantee := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n-\n \t\t// Update clawback vesting account funder\n \t\tupdateFunderMsg := types.NewMsgUpdateVestingFunder(funder, newFunder, vestingAddr)\n \t\t_, err := s.app.VestingKeeper.UpdateVestingFunder(ctx, updateFunderMsg)\n-\t\ts.Require().NoError(err)\n+\t\tExpect(err).To(BeNil())\n \n \t\t// Original funder tries to perform clawback before cliff - is not the current funder\n \t\tmsg := types.NewMsgClawback(funder, vestingAddr, sdk.AccAddress([]byte{}))\n \t\t_, err = s.app.VestingKeeper.Clawback(ctx, msg)\n-\t\ts.Require().Error(err)\n+\t\tExpect(err).NotTo(BeNil())\n \n \t\t// All balances should remain the same\n \t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbNewF := s.app.BankKeeper.GetBalance(s.ctx, newFunder, stakeDenom)\n \t\tbG := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \n-\t\ts.Require().Equal(bF, balanceFunder)\n-\t\ts.Require().Equal(balanceNewFunder, bNewF)\n-\t\ts.Require().Equal(balanceGrantee, bG)\n+\t\tExpect(bF).To(Equal(balanceFunder))\n+\t\tExpect(balanceNewFunder).To(Equal(bNewF))\n+\t\tExpect(balanceGrantee).To(Equal(bG))\n \t})\n \n \tContext(\"governance clawback to community pool\", func() {\n \t\tIt(\"should claw back unvested amount before cliff\", func() {\n \t\t\tctx := sdk.WrapSDKContext(s.ctx)\n-\n \t\t\t// initial balances\n \t\t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\t\tbalanceGrantee := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\t\tbalanceDest := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \t\t\tpool := s.app.DistrKeeper.GetFeePool(s.ctx)\n \t\t\tbalanceCommPool := pool.CommunityPool[0]\n-\n \t\t\t// Perform clawback before cliff\n \t\t\tmsg := types.NewMsgClawback(authtypes.NewModuleAddress(govtypes.ModuleName), vestingAddr, dest)\n \t\t\tres, err := s.app.VestingKeeper.Clawback(ctx, msg)\n \t\t\tExpect(err).To(BeNil())\n \t\t\tExpect(res.Coins).To(Equal(vestingAmtTotal), \"expected different coins to be clawed back\")\n-\n \t\t\t// All initial vesting amount goes to community pool instead of dest\n \t\t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\t\tbG := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\t\tbD := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \t\t\tpool = s.app.DistrKeeper.GetFeePool(s.ctx)\n \t\t\tbCP := pool.CommunityPool[0]\n \n-\t\t\ts.Require().Equal(bF, balanceFunder)\n-\t\t\ts.Require().Equal(balanceGrantee.Sub(vestingAmtTotal[0]).Amount.Uint64(), bG.Amount.Uint64())\n+\t\t\tExpect(bF).To(Equal(balanceFunder))\n+\t\t\tExpect(balanceGrantee.Sub(vestingAmtTotal[0]).Amount.Uint64()).To(Equal(bG.Amount.Uint64()))\n \t\t\t// destination address should remain unchanged\n-\t\t\ts.Require().Equal(balanceDest.Amount.Uint64(), bD.Amount.Uint64())\n+\t\t\tExpect(balanceDest.Amount.Uint64()).To(Equal(bD.Amount.Uint64()))\n \t\t\t// vesting amount should go to community pool\n-\t\t\ts.Require().Equal(balanceCommPool.Amount.Add(math.LegacyNewDec(vestingAmtTotal[0].Amount.Int64())), bCP.Amount)\n-\t\t\ts.Require().Equal(stakeDenom, bCP.Denom)\n+\t\t\tExpect(balanceCommPool.Amount.Add(math.LegacyNewDec(vestingAmtTotal[0].Amount.Int64()))).To(Equal(bCP.Amount))\n+\t\t\tExpect(stakeDenom).To(Equal(bCP.Denom))\n \t\t})\n \n \t\tIt(\"should claw back any unvested amount after cliff before unlocking\", func() {\n\n@@ -1172,32 +1204,31 @@\nvar _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\ts.CommitAfter(cliffDuration * time.Second)\n \n \t\t\t// Check that all tokens are locked and some, but not all tokens are vested\n-\t\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\t\tunlocked = clawbackAccount.GetUnlockedOnly(s.ctx.BlockTime())\n-\t\t\tfree = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\tunlocked = clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n+\t\t\tfree = clawbackAccount.GetUnlockedVestedCoins(s.ctx.BlockTime())\n \t\t\tvesting = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n \t\t\texpVestedAmount := amt.Mul(math.NewInt(cliff))\n \t\t\texpVested := sdk.NewCoins(sdk.NewCoin(stakeDenom, expVestedAmount))\n \t\t\tunvested := vestingAmtTotal.Sub(vested...)\n \n-\t\t\ts.Require().Equal(expVested, vested)\n-\t\t\ts.Require().True(expVestedAmount.GT(math.NewInt(0)))\n-\t\t\ts.Require().True(free.IsZero())\n-\t\t\ts.Require().Equal(vesting, vestingAmtTotal)\n+\t\t\tExpect(expVested).To(Equal(vested))\n+\t\t\tExpect(expVestedAmount.GT(math.NewInt(0))).To(BeTrue())\n+\t\t\tExpect(free.IsZero()).To(BeTrue())\n+\t\t\tExpect(vesting).To(Equal(vestingAmtTotal.Sub(expVested...)))\n \n \t\t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n-\t\t\tbalanceGrantee := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\t\tbalanceDest := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \t\t\tpool := s.app.DistrKeeper.GetFeePool(s.ctx)\n \t\t\tbalanceCommPool := pool.CommunityPool[0]\n \n \t\t\ttestClawbackAccount := TestClawbackAccount{\n-\t\t\t\tprivKey:         nil,\n+\t\t\t\tprivKey:         vestingPriv,\n \t\t\t\taddress:         vestingAddr,\n \t\t\t\tclawbackAccount: clawbackAccount,\n \t\t\t}\n \t\t\t// stake vested tokens\n-\t\t\t_, err := delegate(testClawbackAccount, vested)\n+\t\t\t_, err := testutil.Delegate(s.ctx, s.app, testClawbackAccount.privKey, vested[0], s.validator)\n \t\t\tExpect(err).To(BeNil())\n \n \t\t\t// Perform clawback\n\n@@ -1206,56 +1237,65 @@\nvar _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\tres, err := s.app.VestingKeeper.Clawback(ctx, msg)\n \t\t\tExpect(err).To(BeNil())\n \t\t\tExpect(res.Coins).To(Equal(unvested), \"expected unvested coins to be clawed back\")\n-\n \t\t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\t\tbG := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\t\tbD := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \t\t\tpool = s.app.DistrKeeper.GetFeePool(s.ctx)\n \t\t\tbCP := pool.CommunityPool[0]\n \n-\t\t\texpClawback := clawbackAccount.GetUnvestedOnly(s.ctx.BlockTime())\n+\t\t\texpClawback := clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n \n \t\t\t// Any unvested amount is clawed back to community pool\n-\t\t\ts.Require().Equal(balanceFunder, bF)\n-\t\t\ts.Require().Equal(balanceGrantee.Sub(expClawback[0]).Amount.Uint64(), bG.Amount.Uint64())\n-\t\t\ts.Require().Equal(balanceDest.Amount.Uint64(), bD.Amount.Uint64())\n+\t\t\tExpect(balanceFunder).To(Equal(bF))\n+\t\t\t// grantee balance should be zero because delegated all unvested tokens\n+\t\t\tExpect(bG.Amount).To(Equal(math.ZeroInt()))\n+\t\t\tExpect(balanceDest.Amount.Uint64()).To(Equal(bD.Amount.Uint64()))\n \t\t\t// vesting amount should go to community pool\n-\t\t\ts.Require().Equal(balanceCommPool.Amount.Add(math.LegacyNewDec(expClawback[0].Amount.Int64())), bCP.Amount)\n-\t\t\ts.Require().Equal(stakeDenom, bCP.Denom)\n+\t\t\tExpect(balanceCommPool.Amount.Add(math.LegacyNewDec(expClawback[0].Amount.Int64()))).To(Equal(bCP.Amount))\n+\t\t\tExpect(stakeDenom).To(Equal(bCP.Denom))\n+\n+\t\t\t// check delegation was not clawed back\n+\t\t\tqueryHelper := baseapp.NewQueryServerTestHelper(s.ctx, s.app.InterfaceRegistry())\n+\t\t\tquerier := stakingkeeper.Querier{Keeper: s.app.StakingKeeper.Keeper}\n+\t\t\tstakingtypes.RegisterQueryServer(queryHelper, querier)\n+\t\t\tqc := stakingtypes.NewQueryClient(queryHelper)\n+\t\t\tdelRes, err := qc.Delegation(s.ctx, &stakingtypes.QueryDelegationRequest{DelegatorAddr: vestingAddr.String(), ValidatorAddr: s.validator.OperatorAddress})\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\tExpect(delRes.DelegationResponse).NotTo(BeNil())\n+\t\t\tExpect(delRes.DelegationResponse.Balance).To(Equal(vested[0]))\n \t\t})\n \n \t\tIt(\"should claw back any unvested amount after cliff and unlocking\", func() {\n \t\t\t// Surpass lockup duration\n \t\t\t// A strict `if t < clawbackTime` comparison is used in ComputeClawback\n \t\t\t// so, we increment the duration with 1 for the free token calculation to match\n-\t\t\tlockupDuration := time.Duration(lockupLength + 1)\n+\t\t\tlockupDuration := time.Duration(testutil.TestVestingSchedule.LockupPeriodLength + 1)\n \t\t\ts.CommitAfter(lockupDuration * time.Second)\n \n \t\t\t// Check if some, but not all tokens are vested and unlocked\n-\t\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\t\tunlocked = clawbackAccount.GetUnlockedOnly(s.ctx.BlockTime())\n+\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\tunlocked = clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n \t\t\tfree = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n \t\t\tvesting = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n \t\t\texpVestedAmount := amt.Mul(math.NewInt(lockup))\n \t\t\texpVested := sdk.NewCoins(sdk.NewCoin(stakeDenom, expVestedAmount))\n \t\t\tunvested := vestingAmtTotal.Sub(vested...)\n \n-\t\t\ts.Require().Equal(free, vested)\n-\t\t\ts.Require().Equal(expVested, vested)\n-\t\t\ts.Require().True(expVestedAmount.GT(math.NewInt(0)))\n-\t\t\ts.Require().Equal(vesting, unvested)\n+\t\t\tExpect(free).To(Equal(vested))\n+\t\t\tExpect(expVested).To(Equal(vested))\n+\t\t\tExpect(expVestedAmount.GT(math.NewInt(0))).To(BeTrue())\n+\t\t\tExpect(vesting).To(Equal(unvested))\n \n \t\t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n-\t\t\tbalanceGrantee := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\t\tbalanceDest := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \n \t\t\ttestClawbackAccount := TestClawbackAccount{\n-\t\t\t\tprivKey:         nil,\n+\t\t\t\tprivKey:         vestingPriv,\n \t\t\t\taddress:         vestingAddr,\n \t\t\t\tclawbackAccount: clawbackAccount,\n \t\t\t}\n \t\t\t// stake vested tokens\n-\t\t\t_, err := delegate(testClawbackAccount, vested)\n+\t\t\t_, err := testutil.Delegate(s.ctx, s.app, testClawbackAccount.privKey, vested[0], s.validator)\n \t\t\tExpect(err).To(BeNil())\n \n \t\t\t// Perform clawback\n\n@@ -1264,15 +1304,22 @@\nvar _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\tres, err := s.app.VestingKeeper.Clawback(ctx, msg)\n \t\t\tExpect(err).To(BeNil())\n \t\t\tExpect(res.Coins).To(Equal(unvested), \"expected only unvested coins to be clawed back\")\n-\n \t\t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\t\tbG := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\t\tbD := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \n \t\t\t// Any unvested amount is clawed back\n-\t\t\ts.Require().Equal(balanceFunder, bF)\n-\t\t\ts.Require().Equal(balanceGrantee.Sub(vesting[0]).Amount.Uint64(), bG.Amount.Uint64())\n-\t\t\ts.Require().Equal(balanceDest.Add(vesting[0]).Amount.Uint64(), bD.Amount.Uint64())\n+\t\t\tExpect(balanceFunder).To(Equal(bF))\n+\t\t\t// final grantee balance should be 0 because delegated all the vested amt\n+\t\t\tExpect(bG.Amount).To(Equal(math.ZeroInt()))\n+\t\t\tExpect(balanceDest.Add(vesting[0]).Amount.Uint64()).To(Equal(bD.Amount.Uint64()))\n+\n+\t\t\t// check delegated tokens were not clawed back\n+\t\t\tstkQuerier := stakingkeeper.Querier{Keeper: s.app.StakingKeeper.Keeper}\n+\t\t\tdelRes, err := stkQuerier.DelegatorDelegations(s.ctx, &stakingtypes.QueryDelegatorDelegationsRequest{DelegatorAddr: vestingAddr.String()})\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\tExpect(delRes.DelegationResponses).To(HaveLen(1))\n+\t\t\tExpect(delRes.DelegationResponses[0].Balance.Amount).To(Equal(vested[0].Amount))\n \t\t})\n \n \t\tIt(\"should not claw back any amount after vesting periods end\", func() {\n\n@@ -1281,34 +1328,33 @@\nvar _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\ts.CommitAfter(vestingDuration * time.Second)\n \n \t\t\t// Check if some, but not all tokens are vested and unlocked\n-\t\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\t\tunlocked = clawbackAccount.GetUnlockedOnly(s.ctx.BlockTime())\n+\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\tunlocked = clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n \t\t\tfree = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n \t\t\tvesting = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n \n \t\t\texpVested := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(periodsTotal))))\n \t\t\tunvested := vestingAmtTotal.Sub(vested...)\n \n-\t\t\ts.Require().Equal(free, vested)\n-\t\t\ts.Require().Equal(expVested, vested)\n-\t\t\ts.Require().Equal(expVested, vestingAmtTotal)\n-\t\t\ts.Require().Equal(unlocked, vestingAmtTotal)\n-\t\t\ts.Require().Equal(vesting, unvested)\n-\t\t\ts.Require().True(vesting.IsZero())\n+\t\t\tExpect(free).To(Equal(vested))\n+\t\t\tExpect(expVested).To(Equal(vested))\n+\t\t\tExpect(expVested).To(Equal(vestingAmtTotal))\n+\t\t\tExpect(unlocked).To(Equal(vestingAmtTotal))\n+\t\t\tExpect(vesting).To(Equal(unvested))\n+\t\t\tExpect(vesting.IsZero()).To(BeTrue())\n \n \t\t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n-\t\t\tbalanceGrantee := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\t\tbalanceDest := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \t\t\tpool := s.app.DistrKeeper.GetFeePool(s.ctx)\n \t\t\tbalanceCommPool := pool.CommunityPool[0]\n \n \t\t\ttestClawbackAccount := TestClawbackAccount{\n-\t\t\t\tprivKey:         nil,\n+\t\t\t\tprivKey:         vestingPriv,\n \t\t\t\taddress:         vestingAddr,\n \t\t\t\tclawbackAccount: clawbackAccount,\n \t\t\t}\n \t\t\t// stake vested tokens\n-\t\t\t_, err := delegate(testClawbackAccount, vested)\n+\t\t\t_, err := testutil.Delegate(s.ctx, s.app, testClawbackAccount.privKey, vested[0], s.validator)\n \t\t\tExpect(err).To(BeNil())\n \n \t\t\t// Perform clawback\n\n@@ -1317,41 +1363,44 @@\nvar _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\tres, err := s.app.VestingKeeper.Clawback(ctx, msg)\n \t\t\tExpect(err).To(BeNil(), \"expected no error during clawback\")\n \t\t\tExpect(res.Coins).To(BeEmpty(), \"expected nothing to be clawed back after end of vesting schedules\")\n-\n \t\t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\t\tbG := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\t\tbD := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \t\t\tpool = s.app.DistrKeeper.GetFeePool(s.ctx)\n \t\t\tbCP := pool.CommunityPool[0]\n \n \t\t\t// No amount is clawed back\n-\t\t\ts.Require().Equal(balanceFunder, bF)\n-\t\t\ts.Require().Equal(balanceGrantee, bG)\n-\t\t\ts.Require().Equal(balanceDest, bD)\n-\t\t\ts.Require().Equal(balanceCommPool.Amount, bCP.Amount)\n+\t\t\tExpect(balanceFunder).To(Equal(bF))\n+\t\t\t// final grantee balance should be 0 because delegated all the vested amt\n+\t\t\tExpect(bG.Amount).To(Equal(math.ZeroInt()))\n+\t\t\tExpect(balanceDest).To(Equal(bD))\n+\t\t\tExpect(balanceCommPool.Amount).To(Equal(bCP.Amount))\n+\t\t\t// check delegated tokens were not clawed back\n+\t\t\tstkQuerier := stakingkeeper.Querier{Keeper: s.app.StakingKeeper.Keeper}\n+\t\t\tdelRes, err := stkQuerier.DelegatorDelegations(s.ctx, &stakingtypes.QueryDelegatorDelegationsRequest{DelegatorAddr: vestingAddr.String()})\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\tExpect(delRes.DelegationResponses).To(HaveLen(1))\n+\t\t\tExpect(delRes.DelegationResponses[0].Balance.Amount).To(Equal(vested[0].Amount))\n \t\t})\n \n \t\tIt(\"should update vesting funder and claw back unvested amount before cliff\", func() {\n \t\t\tctx := sdk.WrapSDKContext(s.ctx)\n \t\t\tnewFunder := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n-\n \t\t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\t\tbalanceNewFunder := s.app.BankKeeper.GetBalance(s.ctx, newFunder, stakeDenom)\n \t\t\tbalanceGrantee := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\t\tpool := s.app.DistrKeeper.GetFeePool(s.ctx)\n \t\t\tbalanceCommPool := pool.CommunityPool[0]\n-\n \t\t\t// Update clawback vesting account funder\n \t\t\tupdateFunderMsg := types.NewMsgUpdateVestingFunder(funder, newFunder, vestingAddr)\n \t\t\t_, err := s.app.VestingKeeper.UpdateVestingFunder(ctx, updateFunderMsg)\n-\t\t\ts.Require().NoError(err)\n+\t\t\tExpect(err).To(BeNil())\n \n \t\t\t// Perform clawback before cliff - funds should go to new funder (no dest address defined)\n \t\t\tmsg := types.NewMsgClawback(authtypes.NewModuleAddress(govtypes.ModuleName), vestingAddr, nil)\n \t\t\tres, err := s.app.VestingKeeper.Clawback(ctx, msg)\n \t\t\tExpect(err).To(BeNil())\n \t\t\tExpect(res.Coins).To(Equal(vestingAmtTotal), \"expected different coins to be clawed back\")\n-\n \t\t\t// All initial vesting amount goes to funder\n \t\t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\t\tbNewF := s.app.BankKeeper.GetBalance(s.ctx, newFunder, stakeDenom)\n\n@@ -1360,18 +1409,17 @@\nvar _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\tbCP := pool.CommunityPool[0]\n \n \t\t\t// Original funder balance should not change\n-\t\t\ts.Require().Equal(bF, balanceFunder)\n+\t\t\tExpect(bF).To(Equal(balanceFunder))\n \t\t\t// New funder should not get the vested tokens\n-\t\t\ts.Require().Equal(balanceNewFunder.Amount.Uint64(), bNewF.Amount.Uint64())\n-\t\t\ts.Require().Equal(balanceGrantee.Sub(vestingAmtTotal[0]).Amount.Uint64(), bG.Amount.Uint64())\n+\t\t\tExpect(balanceNewFunder.Amount.Uint64()).To(Equal(bNewF.Amount.Uint64()))\n+\t\t\tExpect(balanceGrantee.Sub(vestingAmtTotal[0]).Amount.Uint64()).To(Equal(bG.Amount.Uint64()))\n \t\t\t// vesting amount should go to community pool\n-\t\t\ts.Require().Equal(balanceCommPool.Amount.Add(math.LegacyNewDec(vestingAmtTotal[0].Amount.Int64())), bCP.Amount)\n+\t\t\tExpect(balanceCommPool.Amount.Add(math.LegacyNewDec(vestingAmtTotal[0].Amount.Int64()))).To(Equal(bCP.Amount))\n \t\t})\n \n \t\tIt(\"should not claw back when governance clawback is disabled\", func() {\n \t\t\t// disable governance clawback\n \t\t\ts.app.VestingKeeper.SetGovClawbackDisabled(s.ctx, vestingAddr)\n-\n \t\t\t// Perform clawback before cliff\n \t\t\tmsg := types.NewMsgClawback(authtypes.NewModuleAddress(govtypes.ModuleName), vestingAddr, dest)\n \t\t\t_, err := s.app.VestingKeeper.Clawback(s.ctx, msg)\n\n@@ -1395,6 +1443,7 @@\nvar _ = Describe(\"Clawback Vesting Account - Smart contract\", func() {\n \t)\n \n \tBeforeEach(func() {\n+\t\tExpect(s.SetupTest()).To(BeNil()) // reset\n \t\tcontract = contracts.ERC20MinterBurnerDecimalsContract\n \t\tcontractAddr, err = testutil.DeployContract(\n \t\t\ts.ctx,\n\n@@ -1406,7 +1455,6 @@\nvar _ = Describe(\"Clawback Vesting Account - Smart contract\", func() {\n \t\t)\n \t\tExpect(err).ToNot(HaveOccurred(), \"failed to deploy contract\")\n \t})\n-\n \tIt(\"should not convert a smart contract to a clawback vesting account\", func() {\n \t\tmsgCreate := types.NewMsgCreateClawbackVestingAccount(\n \t\t\ts.address.Bytes(),\n\n@@ -1420,13 +1468,11 @@\nvar _ = Describe(\"Clawback Vesting Account - Smart contract\", func() {\n \t\t\t\t\"account %s is a contract account and cannot be converted in a clawback vesting account\",\n \t\t\t\tsdk.AccAddress(contractAddr.Bytes()).String()),\n \t\t))\n-\n \t\t// Check that the account was not converted\n \t\tacc := s.app.AccountKeeper.GetAccount(s.ctx, contractAddr.Bytes())\n \t\tExpect(acc).ToNot(BeNil(), \"smart contract should be found\")\n \t\t_, ok := acc.(*types.ClawbackVestingAccount)\n \t\tExpect(ok).To(BeFalse(), \"account should not be a clawback vesting account\")\n-\n \t\t// Check that the contract code was not deleted\n \t\t//\n \t\t// NOTE: When it was possible to create clawback vesting accounts for smart contracts,\n\n@@ -1475,39 +1521,34 @@\nvar _ = Describe(\"Clawback Vesting Account - Barberry bug\", func() {\n \t\t// vestingLength is a period of time in seconds to be used for the creation of the vesting\n \t\t// account.\n \t\tvestingLength = int64(60 * 60 * 24 * 30) // 30 days in seconds\n-\n \t\t// txCost is the cost of a transaction to be deducted from the expected account balance\n \t\ttxCost int64\n \t)\n \n \tBeforeEach(func() {\n-\t\ts.SetupTest()\n+\t\tExpect(s.SetupTest()).To(BeNil()) // reset\n \n \t\t// Initialize the account at the vesting address and the funder accounts by funding them\n \t\tfundedCoins := sdk.Coins{{Denom: utils.BaseDenom, Amount: math.NewInt(2e18)}} // fund more than what is sent to the vesting account for transaction fees\n \t\terr = testutil.FundAccount(s.ctx, s.app.BankKeeper, vestingAddr, fundedCoins)\n \t\tExpect(err).ToNot(HaveOccurred(), \"failed to fund account\")\n \t\terr = testutil.FundAccount(s.ctx, s.app.BankKeeper, funder, fundedCoins)\n \t\tExpect(err).ToNot(HaveOccurred(), \"failed to fund account\")\n-\n \t\t// Create a clawback vesting account\n \t\tmsgCreate := types.NewMsgCreateClawbackVestingAccount(\n \t\t\tfunder,\n \t\t\tvestingAddr,\n \t\t\tfalse,\n \t\t)\n-\n \t\tres, err := testutil.DeliverTx(s.ctx, s.app, vestingPriv, &gasPrice, msgCreate)\n \t\tExpect(err).ToNot(HaveOccurred(), \"failed to create clawback vesting account\")\n \t\ttxCost = gasPrice.Int64() * res.GasWanted\n-\n \t\t// Check clawback acccount was created\n \t\tacc := s.app.AccountKeeper.GetAccount(s.ctx, vestingAddr)\n \t\tExpect(acc).ToNot(BeNil(), \"clawback vesting account not created\")\n \t\t_, ok := acc.(*types.ClawbackVestingAccount)\n \t\tExpect(ok).To(BeTrue(), \"account is not a clawback vesting account\")\n \t})\n-\n \tContext(\"when funding a clawback vesting account\", func() {\n \t\ttestcases := []struct {\n \t\t\tname         string\n\n@@ -1564,27 +1605,23 @@\nvar _ = Describe(\"Clawback Vesting Account - Barberry bug\", func() {\n \t\t\t\terrContains:  \"vesting and/or lockup schedules must be present\",\n \t\t\t},\n \t\t}\n-\n \t\tfor _, tc := range testcases {\n \t\t\ttc := tc\n \t\t\tIt(tc.name, func() {\n \t\t\t\tvar (\n \t\t\t\t\tlockupPeriods  sdkvesting.Periods\n \t\t\t\t\tvestingPeriods sdkvesting.Periods\n \t\t\t\t)\n-\n \t\t\t\tif !tc.lockupCoins.Empty() {\n \t\t\t\t\tlockupPeriods = sdkvesting.Periods{\n \t\t\t\t\t\tsdkvesting.Period{Length: vestingLength, Amount: tc.lockupCoins},\n \t\t\t\t\t}\n \t\t\t\t}\n-\n \t\t\t\tif !tc.vestingCoins.Empty() {\n \t\t\t\t\tvestingPeriods = sdkvesting.Periods{\n \t\t\t\t\t\tsdkvesting.Period{Length: vestingLength, Amount: tc.vestingCoins},\n \t\t\t\t\t}\n \t\t\t\t}\n-\n \t\t\t\t// Fund the clawback vesting account at the given address\n \t\t\t\tmsg := types.NewMsgFundVestingAccount(\n \t\t\t\t\tfunder,\n\n@@ -1593,24 +1630,19 @@\nvar _ = Describe(\"Clawback Vesting Account - Barberry bug\", func() {\n \t\t\t\t\tlockupPeriods,\n \t\t\t\t\tvestingPeriods,\n \t\t\t\t)\n-\n \t\t\t\t// Deliver transaction with message\n \t\t\t\tres, err := testutil.DeliverTx(s.ctx, s.app, funderPriv, nil, msg)\n-\n \t\t\t\t// Get account at the new address\n \t\t\t\tacc := s.app.AccountKeeper.GetAccount(s.ctx, vestingAddr)\n \t\t\t\tvacc, _ := acc.(*types.ClawbackVestingAccount)\n-\n \t\t\t\tif tc.expError {\n \t\t\t\t\tExpect(err).To(HaveOccurred(), \"expected funding the vesting account to have failed\")\n \t\t\t\t\tExpect(err.Error()).To(ContainSubstring(tc.errContains), \"expected funding the vesting account to have failed\")\n-\n \t\t\t\t\tExpect(vacc.LockupPeriods).To(BeEmpty(), \"expected clawback vesting account to not have been funded\")\n \t\t\t\t} else {\n \t\t\t\t\tExpect(err).ToNot(HaveOccurred(), \"failed to fund clawback vesting account\")\n \t\t\t\t\tExpect(res.Code).To(Equal(uint32(0)), \"failed to fund clawback vesting account\")\n \t\t\t\t\tExpect(vacc.LockupPeriods).ToNot(BeEmpty(), \"vesting account should have been funded\")\n-\n \t\t\t\t\t// Check that the vesting account has the correct balance\n \t\t\t\t\tbalance := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, utils.BaseDenom)\n \t\t\t\t\texpBalance := int64(2e18) + int64(1e18) - txCost // fundedCoins + vestingCoins - txCost\n```\n\nFilename: x/vesting/keeper/migrations.go:\n```\n@@ -6,9 +6,13 @@\nimport (\n \tsdk \"github.com/cosmos/cosmos-sdk/types\"\n \t\"github.com/cosmos/cosmos-sdk/types/module\"\n \tv2 \"github.com/evmos/evmos/v18/x/vesting/migrations/v2\"\n+\tv3 \"github.com/evmos/evmos/v18/x/vesting/migrations/v3\"\n )\n \n-var _ module.MigrationHandler = Migrator{}.Migrate1to2\n+var (\n+\t_ module.MigrationHandler = Migrator{}.Migrate1to2\n+\t_ module.MigrationHandler = Migrator{}.Migrate2to3\n+)\n \n // Migrator is a struct for handling in-place store migrations.\n type Migrator struct {\n\n@@ -26,3 +30,8 @@\nfunc NewMigrator(keeper Keeper) Migrator {\n func (m Migrator) Migrate1to2(ctx sdk.Context) error {\n \treturn v2.MigrateStore(ctx, m.keeper.accountKeeper)\n }\n+\n+// Migrate2to3 migrates the store from consensus version 2 to 3\n+func (m Migrator) Migrate2to3(ctx sdk.Context) error {\n+\treturn v3.MigrateStore(ctx, m.keeper.accountKeeper)\n+}\n```\n\nFilename: x/vesting/keeper/migrations_test.go:\n```\n@@ -3,6 +3,7 @@\npackage keeper_test\n import (\n \t\"time\"\n \n+\t\"github.com/cosmos/cosmos-sdk/types\"\n \tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n \tsdkvesting \"github.com/cosmos/cosmos-sdk/x/auth/vesting/types\"\n \ttestutiltx \"github.com/evmos/evmos/v18/testutil/tx\"\n\n@@ -11,8 +12,10 @@\nimport (\n \tvestingtypes \"github.com/evmos/evmos/v18/x/vesting/types\"\n )\n \n-func (suite *KeeperTestSuite) TestMigration() {\n-\tsuite.SetupTest()\n+func (suite *KeeperTestSuite) TestMigrate1to2() {\n+\tif err := suite.SetupTest(); err != nil {\n+\t\tpanic(err)\n+\t}\n \n \t// Create account addresses for testing\n \tvestingAddr, _ := testutiltx.NewAccAddressAndKey()\n\n@@ -45,3 +48,88 @@\nfunc (suite *KeeperTestSuite) TestMigration() {\n \tsuite.Require().NotNil(foundAcc, \"vesting account not found\")\n \tsuite.Require().IsType(&vestingtypes.ClawbackVestingAccount{}, foundAcc, \"vesting account is not a v2 base vesting account\")\n }\n+\n+func (suite *KeeperTestSuite) TestMigrate2to3() {\n+\tvar emtpyCoins types.Coins\n+\tif err := suite.SetupTest(); err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\t// Create account addresses for testing\n+\tvestingAddr, _ := testutiltx.NewAccAddressAndKey()\n+\tfunder, _ := testutiltx.NewAccAddressAndKey()\n+\n+\t// create a base vesting account instead of a clawback vesting account at the vesting address\n+\tbaseAccount := authtypes.NewBaseAccountWithAddress(vestingAddr)\n+\tacc := sdkvesting.NewBaseVestingAccount(baseAccount, balances, 500000)\n+\n+\ttestCases := []struct {\n+\t\tname                    string\n+\t\tinitialDelegatedVesting types.Coins\n+\t\tinitialDelegatedFree    types.Coins\n+\t\texpectedDelegatedFree   types.Coins\n+\t}{\n+\t\t{\n+\t\t\tname:                    \"delegated vesting > 0 and delegated free == 0\",\n+\t\t\tinitialDelegatedVesting: quarter,\n+\t\t\tinitialDelegatedFree:    emtpyCoins,\n+\t\t\texpectedDelegatedFree:   quarter,\n+\t\t},\n+\t\t{\n+\t\t\tname:                    \"delegated vesting > 0 and delegated free > 0\",\n+\t\t\tinitialDelegatedVesting: quarter,\n+\t\t\tinitialDelegatedFree:    quarter,\n+\t\t\texpectedDelegatedFree:   types.NewCoins(types.NewInt64Coin(\"test\", 500)),\n+\t\t},\n+\t\t{\n+\t\t\tname:                    \"delegated vesting == 0 and delegated free > 0\",\n+\t\t\tinitialDelegatedVesting: emtpyCoins,\n+\t\t\tinitialDelegatedFree:    quarter,\n+\t\t\texpectedDelegatedFree:   quarter,\n+\t\t},\n+\t\t{\n+\t\t\tname:                    \"delegated vesting == 0 and delegated free == 0\",\n+\t\t\tinitialDelegatedVesting: emtpyCoins,\n+\t\t\tinitialDelegatedFree:    emtpyCoins,\n+\t\t\texpectedDelegatedFree:   emtpyCoins,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tsuite.Run(tc.name, func() {\n+\t\t\tacc.DelegatedVesting = tc.initialDelegatedVesting\n+\t\t\tacc.DelegatedFree = tc.initialDelegatedFree\n+\n+\t\t\tvestAcc := &vestingtypes.ClawbackVestingAccount{\n+\t\t\t\tBaseVestingAccount: acc,\n+\t\t\t\tFunderAddress:      funder.String(),\n+\t\t\t\tStartTime:          time.Now(),\n+\t\t\t\tLockupPeriods:      lockupPeriods,\n+\t\t\t\tVestingPeriods:     vestingPeriods,\n+\t\t\t}\n+\t\t\tsuite.app.AccountKeeper.SetAccount(suite.ctx, vestAcc)\n+\n+\t\t\t// check account was created successfully\n+\t\t\tfoundAcc := suite.app.AccountKeeper.GetAccount(suite.ctx, vestingAddr)\n+\t\t\tsuite.Require().NotNil(foundAcc, \"vesting account not found\")\n+\t\t\tvestAcc, ok := foundAcc.(*vestingtypes.ClawbackVestingAccount)\n+\t\t\tsuite.Require().True(ok)\n+\t\t\tsuite.Require().Equal(tc.initialDelegatedVesting, vestAcc.DelegatedVesting)\n+\t\t\tsuite.Require().Equal(tc.initialDelegatedFree, vestAcc.DelegatedFree)\n+\n+\t\t\t// migrate\n+\t\t\tmigrator := keeper.NewMigrator(suite.app.VestingKeeper)\n+\t\t\terr = migrator.Migrate2to3(suite.ctx)\n+\t\t\tsuite.Require().NoError(err, \"migration failed\")\n+\n+\t\t\t// check that the account delegated vesting coins were migrated\n+\t\t\t// to the delegated free coins\n+\t\t\tfoundAcc = suite.app.AccountKeeper.GetAccount(suite.ctx, vestingAddr)\n+\t\t\tsuite.Require().NotNil(foundAcc, \"vesting account not found\")\n+\t\t\tvestAcc, ok = foundAcc.(*vestingtypes.ClawbackVestingAccount)\n+\t\t\tsuite.Require().True(ok)\n+\t\t\tsuite.Require().Equal(emtpyCoins, vestAcc.DelegatedVesting)\n+\t\t\tsuite.Require().Equal(tc.expectedDelegatedFree, vestAcc.DelegatedFree)\n+\t\t})\n+\t}\n+}\n```\n\nFilename: x/vesting/keeper/msg_server.go:\n```\n@@ -371,6 +371,11 @@\nfunc (k Keeper) ConvertVestingAccount(\n \t\treturn nil, errorsmod.Wrapf(errortypes.ErrInvalidRequest, \"vesting coins still left in account: %s\", msg.VestingAddress)\n \t}\n \n+\t// check if account has any locked up coins left\n+\tif vestingAcc.HasLockedCoins(ctx.BlockTime()) {\n+\t\treturn nil, errorsmod.Wrapf(errortypes.ErrInvalidRequest, \"locked up coins still left in account: %s\", msg.VestingAddress)\n+\t}\n+\t\n \t// if gov clawback is disabled, remove the entry from the store.\n \t// if no entry is found for the address, this will no-op\n \tk.DeleteGovClawbackDisabled(ctx, address)\n```\n\nFilename: x/vesting/keeper/setup_test.go:\n```\n@@ -1,23 +1,34 @@\npackage keeper_test\n \n import (\n+\t\"errors\"\n+\t\"math\"\n \t\"testing\"\n+\t\"time\"\n \n-\t//nolint:revive // dot imports are fine for Ginkgo\n-\t. \"github.com/onsi/ginkgo/v2\"\n-\t//nolint:revive // dot imports are fine for Ginkgo\n-\t. \"github.com/onsi/gomega\"\n-\n+\tsdkmath \"cosmossdk.io/math\"\n+\t\"github.com/cosmos/cosmos-sdk/baseapp\"\n \t\"github.com/cosmos/cosmos-sdk/client\"\n \t\"github.com/cosmos/cosmos-sdk/crypto/keyring\"\n \tcryptotypes \"github.com/cosmos/cosmos-sdk/crypto/types\"\n \tsdk \"github.com/cosmos/cosmos-sdk/types\"\n+\tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n+\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n \tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n \t\"github.com/ethereum/go-ethereum/common\"\n+\t\"github.com/ethereum/go-ethereum/crypto\"\n \t\"github.com/stretchr/testify/suite\"\n \n \tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n-\tevm \"github.com/evmos/evmos/v18/x/evm/types\"\n+\n+\t\"github.com/evmos/evmos/v18/crypto/ethsecp256k1\"\n+\t\"github.com/evmos/evmos/v18/encoding\"\n+\t\"github.com/evmos/evmos/v18/testutil\"\n+\tutiltx \"github.com/evmos/evmos/v18/testutil/tx\"\n+\tevmostypes \"github.com/evmos/evmos/v18/types\"\n+\t\"github.com/evmos/evmos/v18/utils\"\n+\tepochstypes \"github.com/evmos/evmos/v18/x/epochs/types\"\n+\tevmtypes \"github.com/evmos/evmos/v18/x/evm/types\"\n \n \t\"github.com/evmos/evmos/v18/app\"\n \t\"github.com/evmos/evmos/v18/x/vesting/types\"\n\n@@ -41,7 +52,7 @@\ntype KeeperTestSuite struct {\n \n \tctx            sdk.Context\n \tapp            *app.Evmos\n-\tqueryClientEvm evm.QueryClient\n+\tqueryClientEvm evmtypes.QueryClient\n \tqueryClient    types.QueryClient\n \taddress        common.Address\n \tconsAddress    sdk.ConsAddress\n\n@@ -57,12 +68,115 @@\nvar s *KeeperTestSuite\n func TestKeeperTestSuite(t *testing.T) {\n \ts = new(KeeperTestSuite)\n \tsuite.Run(t, s)\n-\n-\t// Run Ginkgo integration tests\n-\tRegisterFailHandler(Fail)\n-\tRunSpecs(t, \"Keeper Suite\")\n }\n \n-func (suite *KeeperTestSuite) SetupTest() {\n-\tsuite.DoSetupTest(suite.T())\n+func (suite *KeeperTestSuite) SetupTest() error {\n+\tcheckTx := false\n+\n+\t// account key\n+\tpriv, err := ethsecp256k1.GenerateKey()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tsuite.address = common.BytesToAddress(priv.PubKey().Address().Bytes())\n+\tsuite.signer = utiltx.NewSigner(priv)\n+\tsuite.priv = priv\n+\n+\t// consensus key\n+\tpriv, err = ethsecp256k1.GenerateKey()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tsuite.consAddress = sdk.ConsAddress(priv.PubKey().Address())\n+\n+\t// Init app\n+\tchainID := utils.TestnetChainID + \"-1\"\n+\tsuite.app = app.Setup(checkTx, nil, chainID)\n+\n+\t// Set Context\n+\theader := testutil.NewHeader(\n+\t\t1, time.Now().UTC(), chainID, suite.consAddress, nil, nil,\n+\t)\n+\tsuite.ctx = suite.app.BaseApp.NewContext(false, header)\n+\n+\t// Setup query helpers\n+\tqueryHelperEvm := baseapp.NewQueryServerTestHelper(suite.ctx, suite.app.InterfaceRegistry())\n+\tevmtypes.RegisterQueryServer(queryHelperEvm, suite.app.EvmKeeper)\n+\tsuite.queryClientEvm = evmtypes.NewQueryClient(queryHelperEvm)\n+\n+\tqueryHelper := baseapp.NewQueryServerTestHelper(suite.ctx, suite.app.InterfaceRegistry())\n+\ttypes.RegisterQueryServer(queryHelper, suite.app.VestingKeeper)\n+\tsuite.queryClient = types.NewQueryClient(queryHelper)\n+\n+\t// Set epoch start time and height for all epoch identifiers from the epoch\n+\t// module\n+\tidentifiers := []string{epochstypes.WeekEpochID, epochstypes.DayEpochID}\n+\tfor _, identifier := range identifiers {\n+\t\tepoch, found := suite.app.EpochsKeeper.GetEpochInfo(suite.ctx, identifier)\n+\t\tif !found {\n+\t\t\treturn errors.New(\"epoch info not found\")\n+\t\t}\n+\t\tepoch.StartTime = suite.ctx.BlockTime()\n+\t\tepoch.CurrentEpochStartHeight = suite.ctx.BlockHeight()\n+\t\tsuite.app.EpochsKeeper.SetEpochInfo(suite.ctx, epoch)\n+\t}\n+\n+\tacc := &evmostypes.EthAccount{\n+\t\tBaseAccount: authtypes.NewBaseAccount(sdk.AccAddress(suite.address.Bytes()), nil, 0, 0),\n+\t\tCodeHash:    common.BytesToHash(crypto.Keccak256(nil)).String(),\n+\t}\n+\n+\tsuite.app.AccountKeeper.SetAccount(suite.ctx, acc)\n+\n+\t// fund signer acc to pay for tx fees\n+\tamt := sdkmath.NewInt(int64(math.Pow10(18) * 2))\n+\terr = testutil.FundAccount(\n+\t\tsuite.ctx,\n+\t\tsuite.app.BankKeeper,\n+\t\tsuite.priv.PubKey().Address().Bytes(),\n+\t\tsdk.NewCoins(sdk.NewCoin(utils.BaseDenom, amt)),\n+\t)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Set Validator\n+\tvalAddr := sdk.ValAddress(suite.address.Bytes())\n+\tvalidator, err := stakingtypes.NewValidator(valAddr, priv.PubKey(), stakingtypes.Description{})\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tvalidator = stakingkeeper.TestingUpdateValidator(suite.app.StakingKeeper.Keeper, suite.ctx, validator, true)\n+\terr = suite.app.StakingKeeper.Hooks().AfterValidatorCreated(suite.ctx, validator.GetOperator())\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\terr = suite.app.StakingKeeper.SetValidatorByConsAddr(suite.ctx, validator)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tvalidators := s.app.StakingKeeper.GetValidators(s.ctx, 1)\n+\tsuite.validator = validators[0]\n+\n+\tencodingConfig := encoding.MakeConfig(app.ModuleBasics)\n+\tsuite.clientCtx = client.Context{}.WithTxConfig(encodingConfig.TxConfig)\n+\tsuite.ethSigner = ethtypes.LatestSignerForChainID(suite.app.EvmKeeper.ChainID())\n+\n+\t// Deploy contracts\n+\tcontract, err = suite.DeployContract(erc20Name, erc20Symbol, erc20Decimals)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tcontract2, err = suite.DeployContract(erc20Name2, erc20Symbol2, erc20Decimals)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Set correct denom in govKeeper\n+\tgovParams := suite.app.GovKeeper.GetParams(suite.ctx)\n+\tgovParams.MinDeposit = sdk.NewCoins(sdk.NewCoin(utils.BaseDenom, sdkmath.NewInt(1e6)))\n+\tvotingPeriod := time.Second\n+\tgovParams.VotingPeriod = &votingPeriod\n+\n+\treturn suite.app.GovKeeper.SetParams(suite.ctx, govParams)\n }\n```\n\nFilename: x/vesting/keeper/utils_test.go:\n```\n@@ -1,134 +1,23 @@\npackage keeper_test\n \n import (\n-\t\"math\"\n \t\"strings\"\n \t\"time\"\n \n \t//nolint:revive // dot imports are fine for Ginkgo\n \t. \"github.com/onsi/gomega\"\n \n \tsdkmath \"cosmossdk.io/math\"\n-\t\"github.com/cosmos/cosmos-sdk/baseapp\"\n-\t\"github.com/cosmos/cosmos-sdk/client\"\n \tsdk \"github.com/cosmos/cosmos-sdk/types\"\n \tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n-\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n-\tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n \t\"github.com/ethereum/go-ethereum/common\"\n-\tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n-\t\"github.com/ethereum/go-ethereum/crypto\"\n \n-\t\"github.com/evmos/evmos/v18/app\"\n-\tcosmosante \"github.com/evmos/evmos/v18/app/ante/cosmos\"\n \tevmante \"github.com/evmos/evmos/v18/app/ante/evm\"\n \t\"github.com/evmos/evmos/v18/contracts\"\n-\t\"github.com/evmos/evmos/v18/crypto/ethsecp256k1\"\n-\t\"github.com/evmos/evmos/v18/encoding\"\n \t\"github.com/evmos/evmos/v18/testutil\"\n-\tutiltx \"github.com/evmos/evmos/v18/testutil/tx\"\n-\tevmostypes \"github.com/evmos/evmos/v18/types\"\n-\t\"github.com/evmos/evmos/v18/utils\"\n-\tepochstypes \"github.com/evmos/evmos/v18/x/epochs/types\"\n-\tevmtypes \"github.com/evmos/evmos/v18/x/evm/types\"\n \t\"github.com/evmos/evmos/v18/x/vesting/types\"\n-\n-\t\"github.com/stretchr/testify/require\"\n )\n \n-func (suite *KeeperTestSuite) DoSetupTest(t require.TestingT) {\n-\tcheckTx := false\n-\n-\t// account key\n-\tpriv, err := ethsecp256k1.GenerateKey()\n-\trequire.NoError(t, err)\n-\tsuite.address = common.BytesToAddress(priv.PubKey().Address().Bytes())\n-\tsuite.signer = utiltx.NewSigner(priv)\n-\tsuite.priv = priv\n-\n-\t// consensus key\n-\tpriv, err = ethsecp256k1.GenerateKey()\n-\trequire.NoError(t, err)\n-\tsuite.consAddress = sdk.ConsAddress(priv.PubKey().Address())\n-\n-\t// Init app\n-\tchainID := utils.TestnetChainID + \"-1\"\n-\tsuite.app = app.Setup(checkTx, nil, chainID)\n-\n-\t// Set Context\n-\theader := testutil.NewHeader(\n-\t\t1, time.Now().UTC(), chainID, suite.consAddress, nil, nil,\n-\t)\n-\tsuite.ctx = suite.app.BaseApp.NewContext(false, header)\n-\n-\t// Setup query helpers\n-\tqueryHelperEvm := baseapp.NewQueryServerTestHelper(suite.ctx, suite.app.InterfaceRegistry())\n-\tevmtypes.RegisterQueryServer(queryHelperEvm, suite.app.EvmKeeper)\n-\tsuite.queryClientEvm = evmtypes.NewQueryClient(queryHelperEvm)\n-\n-\tqueryHelper := baseapp.NewQueryServerTestHelper(suite.ctx, suite.app.InterfaceRegistry())\n-\ttypes.RegisterQueryServer(queryHelper, suite.app.VestingKeeper)\n-\tsuite.queryClient = types.NewQueryClient(queryHelper)\n-\n-\t// Set epoch start time and height for all epoch identifiers from the epoch\n-\t// module\n-\tidentifiers := []string{epochstypes.WeekEpochID, epochstypes.DayEpochID}\n-\tfor _, identifier := range identifiers {\n-\t\tepoch, found := suite.app.EpochsKeeper.GetEpochInfo(suite.ctx, identifier)\n-\t\tsuite.Require().True(found)\n-\t\tepoch.StartTime = suite.ctx.BlockTime()\n-\t\tepoch.CurrentEpochStartHeight = suite.ctx.BlockHeight()\n-\t\tsuite.app.EpochsKeeper.SetEpochInfo(suite.ctx, epoch)\n-\t}\n-\n-\tacc := &evmostypes.EthAccount{\n-\t\tBaseAccount: authtypes.NewBaseAccount(sdk.AccAddress(suite.address.Bytes()), nil, 0, 0),\n-\t\tCodeHash:    common.BytesToHash(crypto.Keccak256(nil)).String(),\n-\t}\n-\n-\tsuite.app.AccountKeeper.SetAccount(suite.ctx, acc)\n-\n-\t// fund signer acc to pay for tx fees\n-\tamt := sdkmath.NewInt(int64(math.Pow10(18) * 2))\n-\terr = testutil.FundAccount(\n-\t\tsuite.ctx,\n-\t\tsuite.app.BankKeeper,\n-\t\tsuite.priv.PubKey().Address().Bytes(),\n-\t\tsdk.NewCoins(sdk.NewCoin(utils.BaseDenom, amt)),\n-\t)\n-\tsuite.Require().NoError(err)\n-\n-\t// Set Validator\n-\tvalAddr := sdk.ValAddress(suite.address.Bytes())\n-\tvalidator, err := stakingtypes.NewValidator(valAddr, priv.PubKey(), stakingtypes.Description{})\n-\trequire.NoError(t, err)\n-\tvalidator = stakingkeeper.TestingUpdateValidator(&suite.app.StakingKeeper, suite.ctx, validator, true)\n-\terr = suite.app.StakingKeeper.Hooks().AfterValidatorCreated(suite.ctx, validator.GetOperator())\n-\trequire.NoError(t, err)\n-\terr = suite.app.StakingKeeper.SetValidatorByConsAddr(suite.ctx, validator)\n-\trequire.NoError(t, err)\n-\tvalidators := s.app.StakingKeeper.GetValidators(s.ctx, 1)\n-\tsuite.validator = validators[0]\n-\n-\tencodingConfig := encoding.MakeConfig(app.ModuleBasics)\n-\tsuite.clientCtx = client.Context{}.WithTxConfig(encodingConfig.TxConfig)\n-\tsuite.ethSigner = ethtypes.LatestSignerForChainID(suite.app.EvmKeeper.ChainID())\n-\n-\t// Deploy contracts\n-\tcontract, err = suite.DeployContract(erc20Name, erc20Symbol, erc20Decimals)\n-\trequire.NoError(t, err)\n-\tcontract2, err = suite.DeployContract(erc20Name2, erc20Symbol2, erc20Decimals)\n-\trequire.NoError(t, err)\n-\n-\t// Set correct denom in govKeeper\n-\tgovParams := suite.app.GovKeeper.GetParams(suite.ctx)\n-\tgovParams.MinDeposit = sdk.NewCoins(sdk.NewCoin(utils.BaseDenom, sdkmath.NewInt(1e6)))\n-\tvotingPeriod := time.Second\n-\tgovParams.VotingPeriod = &votingPeriod\n-\terr = suite.app.GovKeeper.SetParams(suite.ctx, govParams)\n-\tsuite.Require().NoError(err, \"failed to set gov params\")\n-}\n-\n // Commit commits and starts a new block with an updated context.\n func (suite *KeeperTestSuite) Commit() {\n \tsuite.CommitAfter(time.Second * 0)\n\n@@ -218,15 +107,6 @@\nfunc assertEthSucceeds(testAccounts []TestClawbackAccount, funder sdk.AccAddress\n \t}\n }\n \n-// delegate is a helper function which creates a message to delegate a given amount of tokens\n-// to a validator and checks if the Cosmos vesting delegation decorator returns no error.\n-func delegate(account TestClawbackAccount, coins sdk.Coins) (*stakingtypes.MsgDelegate, error) {\n-\tmsg := stakingtypes.NewMsgDelegate(account.address, s.validator.GetOperator(), coins[0])\n-\tdec := cosmosante.NewVestingDelegationDecorator(s.app.AccountKeeper, s.app.StakingKeeper, s.app.BankKeeper, types.ModuleCdc)\n-\terr = testutil.ValidateAnteForMsgs(s.ctx, dec, msg)\n-\treturn msg, err\n-}\n-\n // validateEthVestingTransactionDecorator is a helper function to execute the eth vesting transaction decorator\n // with 1 or more given messages and return any occurring error.\n func validateEthVestingTransactionDecorator(msgs ...sdk.Msg) error {\n```\n\nFilename: x/vesting/migrations/v3/migrate.go:\n```\n@@ -0,0 +1,38 @@\n+// Copyright Tharsis Labs Ltd.(Evmos)\n+// SPDX-License-Identifier:ENCL-1.0(https://github.com/evmos/evmos/blob/main/LICENSE)\n+package v3\n+\n+import (\n+\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n+\taccounttypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n+\tvestingtypes \"github.com/evmos/evmos/v18/x/vesting/types\"\n+)\n+\n+// MigrateStore migrates the x/vesting module state from the consensus version 2 to\n+// version 3.\n+// Specifically, it adds the DelegatedVesting (that should always be 0)\n+// to the DelegatedFree\n+func MigrateStore(\n+\tctx sdk.Context,\n+\tak vestingtypes.AccountKeeper,\n+) error {\n+\tak.IterateAccounts(ctx, func(account accounttypes.AccountI) bool {\n+\t\tif vestAcc, ok := account.(*vestingtypes.ClawbackVestingAccount); ok {\n+\t\t\t// if DelegatedVesting == 0, skip it\n+\t\t\tif !vestAcc.DelegatedVesting.IsAllPositive() {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\t// add DelegatedVesting to DelegatedFree,\n+\t\t\t// because it is not possible to delegate vesting coins.\n+\t\t\t// ONLY vested (free) coins can be delegated\n+\t\t\tvestAcc.DelegatedFree = vestAcc.DelegatedFree.Add(vestAcc.DelegatedVesting...)\n+\t\t\tvestAcc.DelegatedVesting = sdk.NewCoins()\n+\n+\t\t\tak.SetAccount(ctx, vestAcc)\n+\t\t}\n+\n+\t\treturn false\n+\t})\n+\n+\treturn nil\n+}\n```\n\nFilename: x/vesting/migrations/v3/migrate_test.go:\n```\n@@ -0,0 +1,3 @@\n+package v3\n+\n+// NOTE: Migrations are tested in keeper package.\n```\n\nFilename: x/vesting/module.go:\n```\n@@ -28,7 +28,7 @@\nimport (\n )\n \n // consensusVersion defines the current x/vesting module consensus version.\n-const consensusVersion = 2\n+const consensusVersion = 3\n \n var (\n \t_ module.AppModule      = AppModule{}\n\n@@ -133,6 +133,10 @@\nfunc (am AppModule) RegisterServices(cfg module.Configurator) {\n \tif err := cfg.RegisterMigration(types.ModuleName, 1, migrator.Migrate1to2); err != nil {\n \t\tpanic(fmt.Errorf(\"failed to migrate %s to v2: %w\", types.ModuleName, err))\n \t}\n+\n+\tif err := cfg.RegisterMigration(types.ModuleName, 2, migrator.Migrate2to3); err != nil {\n+\t\tpanic(fmt.Errorf(\"failed to migrate %s to v3: %w\", types.ModuleName, err))\n+\t}\n }\n \n // InitGenesis performs a no-op.\n```\n\nFilename: x/vesting/types/clawback_vesting_account.go:\n```\n@@ -51,35 +51,55 @@\nfunc NewClawbackVestingAccount(\n \t}\n }\n \n-// GetVestedCoins returns the total number of vested coins that are still in lockup. If no coins are\n-// vested, nil is returned.\n-func (va ClawbackVestingAccount) GetVestedCoins(blockTime time.Time) sdk.Coins {\n-\t// It's likely that one or the other schedule will be nearly trivial,\n-\t// so there should be little overhead in recomputing the conjunction each time.\n-\tcoins := va.GetUnlockedOnly(blockTime).Min(va.GetVestedOnly(blockTime))\n+// GetLockedUpVestedCoins returns the total number of vested coins that are locked.\n+func (va ClawbackVestingAccount) GetLockedUpVestedCoins(blockTime time.Time) sdk.Coins {\n+\treturn va.GetVestedCoins(blockTime).Sub(va.GetUnlockedVestedCoins(blockTime)...)\n+}\n+\n+// GetUnlockedVestedCoins returns the total number of vested coins that are unlocked.\n+// If no coins are vested and unlocked, nil is returned.\n+func (va ClawbackVestingAccount) GetUnlockedVestedCoins(blockTime time.Time) sdk.Coins {\n+\tcoins := va.GetUnlockedCoins(blockTime).Min(va.GetVestedCoins(blockTime))\n \tif coins.IsZero() {\n-\t\treturn nil\n+\t\treturn sdk.Coins{}\n \t}\n \treturn coins\n }\n \n-// GetVestingCoins returns the total number of vesting coins. If no coins are\n-// vesting, nil is returned.\n+// GetVestingCoins returns the total number of vesting coins (unvested coins).\n+// If no coins are vesting, nil is returned.\n func (va ClawbackVestingAccount) GetVestingCoins(blockTime time.Time) sdk.Coins {\n \treturn va.OriginalVesting.Sub(va.GetVestedCoins(blockTime)...)\n }\n \n-// LockedCoins returns the set of coins that are not spendable (i.e. locked),\n-// defined as the vesting coins that are not delegated.\n+// LockedCoins returns the set of coins that are not spendable (i.e. locked or unvested),\n+// defined as the vesting coins (unvested) plus locked vested coins.\n+//\n+// totalAmt = vesting(un/locked) + lockedVested + unlockedVested\n+//\n+//\t(all)   =   (cannot spend)    (cannot spend)   (CAN spend)\n+//\n+// lockedCoins = totalAmt - unlockedVested\n func (va ClawbackVestingAccount) LockedCoins(blockTime time.Time) sdk.Coins {\n-\treturn va.BaseVestingAccount.LockedCoinsFromVesting(va.GetVestingCoins(blockTime))\n+\treturn va.OriginalVesting.Sub(va.GetUnlockedVestedCoins(blockTime)...)\n }\n \n // TrackDelegation tracks a desired delegation amount by setting the appropriate\n-// values for the amount of delegated vesting, delegated free, and reducing the\n-// overall amount of base coins.\n-func (va *ClawbackVestingAccount) TrackDelegation(blockTime time.Time, balance, amount sdk.Coins) {\n-\tva.BaseVestingAccount.TrackDelegation(balance, va.GetVestingCoins(blockTime), amount)\n+// values for the amount of delegated free coins.\n+// The 'balance' input parameter is the delegator account balance.\n+// The 'amount' input parameter are the delegated coins\n+// Note that unvested coins cannot be delegated\n+func (va *ClawbackVestingAccount) TrackDelegation(_ time.Time, balance, amount sdk.Coins) {\n+\t// Can only delegate vested (free) coins\n+\tfor _, coin := range amount {\n+\t\tbaseAmt := balance.AmountOf(coin.Denom)\n+\t\t// Panic if the delegation amount is zero or if the base coins does not\n+\t\t// exceed the desired delegation amount.\n+\t\tif coin.Amount.IsZero() || baseAmt.LT(coin.Amount) {\n+\t\t\tpanic(\"delegation attempt with zero coins or insufficient funds\")\n+\t\t}\n+\t\tva.DelegatedFree = va.DelegatedFree.Add(coin)\n+\t}\n }\n \n // GetStartTime returns the time when vesting starts for a periodic vesting\n\n@@ -125,7 +145,7 @@\nfunc (va ClawbackVestingAccount) Validate() error {\n \t}\n \n \tif vestingEnd > va.EndTime {\n-\t\treturn errors.New(\"vesting schedule exteds beyond account end time\")\n+\t\treturn errors.New(\"vesting schedule extends beyond account end time\")\n \t}\n \n \tif !CoinEq(vestingCoins, va.OriginalVesting) {\n\n@@ -135,29 +155,25 @@\nfunc (va ClawbackVestingAccount) Validate() error {\n \treturn va.BaseVestingAccount.Validate()\n }\n \n-// GetUnlockedOnly returns the unlocking schedule at blockTime.\n-func (va ClawbackVestingAccount) GetUnlockedOnly(blockTime time.Time) sdk.Coins {\n+// GetUnlockedCoins returns the unlocked coins at blockTime.\n+// Note that these unlocked coins can be vested or unvested\n+// and is determined by the lockup periods\n+func (va ClawbackVestingAccount) GetUnlockedCoins(blockTime time.Time) sdk.Coins {\n \treturn ReadSchedule(va.GetStartTime(), va.EndTime, va.LockupPeriods, va.OriginalVesting, blockTime.Unix())\n }\n \n-// GetLockedOnly returns the locking schedule at blockTime.\n-func (va ClawbackVestingAccount) GetLockedOnly(blockTime time.Time) sdk.Coins {\n-\treturn va.OriginalVesting.Sub(va.GetUnlockedOnly(blockTime)...)\n+// GetLockedUpCoins returns the locked coins at blockTime.\n+// Note that these locked up coins can be vested or unvested,\n+// and is determined by the lockup periods\n+func (va ClawbackVestingAccount) GetLockedUpCoins(blockTime time.Time) sdk.Coins {\n+\treturn va.OriginalVesting.Sub(va.GetUnlockedCoins(blockTime)...)\n }\n \n-// GetVestedOnly returns the vesting schedule at blockTime.\n-func (va ClawbackVestingAccount) GetVestedOnly(blockTime time.Time) sdk.Coins {\n+// GetVestedCoins returns the vested coins at blockTime.\n+func (va ClawbackVestingAccount) GetVestedCoins(blockTime time.Time) sdk.Coins {\n \treturn ReadSchedule(va.GetStartTime(), va.EndTime, va.VestingPeriods, va.OriginalVesting, blockTime.Unix())\n }\n \n-// GetUnvestedOnly returns the unvesting schedule at blockTime.\n-func (va ClawbackVestingAccount) GetUnvestedOnly(blockTime time.Time) sdk.Coins {\n-\ttotalUnvested := va.OriginalVesting.Sub(va.GetVestedOnly(blockTime)...)\n-\tif totalUnvested == nil {\n-\t\ttotalUnvested = sdk.Coins{}\n-\t}\n-\treturn totalUnvested\n-}\n \n // GetPassedPeriodCount returns the amount of passed periods at blockTime.\n func (va ClawbackVestingAccount) GetPassedPeriodCount(blockTime time.Time) int {\n\n@@ -170,8 +186,8 @@\nfunc (va ClawbackVestingAccount) GetPassedPeriodCount(blockTime time.Time) int {\n func (va ClawbackVestingAccount) ComputeClawback(\n \tclawbackTime int64,\n ) (ClawbackVestingAccount, sdk.Coins) {\n-\ttotalVested := va.GetVestedOnly(time.Unix(clawbackTime, 0))\n-\ttotalUnvested := va.GetUnvestedOnly(time.Unix(clawbackTime, 0))\n+\ttotalVested := va.GetVestedCoins(time.Unix(clawbackTime, 0))\n+\ttotalUnvested := va.GetVestingCoins(time.Unix(clawbackTime, 0))\n \n \t// Remove all unvested periods from the schedule\n \tpassedPeriodID := va.GetPassedPeriodCount(time.Unix(clawbackTime, 0))\n\n@@ -203,5 +219,5 @@\nfunc (va ClawbackVestingAccount) ComputeClawback(\n // HasLockedCoins returns true if the block time has not passed all clawback\n // account's lockup periods\n func (va ClawbackVestingAccount) HasLockedCoins(blockTime time.Time) bool {\n-\treturn !va.GetLockedOnly(blockTime).IsZero()\n+\treturn !va.GetLockedUpCoins(blockTime).IsZero()\n }\n```\n\nFilename: x/vesting/types/clawback_vesting_account_test.go:\n```\n@@ -19,12 +19,24 @@\nvar (\n \tstakeDenom    = \"stake\"\n \tfeeDenom      = \"fee\"\n \tlockupPeriods = sdkvesting.Periods{\n-\t\tsdkvesting.Period{Length: int64(16 * 60 * 60), Amount: sdk.NewCoins(sdk.NewInt64Coin(feeDenom, 1000), sdk.NewInt64Coin(stakeDenom, 100))},\n+\t\tsdkvesting.Period{\n+\t\t\tLength: int64(16 * 60 * 60), // 16hs\n+\t\t\tAmount: sdk.NewCoins(sdk.NewInt64Coin(feeDenom, 1000), sdk.NewInt64Coin(stakeDenom, 100)),\n+\t\t},\n \t}\n \tvestingPeriods = sdkvesting.Periods{\n-\t\tsdkvesting.Period{Length: int64(12 * 60 * 60), Amount: sdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)}},\n-\t\tsdkvesting.Period{Length: int64(6 * 60 * 60), Amount: sdk.Coins{sdk.NewInt64Coin(feeDenom, 250), sdk.NewInt64Coin(stakeDenom, 25)}},\n-\t\tsdkvesting.Period{Length: int64(6 * 60 * 60), Amount: sdk.Coins{sdk.NewInt64Coin(feeDenom, 250), sdk.NewInt64Coin(stakeDenom, 25)}},\n+\t\tsdkvesting.Period{\n+\t\t\tLength: int64(12 * 60 * 60), // 12hs\n+\t\t\tAmount: getPercentOfVestingCoins(50),\n+\t\t},\n+\t\tsdkvesting.Period{\n+\t\t\tLength: int64(6 * 60 * 60), // 6hs\n+\t\t\tAmount: getPercentOfVestingCoins(25),\n+\t\t},\n+\t\tsdkvesting.Period{\n+\t\t\tLength: int64(6 * 60 * 60), // 6hs\n+\t\t\tAmount: getPercentOfVestingCoins(25),\n+\t\t},\n \t}\n \torigCoins = sdk.Coins{sdk.NewInt64Coin(feeDenom, 1000), sdk.NewInt64Coin(stakeDenom, 100)}\n )\n\n@@ -38,30 +50,31 @@\nfunc TestVestingAccountSuite(t *testing.T) {\n }\n \n func (suite *VestingAccountTestSuite) TestClawbackAccountNew() {\n-\taddr := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n+\taddr := sdk.AccAddress(\"test_address\")\n \tbaseAcc := authtypes.NewBaseAccountWithAddress(addr)\n \tinitialVesting := sdk.NewCoins(sdk.NewInt64Coin(sdk.DefaultBondDenom, 50))\n \n \ttestCases := []struct {\n-\t\tname   string\n-\t\tacc    authtypes.GenesisAccount\n-\t\texpErr bool\n+\t\tname      string\n+\t\tacc       authtypes.GenesisAccount\n+\t\texpErr    bool\n+\t\texpErrMsg string\n \t}{\n \t\t{\n-\t\t\t\"Clawback vesting account - pass\",\n-\t\t\ttypes.NewClawbackVestingAccount(\n+\t\t\tname: \"Clawback vesting account - pass\",\n+\t\t\tacc: types.NewClawbackVestingAccount(\n \t\t\t\tbaseAcc,\n-\t\t\t\tsdk.AccAddress([]byte(\"the funder\")),\n+\t\t\t\tsdk.AccAddress(\"the funder\"),\n \t\t\t\tinitialVesting,\n \t\t\t\ttime.Now(),\n \t\t\t\tsdkvesting.Periods{sdkvesting.Period{Length: 101, Amount: initialVesting}},\n \t\t\t\tsdkvesting.Periods{sdkvesting.Period{Length: 201, Amount: initialVesting}},\n \t\t\t),\n-\t\t\tfalse,\n+\t\t\texpErr: false,\n \t\t},\n \t\t{\n-\t\t\t\"Clawback vesting account - invalid vesting end\",\n-\t\t\t&types.ClawbackVestingAccount{\n+\t\t\tname: \"Clawback vesting account - invalid vesting end\",\n+\t\t\tacc: &types.ClawbackVestingAccount{\n \t\t\t\tBaseVestingAccount: &sdkvesting.BaseVestingAccount{\n \t\t\t\t\tBaseAccount:     baseAcc,\n \t\t\t\t\tOriginalVesting: initialVesting,\n\n@@ -72,11 +85,12 @@\nfunc (suite *VestingAccountTestSuite) TestClawbackAccountNew() {\n \t\t\t\tLockupPeriods:  sdkvesting.Periods{sdkvesting.Period{Length: 10, Amount: initialVesting}},\n \t\t\t\tVestingPeriods: sdkvesting.Periods{sdkvesting.Period{Length: 10, Amount: initialVesting}},\n \t\t\t},\n-\t\t\ttrue,\n+\t\t\texpErr:    true,\n+\t\t\texpErrMsg: \"vesting start-time must be before end-time\",\n \t\t},\n \t\t{\n-\t\t\t\"Clawback vesting account - lockup too long\",\n-\t\t\t&types.ClawbackVestingAccount{\n+\t\t\tname: \"Clawback vesting account - lockup too long\",\n+\t\t\tacc: &types.ClawbackVestingAccount{\n \t\t\t\tBaseVestingAccount: &sdkvesting.BaseVestingAccount{\n \t\t\t\t\tBaseAccount:     baseAcc,\n \t\t\t\t\tOriginalVesting: initialVesting,\n\n@@ -87,11 +101,12 @@\nfunc (suite *VestingAccountTestSuite) TestClawbackAccountNew() {\n \t\t\t\tLockupPeriods:  sdkvesting.Periods{sdkvesting.Period{Length: 20, Amount: initialVesting}},\n \t\t\t\tVestingPeriods: sdkvesting.Periods{sdkvesting.Period{Length: 10, Amount: initialVesting}},\n \t\t\t},\n-\t\t\ttrue,\n+\t\t\texpErr:    true,\n+\t\t\texpErrMsg: \"lockup schedule extends beyond account end time\",\n \t\t},\n \t\t{\n-\t\t\t\"Clawback vesting account - invalid lockup coins\",\n-\t\t\t&types.ClawbackVestingAccount{\n+\t\t\tname: \"Clawback vesting account - invalid lockup coins\",\n+\t\t\tacc: &types.ClawbackVestingAccount{\n \t\t\t\tBaseVestingAccount: &sdkvesting.BaseVestingAccount{\n \t\t\t\t\tBaseAccount:     baseAcc,\n \t\t\t\t\tOriginalVesting: initialVesting,\n\n@@ -102,11 +117,12 @@\nfunc (suite *VestingAccountTestSuite) TestClawbackAccountNew() {\n \t\t\t\tLockupPeriods:  sdkvesting.Periods{sdkvesting.Period{Length: 10, Amount: initialVesting.Add(initialVesting...)}},\n \t\t\t\tVestingPeriods: sdkvesting.Periods{sdkvesting.Period{Length: 10, Amount: initialVesting}},\n \t\t\t},\n-\t\t\ttrue,\n+\t\t\texpErr:    true,\n+\t\t\texpErrMsg: \"original vesting coins does not match the sum of all coins in lockup periods\",\n \t\t},\n \t\t{\n-\t\t\t\"Clawback vesting account - vesting too long\",\n-\t\t\t&types.ClawbackVestingAccount{\n+\t\t\tname: \"Clawback vesting account - vesting too long\",\n+\t\t\tacc: &types.ClawbackVestingAccount{\n \t\t\t\tBaseVestingAccount: &sdkvesting.BaseVestingAccount{\n \t\t\t\t\tBaseAccount:     baseAcc,\n \t\t\t\t\tOriginalVesting: initialVesting,\n\n@@ -117,11 +133,12 @@\nfunc (suite *VestingAccountTestSuite) TestClawbackAccountNew() {\n \t\t\t\tLockupPeriods:  sdkvesting.Periods{sdkvesting.Period{Length: 10, Amount: initialVesting}},\n \t\t\t\tVestingPeriods: sdkvesting.Periods{sdkvesting.Period{Length: 20, Amount: initialVesting}},\n \t\t\t},\n-\t\t\ttrue,\n+\t\t\texpErr:    true,\n+\t\t\texpErrMsg: \"vesting schedule extends beyond account end time\",\n \t\t},\n \t\t{\n-\t\t\t\"Clawback vesting account - invalid vesting coins\",\n-\t\t\t&types.ClawbackVestingAccount{\n+\t\t\tname: \"Clawback vesting account - invalid vesting coins\",\n+\t\t\tacc: &types.ClawbackVestingAccount{\n \t\t\t\tBaseVestingAccount: &sdkvesting.BaseVestingAccount{\n \t\t\t\t\tBaseAccount:     baseAcc,\n \t\t\t\t\tOriginalVesting: initialVesting,\n\n@@ -132,242 +149,186 @@\nfunc (suite *VestingAccountTestSuite) TestClawbackAccountNew() {\n \t\t\t\tLockupPeriods:  sdkvesting.Periods{sdkvesting.Period{Length: 10, Amount: initialVesting}},\n \t\t\t\tVestingPeriods: sdkvesting.Periods{sdkvesting.Period{Length: 10, Amount: initialVesting.Add(initialVesting...)}},\n \t\t\t},\n-\t\t\ttrue,\n+\t\t\texpErr:    true,\n+\t\t\texpErrMsg: \"original vesting coins does not match the sum of all coins in vesting periods\",\n \t\t},\n \t}\n \n \tfor _, tc := range testCases {\n \t\tsuite.Run(tc.name, func() {\n-\t\t\tsuite.Require().Equal(tc.expErr, tc.acc.Validate() != nil)\n+\t\t\terr := tc.acc.Validate()\n+\t\t\tif tc.expErr {\n+\t\t\t\tsuite.Require().Error(err)\n+\t\t\t\tsuite.Require().Contains(err.Error(), tc.expErrMsg)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tsuite.Require().NoError(err)\n \t\t})\n \t}\n }\n \n-func (suite *VestingAccountTestSuite) TestGetVestedVestingLockedCoins() {\n+func (suite *VestingAccountTestSuite) TestGetCoinsFunctions() {\n \tnow := tmtime.Now()\n \tendTime := now.Add(24 * time.Hour)\n \taddr := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n \tbacc := authtypes.NewBaseAccountWithAddress(addr)\n \tva := types.NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte(\"funder\")), origCoins, now, lockupPeriods, vestingPeriods)\n \n \ttestCases := []struct {\n-\t\tname              string\n-\t\ttime              time.Time\n-\t\texpVestedCoins    sdk.Coins\n-\t\texpUnvestedCoins  sdk.Coins\n-\t\texpSpendableCoins sdk.Coins\n+\t\tname                   string\n+\t\ttime                   time.Time\n+\t\texpVestedCoins         sdk.Coins\n+\t\texpLockedUpVestedCoins sdk.Coins\n+\t\texpUnlockedVestedCoins sdk.Coins\n+\t\texpUnvestedCoins       sdk.Coins\n+\t\texpLockedUpCoins       sdk.Coins\n+\t\texpUnlockedCoins       sdk.Coins\n+\t\texpNotSpendable        sdk.Coins\n \t}{\n \t\t{\n-\t\t\t\"no coins vested at the beginning of the vesting schedule\",\n-\t\t\tnow,\n-\t\t\tnil,\n-\t\t\torigCoins,\n-\t\t\torigCoins,\n-\t\t},\n-\t\t{\n-\t\t\t\"all coins vested at the end of the vesting schedule\",\n-\t\t\tendTime,\n-\t\t\torigCoins,\n-\t\t\tsdk.Coins{},\n-\t\t\tsdk.NewCoins(),\n-\t\t},\n-\t\t{\n-\t\t\t\"no coins vested during first vesting period\",\n-\t\t\tnow.Add(6 * time.Hour),\n-\t\t\tnil,\n-\t\t\torigCoins,\n-\t\t\torigCoins,\n-\t\t},\n-\t\t{\n-\t\t\t\"no coins vested after period 1 before unlocking\",\n-\t\t\tnow.Add(14 * time.Hour),\n-\t\t\tnil,\n-\t\t\torigCoins,\n-\t\t\torigCoins,\n-\t\t},\n-\t\t{\n-\t\t\t\"50 percent of coins vested after period 1 at unlocking\",\n-\t\t\tnow.Add(16 * time.Hour),\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t},\n-\t\t{\n-\t\t\t\"period 2 coins don't vest until period is over\",\n-\t\t\tnow.Add(17 * time.Hour),\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t},\n-\t\t{\n-\t\t\t\"75 percent of coins vested after period 2\",\n-\t\t\tnow.Add(18 * time.Hour),\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 750), sdk.NewInt64Coin(stakeDenom, 75)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 250), sdk.NewInt64Coin(stakeDenom, 25)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 250), sdk.NewInt64Coin(stakeDenom, 25)},\n-\t\t},\n-\t\t{\n-\t\t\t\"100 percent of coins vested\",\n-\t\t\tnow.Add(48 * time.Hour),\n-\t\t\torigCoins,\n-\t\t\tsdk.Coins{},\n-\t\t\tsdk.NewCoins(),\n+\t\t\tname:                   \"no coins vested at the beginning of the vesting schedule, all locked\",\n+\t\t\ttime:                   now,\n+\t\t\texpVestedCoins:         sdk.Coins{},\n+\t\t\texpLockedUpVestedCoins: sdk.Coins{},\n+\t\t\texpUnlockedVestedCoins: sdk.Coins{},\n+\t\t\texpUnvestedCoins:       origCoins,\n+\t\t\texpLockedUpCoins:       origCoins,\n+\t\t\texpUnlockedCoins:       sdk.Coins{},\n+\t\t\texpNotSpendable:        origCoins,\n+\t\t},\n+\t\t{\n+\t\t\tname:                   \"all coins vested and unlocked at the end of the vesting schedule\",\n+\t\t\ttime:                   endTime,\n+\t\t\texpVestedCoins:         origCoins,\n+\t\t\texpLockedUpVestedCoins: sdk.Coins{},\n+\t\t\texpUnlockedVestedCoins: origCoins,\n+\t\t\texpUnvestedCoins:       sdk.Coins{},\n+\t\t\texpLockedUpCoins:       sdk.Coins{},\n+\t\t\texpUnlockedCoins:       origCoins,\n+\t\t\texpNotSpendable:        sdk.Coins{},\n+\t\t},\n+\t\t{\n+\t\t\tname:                   \"no coins vested during first vesting period, all still locked\",\n+\t\t\ttime:                   now.Add(6 * time.Hour),\n+\t\t\texpVestedCoins:         sdk.Coins{},\n+\t\t\texpLockedUpVestedCoins: sdk.Coins{},\n+\t\t\texpUnlockedVestedCoins: sdk.Coins{},\n+\t\t\texpUnvestedCoins:       origCoins,\n+\t\t\texpLockedUpCoins:       origCoins,\n+\t\t\texpUnlockedCoins:       sdk.Coins{},\n+\t\t\texpNotSpendable:        origCoins,\n+\t\t},\n+\t\t{\n+\t\t\tname:                   \"50 percent of coins are vested after 1st vesting period, but before unlocking (all locked coins)\",\n+\t\t\ttime:                   now.Add(12 * time.Hour),\n+\t\t\texpVestedCoins:         getPercentOfVestingCoins(50),\n+\t\t\texpLockedUpVestedCoins: getPercentOfVestingCoins(50),\n+\t\t\texpUnlockedVestedCoins: sdk.Coins{},\n+\t\t\texpUnvestedCoins:       getPercentOfVestingCoins(50),\n+\t\t\texpLockedUpCoins:       origCoins,\n+\t\t\texpUnlockedCoins:       sdk.Coins{},\n+\t\t\texpNotSpendable:        origCoins,\n+\t\t},\n+\t\t{\n+\t\t\tname:                   \"after lockup period (all coins unlocked) - 50 percent of coins already vested\",\n+\t\t\ttime:                   now.Add(16 * time.Hour),\n+\t\t\texpVestedCoins:         getPercentOfVestingCoins(50),\n+\t\t\texpLockedUpVestedCoins: sdk.Coins{},\n+\t\t\texpUnlockedVestedCoins: getPercentOfVestingCoins(50),\n+\t\t\texpUnvestedCoins:       getPercentOfVestingCoins(50),\n+\t\t\texpLockedUpCoins:       sdk.Coins{},\n+\t\t\texpUnlockedCoins:       origCoins,\n+\t\t\texpNotSpendable:        getPercentOfVestingCoins(50),\n+\t\t},\n+\t\t{\n+\t\t\tname:                   \"in between vesting periods 1 and 2 - no new coins don't vested\",\n+\t\t\ttime:                   now.Add(17 * time.Hour),\n+\t\t\texpVestedCoins:         getPercentOfVestingCoins(50),\n+\t\t\texpLockedUpVestedCoins: sdk.Coins{},\n+\t\t\texpUnlockedVestedCoins: getPercentOfVestingCoins(50),\n+\t\t\texpUnvestedCoins:       getPercentOfVestingCoins(50),\n+\t\t\texpLockedUpCoins:       sdk.Coins{},\n+\t\t\texpUnlockedCoins:       origCoins,\n+\t\t\texpNotSpendable:        getPercentOfVestingCoins(50),\n+\t\t},\n+\t\t{\n+\t\t\tname:                   \"75 percent of coins vested after period 2\",\n+\t\t\ttime:                   now.Add(18 * time.Hour),\n+\t\t\texpVestedCoins:         getPercentOfVestingCoins(75),\n+\t\t\texpLockedUpVestedCoins: sdk.Coins{},\n+\t\t\texpUnlockedVestedCoins: getPercentOfVestingCoins(75),\n+\t\t\texpUnvestedCoins:       getPercentOfVestingCoins(25),\n+\t\t\texpLockedUpCoins:       sdk.Coins{},\n+\t\t\texpUnlockedCoins:       origCoins,\n+\t\t\texpNotSpendable:        getPercentOfVestingCoins(25),\n+\t\t},\n+\t\t{\n+\t\t\tname:                   \"100 percent of coins vested\",\n+\t\t\ttime:                   now.Add(48 * time.Hour),\n+\t\t\texpVestedCoins:         origCoins,\n+\t\t\texpLockedUpVestedCoins: sdk.Coins{},\n+\t\t\texpUnlockedVestedCoins: origCoins,\n+\t\t\texpUnvestedCoins:       sdk.Coins{},\n+\t\t\texpLockedUpCoins:       sdk.Coins{},\n+\t\t\texpUnlockedCoins:       origCoins,\n+\t\t\texpNotSpendable:        sdk.Coins{},\n \t\t},\n \t}\n \n \tfor _, tc := range testCases {\n \t\tsuite.Run(tc.name, func() {\n \t\t\tvestedCoins := va.GetVestedCoins(tc.time)\n \t\t\tsuite.Require().Equal(tc.expVestedCoins, vestedCoins)\n+\t\t\tlockedUpVested := va.GetLockedUpVestedCoins(tc.time)\n+\t\t\tsuite.Require().Equal(tc.expLockedUpVestedCoins, lockedUpVested)\n+\t\t\tunlockedVestedCoins := va.GetUnlockedVestedCoins(tc.time)\n+\t\t\tsuite.Require().Equal(tc.expUnlockedVestedCoins, unlockedVestedCoins)\n \t\t\tunvestedCoins := va.GetVestingCoins(tc.time)\n \t\t\tsuite.Require().Equal(tc.expUnvestedCoins, unvestedCoins)\n-\t\t\tspendableCoins := va.LockedCoins(tc.time)\n-\t\t\tsuite.Require().Equal(tc.expSpendableCoins, spendableCoins)\n-\t\t})\n-\t}\n-}\n-\n-func (suite *VestingAccountTestSuite) TestGetVestedUnvestedLockedOnly() {\n-\tnow := tmtime.Now()\n-\tendTime := now.Add(24 * time.Hour)\n-\taddr := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n-\tbacc := authtypes.NewBaseAccountWithAddress(addr)\n-\tva := types.NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte(\"funder\")), origCoins, now, lockupPeriods, vestingPeriods)\n-\n-\ttestCases := []struct {\n-\t\tname             string\n-\t\ttime             time.Time\n-\t\texpVestedCoins   sdk.Coins\n-\t\texpUnvestedCoins sdk.Coins\n-\t\texpLockedCoins   sdk.Coins\n-\t}{\n-\t\t{\n-\t\t\t\"no coins vested at the beginning of the vesting schedule\",\n-\t\t\tnow,\n-\t\t\tsdk.Coins{},\n-\t\t\torigCoins,\n-\t\t\torigCoins,\n-\t\t},\n-\t\t{\n-\t\t\t\"all coins vested at the end of the vesting schedule\",\n-\t\t\tendTime,\n-\t\t\torigCoins,\n-\t\t\tsdk.Coins{},\n-\t\t\tsdk.Coins{},\n-\t\t},\n-\t\t{\n-\t\t\t\"no coins vested during first vesting period\",\n-\t\t\tnow.Add(6 * time.Hour),\n-\t\t\tsdk.Coins{},\n-\t\t\torigCoins,\n-\t\t\torigCoins,\n-\t\t},\n-\t\t{\n-\t\t\t\"50 percent of coins vested after period 1 before unlocking\",\n-\t\t\tnow.Add(14 * time.Hour),\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\torigCoins,\n-\t\t},\n-\t\t{\n-\t\t\t\"50 percent of coins vested after period 1 at unlocking\",\n-\t\t\tnow.Add(16 * time.Hour),\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{},\n-\t\t},\n-\t\t{\n-\t\t\t\"period 2 coins don't vest until period is over\",\n-\t\t\tnow.Add(17 * time.Hour),\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{},\n-\t\t},\n-\t\t{\n-\t\t\t\"75 percent of coins vested after period 2\",\n-\t\t\tnow.Add(18 * time.Hour),\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 750), sdk.NewInt64Coin(stakeDenom, 75)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 250), sdk.NewInt64Coin(stakeDenom, 25)},\n-\t\t\tsdk.Coins{},\n-\t\t},\n-\t\t{\n-\t\t\t\"100 percent of coins vested\",\n-\t\t\tnow.Add(48 * time.Hour),\n-\t\t\torigCoins,\n-\t\t\tsdk.Coins{},\n-\t\t\tsdk.Coins{},\n-\t\t},\n-\t}\n-\n-\tfor _, tc := range testCases {\n-\t\tsuite.Run(tc.name, func() {\n-\t\t\tvestedCoins := va.GetVestedOnly(tc.time)\n-\t\t\tsuite.Require().Equal(tc.expVestedCoins, vestedCoins)\n-\t\t\tunvestedCoins := va.GetUnvestedOnly(tc.time)\n-\t\t\tsuite.Require().Equal(tc.expUnvestedCoins, unvestedCoins)\n-\t\t\tlockedCoins := va.GetLockedOnly(tc.time)\n-\t\t\tsuite.Require().Equal(tc.expLockedCoins, lockedCoins)\n+\t\t\tlockedUpCoins := va.GetLockedUpCoins(tc.time)\n+\t\t\tsuite.Require().Equal(tc.expLockedUpCoins, lockedUpCoins)\n+\t\t\tunlockedCoins := va.GetUnlockedCoins(tc.time)\n+\t\t\tsuite.Require().Equal(tc.expUnlockedCoins, unlockedCoins)\n+\t\t\tsuite.Require().Equal(tc.expNotSpendable, va.LockedCoins(tc.time))\n \t\t})\n \t}\n }\n-\n func (suite *VestingAccountTestSuite) TestTrackDelegationUndelegation() {\n \tnow := tmtime.Now()\n \tendTime := now.Add(24 * time.Hour)\n \n \ttestCases := []struct {\n-\t\tname                   string\n-\t\tdelegate               func(*types.ClawbackVestingAccount)\n-\t\texpDelegatedUnvested   sdk.Coins\n-\t\texpDelegatedFree       sdk.Coins\n-\t\tundelegate             func(*types.ClawbackVestingAccount)\n-\t\texpUndelegatedUnvested sdk.Coins\n-\t\texpUndelegatedFree     sdk.Coins\n-\t\texpDelegationPanic     bool\n-\t\texpUndelegationPanic   bool\n+\t\tname                 string\n+\t\tdelegate             func(*types.ClawbackVestingAccount)\n+\t\texpDelegatedFree     sdk.Coins\n+\t\tundelegate           func(*types.ClawbackVestingAccount)\n+\t\texpUndelegatedFree   sdk.Coins\n+\t\texpDelegationPanic   bool\n+\t\texpUndelegationPanic bool\n \t}{\n-\t\t{\n-\t\t\t\"delegate and undelegate all unvested coins\",\n-\t\t\tfunc(va *types.ClawbackVestingAccount) {\n-\t\t\t\tva.TrackDelegation(now, origCoins, origCoins)\n-\t\t\t},\n-\t\t\torigCoins,\n-\t\t\tnil,\n-\t\t\tfunc(va *types.ClawbackVestingAccount) {\n-\t\t\t\tva.TrackUndelegation(origCoins)\n-\t\t\t},\n-\t\t\tsdk.Coins{},\n-\t\t\tnil,\n-\t\t\tfalse,\n-\t\t\tfalse,\n-\t\t},\n \t\t{\n \t\t\t\"delegate and undelegated all vested coins\",\n \t\t\tfunc(va *types.ClawbackVestingAccount) {\n \t\t\t\tva.TrackDelegation(endTime, origCoins, origCoins)\n \t\t\t},\n-\t\t\tnil,\n \t\t\torigCoins,\n \t\t\tfunc(va *types.ClawbackVestingAccount) {\n \t\t\t\tva.TrackUndelegation(origCoins)\n \t\t\t},\n-\t\t\tnil,\n \t\t\tsdk.Coins{},\n \t\t\tfalse,\n \t\t\tfalse,\n \t\t},\n \t\t{\n-\t\t\t\"delegate and undelegate half of unvested coins\",\n+\t\t\t\"delegate and undelegate half of vested coins\",\n \t\t\tfunc(va *types.ClawbackVestingAccount) {\n \t\t\t\tva.TrackDelegation(now, origCoins, vestingPeriods[0].Amount)\n \t\t\t},\n \t\t\tvestingPeriods[0].Amount,\n-\t\t\tnil,\n \t\t\tfunc(va *types.ClawbackVestingAccount) {\n \t\t\t\tva.TrackUndelegation(vestingPeriods[0].Amount)\n \t\t\t},\n \t\t\tsdk.Coins{},\n-\t\t\tnil,\n \t\t\tfalse,\n \t\t\tfalse,\n \t\t},\n\n@@ -377,12 +338,10 @@\nfunc (suite *VestingAccountTestSuite) TestTrackDelegationUndelegation() {\n \t\t\t\tva.TrackDelegation(now, origCoins, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 1000000)})\n \t\t\t},\n \t\t\tvestingPeriods[0].Amount,\n-\t\t\tnil,\n \t\t\tfunc(va *types.ClawbackVestingAccount) {\n \t\t\t\tva.TrackUndelegation(vestingPeriods[0].Amount)\n \t\t\t},\n \t\t\tsdk.Coins{},\n-\t\t\tsdk.Coins{},\n \t\t\ttrue,\n \t\t\tfalse,\n \t\t},\n\n@@ -392,12 +351,10 @@\nfunc (suite *VestingAccountTestSuite) TestTrackDelegationUndelegation() {\n \t\t\t\tva.TrackDelegation(now, origCoins, origCoins)\n \t\t\t},\n \t\t\tvestingPeriods[0].Amount,\n-\t\t\tnil,\n \t\t\tfunc(va *types.ClawbackVestingAccount) {\n \t\t\t\tva.TrackUndelegation(sdk.Coins{sdk.NewInt64Coin(stakeDenom, 0)})\n \t\t\t},\n \t\t\tsdk.Coins{},\n-\t\t\tsdk.Coins{},\n \t\t\tfalse,\n \t\t\ttrue,\n \t\t},\n\n@@ -407,13 +364,11 @@\nfunc (suite *VestingAccountTestSuite) TestTrackDelegationUndelegation() {\n \t\t\t\tva.TrackDelegation(now.Add(17*time.Hour), origCoins, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)})\n \t\t\t\tva.TrackDelegation(now.Add(17*time.Hour), origCoins, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)})\n \t\t\t},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)},\n+\t\t\tsdk.Coins{sdk.NewInt64Coin(stakeDenom, 100)},\n \t\t\tfunc(va *types.ClawbackVestingAccount) {\n \t\t\t\tva.TrackUndelegation(sdk.Coins{sdk.NewInt64Coin(stakeDenom, 25)})\n \t\t\t},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(stakeDenom, 25)},\n+\t\t\tsdk.Coins{sdk.NewInt64Coin(stakeDenom, 75)},\n \t\t\tfalse,\n \t\t\tfalse,\n \t\t},\n\n@@ -423,26 +378,21 @@\nfunc (suite *VestingAccountTestSuite) TestTrackDelegationUndelegation() {\n \t\t\t\tva.TrackDelegation(now.Add(17*time.Hour), origCoins, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)})\n \t\t\t\tva.TrackDelegation(now.Add(17*time.Hour), origCoins, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)})\n \t\t\t},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)},\n+\t\t\tsdk.Coins{sdk.NewInt64Coin(stakeDenom, 100)},\n \t\t\tfunc(va *types.ClawbackVestingAccount) {\n \t\t\t\tva.TrackUndelegation(sdk.Coins{sdk.NewInt64Coin(stakeDenom, 25)})\n \t\t\t\tva.TrackUndelegation(sdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)})\n \t\t\t},\n \t\t\tsdk.Coins{sdk.NewInt64Coin(stakeDenom, 25)},\n-\t\t\tsdk.Coins{},\n \t\t\tfalse,\n \t\t\tfalse,\n \t\t},\n \t}\n-\n \tfor _, tc := range testCases {\n \t\tsuite.Run(tc.name, func() {\n \t\t\taddr := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n \t\t\tbacc := authtypes.NewBaseAccountWithAddress(addr)\n-\n \t\t\tva := types.NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte(\"funder\")), origCoins, now, lockupPeriods, vestingPeriods)\n-\n \t\t\tif tc.expDelegationPanic { //nolint:gocritic\n \t\t\t\tsuite.Require().Panics(func() {\n \t\t\t\t\ttc.delegate(va)\n\n@@ -452,14 +402,15 @@\nfunc (suite *VestingAccountTestSuite) TestTrackDelegationUndelegation() {\n \t\t\t\t\ttc.undelegate(va)\n \t\t\t\t})\n \t\t\t} else {\n+\t\t\t\tvar emptyCoins sdk.Coins\n \t\t\t\t// Track Delegation\n \t\t\t\ttc.delegate(va)\n-\t\t\t\tsuite.Require().Equal(tc.expDelegatedUnvested, va.DelegatedVesting)\n+\t\t\t\tsuite.Require().Equal(emptyCoins, va.DelegatedVesting)\n \t\t\t\tsuite.Require().Equal(tc.expDelegatedFree, va.DelegatedFree)\n \n \t\t\t\t// Track Undelegation\n \t\t\t\ttc.undelegate(va)\n-\t\t\t\tsuite.Require().Equal(tc.expUndelegatedUnvested, va.DelegatedVesting)\n+\t\t\t\tsuite.Require().Equal(emptyCoins, va.DelegatedVesting)\n \t\t\t\tsuite.Require().Equal(tc.expUndelegatedFree, va.DelegatedFree)\n \t\t\t}\n \t\t})\n\n@@ -538,3 +489,16 @@\nfunc (suite *VestingAccountTestSuite) TestComputeClawback() {\n \t\t})\n \t}\n }\n+\n+// getPercentOfVestingCoins is a helper function to calculate\n+// the specified percentage of the coins in the vesting schedule\n+func getPercentOfVestingCoins(percentage int64) sdk.Coins {\n+\tif percentage < 0 || percentage > 100 {\n+\t\tpanic(\"invalid percentage passed!\")\n+\t}\n+\tvar retCoins sdk.Coins\n+\tfor _, coin := range origCoins {\n+\t\tretCoins = retCoins.Add(sdk.NewCoin(coin.Denom, coin.Amount.MulRaw(percentage).QuoRaw(100)))\n+\t}\n+\treturn retCoins\n+}\n```\n\nFilename: x/vesting/types/schedule.go:\n```\n@@ -8,7 +8,7 @@\nimport (\n \tsdkvesting \"github.com/cosmos/cosmos-sdk/x/auth/vesting/types\"\n )\n \n-// ReadSchedule returns the value of a schedule at readTime.\n+// ReadSchedule returns the coins of a schedule at readTime.\n //\n // A \"schedule\" is an increasing step function of Coins over time. It's\n // specified as an absolute start time and a sequence of relative periods, with\n```"
        }
    ],
    "sw_version": "v17.0.1",
    "sw_version_wget": "https://github.com/evmos/evmos/archive/refs/tags/v17.0.1.zip",
    "description": "Evmos is the Ethereum Virtual Machine (EVM) Hub on the Cosmos Network. The spendable balance is not updated properly when delegating vested tokens. The issue allows a clawback vesting account to anticipate the release of unvested tokens.  This vulnerability is fixed in 18.0.0.",
    "sec_adv": [
        {
            "url": "https://github.com/evmos/evmos/security/advisories/GHSA-pxv8-qhrh-jc7v",
            "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\nevmos\n/\nevmos\nPublic\nNotifications You must be signed in to change notification settings\nFork 896\nStar 1.7k\nCode\nIssues\n19\nPull requests\n30\nDiscussions\nActions\nSecurity\n9\nInsights\nAdditional navigation options\nTransferring unvested tokens after delegations\nLow sandoche published GHSA-pxv8-qhrh-jc7v on Jun 6, 2024Jun 6, 2024\nPackage\ngomod github.com/evmos/evmos\n(\nGo\n)\nAffected versions\n<= 17.0.1\nPatched versions\n>=18\nDescription\nImpact\nThis advisory has been created to address the following vulnerabilities found in the Evmos codebase and affecting vesting accounts.\nWrong spendable balance computation\nThe spendable balance is not updated properly when delegating vested tokens. The following example help in describing the issue:\nGiven a clawback vesting account with a starting 15M vesting schedule. The initial spendable balance is 0.\nTime passes and 5M are vested. The spendable balance is now 5M.\nThe account delegate 5M. The spendable balance should be 0, but returns 5M\nThe account can send 5M to another account.\nThe issue allowed a clawback vesting account to anticipate the release of unvested tokens.\nMissing precompile checks\nPreliminary checks on actions computed by the clawback vesting accounts are performed in the ante handler. Evmos core, implements two different ante handlers: one for Cosmos transactions and one for Ethereum transactions. Checks performed on the two implementation are different.\nThe vulnerability discovered allowed a clawback account to bypass Cosmos ante handler checks by sending an Ethereum transaction targeting a precompile used to interact with a Cosmos SDK module.\nMissing create validator check\nThis vulnerability allowed a user to create a validator using vested tokens to deposit the self-bond.\nPatches\nThe spendable balance function has been fixed correcting the TrackDelegation function.\nThe checks for the staking module, for the delegation and the create validator, has been moved into the MsgServer of a wrapper around the Cosmos SDK staking module.\nThe issues have been patched in versions >=V18.0.0.\nReferences\nEvmos vesting module\nFor more information\nIf you have any questions or comments about this advisory:\nReach out to the Core Team in Discord\nOpen a discussion in evmos/evmos\nEmail us at security@evmos.org for security questions\nSeverity\nLow\n3.5\n/ 10\nCVSS v3 base metrics\nAttack vector\nNetwork\nAttack complexity\nLow\nPrivileges required\nLow\nUser interaction\nRequired\nScope\nUnchanged\nConfidentiality\nNone\nIntegrity\nNone\nAvailability\nLow\nLearn more about base metrics\nCVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:N/A:L\nCVE ID\nCVE-2024-32873\nWeaknesses\nNo CWEs\nFooter\n\u00a9 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
            "effective": false,
            "effective_reason": "The advisory describes specific issues and provides an example to illustrate the problem, but it does not include explicit step-by-step instructions or a working exploit code."
        }
    ],
    "cwe": [
        {
            "id": "CWE-682",
            "value": "CWE-682: Incorrect Calculation"
        }
    ],
    "dir_tree": ".\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ante\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 cosmos\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 evm\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 post\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 upgrades\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 v10\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 v11\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 v12\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 v13\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 v14\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 v15\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 v16\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 v17\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 v18\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 v8\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 v8_1\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 v8_2\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 v9\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 v9_1\n\u251c\u2500\u2500 client\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 block\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 debug\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 docs\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 statik\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 swagger-ui\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 keys\n\u251c\u2500\u2500 cmd\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 config\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 evmosd\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 opendb\n\u251c\u2500\u2500 contracts\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 compiled_contracts\n\u251c\u2500\u2500 crypto\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 codec\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ethsecp256k1\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 hd\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 keyring\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 secp256r1\n\u251c\u2500\u2500 encoding\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 codec\n\u251c\u2500\u2500 ethereum\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 eip712\n\u251c\u2500\u2500 ibc\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 testing\n\u251c\u2500\u2500 indexer\n\u251c\u2500\u2500 networks\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 local\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 evmos\n\u251c\u2500\u2500 nix\n\u251c\u2500\u2500 precompiles\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 authorization\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 bank\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 testdata\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 bech32\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 common\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 distribution\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 erc20\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 testdata\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ics20\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 outposts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 osmosis\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 stride\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 p256\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 staking\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 testdata\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 testutil\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 contracts\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 vesting\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 testdata\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 werc20\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 testdata\n\u251c\u2500\u2500 proto\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ethermint\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 crypto\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 v1\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 ethsecp256k1\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 evm\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 v1\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 feemarket\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 v1\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 types\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 v1\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 evmos\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 epochs\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 v1\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 erc20\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 v1\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 incentives\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 v1\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 inflation\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 v1\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 revenue\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 v1\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 vesting\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 v1\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 v2\n\u251c\u2500\u2500 rpc\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 backend\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 mocks\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ethereum\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 pubsub\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 namespaces\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 ethereum\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 debug\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 eth\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 filters\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 miner\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 net\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 personal\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 txpool\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 web3\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 types\n\u251c\u2500\u2500 scripts\n\u251c\u2500\u2500 server\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 config\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 flags\n\u251c\u2500\u2500 tests\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 e2e\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 upgrade\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 integration\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 ledger\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 mocks\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 nix_tests\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 configs\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 cosmwasm\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 artifacts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 hardhat\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 contracts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 osmosis\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 solidity\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 suites\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 basic\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u251c\u2500\u2500 contracts\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u2514\u2500\u2500 test\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 eip1559\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u2514\u2500\u2500 test\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 exception\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u251c\u2500\u2500 contracts\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 test\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u251c\u2500\u2500 migrations\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u2514\u2500\u2500 test\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 opcode\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u251c\u2500\u2500 contracts\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u251c\u2500\u2500 migrations\n\u2502\u00a0\u00a0         \u2502\u00a0\u00a0 \u2514\u2500\u2500 test\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 precompiles\n\u2502\u00a0\u00a0             \u251c\u2500\u2500 contracts\n\u2502\u00a0\u00a0             \u2514\u2500\u2500 test\n\u251c\u2500\u2500 testutil\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 integration\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 common\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 factory\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 grpc\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 network\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 evmos\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 factory\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 grpc\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 keyring\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 network\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 ibc\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 chain\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 coordinator\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 network\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 tx\n\u251c\u2500\u2500 types\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 tests\n\u251c\u2500\u2500 utils\n\u251c\u2500\u2500 version\n\u251c\u2500\u2500 wallets\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 accounts\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ledger\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 mocks\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 usbwallet\n\u2514\u2500\u2500 x\n    \u251c\u2500\u2500 epochs\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 client\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 cli\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 keeper\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 types\n    \u251c\u2500\u2500 erc20\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 client\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 cli\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 metadata\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 keeper\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 migrations\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 v3\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 types\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 types\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 mocks\n    \u251c\u2500\u2500 evm\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 client\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 cli\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 keeper\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 migrations\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v4\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 types\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v5\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 types\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 v6\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 types\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 statedb\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 types\n    \u251c\u2500\u2500 feemarket\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 client\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 cli\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 keeper\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 migrations\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 v4\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 types\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 types\n    \u251c\u2500\u2500 ibc\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 transfer\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 keeper\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 types\n    \u251c\u2500\u2500 incentives\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 types\n    \u251c\u2500\u2500 inflation\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 v1\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 client\n    \u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 cli\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 keeper\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 migrations\n    \u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 v2\n    \u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 types\n    \u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 v3\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 types\n    \u251c\u2500\u2500 revenue\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 v1\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 client\n    \u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 cli\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 keeper\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 migrations\n    \u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 v2\n    \u2502\u00a0\u00a0     \u2502\u00a0\u00a0     \u2514\u2500\u2500 types\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 types\n    \u2514\u2500\u2500 vesting\n        \u251c\u2500\u2500 client\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 cli\n        \u251c\u2500\u2500 keeper\n        \u251c\u2500\u2500 migrations\n        \u2502\u00a0\u00a0 \u251c\u2500\u2500 types\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 v2\n        \u2514\u2500\u2500 types\n\n246 directories\n",
    "repo_path": "evmos-17.0.1/"
}