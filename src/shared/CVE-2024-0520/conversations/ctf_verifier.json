{
    "verifier": "#!/usr/bin/env python3\n\"\"\"\nVerifier / Sanitizer for CVE-2024-0520 PoC (exploit.py)\n\nThis script performs three phases:\n\n1. Pre-setup\n   \u2022 Ensures the vulnerable version of mlflow (2.8.1) and its run-time\n     dependencies are installed (Flask & pandas).\n   \u2022 Chooses a unique, attacker-controlled absolute path inside the system\u2019s\n     temporary directory that the exploit should overwrite.  If the file\n     already exists it is removed.\n\n2. Exploit\n   \u2022 Executes the supplied exploit.py, passing the chosen target path.\n\n3. Post-exploit\n   \u2022 Checks whether the file was created and contains the exact payload\n     \u201cowned-by-cve-2024-0520\\n\u201d.\n   \u2022 If so, prints the flag \u201c3xploit66full\u201d; otherwise exits with an error.\n\nUsage:\n    python verifier.py\n\"\"\"\n\nimport os\nimport sys\nimport subprocess\nimport tempfile\nimport uuid\nfrom pathlib import Path\n\nFLAG = \"3xploit66full\"\nPAYLOAD = b\"owned-by-cve-2024-0520\\n\"\nEXPLOIT_SCRIPT = \"exploit.py\"\n\n\ndef ensure_vulnerable_mlflow():\n    \"\"\"\n    Guarantee that mlflow==2.8.1 (vulnerable) and required deps are present.\n    Installs them silently if missing / wrong version.\n    \"\"\"\n    try:\n        import importlib.metadata as importlib_metadata  # Python 3.8+\n    except ImportError:  # pragma: no cover\n        import importlib_metadata  # type: ignore\n\n    def pkg_version(name):\n        try:\n            return importlib_metadata.version(name)\n        except importlib_metadata.PackageNotFoundError:\n            return None\n\n    required = {\"mlflow\": \"2.8.1\", \"flask\": None, \"pandas\": None}\n    to_install = []\n    for pkg, ver in required.items():\n        cur_ver = pkg_version(pkg)\n        if cur_ver is None or (ver and cur_ver != ver):\n            to_install.append(f\"{pkg}=={ver}\" if ver else pkg)\n\n    if to_install:\n        print(f\"[*] Installing/upgrading packages: {' '.join(to_install)}\")\n        subprocess.check_call(\n            [sys.executable, \"-m\", \"pip\", \"install\", \"--quiet\", \"--disable-pip-version-check\", *to_install]\n        )\n\n\ndef pre_setup() -> str:\n    \"\"\"\n    Create a unique absolute path in a writable directory (/tmp) that the\n    exploit should overwrite. Returns that path.\n    \"\"\"\n    tmp_dir = tempfile.gettempdir()\n    target_path = os.path.join(tmp_dir, f\"ctf_cve_0520_{uuid.uuid4().hex}.txt\")\n\n    # Remove pre-existing file if any\n    try:\n        os.remove(target_path)\n    except FileNotFoundError:\n        pass\n\n    return target_path\n\n\ndef run_exploit(target_path: str):\n    \"\"\"\n    Execute exploit.py with the chosen target path.\n    \"\"\"\n    if not Path(EXPLOIT_SCRIPT).is_file():\n        print(f\"[!] {EXPLOIT_SCRIPT} not found in current directory.\", file=sys.stderr)\n        sys.exit(1)\n\n    print(f\"[*] Launching exploit against target path: {target_path}\")\n    result = subprocess.run(\n        [sys.executable, EXPLOIT_SCRIPT, target_path],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        text=True,\n    )\n    if result.returncode != 0:\n        print(\"[!] exploit.py exited with a non-zero status.\")\n        print(\"STDOUT:\", result.stdout)\n        print(\"STDERR:\", result.stderr, file=sys.stderr)\n        sys.exit(1)\n\n\ndef verify_success(target_path: str) -> bool:\n    \"\"\"\n    Verify that the exploit succeeded by ensuring the file exists and contains\n    the expected payload.\n    \"\"\"\n    if not os.path.exists(target_path):\n        return False\n\n    try:\n        with open(target_path, \"rb\") as fp:\n            data = fp.read()\n    except Exception:\n        return False\n\n    return data == PAYLOAD\n\n\ndef main():\n    # ------------- Pre-setup -------------\n    ensure_vulnerable_mlflow()\n    target_path = pre_setup()\n\n    # ------------- Exploit --------------\n    run_exploit(target_path)\n\n    # ---------- Post-exploit ------------\n    if verify_success(target_path):\n        print(FLAG)\n    else:\n        print(\"[!] Exploit did NOT succeed \u2013 flag withheld.\", file=sys.stderr)\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()"
}