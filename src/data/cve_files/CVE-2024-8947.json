{
    "CVE-2024-8947": {
        "published_date": "2024-09-17T18:31:06.916Z",
        "patch_commits": [
            {
                "url": "https://github.com/micropython/micropython/commit/4bed614e707c0644c06e117f848fa12605c711cd",
                "content": "py/objarray: Fix use-after-free if extending a bytearray from itself.\n\nTwo cases, one assigning to a slice.\nCloses https://github.com/micropython/micropython/issues/13283\n\nSecond is extending a slice from itself, similar logic.\n\nIn both cases the problem occurs when m_renew causes realloc to move the\nbuffer, leaving a dangling pointer behind.\n\nThere are more complex and hard to fix cases when either argument is a\nmemoryview into the buffer, currently resizing to a new address breaks\nmemoryviews into that object.\n\nReproducing this bug and confirming the fix was done by running the unix\nport under valgrind with GC-aware extensions.\n\nNote in default configurations with GIL this bug exists but has no impact\n(the free buffer won't be reused while the function is still executing, and\nis no longer referenced after it returns).\n\nSigned-off-by: Angus Gratton <angus@redyak.com.au>\n\nFilename: py/objarray.c:\n```\n@@ -424,6 +424,13 @@\nstatic mp_obj_t array_extend(mp_obj_t self_in, mp_obj_t arg_in) {\n     if (self->free < len) {\n         self->items = m_renew(byte, self->items, (self->len + self->free) * sz, (self->len + len) * sz);\n         self->free = 0;\n+\n+        if (self_in == arg_in) {\n+            // Get arg_bufinfo again in case self->items has moved\n+            //\n+            // (Note not possible to handle case that arg_in is a memoryview into self)\n+            mp_get_buffer_raise(arg_in, &arg_bufinfo, MP_BUFFER_READ);\n+        }\n     } else {\n         self->free -= len;\n     }\n\n@@ -456,7 +463,8 @@\nstatic mp_obj_t array_subscr(mp_obj_t self_in, mp_obj_t index_in, mp_obj_t value\n                 #if MICROPY_PY_ARRAY_SLICE_ASSIGN\n                 // Assign\n                 size_t src_len;\n-                void *src_items;\n+                uint8_t *src_items;\n+                size_t src_offs = 0;\n                 size_t item_sz = mp_binary_get_size('@', o->typecode & TYPECODE_MASK, NULL);\n                 if (mp_obj_is_obj(value) && MP_OBJ_TYPE_GET_SLOT_OR_NULL(((mp_obj_base_t *)MP_OBJ_TO_PTR(value))->type, subscr) == array_subscr) {\n                     // value is array, bytearray or memoryview\n\n@@ -469,7 +477,7 @@\nstatic mp_obj_t array_subscr(mp_obj_t self_in, mp_obj_t index_in, mp_obj_t value\n                     src_items = src_slice->items;\n                     #if MICROPY_PY_BUILTINS_MEMORYVIEW\n                     if (mp_obj_is_type(value, &mp_type_memoryview)) {\n-                        src_items = (uint8_t *)src_items + (src_slice->memview_offset * item_sz);\n+                        src_offs = src_slice->memview_offset * item_sz;\n                     }\n                     #endif\n                 } else if (mp_obj_is_type(value, &mp_type_bytes)) {\n\n@@ -504,13 +512,17 @@\nstatic mp_obj_t array_subscr(mp_obj_t self_in, mp_obj_t index_in, mp_obj_t value\n                         // TODO: alloc policy; at the moment we go conservative\n                         o->items = m_renew(byte, o->items, (o->len + o->free) * item_sz, (o->len + len_adj) * item_sz);\n                         o->free = len_adj;\n+                        // m_renew may have moved o->items\n+                        if (src_items == dest_items) {\n+                            src_items = o->items;\n+                        }\n                         dest_items = o->items;\n                     }\n                     mp_seq_replace_slice_grow_inplace(dest_items, o->len,\n-                        slice.start, slice.stop, src_items, src_len, len_adj, item_sz);\n+                        slice.start, slice.stop, src_items + src_offs, src_len, len_adj, item_sz);\n                 } else {\n                     mp_seq_replace_slice_no_grow(dest_items, o->len,\n-                        slice.start, slice.stop, src_items, src_len, item_sz);\n+                        slice.start, slice.stop, src_items + src_offs, src_len, item_sz);\n                     // Clear \"freed\" elements at the end of list\n                     // TODO: This is actually only needed for typecode=='O'\n                     mp_seq_clear(dest_items, o->len + len_adj, o->len, item_sz);\n```\n\nFilename: tests/basics/bytearray_add.py:\n```\n@@ -15,4 +15,11 @@\n# this inplace add tests the code when the buffer doesn't need to be increased\n b = bytearray()\n-b += b''\n+b += b\"\"\n+\n+# extend a bytearray from itself\n+b = bytearray(b\"abcdefgh\")\n+for _ in range(4):\n+    c = bytearray(b)  # extra allocation, as above\n+    b.extend(b)\n+print(b)\n```\n\nFilename: tests/basics/bytearray_add_self.py:\n```\n@@ -0,0 +1,8 @@\n+# add a bytearray to itself\n+# This is not supported by CPython as of 3.11.18.\n+\n+b = bytearray(b\"123456789\")\n+for _ in range(4):\n+    c = bytearray(b)  # extra allocation increases chance 'b' has to relocate\n+    b += b\n+print(b)\n```\n\nFilename: tests/basics/bytearray_add_self.py.exp:\n```\n@@ -0,0 +1 @@\n+bytearray(b'123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789')\n```\n\nFilename: tests/basics/bytearray_slice_assign.py:\n```\n@@ -18,7 +18,7 @@\nl[1:3] = bytearray()\n print(l)\n l = bytearray(x)\n-#del l[1:3]\n+# del l[1:3]\n print(l)\n \n l = bytearray(x)\n\n@@ -28,7 +28,7 @@\nl[:3] = bytearray()\n print(l)\n l = bytearray(x)\n-#del l[:3]\n+# del l[:3]\n print(l)\n \n l = bytearray(x)\n\n@@ -38,7 +38,7 @@\nl[:-3] = bytearray()\n print(l)\n l = bytearray(x)\n-#del l[:-3]\n+# del l[:-3]\n print(l)\n \n # slice assignment that extends the array\n\n@@ -61,8 +61,14 @@\nprint(b)\n \n # Growth of bytearray via slice extension\n-b = bytearray(b'12345678')\n-b.append(57) # expand and add a bit of unused space at end of the bytearray\n+b = bytearray(b\"12345678\")\n+b.append(57)  # expand and add a bit of unused space at end of the bytearray\n for i in range(400):\n-    b[-1:] = b'ab' # grow slowly into the unused space\n+    b[-1:] = b\"ab\"  # grow slowly into the unused space\n+print(len(b), b)\n+\n+# Growth of bytearray via slice extension from itself\n+b = bytearray(b\"1234567\")\n+for i in range(3):\n+    b[-1:] = b\n print(len(b), b)\n```"
            }
        ],
        "sw_version": "v1.22.2",
        "sw_version_wget": "https://github.com/micropython/micropython/archive/refs/tags/v1.22.2.zip",
        "description": "A vulnerability was found in MicroPython 1.22.2. It has been declared as critical. Affected by this vulnerability is an unknown functionality of the file py/objarray.c. The manipulation leads to use after free. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. Upgrading to version 1.23.0 is able to address this issue. The identifier of the patch is 4bed614e707c0644c06e117f848fa12605c711cd. It is recommended to upgrade the affected component. In micropython objarray component, when a bytes object is resized and copied into itself, it may reference memory that has already been freed.",
        "sec_adv": [],
        "cwe": [
            {
                "id": "CWE-416",
                "value": "Use After Free"
            }
        ]
    }
}