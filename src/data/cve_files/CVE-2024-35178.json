{
    "CVE-2024-35178": {
        "published_date": "2024-06-06T15:37:10.348Z",
        "patch_commits": [
            {
                "url": "https://github.com/jupyter-server/jupyter_server/commit/79fbf801c5908f4d1d9bc90004b74cfaaeeed2df",
                "content": "Merge pull request from GHSA-hrw6-wg82-cm62\n\n* filefind: avoid handling absolute paths\n\nwe don't need or want absolute path support,\nwhich we inherited from generic ipython_genutils\n\nonly supporting relative paths lets us avoid attempting to accessing files we know we won't accept\n\n* Apply suggestions from code review\n\nCo-authored-by: M Bussonnier <bussonniermatthias@gmail.com>\n\n* filefind: only accept Sequence[str]\n\nwe only call it one place, might as well be simple about it\n\n* version_info gate for is_relative_to\n\n* clarify docstring\n\nCo-authored-by: Carol Willing <carolcode@willingconsulting.com>\n\n---------\n\nCo-authored-by: M Bussonnier <bussonniermatthias@gmail.com>\nCo-authored-by: Carol Willing <carolcode@willingconsulting.com>\n\nFilename: jupyter_server/utils.py:\n```\n@@ -11,6 +11,7 @@\nimport sys\n import warnings\n from contextlib import contextmanager\n+from pathlib import Path\n from typing import Any, Generator, NewType, Sequence\n from urllib.parse import (\n     SplitResult,\n\n@@ -338,81 +339,65 @@\ndef is_namespace_package(namespace: str) -> bool | None:\n     return isinstance(spec.submodule_search_locations, _NamespacePath)\n \n \n-def filefind(filename: str, path_dirs: Sequence[str] | str | None = None) -> str:\n+def filefind(filename: str, path_dirs: Sequence[str]) -> str:\n     \"\"\"Find a file by looking through a sequence of paths.\n-    This iterates through a sequence of paths looking for a file and returns\n-    the full, absolute path of the first occurrence of the file.  If no set of\n-    path dirs is given, the filename is tested as is, after running through\n-    :func:`expandvars` and :func:`expanduser`.  Thus a simple call::\n \n-        filefind(\"myfile.txt\")\n+    For use in FileFindHandler.\n \n-    will find the file in the current working dir, but::\n+    Iterates through a sequence of paths looking for a file and returns\n+    the full, absolute path of the first occurrence of the file.\n \n-        filefind(\"~/myfile.txt\")\n+    Absolute paths are not accepted for inputs.\n \n-    Will find the file in the users home directory.  This function does not\n-    automatically try any paths, such as the cwd or the user's home directory.\n+    This function does not automatically try any paths,\n+    such as the cwd or the user's home directory.\n \n     Parameters\n     ----------\n     filename : str\n-        The filename to look for.\n-    path_dirs : str, None or sequence of str\n-        The sequence of paths to look for the file in.  If None, the filename\n-        need to be absolute or be in the cwd.  If a string, the string is\n-        put into a sequence and the searched.  If a sequence, walk through\n-        each element and join with ``filename``, calling :func:`expandvars`\n-        and :func:`expanduser` before testing for existence.\n+        The filename to look for. Must be a relative path.\n+    path_dirs : sequence of str\n+        The sequence of paths to look in for the file.\n+        Walk through each element and join with ``filename``.\n+        Only after ensuring the path resolves within the directory is it checked for existence.\n \n     Returns\n     -------\n-    Raises :exc:`IOError` or returns absolute path to file.\n+    Raises :exc:`OSError` or returns absolute path to file.\n     \"\"\"\n-\n-    # If paths are quoted, abspath gets confused, strip them...\n-    filename = filename.strip('\"').strip(\"'\")\n-    # If the input is an absolute path, just check it exists\n-    if os.path.isabs(filename) and os.path.isfile(filename):\n-        return filename\n-\n-    if path_dirs is None:\n-        path_dirs = (\"\",)\n-    elif isinstance(path_dirs, str):\n-        path_dirs = (path_dirs,)\n-\n-    for path in path_dirs:\n-        if path == \".\":\n-            path = os.getcwd()  # noqa: PLW2901\n-        testname = expand_path(os.path.join(path, filename))\n-        if os.path.isfile(testname):\n-            return os.path.abspath(testname)\n+    file_path = Path(filename)\n+\n+    # If the input is an absolute path, reject it\n+    if file_path.is_absolute():\n+        msg = f\"{filename} is absolute, filefind only accepts relative paths.\"\n+        raise OSError(msg)\n+\n+    for path_str in path_dirs:\n+        path = Path(path_str).absolute()\n+        test_path = path / file_path\n+        # os.path.abspath resolves '..', but Path.absolute() doesn't\n+        # Path.resolve() does, but traverses symlinks, which we don't want\n+        test_path = Path(os.path.abspath(test_path))\n+        if sys.version_info >= (3, 9):\n+            if not test_path.is_relative_to(path):\n+                # points outside root, e.g. via `filename='../foo'`\n+                continue\n+        else:\n+            # is_relative_to is new in 3.9\n+            try:\n+                test_path.relative_to(path)\n+            except ValueError:\n+                # points outside root, e.g. via `filename='../foo'`\n+                continue\n+        # make sure we don't call is_file before we know it's a file within a prefix\n+        # GHSA-hrw6-wg82-cm62 - can leak password hash on windows.\n+        if test_path.is_file():\n+            return os.path.abspath(test_path)\n \n     msg = f\"File {filename!r} does not exist in any of the search paths: {path_dirs!r}\"\n     raise OSError(msg)\n \n \n-def expand_path(s: str) -> str:\n-    \"\"\"Expand $VARS and ~names in a string, like a shell\n-\n-    :Examples:\n-       In [2]: os.environ['FOO']='test'\n-       In [3]: expand_path('variable FOO is $FOO')\n-       Out[3]: 'variable FOO is test'\n-    \"\"\"\n-    # This is a pretty subtle hack. When expand user is given a UNC path\n-    # on Windows (\\\\server\\share$\\%username%), os.path.expandvars, removes\n-    # the $ to get (\\\\server\\share\\%username%). I think it considered $\n-    # alone an empty var. But, we need the $ to remains there (it indicates\n-    # a hidden share).\n-    if os.name == \"nt\":\n-        s = s.replace(\"$\\\\\", \"IPYTHON_TEMP\")\n-    s = os.path.expandvars(os.path.expanduser(s))\n-    if os.name == \"nt\":\n-        s = s.replace(\"IPYTHON_TEMP\", \"$\\\\\")\n-    return s\n-\n-\n def import_item(name: str) -> Any:\n     \"\"\"Import and return ``bar`` given the string ``foo.bar``.\n     Calling ``bar = import_item(\"foo.bar\")`` is the functional equivalent of\n```\n\nFilename: tests/test_utils.py:\n```\n@@ -13,6 +13,7 @@\nfrom jupyter_server.utils import (\n     check_pid,\n     check_version,\n+    filefind,\n     is_namespace_package,\n     path2url,\n     run_sync_in_loop,\n\n@@ -125,3 +126,41 @@\ndef test_unix_socket_in_use(tmp_path):\n     sock.listen(0)\n     assert unix_socket_in_use(server_address)\n     sock.close()\n+\n+\n+@pytest.mark.parametrize(\n+    \"filename, result\",\n+    [\n+        (\"/foo\", OSError),\n+        (\"../c/in-c\", OSError),\n+        (\"in-a\", \"a/in-a\"),\n+        (\"in-b\", \"b/in-b\"),\n+        (\"in-both\", \"a/in-both\"),\n+        (r\"\\in-a\", OSError),\n+        (\"not-found\", OSError),\n+    ],\n+)\n+def test_filefind(tmp_path, filename, result):\n+    a = tmp_path / \"a\"\n+    a.mkdir()\n+    b = tmp_path / \"b\"\n+    b.mkdir()\n+    c = tmp_path / \"c\"\n+    c.mkdir()\n+    for parent in (a, b):\n+        with parent.joinpath(\"in-both\").open(\"w\"):\n+            pass\n+    with a.joinpath(\"in-a\").open(\"w\"):\n+        pass\n+    with b.joinpath(\"in-b\").open(\"w\"):\n+        pass\n+    with c.joinpath(\"in-c\").open(\"w\"):\n+        pass\n+\n+    if isinstance(result, str):\n+        found = filefind(filename, [str(a), str(b)])\n+        found_relative = Path(found).relative_to(tmp_path)\n+        assert str(found_relative) == result\n+    else:\n+        with pytest.raises(result):\n+            filefind(filename, [str(a), str(b)])\n```"
            }
        ],
        "sw_version": "v2.14.0",
        "sw_version_wget": "https://github.com/jupyter-server/jupyter_server/archive/refs/tags/v2.14.0.zip",
        "description": "The Jupyter Server provides the backend for Jupyter web applications. Jupyter Server on Windows has a vulnerability that lets unauthenticated attackers leak the NTLMv2 password hash of the Windows user running the Jupyter server. An attacker can crack this password to gain access to the Windows machine hosting the Jupyter server, or access other network-accessible machines or 3rd party services using that credential. Or an attacker perform an NTLM relay attack without cracking the credential to gain access to other network-accessible machines. This vulnerability is fixed in 2.14.1.",
        "sec_adv": [
            {
                "url": "https://github.com/jupyter-server/jupyter_server/security/advisories/GHSA-hrw6-wg82-cm62",
                "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\njupyter-server\n/\njupyter_server\nPublic\nNotifications You must be signed in to change notification settings\nFork 336\nStar 523\nCode\nIssues\n178\nPull requests\n36\nDiscussions\nActions\nProjects\nSecurity\n8\nInsights\nAdditional navigation options\nJupyter server on Windows discloses Windows user password hash\nHigh blink1073 published GHSA-hrw6-wg82-cm62 on Jun 6, 2024Jun 6, 2024\nPackage\npip jupyter_server\n(\npip\n)\nAffected versions\n<=2.14.0\nPatched versions\n2.14.1\nDescription\nSummary\nJupyter Server on Windows has a vulnerability that lets unauthenticated attackers leak the NTLMv2 password hash of the Windows user running the Jupyter server. An attacker can crack this password to gain access to the Windows machine hosting the Jupyter server, or access other network-accessible machines or 3rd party services using that credential. Or an attacker perform an NTLM relay attack without cracking the credential to gain access to other network-accessible machines.\nSeverity\nHigh\n7.5\n/ 10\nCVSS v3 base metrics\nAttack vector\nNetwork\nAttack complexity\nLow\nPrivileges required\nNone\nUser interaction\nNone\nScope\nUnchanged\nConfidentiality\nHigh\nIntegrity\nNone\nAvailability\nNone\nLearn more about base metrics\nCVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N\nCVE ID\nCVE-2024-35178\nWeaknesses\nNo CWEs\nCredits\nnvn1729\nReporter\nFooter\nÂ© 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
                "effective": false,
                "effective_reason": "The provided advisory describes the vulnerability but does not include a proof of concept or detailed reproduction steps."
            }
        ],
        "cwe": [
            {
                "id": "CWE-200",
                "value": "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor"
            }
        ]
    }
}