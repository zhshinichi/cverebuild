{
    "CVE-2024-50349": {
        "published_date": "2025-01-14T18:43:42.620Z",
        "patch_commits": [
            {
                "url": "https://github.com/git/git/commit/7725b8100ffbbff2750ee4d61a0fcc1f53a086e8",
                "content": "credential: sanitize the user prompt\n\nWhen asking the user interactively for credentials, we want to avoid\nmisleading them e.g. via control sequences that pretend that the URL\ntargets a trusted host when it does not.\n\nWhile Git learned, over the course of the preceding commits, to disallow\nURLs containing URL-encoded control characters by default, credential\nhelpers are still allowed to specify values very freely (apart from Line\nFeed and NUL characters, anything is allowed), and this would allow,\nsay, a username containing control characters to be specified that would\nthen be displayed in the interactive terminal prompt asking the user for\nthe password, potentially sending those control characters directly to\nthe terminal. This is undesirable because control characters can be used\nto mislead users to divulge secret information to untrusted sites.\n\nTo prevent such an attack vector, let's add a `git_prompt()` that forces\nthe displayed text to be sanitized, i.e. displaying question marks\ninstead of control characters.\n\nNote: While this commit's diff changes a lot of `user@host` strings to\n`user%40host`, which may look suspicious on the surface, there is a good\nreason for that: this string specifies a user name, not a\n<username>@<hostname> combination! In the context of t5541, the actual\ncombination looks like this: `user%40@127.0.0.1:5541`. Therefore, these\nstring replacements document a net improvement introduced by this\ncommit, as `user@host@127.0.0.1` could have left readers wondering where\nthe user name ends and where the host name begins.\n\nHinted-at-by: Jeff King <peff@peff.net>\nSigned-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>\n\nFilename: Documentation/config/credential.txt:\n```\n@@ -14,6 +14,12 @@\ncredential.useHttpPath::\n \tor https URL to be important. Defaults to false. See\n \tlinkgit:gitcredentials[7] for more information.\n \n+credential.sanitizePrompt::\n+\tBy default, user names and hosts that are shown as part of the\n+\tpassword prompt are not allowed to contain control characters (they\n+\twill be URL-encoded by default). Configure this setting to `false` to\n+\toverride that behavior.\n+\n credential.username::\n \tIf no username is set for a network authentication, use this username\n \tby default. See credential.<context>.* below, and\n```\n\nFilename: credential.c:\n```\n@@ -67,6 +67,8 @@\nstatic int credential_config_callback(const char *var, const char *value,\n \t}\n \telse if (!strcmp(key, \"usehttppath\"))\n \t\tc->use_http_path = git_config_bool(var, value);\n+\telse if (!strcmp(key, \"sanitizeprompt\"))\n+\t\tc->sanitize_prompt = git_config_bool(var, value);\n \n \treturn 0;\n }\n\n@@ -179,7 +181,10 @@\nstatic char *credential_ask_one(const char *what, struct credential *c,\n \tstruct strbuf prompt = STRBUF_INIT;\n \tchar *r;\n \n-\tcredential_describe(c, &desc);\n+\tif (c->sanitize_prompt)\n+\t\tcredential_format(c, &desc);\n+\telse\n+\t\tcredential_describe(c, &desc);\n \tif (desc.len)\n \t\tstrbuf_addf(&prompt, \"%s for '%s': \", what, desc.buf);\n \telse\n```\n\nFilename: credential.h:\n```\n@@ -119,7 +119,8 @@\nstruct credential {\n \t\t configured:1,\n \t\t quit:1,\n \t\t use_http_path:1,\n-\t\t username_from_proto:1;\n+\t\t username_from_proto:1,\n+\t\t sanitize_prompt:1;\n \n \tchar *username;\n \tchar *password;\n\n@@ -132,6 +133,7 @@\nstruct credential {\n #define CREDENTIAL_INIT { \\\n \t.helpers = STRING_LIST_INIT_DUP, \\\n \t.password_expiry_utc = TIME_MAX, \\\n+\t.sanitize_prompt = 1, \\\n }\n \n /* Initialize a credential structure, setting all fields to empty. */\n```\n\nFilename: t/t0300-credentials.sh:\n```\n@@ -45,6 +45,10 @@\ntest_expect_success 'setup helper scripts' '\n \ttest -z \"$pexpiry\" || echo password_expiry_utc=$pexpiry\n \tEOF\n \n+\twrite_script git-credential-cntrl-in-username <<-\\EOF &&\n+\tprintf \"username=\\\\007latrix Lestrange\\\\n\"\n+\tEOF\n+\n \tPATH=\"$PWD:$PATH\"\n '\n\n@@ -825,4 +829,20 @@\ntest_expect_success 'credential config with partial URLs' '\n \ttest_i18ngrep \"skipping credential lookup for key\" stderr\n '\n \n+BEL=\"$(printf '\\007')\"\n+\n+test_expect_success 'interactive prompt is sanitized' '\n+\tcheck fill cntrl-in-username <<-EOF\n+\tprotocol=https\n+\thost=example.org\n+\t--\n+\tprotocol=https\n+\thost=example.org\n+\tusername=${BEL}latrix Lestrange\n+\tpassword=askpass-password\n+\t--\n+\taskpass: Password for ${SQ}https://%07latrix%20Lestrange@example.org${SQ}:\n+\tEOF\n+'\n+\n test_done\n```\n\nFilename: t/t5541-http-push-smart.sh:\n```\n@@ -351,7 +351,7 @@\ntest_expect_success 'push over smart http with auth' '\n \tgit push \"$HTTPD_URL\"/auth/smart/test_repo.git &&\n \tgit --git-dir=\"$HTTPD_DOCUMENT_ROOT_PATH/test_repo.git\" \\\n \t\tlog -1 --format=%s >actual &&\n-\texpect_askpass both user@host &&\n+\texpect_askpass both user%40host &&\n \ttest_cmp expect actual\n '\n\n@@ -363,7 +363,7 @@\ntest_expect_success 'push to auth-only-for-push repo' '\n \tgit push \"$HTTPD_URL\"/auth-push/smart/test_repo.git &&\n \tgit --git-dir=\"$HTTPD_DOCUMENT_ROOT_PATH/test_repo.git\" \\\n \t\tlog -1 --format=%s >actual &&\n-\texpect_askpass both user@host &&\n+\texpect_askpass both user%40host &&\n \ttest_cmp expect actual\n '\n\n@@ -393,7 +393,7 @@\ntest_expect_success 'push into half-auth-complete requires password' '\n \tgit push \"$HTTPD_URL/half-auth-complete/smart/half-auth.git\" &&\n \tgit --git-dir=\"$HTTPD_DOCUMENT_ROOT_PATH/half-auth.git\" \\\n \t\tlog -1 --format=%s >actual &&\n-\texpect_askpass both user@host &&\n+\texpect_askpass both user%40host &&\n \ttest_cmp expect actual\n '\n```\n\nFilename: t/t5550-http-fetch-dumb.sh:\n```\n@@ -90,13 +90,13 @@\ntest_expect_success 'http auth can use user/pass in URL' '\n test_expect_success 'http auth can use just user in URL' '\n \tset_askpass wrong pass@host &&\n \tgit clone \"$HTTPD_URL_USER/auth/dumb/repo.git\" clone-auth-pass &&\n-\texpect_askpass pass user@host\n+\texpect_askpass pass user%40host\n '\n \n test_expect_success 'http auth can request both user and pass' '\n \tset_askpass user@host pass@host &&\n \tgit clone \"$HTTPD_URL/auth/dumb/repo.git\" clone-auth-both &&\n-\texpect_askpass both user@host\n+\texpect_askpass both user%40host\n '\n \n test_expect_success 'http auth respects credential helper config' '\n\n@@ -114,14 +114,14 @@\ntest_expect_success 'http auth can get username from config' '\n \ttest_config_global \"credential.$HTTPD_URL.username\" user@host &&\n \tset_askpass wrong pass@host &&\n \tgit clone \"$HTTPD_URL/auth/dumb/repo.git\" clone-auth-user &&\n-\texpect_askpass pass user@host\n+\texpect_askpass pass user%40host\n '\n \n test_expect_success 'configured username does not override URL' '\n \ttest_config_global \"credential.$HTTPD_URL.username\" wrong &&\n \tset_askpass wrong pass@host &&\n \tgit clone \"$HTTPD_URL_USER/auth/dumb/repo.git\" clone-auth-user2 &&\n-\texpect_askpass pass user@host\n+\texpect_askpass pass user%40host\n '\n \n test_expect_success 'set up repo with http submodules' '\n\n@@ -142,7 +142,7 @@\ntest_expect_success 'cmdline credential config passes to submodule via clone' '\n \tset_askpass wrong pass@host &&\n \tgit -c \"credential.$HTTPD_URL.username=user@host\" \\\n \t\tclone --recursive super super-clone &&\n-\texpect_askpass pass user@host\n+\texpect_askpass pass user%40host\n '\n \n test_expect_success 'cmdline credential config passes submodule via fetch' '\n\n@@ -153,7 +153,7 @@\ntest_expect_success 'cmdline credential config passes submodule via fetch' '\n \tgit -C super-clone \\\n \t    -c \"credential.$HTTPD_URL.username=user@host\" \\\n \t    fetch --recurse-submodules &&\n-\texpect_askpass pass user@host\n+\texpect_askpass pass user%40host\n '\n \n test_expect_success 'cmdline credential config passes submodule update' '\n\n@@ -170,7 +170,7 @@\ntest_expect_success 'cmdline credential config passes submodule update' '\n \tgit -C super-clone \\\n \t    -c \"credential.$HTTPD_URL.username=user@host\" \\\n \t    submodule update &&\n-\texpect_askpass pass user@host\n+\texpect_askpass pass user%40host\n '\n \n test_expect_success 'fetch changes via http' '\n```\n\nFilename: t/t5551-http-fetch-smart.sh:\n```\n@@ -181,7 +181,7 @@\ntest_expect_success 'clone from password-protected repository' '\n \techo two >expect &&\n \tset_askpass user@host pass@host &&\n \tgit clone --bare \"$HTTPD_URL/auth/smart/repo.git\" smart-auth &&\n-\texpect_askpass both user@host &&\n+\texpect_askpass both user%40host &&\n \tgit --git-dir=smart-auth log -1 --format=%s >actual &&\n \ttest_cmp expect actual\n '\n\n@@ -199,7 +199,7 @@\ntest_expect_success 'clone from auth-only-for-objects repository' '\n \techo two >expect &&\n \tset_askpass user@host pass@host &&\n \tgit clone --bare \"$HTTPD_URL/auth-fetch/smart/repo.git\" half-auth &&\n-\texpect_askpass both user@host &&\n+\texpect_askpass both user%40host &&\n \tgit --git-dir=half-auth log -1 --format=%s >actual &&\n \ttest_cmp expect actual\n '\n\n@@ -224,14 +224,14 @@\ntest_expect_success 'redirects send auth to new location' '\n \tset_askpass user@host pass@host &&\n \tgit -c credential.useHttpPath=true \\\n \t  clone $HTTPD_URL/smart-redir-auth/repo.git repo-redir-auth &&\n-\texpect_askpass both user@host auth/smart/repo.git\n+\texpect_askpass both user%40host auth/smart/repo.git\n '\n \n test_expect_success 'GIT_TRACE_CURL redacts auth details' '\n \trm -rf redact-auth trace &&\n \tset_askpass user@host pass@host &&\n \tGIT_TRACE_CURL=\"$(pwd)/trace\" git clone --bare \"$HTTPD_URL/auth/smart/repo.git\" redact-auth &&\n-\texpect_askpass both user@host &&\n+\texpect_askpass both user%40host &&\n \n \t# Ensure that there is no \"Basic\" followed by a base64 string, but that\n \t# the auth details are redacted\n\n@@ -243,7 +243,7 @@\ntest_expect_success 'GIT_CURL_VERBOSE redacts auth details' '\n \trm -rf redact-auth trace &&\n \tset_askpass user@host pass@host &&\n \tGIT_CURL_VERBOSE=1 git clone --bare \"$HTTPD_URL/auth/smart/repo.git\" redact-auth 2>trace &&\n-\texpect_askpass both user@host &&\n+\texpect_askpass both user%40host &&\n \n \t# Ensure that there is no \"Basic\" followed by a base64 string, but that\n \t# the auth details are redacted\n\n@@ -256,7 +256,7 @@\ntest_expect_success 'GIT_TRACE_CURL does not redact auth details if GIT_TRACE_RE\n \tset_askpass user@host pass@host &&\n \tGIT_TRACE_REDACT=0 GIT_TRACE_CURL=\"$(pwd)/trace\" \\\n \t\tgit clone --bare \"$HTTPD_URL/auth/smart/repo.git\" redact-auth &&\n-\texpect_askpass both user@host &&\n+\texpect_askpass both user%40host &&\n \n \tgrep -i \"Authorization: Basic [0-9a-zA-Z+/]\" trace\n '\n\n@@ -568,7 +568,7 @@\ntest_expect_success 'http auth remembers successful credentials' '\n \t# the first request prompts the user...\n \tset_askpass user@host pass@host &&\n \tgit ls-remote \"$HTTPD_URL/auth/smart/repo.git\" >/dev/null &&\n-\texpect_askpass both user@host &&\n+\texpect_askpass both user%40host &&\n \n \t# ...and the second one uses the stored value rather than\n \t# prompting the user.\n\n@@ -599,7 +599,7 @@\ntest_expect_success 'http auth forgets bogus credentials' '\n \t# us to prompt the user again.\n \tset_askpass user@host pass@host &&\n \tgit ls-remote \"$HTTPD_URL/auth/smart/repo.git\" >/dev/null &&\n-\texpect_askpass both user@host\n+\texpect_askpass both user%40host\n '\n \n test_expect_success 'client falls back from v2 to v0 to match server' '\n```"
            },
            {
                "url": "https://github.com/git/git/commit/c903985bf7e772e2d08275c1a95c8a55ab011577",
                "content": "credential_format(): also encode <host>[:<port>]\n\nAn upcoming change wants to sanitize the credential password prompt\nwhere a URL is displayed that may potentially come from a `.gitmodules`\nfile. To this end, the `credential_format()` function is employed.\n\nTo sanitize the host name (and optional port) part of the URL, we need a\nnew mode of the `strbuf_add_percentencode()` function because the\ncurrent mode is both too strict and too lenient: too strict because it\nencodes `:`, `[` and `]` (which should be left unencoded in\n`<host>:<port>` and in IPv6 addresses), and too lenient because it does\nnot encode invalid host name characters `/`, `_` and `~`.\n\nSo let's introduce and use a new mode specifically to encode the host\nname and optional port part of a URI, leaving alpha-numerical\ncharacters, periods, colons and brackets alone and encoding all others.\n\nThis only leads to a change of behavior for URLs that contain invalid\nhost names.\n\nSigned-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>\n\nFilename: credential.c:\n```\n@@ -164,7 +164,8 @@\nstatic void credential_format(struct credential *c, struct strbuf *out)\n \t\tstrbuf_addch(out, '@');\n \t}\n \tif (c->host)\n-\t\tstrbuf_addstr(out, c->host);\n+\t\tstrbuf_add_percentencode(out, c->host,\n+\t\t\t\t\t STRBUF_ENCODE_HOST_AND_PORT);\n \tif (c->path) {\n \t\tstrbuf_addch(out, '/');\n \t\tstrbuf_add_percentencode(out, c->path, 0);\n```\n\nFilename: strbuf.c:\n```\n@@ -492,7 +492,9 @@\nvoid strbuf_add_percentencode(struct strbuf *dst, const char *src, int flags)\n \t\tunsigned char ch = src[i];\n \t\tif (ch <= 0x1F || ch >= 0x7F ||\n \t\t    (ch == '/' && (flags & STRBUF_ENCODE_SLASH)) ||\n-\t\t    strchr(URL_UNSAFE_CHARS, ch))\n+\t\t    ((flags & STRBUF_ENCODE_HOST_AND_PORT) ?\n+\t\t     !isalnum(ch) && !strchr(\"-.:[]\", ch) :\n+\t\t     !!strchr(URL_UNSAFE_CHARS, ch)))\n \t\t\tstrbuf_addf(dst, \"%%%02X\", (unsigned char)ch);\n \t\telse\n \t\t\tstrbuf_addch(dst, ch);\n```\n\nFilename: strbuf.h:\n```\n@@ -380,6 +380,7 @@\nsize_t strbuf_expand_dict_cb(struct strbuf *sb,\n void strbuf_addbuf_percentquote(struct strbuf *dst, const struct strbuf *src);\n \n #define STRBUF_ENCODE_SLASH 1\n+#define STRBUF_ENCODE_HOST_AND_PORT 2\n \n /**\n  * Append the contents of a string to a strbuf, percent-encoding any characters\n```\n\nFilename: t/t0300-credentials.sh:\n```\n@@ -514,6 +514,19 @@\ntest_expect_success 'match percent-encoded values in username' '\n \tEOF\n '\n \n+test_expect_success 'match percent-encoded values in hostname' '\n+\ttest_config \"credential.https://a%20b%20c/.helper\" \"$HELPER\" &&\n+\tcheck fill <<-\\EOF\n+\turl=https://a b c/\n+\t--\n+\tprotocol=https\n+\thost=a b c\n+\tusername=foo\n+\tpassword=bar\n+\t--\n+\tEOF\n+'\n+\n test_expect_success 'fetch with multiple path components' '\n \ttest_unconfig credential.helper &&\n \ttest_config credential.https://example.com/foo/repo.git.helper \"verbatim foo bar\" &&\n```"
            }
        ],
        "sw_version": "v2.40.3",
        "sw_version_wget": "https://github.com/git/git/archive/refs/tags/v2.40.3.zip",
        "description": "Git is a fast, scalable, distributed revision control system with an unusually rich command set that provides both high-level operations and full access to internals. When Git asks for credentials via a terminal prompt (i.e. without using any credential helper), it prints out the host name for which the user is expected to provide a username and/or a password. At this stage, any URL-encoded parts have been decoded already, and are printed verbatim. This allows attackers to craft URLs that contain ANSI escape sequences that the terminal interpret to confuse users e.g. into providing passwords for trusted Git hosting sites when in fact they are then sent to untrusted sites that are under the attacker's control. This issue has been patch via commits `7725b81` and `c903985` which are included in release versions v2.48.1, v2.47.2, v2.46.3, v2.45.3, v2.44.3, v2.43.6, v2.42.4, v2.41.3, and v2.40.4. Users are advised to upgrade. Users unable to upgrade should avoid cloning from untrusted URLs, especially recursive clones.",
        "sec_adv": [
            {
                "url": "https://github.com/git/git/security/advisories/GHSA-hmg8-h7qf-7cxr",
                "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\ngit\n/\ngit\nPublic\nNotifications You must be signed in to change notification settings\nFork 26.2k\nStar 54.8k\nCode\nPull requests\n228\nActions\nSecurity\n29\nInsights\nAdditional navigation options\nGit does not neutralize control sequences in account names when asking for credentials interactively\nLow dscho published GHSA-hmg8-h7qf-7cxr on Jan 14Jan 14, 2025\nPackage\ngit\nAffected versions\nv2.48.0 <=v2.47.1 <=v2.46.2 <=v2.45.2 <=v2.44.2 <=v2.43.5 <=v2.42.3 <=v2.41.2 <=v2.40.3\nPatched versions\nv2.48.1 v2.47.2 v2.46.3 v2.45.3 v2.44.3 v2.43.6 v2.42.4 v2.41.3 v2.40.4\nDescription\nImpact\nWhen Git asks for credentials via a terminal prompt (i.e. without using any credential helper), it prints out the host name for which the user is expected to provide a username and/or a password. At this stage, any URL-encoded parts have been decoded already, and are printed verbatim. This allows attackers to craft URLs that contain ANSI escape sequences that the terminal interpret to confuse users e.g. into providing passwords for trusted Git hosting sites when in fact they are then sent to untrusted sites that are under the attacker's control.\nPatches\n7725b81\nc903985\nWorkarounds\nAvoid cloning from untrusted URLs, especially recursive clones.\nSeverity\nLow\n2.1\n/ 10\nCVSS v4 base metrics\nExploitability Metrics\nAttack Vector\nNetwork\nAttack Complexity\nHigh\nAttack Requirements\nPresent\nPrivileges Required\nNone\nUser interaction\nActive\nVulnerable System Impact Metrics\nConfidentiality\nNone\nIntegrity\nLow\nAvailability\nNone\nSubsequent System Impact Metrics\nConfidentiality\nLow\nIntegrity\nLow\nAvailability\nNone\nLearn more about base metrics\nCVSS:4.0/AV:N/AC:H/AT:P/PR:N/UI:A/VC:N/VI:L/VA:N/SC:L/SI:L/SA:N\nCVE ID\nCVE-2024-50349\nWeaknesses\nCWE-116 CWE-147 CWE-150\nCredits\ndscho\nRemediation developer\nFooter\nÂ© 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
                "effective": false,
                "effective_reason": "The advisory does not describe a proof of concept or specific steps to reproduce the vulnerability."
            }
        ],
        "cwe": [
            {
                "id": "CWE-116",
                "value": "CWE-116: Improper Encoding or Escaping of Output"
            },
            {
                "id": "CWE-147",
                "value": "CWE-147: Improper Neutralization of Input Terminators"
            },
            {
                "id": "CWE-150",
                "value": "CWE-150: Improper Neutralization of Escape, Meta, or Control Sequences"
            }
        ]
    }
}