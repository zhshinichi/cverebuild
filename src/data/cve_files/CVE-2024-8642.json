{
    "CVE-2024-8642": {
        "published_date": "2024-09-11T13:34:28.463Z",
        "patch_commits": [
            {
                "url": "https://github.com/eclipse-edc/Connector/commit/04899e91dcdb4a407db4eb7af3e7b6ff9a9e9ad6",
                "content": "refactor: cleanup deprecated stuff (#4451)\n\nFilename: DEPENDENCIES:\n```\n@@ -59,7 +59,7 @@\nmaven/mavencentral/com.github.stephenc.jcip/jcip-annotations/1.0-1, Apache-2.0,\n maven/mavencentral/com.google.code.findbugs/jsr305/2.0.1, BSD-3-Clause AND CC-BY-2.5 AND LGPL-2.1+, approved, CQ13390\n maven/mavencentral/com.google.code.findbugs/jsr305/3.0.2, CC-BY-2.5, approved, #15220\n maven/mavencentral/com.google.code.gson/gson/2.10.1, Apache-2.0, approved, #6159\n-maven/mavencentral/com.google.crypto.tink/tink/1.15.0, , restricted, clearlydefined\n+maven/mavencentral/com.google.crypto.tink/tink/1.15.0, Apache-2.0, approved, clearlydefined\n maven/mavencentral/com.google.errorprone/error_prone_annotations/2.11.0, Apache-2.0, approved, clearlydefined\n maven/mavencentral/com.google.errorprone/error_prone_annotations/2.22.0, Apache-2.0, approved, #10661\n maven/mavencentral/com.google.errorprone/error_prone_annotations/2.28.0, Apache-2.0, approved, #15107\n\n@@ -82,7 +82,7 @@\nmaven/mavencentral/com.lmax/disruptor/3.4.4, Apache-2.0, approved, clearlydefine\n maven/mavencentral/com.networknt/json-schema-validator/1.0.76, Apache-2.0, approved, CQ22638\n maven/mavencentral/com.nimbusds/nimbus-jose-jwt/9.28, Apache-2.0, approved, clearlydefined\n maven/mavencentral/com.nimbusds/nimbus-jose-jwt/9.40, Apache-2.0, approved, #15156\n-maven/mavencentral/com.puppycrawl.tools/checkstyle/10.18.1, LGPL-2.1-or-later, restricted, clearlydefined\n+maven/mavencentral/com.puppycrawl.tools/checkstyle/10.18.1, LGPL-2.1-or-later AND (Apache-2.0 AND LGPL-2.1-or-later) AND Apache-2.0, approved, #16060\n maven/mavencentral/com.samskivert/jmustache/1.15, BSD-2-Clause AND BSD-3-Clause, approved, clearlydefined\n maven/mavencentral/com.squareup.okhttp3/okhttp-dnsoverhttps/4.12.0, Apache-2.0, approved, #11159\n maven/mavencentral/com.squareup.okhttp3/okhttp/4.12.0, Apache-2.0, approved, #15227\n\n@@ -195,7 +195,7 @@\nmaven/mavencentral/net.javacrumbs.json-unit/json-unit-core/2.36.0, Apache-2.0, a\n maven/mavencentral/net.minidev/accessors-smart/2.4.7, Apache-2.0, approved, #7515\n maven/mavencentral/net.minidev/json-smart/2.4.7, Apache-2.0, approved, #3288\n maven/mavencentral/net.sf.jopt-simple/jopt-simple/5.0.4, MIT, approved, CQ13174\n-maven/mavencentral/net.sf.saxon/Saxon-HE/12.5, NOASSERTION, restricted, clearlydefined\n+maven/mavencentral/net.sf.saxon/Saxon-HE/12.5, MPL-2.0-no-copyleft-exception AND (LicenseRef-scancode-proprietary-license AND MPL-2.0-no-copyleft-exception) AND (MPL-2.0-no-copyleft-exception AND X11) AND (MIT AND MPL-2.0-no-copyleft-exception) AND (MPL-1.0 AND MPL-2.0-no-copyleft-exception) AND (Apache-2.0 AND MPL-2.0-no-copyleft-exception) AND MPL-1.0, restricted, #16061\n maven/mavencentral/org.antlr/antlr4-runtime/4.13.2, BSD-3-Clause, approved, #10767\n maven/mavencentral/org.apache.commons/commons-compress/1.24.0, Apache-2.0 AND BSD-3-Clause AND bzip2-1.0.6 AND LicenseRef-Public-Domain, approved, #10368\n maven/mavencentral/org.apache.commons/commons-digester3/3.2, Apache-2.0, approved, clearlydefined\n\n@@ -219,7 +219,7 @@\nmaven/mavencentral/org.apache.httpcomponents/httpclient/4.5.13, Apache-2.0, appr\n maven/mavencentral/org.apache.httpcomponents/httpcore/4.4.13, Apache-2.0, approved, CQ23528\n maven/mavencentral/org.apache.httpcomponents/httpcore/4.4.14, Apache-2.0, approved, CQ23528\n maven/mavencentral/org.apache.httpcomponents/httpmime/4.5.13, Apache-2.0, approved, CQ11718\n-maven/mavencentral/org.apache.kafka/kafka-clients/3.8.0, Apache-2.0, restricted, clearlydefined\n+maven/mavencentral/org.apache.kafka/kafka-clients/3.8.0, Apache-2.0 AND (Apache-2.0 AND MIT) AND (Apache-2.0 AND BSD-3-Clause), approved, #16063\n maven/mavencentral/org.apache.maven.doxia/doxia-core/1.12.0, Apache-2.0, approved, clearlydefined\n maven/mavencentral/org.apache.maven.doxia/doxia-logging-api/1.12.0, Apache-2.0, approved, clearlydefined\n maven/mavencentral/org.apache.maven.doxia/doxia-module-xdoc/1.12.0, Apache-2.0, approved, clearlydefined\n\n@@ -309,7 +309,7 @@\nmaven/mavencentral/org.junit.jupiter/junit-jupiter-params/5.11.0, EPL-2.0, appro\n maven/mavencentral/org.junit.platform/junit-platform-commons/1.11.0, EPL-2.0, approved, #15936\n maven/mavencentral/org.junit.platform/junit-platform-engine/1.11.0, EPL-2.0, approved, #15932\n maven/mavencentral/org.junit.platform/junit-platform-launcher/1.11.0, EPL-2.0, approved, #15934\n-maven/mavencentral/org.junit/junit-bom/5.11.0, , restricted, clearlydefined\n+maven/mavencentral/org.junit/junit-bom/5.11.0, EPL-2.0, approved, #16062\n maven/mavencentral/org.junit/junit-bom/5.9.2, EPL-2.0, approved, #4711\n maven/mavencentral/org.jvnet.mimepull/mimepull/1.9.15, CDDL-1.1 OR GPL-2.0-only WITH Classpath-exception-2.0, approved, CQ21484\n maven/mavencentral/org.latencyutils/LatencyUtils/2.0.3, CC0-1.0, approved, #15280\n```\n\nFilename: core/control-plane/control-plane-aggregate-services/src/main/java/org/eclipse/edc/connector/controlplane/services/catalog/CatalogProtocolServiceImpl.java:\n```\n@@ -28,16 +28,12 @@\nimport org.jetbrains.annotations.NotNull;\n \n import static java.lang.String.format;\n-import static org.eclipse.edc.spi.constants.CoreConstants.EDC_NAMESPACE;\n \n public class CatalogProtocolServiceImpl implements CatalogProtocolService {\n \n     @PolicyScope\n     public static final String CATALOGING_REQUEST_SCOPE = \"request.catalog\";\n \n-    @Deprecated(since = \"0.5.1\")\n-    private static final String EDC_PROPERTY_PARTICIPANT_ID = EDC_NAMESPACE + \"participantId\";\n-\n     private final DatasetResolver datasetResolver;\n     private final DataServiceRegistry dataServiceRegistry;\n     private final String participantId;\n\n@@ -69,7 +65,6 @@\npublic ServiceResult<Catalog> getCatalog(CatalogRequestMessage message, TokenRep\n                                 .dataServices(dataServices)\n                                 .datasets(datasets.toList())\n                                 .participantId(participantId)\n-                                .property(EDC_PROPERTY_PARTICIPANT_ID, participantId)\n                                 .build();\n                     }\n                 })\n```\n\nFilename: data-protocols/dsp/dsp-catalog/dsp-catalog-transform/src/main/java/org/eclipse/edc/protocol/dsp/catalog/transform/from/JsonObjectFromDataServiceTransformer.java:\n```\n@@ -27,8 +27,6 @@\nimport static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.DCAT_DATA_SERVICE_TYPE;\n import static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.DCAT_ENDPOINT_DESCRIPTION_ATTRIBUTE;\n import static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.DCAT_ENDPOINT_URL_ATTRIBUTE;\n-import static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.DCT_ENDPOINT_URL_ATTRIBUTE;\n-import static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.DCT_TERMS_ATTRIBUTE;\n \n /**\n  * Converts from a {@link DataService} to a DCAT data service as a {@link JsonObject} in JSON-LD expanded form.\n\n@@ -51,10 +49,6 @@\npublic JsonObjectFromDataServiceTransformer(JsonBuilderFactory jsonFactory) {\n         addIfNotNull(dataService.getEndpointDescription(), DCAT_ENDPOINT_DESCRIPTION_ATTRIBUTE, objectBuilder);\n         addIfNotNull(dataService.getEndpointUrl(), DCAT_ENDPOINT_URL_ATTRIBUTE, objectBuilder);\n \n-        // deprecated attributes, to be removed\n-        addIfNotNull(dataService.getEndpointDescription(), DCT_TERMS_ATTRIBUTE, objectBuilder);\n-        addIfNotNull(dataService.getEndpointUrl(), DCT_ENDPOINT_URL_ATTRIBUTE, objectBuilder);\n-\n         return objectBuilder.build();\n     }\n```\n\nFilename: data-protocols/dsp/dsp-catalog/dsp-catalog-transform/src/test/java/org/eclipse/edc/protocol/dsp/catalog/transform/from/JsonObjectFromDataServiceTransformerTest.java:\n```\n@@ -29,8 +29,6 @@\nimport static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.DCAT_DATA_SERVICE_TYPE;\n import static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.DCAT_ENDPOINT_DESCRIPTION_ATTRIBUTE;\n import static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.DCAT_ENDPOINT_URL_ATTRIBUTE;\n-import static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.DCT_ENDPOINT_URL_ATTRIBUTE;\n-import static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.DCT_TERMS_ATTRIBUTE;\n import static org.mockito.Mockito.mock;\n \n class JsonObjectFromDataServiceTransformerTest {\n\n@@ -62,21 +60,4 @@\nvoid transform_returnJsonObject() {\n         assertThat(result.getJsonString(DCAT_ENDPOINT_URL_ATTRIBUTE).getString()).isEqualTo(\"url\");\n     }\n \n-    @Deprecated\n-    @Test\n-    void deprecated_attributes() {\n-        var dataService = DataService.Builder.newInstance()\n-                .id(\"dataServiceId\")\n-                .endpointDescription(\"description\")\n-                .endpointUrl(\"url\")\n-                .build();\n-\n-        var result = transformer.transform(dataService, context);\n-\n-        assertThat(result).isNotNull();\n-        assertThat(result.getJsonString(ID).getString()).isEqualTo(dataService.getId());\n-        assertThat(result.getJsonString(TYPE).getString()).isEqualTo(DCAT_DATA_SERVICE_TYPE);\n-        assertThat(result.getJsonString(DCT_TERMS_ATTRIBUTE).getString()).isEqualTo(\"description\");\n-        assertThat(result.getJsonString(DCT_ENDPOINT_URL_ATTRIBUTE).getString()).isEqualTo(\"url\");\n-    }\n }\n```\n\nFilename: data-protocols/dsp/dsp-negotiation/dsp-negotiation-transform/src/main/java/org/eclipse/edc/protocol/dsp/negotiation/transform/from/JsonObjectFromContractAgreementMessageTransformer.java:\n```\n@@ -29,12 +29,9 @@\nimport static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.ODRL_ASSIGNEE_ATTRIBUTE;\n import static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.ODRL_ASSIGNER_ATTRIBUTE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_PROPERTY_AGREEMENT;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_ID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_PROPERTY_TIMESTAMP;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_TYPE_CONTRACT_AGREEMENT_MESSAGE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_PID;\n\n@@ -70,8 +67,6 @@\npublic JsonObjectFromContractAgreementMessageTransformer(JsonBuilderFactory json\n                 .add(ID, agreement.getId())\n                 .add(ODRL_ASSIGNEE_ATTRIBUTE, agreement.getConsumerId())\n                 .add(ODRL_ASSIGNER_ATTRIBUTE, agreement.getProviderId())\n-                .add(DSPACE_PROPERTY_CONSUMER_ID, agreement.getConsumerId())\n-                .add(DSPACE_PROPERTY_PROVIDER_ID, agreement.getProviderId())\n                 .add(DSPACE_PROPERTY_TIMESTAMP, signing)\n                 .build();\n\n@@ -80,7 +75,6 @@\npublic JsonObjectFromContractAgreementMessageTransformer(JsonBuilderFactory json\n                 .add(TYPE, DSPACE_TYPE_CONTRACT_AGREEMENT_MESSAGE)\n                 .add(DSPACE_PROPERTY_PROVIDER_PID, agreementMessage.getProviderPid())\n                 .add(DSPACE_PROPERTY_CONSUMER_PID, agreementMessage.getConsumerPid())\n-                .add(DSPACE_PROPERTY_PROCESS_ID, agreementMessage.getProcessId())\n                 .add(DSPACE_PROPERTY_AGREEMENT, copiedPolicy)\n                 .build();\n     }\n```\n\nFilename: data-protocols/dsp/dsp-negotiation/dsp-negotiation-transform/src/main/java/org/eclipse/edc/protocol/dsp/negotiation/transform/from/JsonObjectFromContractAgreementVerificationMessageTransformer.java:\n```\n@@ -26,7 +26,6 @@\nimport static org.eclipse.edc.jsonld.spi.JsonLdKeywords.TYPE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_TYPE_CONTRACT_AGREEMENT_VERIFICATION_MESSAGE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_PID;\n \n /**\n\n@@ -48,7 +47,6 @@\npublic JsonObjectFromContractAgreementVerificationMessageTransformer(JsonBuilder\n                 .add(TYPE, DSPACE_TYPE_CONTRACT_AGREEMENT_VERIFICATION_MESSAGE)\n                 .add(DSPACE_PROPERTY_CONSUMER_PID, verificationMessage.getConsumerPid())\n                 .add(DSPACE_PROPERTY_PROVIDER_PID, verificationMessage.getProviderPid())\n-                .add(DSPACE_PROPERTY_PROCESS_ID, verificationMessage.getProcessId())\n                 .build();\n     }\n }\n```\n\nFilename: data-protocols/dsp/dsp-negotiation/dsp-negotiation-transform/src/main/java/org/eclipse/edc/protocol/dsp/negotiation/transform/from/JsonObjectFromContractNegotiationEventMessageTransformer.java:\n```\n@@ -29,7 +29,6 @@\nimport static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_VALUE_NEGOTIATION_EVENT_TYPE_ACCEPTED;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_VALUE_NEGOTIATION_EVENT_TYPE_FINALIZED;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_PID;\n\n@@ -52,7 +51,6 @@\npublic JsonObjectFromContractNegotiationEventMessageTransformer(JsonBuilderFacto\n                 .add(TYPE, DSPACE_TYPE_CONTRACT_NEGOTIATION_EVENT_MESSAGE)\n                 .add(DSPACE_PROPERTY_CONSUMER_PID, eventMessage.getConsumerPid())\n                 .add(DSPACE_PROPERTY_PROVIDER_PID, eventMessage.getProviderPid())\n-                .add(DSPACE_PROPERTY_PROCESS_ID, eventMessage.getProcessId())\n                 .add(DSPACE_PROPERTY_EVENT_TYPE, switch (eventMessage.getType()) {\n                     case ACCEPTED -> DSPACE_VALUE_NEGOTIATION_EVENT_TYPE_ACCEPTED;\n                     case FINALIZED -> DSPACE_VALUE_NEGOTIATION_EVENT_TYPE_FINALIZED;\n```\n\nFilename: data-protocols/dsp/dsp-negotiation/dsp-negotiation-transform/src/main/java/org/eclipse/edc/protocol/dsp/negotiation/transform/from/JsonObjectFromContractNegotiationTerminationMessageTransformer.java:\n```\n@@ -27,7 +27,6 @@\nimport static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_TYPE_CONTRACT_NEGOTIATION_TERMINATION_MESSAGE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CODE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_PID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_REASON;\n\n@@ -49,8 +48,7 @@\npublic JsonObjectFromContractNegotiationTerminationMessageTransformer(JsonBuilde\n                 .add(ID, terminationMessage.getId())\n                 .add(TYPE, DSPACE_TYPE_CONTRACT_NEGOTIATION_TERMINATION_MESSAGE)\n                 .add(DSPACE_PROPERTY_CONSUMER_PID, terminationMessage.getConsumerPid())\n-                .add(DSPACE_PROPERTY_PROVIDER_PID, terminationMessage.getProviderPid())\n-                .add(DSPACE_PROPERTY_PROCESS_ID, terminationMessage.getProcessId());\n+                .add(DSPACE_PROPERTY_PROVIDER_PID, terminationMessage.getProviderPid());\n \n         addIfNotNull(terminationMessage.getRejectionReason(), DSPACE_PROPERTY_REASON, builder);\n         addIfNotNull(terminationMessage.getCode(), DSPACE_PROPERTY_CODE, builder);\n```\n\nFilename: data-protocols/dsp/dsp-negotiation/dsp-negotiation-transform/src/main/java/org/eclipse/edc/protocol/dsp/negotiation/transform/from/JsonObjectFromContractNegotiationTransformer.java:\n```\n@@ -34,7 +34,6 @@\nimport static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_VALUE_NEGOTIATION_STATE_TERMINATED;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_VALUE_NEGOTIATION_STATE_VERIFIED;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_PID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_STATE;\n\n@@ -58,7 +57,6 @@\npublic JsonObjectFromContractNegotiationTransformer(JsonBuilderFactory jsonFacto\n                 .add(TYPE, DSPACE_TYPE_CONTRACT_NEGOTIATION)\n                 .add(DSPACE_PROPERTY_CONSUMER_PID, pidFor(contractNegotiation, ContractNegotiation.Type.CONSUMER))\n                 .add(DSPACE_PROPERTY_PROVIDER_PID, pidFor(contractNegotiation, ContractNegotiation.Type.PROVIDER))\n-                .add(DSPACE_PROPERTY_PROCESS_ID, pidFor(contractNegotiation, ContractNegotiation.Type.CONSUMER))\n                 .add(DSPACE_PROPERTY_STATE, state(contractNegotiation.getState(), context))\n                 .build();\n     }\n```\n\nFilename: data-protocols/dsp/dsp-negotiation/dsp-negotiation-transform/src/main/java/org/eclipse/edc/protocol/dsp/negotiation/transform/from/JsonObjectFromContractOfferMessageTransformer.java:\n```\n@@ -29,7 +29,6 @@\nimport static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_TYPE_CONTRACT_OFFER_MESSAGE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CALLBACK_ADDRESS;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_PID;\n \n /**\n\n@@ -49,8 +48,7 @@\npublic JsonObjectFromContractOfferMessageTransformer(JsonBuilderFactory jsonFact\n         var builder = jsonFactory.createObjectBuilder()\n                 .add(ID, message.getId())\n                 .add(TYPE, DSPACE_TYPE_CONTRACT_OFFER_MESSAGE)\n-                .add(DSPACE_PROPERTY_PROVIDER_PID, message.getProviderPid())\n-                .add(DSPACE_PROPERTY_PROCESS_ID, message.getProcessId());\n+                .add(DSPACE_PROPERTY_PROVIDER_PID, message.getProviderPid());\n \n         addIfNotNull(message.getConsumerPid(), DSPACE_PROPERTY_CONSUMER_PID, builder);\n         addIfNotNull(message.getCallbackAddress(), DSPACE_PROPERTY_CALLBACK_ADDRESS, builder);\n```\n\nFilename: data-protocols/dsp/dsp-negotiation/dsp-negotiation-transform/src/main/java/org/eclipse/edc/protocol/dsp/negotiation/transform/from/JsonObjectFromContractRequestMessageTransformer.java:\n```\n@@ -29,7 +29,6 @@\nimport static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_TYPE_CONTRACT_REQUEST_MESSAGE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CALLBACK_ADDRESS;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_PID;\n\n@@ -50,8 +49,7 @@\npublic JsonObjectFromContractRequestMessageTransformer(JsonBuilderFactory jsonFa\n         var builder = jsonFactory.createObjectBuilder()\n                 .add(ID, requestMessage.getId())\n                 .add(TYPE, DSPACE_TYPE_CONTRACT_REQUEST_MESSAGE)\n-                .add(DSPACE_PROPERTY_CONSUMER_PID, requestMessage.getConsumerPid())\n-                .add(DSPACE_PROPERTY_PROCESS_ID, requestMessage.getProcessId());\n+                .add(DSPACE_PROPERTY_CONSUMER_PID, requestMessage.getConsumerPid());\n \n         addIfNotNull(requestMessage.getProviderPid(), DSPACE_PROPERTY_PROVIDER_PID, builder);\n         addIfNotNull(requestMessage.getCallbackAddress(), DSPACE_PROPERTY_CALLBACK_ADDRESS, builder);\n```\n\nFilename: data-protocols/dsp/dsp-negotiation/dsp-negotiation-transform/src/main/java/org/eclipse/edc/protocol/dsp/negotiation/transform/to/JsonObjectToContractAgreementMessageTransformer.java:\n```\n@@ -41,8 +41,7 @@\n* Creates a {@link ContractAgreementMessage} from a {@link JsonObject}.\n  */\n public class JsonObjectToContractAgreementMessageTransformer extends AbstractJsonLdTransformer<JsonObject, ContractAgreementMessage> {\n-    private static final Set<String> EXCLUDED_POLICY_KEYWORDS =\n-            Set.of(DSPACE_PROPERTY_CONSUMER_ID, DSPACE_PROPERTY_PROVIDER_ID, DSPACE_PROPERTY_TIMESTAMP);\n+    private static final Set<String> EXCLUDED_POLICY_KEYWORDS = Set.of(DSPACE_PROPERTY_TIMESTAMP, DSPACE_PROPERTY_CONSUMER_ID, DSPACE_PROPERTY_PROVIDER_ID);\n \n     public JsonObjectToContractAgreementMessageTransformer() {\n         super(JsonObject.class, ContractAgreementMessage.class);\n\n@@ -126,24 +125,6 @@\nprivate ContractAgreement contractAgreement(JsonObject jsonAgreement, Policy pol\n                 .policy(policy)\n                 .assetId(policy.getTarget());\n \n-        if (assignee == null && !transformMandatoryString(jsonAgreement.get(DSPACE_PROPERTY_CONSUMER_ID), builder::consumerId, context)) {\n-            context.problem()\n-                    .missingProperty()\n-                    .type(DSPACE_TYPE_CONTRACT_AGREEMENT_MESSAGE)\n-                    .property(DSPACE_PROPERTY_CONSUMER_ID)\n-                    .report();\n-            return null;\n-        }\n-\n-        if (assigner == null && !transformMandatoryString(jsonAgreement.get(DSPACE_PROPERTY_PROVIDER_ID), builder::providerId, context)) {\n-            context.problem()\n-                    .missingProperty()\n-                    .type(DSPACE_TYPE_CONTRACT_AGREEMENT_MESSAGE)\n-                    .property(DSPACE_PROPERTY_PROVIDER_ID)\n-                    .report();\n-            return null;\n-        }\n-\n         var timestamp = transformString(jsonAgreement.get(DSPACE_PROPERTY_TIMESTAMP), context);\n         if (timestamp == null) {\n             context.problem()\n```\n\nFilename: data-protocols/dsp/dsp-negotiation/dsp-negotiation-transform/src/main/java/org/eclipse/edc/protocol/dsp/negotiation/transform/to/JsonObjectToContractAgreementVerificationMessageTransformer.java:\n```\n@@ -23,7 +23,6 @@\nimport static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_TYPE_CONTRACT_AGREEMENT_VERIFICATION_MESSAGE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_PID;\n \n /**\n\n@@ -38,30 +37,21 @@\npublic JsonObjectToContractAgreementVerificationMessageTransformer() {\n     @Override\n     public @Nullable ContractAgreementVerificationMessage transform(@NotNull JsonObject object, @NotNull TransformerContext context) {\n         var builder = ContractAgreementVerificationMessage.Builder.newInstance();\n-        var processId = object.get(DSPACE_PROPERTY_PROCESS_ID);\n         if (!transformMandatoryString(object.get(DSPACE_PROPERTY_CONSUMER_PID), builder::consumerPid, context)) {\n-            if (processId == null) {\n-                context.problem()\n-                        .missingProperty()\n-                        .type(DSPACE_TYPE_CONTRACT_AGREEMENT_VERIFICATION_MESSAGE)\n-                        .property(DSPACE_PROPERTY_CONSUMER_PID)\n-                        .report();\n-                return null;\n-            } else {\n-                builder.consumerPid(transformString(processId, context));\n-            }\n+            context.problem()\n+                    .missingProperty()\n+                    .type(DSPACE_TYPE_CONTRACT_AGREEMENT_VERIFICATION_MESSAGE)\n+                    .property(DSPACE_PROPERTY_CONSUMER_PID)\n+                    .report();\n+            return null;\n         }\n         if (!transformMandatoryString(object.get(DSPACE_PROPERTY_PROVIDER_PID), builder::providerPid, context)) {\n-            if (processId == null) {\n-                context.problem()\n-                        .missingProperty()\n-                        .type(DSPACE_TYPE_CONTRACT_AGREEMENT_VERIFICATION_MESSAGE)\n-                        .property(DSPACE_PROPERTY_PROVIDER_PID)\n-                        .report();\n-                return null;\n-            } else {\n-                builder.providerPid(transformString(processId, context));\n-            }\n+            context.problem()\n+                    .missingProperty()\n+                    .type(DSPACE_TYPE_CONTRACT_AGREEMENT_VERIFICATION_MESSAGE)\n+                    .property(DSPACE_PROPERTY_PROVIDER_PID)\n+                    .report();\n+            return null;\n         }\n \n         return builder.build();\n```\n\nFilename: data-protocols/dsp/dsp-negotiation/dsp-negotiation-transform/src/test/java/org/eclipse/edc/protocol/dsp/negotiation/transform/from/JsonObjectFromContractAgreementMessageTransformerTest.java:\n```\n@@ -38,12 +38,9 @@\nimport static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.ODRL_ASSIGNEE_ATTRIBUTE;\n import static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.ODRL_ASSIGNER_ATTRIBUTE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_PROPERTY_AGREEMENT;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_ID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_PROPERTY_TIMESTAMP;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_TYPE_CONTRACT_AGREEMENT_MESSAGE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_PID;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyString;\n\n@@ -77,7 +74,6 @@\nvoid setUp() {\n     void transform() {\n         var message = ContractAgreementMessage.Builder.newInstance()\n                 .protocol(DSP)\n-                .processId(\"processId\")\n                 .providerPid(\"providerPid\")\n                 .consumerPid(\"consumerPid\")\n                 .counterPartyAddress(\"https://example.com\")\n\n@@ -102,7 +98,6 @@\nvoid transform() {\n         assertThat(result.getString(TYPE)).isEqualTo(DSPACE_TYPE_CONTRACT_AGREEMENT_MESSAGE);\n         assertThat(result.getString(DSPACE_PROPERTY_PROVIDER_PID)).isEqualTo(\"providerPid\");\n         assertThat(result.getString(DSPACE_PROPERTY_CONSUMER_PID)).isEqualTo(\"consumerPid\");\n-        assertThat(result.getString(DSPACE_PROPERTY_PROCESS_ID)).isEqualTo(\"processId\");\n \n         var jsonAgreement = result.getJsonObject(DSPACE_PROPERTY_AGREEMENT);\n         assertThat(jsonAgreement).isNotNull();\n\n@@ -114,38 +109,6 @@\nvoid transform() {\n         verify(context, never()).reportProblem(anyString());\n     }\n \n-    @Deprecated(since = \"0.5.1\")\n-    @Test\n-    void shouldSetConsumerIdAndProviderIdForBackwardCompatibility() {\n-        var message = ContractAgreementMessage.Builder.newInstance()\n-                .protocol(DSP)\n-                .processId(\"processId\")\n-                .providerPid(\"providerPid\")\n-                .consumerPid(\"consumerPid\")\n-                .counterPartyAddress(\"https://example.com\")\n-                .contractAgreement(ContractAgreement.Builder.newInstance()\n-                        .id(AGREEMENT_ID)\n-                        .providerId(PROVIDER_ID)\n-                        .consumerId(CONSUMER_ID)\n-                        .assetId(\"assetId\")\n-                        .policy(policy()).build())\n-                .build();\n-        var policyObject = jsonFactory.createObjectBuilder()\n-                .add(ID, \"contractOfferId\")\n-                .build();\n-\n-        when(context.transform(any(Policy.class), eq(JsonObject.class))).thenReturn(policyObject);\n-\n-        var result = transformer.transform(message, context);\n-\n-        assertThat(result).isNotNull();\n-        var jsonAgreement = result.getJsonObject(DSPACE_PROPERTY_AGREEMENT);\n-        assertThat(jsonAgreement.getString(DSPACE_PROPERTY_CONSUMER_ID)).isEqualTo(CONSUMER_ID);\n-        assertThat(jsonAgreement.getString(DSPACE_PROPERTY_PROVIDER_ID)).isEqualTo(PROVIDER_ID);\n-\n-        verify(context, never()).reportProblem(anyString());\n-    }\n-\n     @Test\n     void transform_policyError() {\n         var message = ContractAgreementMessage.Builder.newInstance()\n```\n\nFilename: data-protocols/dsp/dsp-negotiation/dsp-negotiation-transform/src/test/java/org/eclipse/edc/protocol/dsp/negotiation/transform/from/JsonObjectFromContractAgreementVerificationMessageTransformerTest.java:\n```\n@@ -27,7 +27,6 @@\nimport static org.eclipse.edc.jsonld.spi.JsonLdKeywords.TYPE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_TYPE_CONTRACT_AGREEMENT_VERIFICATION_MESSAGE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_PID;\n import static org.mockito.ArgumentMatchers.anyString;\n import static org.mockito.Mockito.mock;\n\n@@ -47,7 +46,6 @@\nvoid transform() {\n         var value = \"example\";\n         var message = ContractAgreementVerificationMessage.Builder.newInstance()\n                 .protocol(value)\n-                .processId(\"processId\")\n                 .consumerPid(\"consumerPid\")\n                 .providerPid(\"providerPid\")\n                 .counterPartyAddress(value)\n\n@@ -60,7 +58,6 @@\nvoid transform() {\n         assertThat(result.getJsonString(TYPE).getString()).isEqualTo(DSPACE_TYPE_CONTRACT_AGREEMENT_VERIFICATION_MESSAGE);\n         assertThat(result.getJsonString(DSPACE_PROPERTY_CONSUMER_PID).getString()).isEqualTo(\"consumerPid\");\n         assertThat(result.getJsonString(DSPACE_PROPERTY_PROVIDER_PID).getString()).isEqualTo(\"providerPid\");\n-        assertThat(result.getJsonString(DSPACE_PROPERTY_PROCESS_ID).getString()).isEqualTo(\"processId\");\n \n         verify(context, never()).reportProblem(anyString());\n     }\n```\n\nFilename: data-protocols/dsp/dsp-negotiation/dsp-negotiation-transform/src/test/java/org/eclipse/edc/protocol/dsp/negotiation/transform/from/JsonObjectFromContractNegotiationEventMessageTransformerTest.java:\n```\n@@ -30,7 +30,6 @@\nimport static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_TYPE_CONTRACT_NEGOTIATION_EVENT_MESSAGE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_VALUE_NEGOTIATION_EVENT_TYPE_ACCEPTED;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_PID;\n import static org.mockito.ArgumentMatchers.anyString;\n import static org.mockito.Mockito.mock;\n\n@@ -50,7 +49,6 @@\nclass JsonObjectFromContractNegotiationEventMessageTransformerTest {\n     void transform() {\n         var message = ContractNegotiationEventMessage.Builder.newInstance()\n                 .protocol(DSP)\n-                .processId(\"processId\")\n                 .consumerPid(\"consumerPid\")\n                 .providerPid(\"providerPid\")\n                 .counterPartyAddress(\"https://test.com\")\n\n@@ -64,7 +62,6 @@\nvoid transform() {\n         assertThat(result.getString(TYPE)).isEqualTo(DSPACE_TYPE_CONTRACT_NEGOTIATION_EVENT_MESSAGE);\n         assertThat(result.getString(DSPACE_PROPERTY_PROVIDER_PID)).isEqualTo(\"providerPid\");\n         assertThat(result.getString(DSPACE_PROPERTY_CONSUMER_PID)).isEqualTo(\"consumerPid\");\n-        assertThat(result.getString(DSPACE_PROPERTY_PROCESS_ID)).isEqualTo(\"processId\");\n         assertThat(result.getString(DSPACE_PROPERTY_EVENT_TYPE)).isEqualTo(DSPACE_VALUE_NEGOTIATION_EVENT_TYPE_ACCEPTED);\n \n         verify(context, never()).reportProblem(anyString());\n```\n\nFilename: data-protocols/dsp/dsp-negotiation/dsp-negotiation-transform/src/test/java/org/eclipse/edc/protocol/dsp/negotiation/transform/from/JsonObjectFromContractNegotiationTerminationMessageTransformerTest.java:\n```\n@@ -28,7 +28,6 @@\nimport static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_TYPE_CONTRACT_NEGOTIATION_TERMINATION_MESSAGE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CODE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_PID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_REASON;\n import static org.mockito.ArgumentMatchers.anyString;\n\n@@ -51,7 +50,6 @@\nclass JsonObjectFromContractNegotiationTerminationMessageTransformerTest {\n     void transform() {\n         var message = ContractNegotiationTerminationMessage.Builder.newInstance()\n                 .protocol(DSP)\n-                .processId(\"processId\")\n                 .consumerPid(\"consumerPid\")\n                 .providerPid(\"providerPid\")\n                 .counterPartyAddress(\"https://test.com\")\n\n@@ -66,7 +64,6 @@\nvoid transform() {\n         assertThat(result.getString(TYPE)).isEqualTo(DSPACE_TYPE_CONTRACT_NEGOTIATION_TERMINATION_MESSAGE);\n         assertThat(result.getString(DSPACE_PROPERTY_CONSUMER_PID)).isEqualTo(\"consumerPid\");\n         assertThat(result.getString(DSPACE_PROPERTY_PROVIDER_PID)).isEqualTo(\"providerPid\");\n-        assertThat(result.getString(DSPACE_PROPERTY_PROCESS_ID)).isEqualTo(\"processId\");\n         assertThat(result.getString(DSPACE_PROPERTY_CODE)).isEqualTo(REJECTION_CODE);\n         assertThat(result.getString(DSPACE_PROPERTY_REASON)).isEqualTo(REJECTION_REASON);\n```\n\nFilename: data-protocols/dsp/dsp-negotiation/dsp-negotiation-transform/src/test/java/org/eclipse/edc/protocol/dsp/negotiation/transform/from/JsonObjectFromContractNegotiationTransformerTest.java:\n```\n@@ -56,7 +56,6 @@\nimport static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_VALUE_NEGOTIATION_STATE_TERMINATED;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_VALUE_NEGOTIATION_STATE_VERIFIED;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_PID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_STATE;\n import static org.mockito.ArgumentMatchers.anyString;\n\n@@ -95,7 +94,6 @@\nvoid transform_consumer() {\n         assertThat(result.getString(TYPE)).isEqualTo(DSPACE_TYPE_CONTRACT_NEGOTIATION);\n         assertThat(result.getString(DSPACE_PROPERTY_CONSUMER_PID)).isEqualTo(\"consumerPid\");\n         assertThat(result.getString(DSPACE_PROPERTY_PROVIDER_PID)).isEqualTo(\"providerPid\");\n-        assertThat(result.getString(DSPACE_PROPERTY_PROCESS_ID)).isEqualTo(\"consumerPid\");\n \n         verify(context, never()).reportProblem(anyString());\n     }\n\n@@ -119,7 +117,6 @@\nvoid transform_provider() {\n         assertThat(result.getString(TYPE)).isEqualTo(DSPACE_TYPE_CONTRACT_NEGOTIATION);\n         assertThat(result.getString(DSPACE_PROPERTY_CONSUMER_PID)).isEqualTo(\"consumerPid\");\n         assertThat(result.getString(DSPACE_PROPERTY_PROVIDER_PID)).isEqualTo(\"providerPid\");\n-        assertThat(result.getString(DSPACE_PROPERTY_PROCESS_ID)).isEqualTo(\"consumerPid\");\n \n         verify(context, never()).reportProblem(anyString());\n     }\n```\n\nFilename: data-protocols/dsp/dsp-negotiation/dsp-negotiation-transform/src/test/java/org/eclipse/edc/protocol/dsp/negotiation/transform/from/JsonObjectFromContractOfferMessageTransformerTest.java:\n```\n@@ -34,7 +34,6 @@\nimport static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_TYPE_CONTRACT_OFFER_MESSAGE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CALLBACK_ADDRESS;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_PID;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyString;\n\n@@ -67,7 +66,6 @@\nvoid transform_shouldReturnJsonObject_whenValidMessage() {\n         var message = ContractOfferMessage.Builder.newInstance()\n                 .id(MESSAGE_ID)\n                 .callbackAddress(CALLBACK_ADDRESS)\n-                .processId(\"processId\")\n                 .providerPid(\"providerPid\")\n                 .consumerPid(\"consumerPid\")\n                 .protocol(PROTOCOL)\n\n@@ -88,7 +86,6 @@\nvoid transform_shouldReturnJsonObject_whenValidMessage() {\n         assertThat(result.getJsonObject(DSPACE_PROPERTY_OFFER).getJsonString(ID).getString()).isEqualTo(CONTRACT_OFFER_ID);\n         assertThat(result.getString(DSPACE_PROPERTY_PROVIDER_PID)).isEqualTo(\"providerPid\");\n         assertThat(result.getString(DSPACE_PROPERTY_CONSUMER_PID)).isEqualTo(\"consumerPid\");\n-        assertThat(result.getString(DSPACE_PROPERTY_PROCESS_ID)).isEqualTo(\"processId\");\n \n         verify(context, never()).reportProblem(anyString());\n     }\n```\n\nFilename: data-protocols/dsp/dsp-negotiation/dsp-negotiation-transform/src/test/java/org/eclipse/edc/protocol/dsp/negotiation/transform/from/JsonObjectFromContractRequestMessageTransformerTest.java:\n```\n@@ -34,7 +34,6 @@\nimport static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_TYPE_CONTRACT_REQUEST_MESSAGE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CALLBACK_ADDRESS;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_PID;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyString;\n\n@@ -67,7 +66,6 @@\nvoid setUp() {\n     @Test\n     void verify_contractOffer() {\n         var message = contractRequestMessageBuilder()\n-                .processId(\"processId\")\n                 .consumerPid(\"consumerPid\")\n                 .providerPid(\"providerPid\")\n                 .contractOffer(contractOffer())\n\n@@ -85,7 +83,6 @@\nvoid verify_contractOffer() {\n         assertThat(result.getJsonObject(DSPACE_PROPERTY_OFFER).getString(ID)).isEqualTo(CONTRACT_OFFER_ID);\n         assertThat(result.getJsonString(DSPACE_PROPERTY_CONSUMER_PID).getString()).isEqualTo(\"consumerPid\");\n         assertThat(result.getJsonString(DSPACE_PROPERTY_PROVIDER_PID).getString()).isEqualTo(\"providerPid\");\n-        assertThat(result.getJsonString(DSPACE_PROPERTY_PROCESS_ID).getString()).isEqualTo(\"processId\");\n \n         verify(context, never()).reportProblem(anyString());\n     }\n```\n\nFilename: data-protocols/dsp/dsp-negotiation/dsp-negotiation-transform/src/test/java/org/eclipse/edc/protocol/dsp/negotiation/transform/to/JsonObjectToContractAgreementMessageTransformerTest.java:\n```\n@@ -40,8 +40,6 @@\nimport static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.ODRL_POLICY_TYPE_AGREEMENT;\n import static org.eclipse.edc.protocol.dsp.negotiation.transform.to.TestInput.getExpanded;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_PROPERTY_AGREEMENT;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_ID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_PROPERTY_TIMESTAMP;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_TYPE_CONTRACT_AGREEMENT_MESSAGE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n\n@@ -113,46 +111,6 @@\nvoid transform() {\n         verify(context, never()).reportProblem(anyString());\n     }\n \n-    @Deprecated\n-    @Test\n-    void transformFallbackConsumerIdProviderId_whenAssigneeAndAssignerAreMissing() {\n-        var message = jsonFactory.createObjectBuilder()\n-                .add(ID, MESSAGE_ID)\n-                .add(TYPE, DSPACE_TYPE_CONTRACT_AGREEMENT_MESSAGE)\n-                .add(DSPACE_PROPERTY_CONSUMER_PID, \"consumerPid\")\n-                .add(DSPACE_PROPERTY_PROVIDER_PID, \"providerPid\")\n-                .add(DSPACE_PROPERTY_AGREEMENT, jsonFactory.createObjectBuilder()\n-                        .add(ID, AGREEMENT_ID)\n-                        .add(TYPE, ODRL_POLICY_TYPE_AGREEMENT)\n-                        .add(DSPACE_PROPERTY_CONSUMER_ID, CONSUMER_ID)\n-                        .add(DSPACE_PROPERTY_PROVIDER_ID, PROVIDER_ID)\n-                        .add(DSPACE_PROPERTY_TIMESTAMP, TIMESTAMP)\n-                        .build())\n-                .build();\n-\n-        var policy = policyBuilder().assignee(null).assigner(null).build();\n-        when(context.transform(any(JsonObject.class), eq(Policy.class))).thenReturn(policy);\n-\n-        var result = transformer.transform(getExpanded(message), context);\n-\n-        assertThat(result).isNotNull();\n-        assertThat(result.getClass()).isEqualTo(ContractAgreementMessage.class);\n-        assertThat(result.getProtocol()).isNotEmpty();\n-        assertThat(result.getConsumerPid()).isEqualTo(\"consumerPid\");\n-        assertThat(result.getProviderPid()).isEqualTo(\"providerPid\");\n-\n-        var agreement = result.getContractAgreement();\n-        assertThat(agreement).isNotNull();\n-        assertThat(agreement.getClass()).isEqualTo(ContractAgreement.class);\n-        assertThat(agreement.getId()).isEqualTo(AGREEMENT_ID);\n-        assertThat(agreement.getConsumerId()).isEqualTo(CONSUMER_ID);\n-        assertThat(agreement.getProviderId()).isEqualTo(PROVIDER_ID);\n-        assertThat(agreement.getAssetId()).isEqualTo(TARGET);\n-        assertThat(agreement.getContractSigningDate()).isEqualTo(Instant.parse(TIMESTAMP).getEpochSecond());\n-\n-        verify(context, never()).reportProblem(anyString());\n-    }\n-\n     @Test\n     void transform_nullPolicy() {\n         var value = \"example\";\n```\n\nFilename: data-protocols/dsp/dsp-negotiation/dsp-negotiation-transform/src/test/java/org/eclipse/edc/protocol/dsp/negotiation/transform/to/JsonObjectToContractAgreementVerificationMessageTransformerTest.java:\n```\n@@ -29,7 +29,6 @@\nimport static org.eclipse.edc.protocol.dsp.negotiation.transform.to.TestInput.getExpanded;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspNegotiationPropertyAndTypeNames.DSPACE_TYPE_CONTRACT_AGREEMENT_VERIFICATION_MESSAGE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_PID;\n import static org.mockito.ArgumentMatchers.anyString;\n import static org.mockito.ArgumentMatchers.contains;\n\n@@ -72,25 +71,6 @@\nvoid transform() {\n         verify(context, never()).reportProblem(anyString());\n     }\n \n-    @Test\n-    void transform_processId() {\n-        var message = jsonFactory.createObjectBuilder()\n-                .add(JsonLdKeywords.ID, \"messageId\")\n-                .add(JsonLdKeywords.TYPE, DSPACE_TYPE_CONTRACT_AGREEMENT_VERIFICATION_MESSAGE)\n-                .add(DSPACE_PROPERTY_PROCESS_ID, \"processId\")\n-                .build();\n-\n-        var result = transformer.transform(getExpanded(message), context);\n-\n-        assertThat(result).isNotNull();\n-        assertThat(result.getClass()).isEqualTo(ContractAgreementVerificationMessage.class);\n-        assertThat(result.getProtocol()).isNotEmpty();\n-        assertThat(result.getConsumerPid()).isEqualTo(\"processId\");\n-        assertThat(result.getProviderPid()).isEqualTo(\"processId\");\n-\n-        verify(context, never()).reportProblem(anyString());\n-    }\n-\n     @Test\n     void verify_failTransformWhenConsumerPidMissing() {\n         var message = jsonFactory.createObjectBuilder()\n```\n\nFilename: data-protocols/dsp/dsp-spi/src/main/java/org/eclipse/edc/protocol/dsp/spi/type/DspNegotiationPropertyAndTypeNames.java:\n```\n@@ -38,9 +38,7 @@\npublic interface DspNegotiationPropertyAndTypeNames {\n     String DSPACE_PROPERTY_AGREEMENT = DSPACE_SCHEMA + \"agreement\";\n     String DSPACE_PROPERTY_OFFER = DSPACE_SCHEMA + \"offer\";\n     String DSPACE_PROPERTY_TIMESTAMP = DSPACE_SCHEMA + \"timestamp\";\n-    @Deprecated(since = \"0.5.1\")\n     String DSPACE_PROPERTY_CONSUMER_ID = DSPACE_SCHEMA + \"consumerId\";\n-    @Deprecated(since = \"0.5.1\")\n     String DSPACE_PROPERTY_PROVIDER_ID = DSPACE_SCHEMA + \"providerId\";\n \n     // event types\n```\n\nFilename: data-protocols/dsp/dsp-spi/src/main/java/org/eclipse/edc/protocol/dsp/spi/type/DspPropertyAndTypeNames.java:\n```\n@@ -25,7 +25,6 @@\npublic interface DspPropertyAndTypeNames {\n     String DSPACE_PROPERTY_REASON = DSPACE_SCHEMA + \"reason\";\n     String DSPACE_PROPERTY_CONSUMER_PID = DSPACE_SCHEMA + \"consumerPid\";\n     String DSPACE_PROPERTY_PROVIDER_PID = DSPACE_SCHEMA + \"providerPid\";\n-    @Deprecated(since = \"0.5.1\")\n     String DSPACE_PROPERTY_PROCESS_ID = DSPACE_SCHEMA + \"processId\";\n     String DSPACE_PROPERTY_CALLBACK_ADDRESS = DSPACE_SCHEMA + \"callbackAddress\";\n     String DSPACE_PROPERTY_STATE = DSPACE_SCHEMA + \"state\";\n```\n\nFilename: data-protocols/dsp/dsp-transfer-process/dsp-transfer-process-transform/src/main/java/org/eclipse/edc/protocol/dsp/transferprocess/transform/type/from/JsonObjectFromTransferCompletionMessageTransformer.java:\n```\n@@ -25,7 +25,6 @@\nimport static org.eclipse.edc.jsonld.spi.JsonLdKeywords.ID;\n import static org.eclipse.edc.jsonld.spi.JsonLdKeywords.TYPE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_PID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspTransferProcessPropertyAndTypeNames.DSPACE_TYPE_TRANSFER_COMPLETION_MESSAGE;\n\n@@ -46,7 +45,6 @@\npublic JsonObjectFromTransferCompletionMessageTransformer(JsonBuilderFactory jso\n                 .add(TYPE, DSPACE_TYPE_TRANSFER_COMPLETION_MESSAGE)\n                 .add(DSPACE_PROPERTY_CONSUMER_PID, transferCompletionMessage.getConsumerPid())\n                 .add(DSPACE_PROPERTY_PROVIDER_PID, transferCompletionMessage.getProviderPid())\n-                .add(DSPACE_PROPERTY_PROCESS_ID, transferCompletionMessage.getProcessId())\n                 .build();\n     }\n }\n```\n\nFilename: data-protocols/dsp/dsp-transfer-process/dsp-transfer-process-transform/src/main/java/org/eclipse/edc/protocol/dsp/transferprocess/transform/type/from/JsonObjectFromTransferRequestMessageTransformer.java:\n```\n@@ -27,10 +27,8 @@\nimport static org.eclipse.edc.jsonld.spi.JsonLdKeywords.ID;\n import static org.eclipse.edc.jsonld.spi.JsonLdKeywords.TYPE;\n import static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.DCT_FORMAT_ATTRIBUTE;\n-import static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.DEPRECATED_DCT_FORMAT_ATTRIBUTE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CALLBACK_ADDRESS;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspTransferProcessPropertyAndTypeNames.DSPACE_PROPERTY_CONTRACT_AGREEMENT_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspTransferProcessPropertyAndTypeNames.DSPACE_PROPERTY_DATA_ADDRESS;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspTransferProcessPropertyAndTypeNames.DSPACE_TYPE_TRANSFER_REQUEST_MESSAGE;\n\n@@ -54,11 +52,9 @@\npublic JsonObjectFromTransferRequestMessageTransformer(JsonBuilderFactory jsonBu\n                 .add(ID, transferRequestMessage.getId())\n                 .add(TYPE, DSPACE_TYPE_TRANSFER_REQUEST_MESSAGE)\n                 .add(DSPACE_PROPERTY_CONTRACT_AGREEMENT_ID, transferRequestMessage.getContractId())\n-                .add(DEPRECATED_DCT_FORMAT_ATTRIBUTE, format)\n                 .add(DCT_FORMAT_ATTRIBUTE, format)\n                 .add(DSPACE_PROPERTY_CALLBACK_ADDRESS, transferRequestMessage.getCallbackAddress())\n-                .add(DSPACE_PROPERTY_CONSUMER_PID, transferRequestMessage.getConsumerPid())\n-                .add(DSPACE_PROPERTY_PROCESS_ID, transferRequestMessage.getProcessId());\n+                .add(DSPACE_PROPERTY_CONSUMER_PID, transferRequestMessage.getConsumerPid());\n \n         if (transferRequestMessage.getDataDestination() != null && transferRequestMessage.getDataDestination().getProperties().size() > 1) {\n             builder.add(DSPACE_PROPERTY_DATA_ADDRESS, context.transform(transferRequestMessage.getDataDestination(), JsonObject.class));\n```\n\nFilename: data-protocols/dsp/dsp-transfer-process/dsp-transfer-process-transform/src/main/java/org/eclipse/edc/protocol/dsp/transferprocess/transform/type/from/JsonObjectFromTransferStartMessageTransformer.java:\n```\n@@ -25,7 +25,6 @@\nimport static org.eclipse.edc.jsonld.spi.JsonLdKeywords.ID;\n import static org.eclipse.edc.jsonld.spi.JsonLdKeywords.TYPE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_PID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspTransferProcessPropertyAndTypeNames.DSPACE_PROPERTY_DATA_ADDRESS;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspTransferProcessPropertyAndTypeNames.DSPACE_TYPE_TRANSFER_START_MESSAGE;\n\n@@ -45,8 +44,7 @@\npublic JsonObjectFromTransferStartMessageTransformer(JsonBuilderFactory jsonBuil\n                 .add(ID, transferStartMessage.getId())\n                 .add(TYPE, DSPACE_TYPE_TRANSFER_START_MESSAGE)\n                 .add(DSPACE_PROPERTY_PROVIDER_PID, transferStartMessage.getProviderPid())\n-                .add(DSPACE_PROPERTY_CONSUMER_PID, transferStartMessage.getConsumerPid())\n-                .add(DSPACE_PROPERTY_PROCESS_ID, transferStartMessage.getProcessId());\n+                .add(DSPACE_PROPERTY_CONSUMER_PID, transferStartMessage.getConsumerPid());\n \n         if (transferStartMessage.getDataAddress() != null) {\n             builder.add(DSPACE_PROPERTY_DATA_ADDRESS, context.transform(transferStartMessage.getDataAddress(), JsonObject.class));\n```\n\nFilename: data-protocols/dsp/dsp-transfer-process/dsp-transfer-process-transform/src/main/java/org/eclipse/edc/protocol/dsp/transferprocess/transform/type/from/JsonObjectFromTransferTerminationMessageTransformer.java:\n```\n@@ -26,7 +26,6 @@\nimport static org.eclipse.edc.jsonld.spi.JsonLdKeywords.TYPE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CODE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_PID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_REASON;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspTransferProcessPropertyAndTypeNames.DSPACE_TYPE_TRANSFER_TERMINATION_MESSAGE;\n\n@@ -46,8 +45,7 @@\npublic JsonObjectFromTransferTerminationMessageTransformer(JsonBuilderFactory js\n                 .add(ID, transferTerminationMessage.getId())\n                 .add(TYPE, DSPACE_TYPE_TRANSFER_TERMINATION_MESSAGE)\n                 .add(DSPACE_PROPERTY_CONSUMER_PID, transferTerminationMessage.getConsumerPid())\n-                .add(DSPACE_PROPERTY_PROVIDER_PID, transferTerminationMessage.getProviderPid())\n-                .add(DSPACE_PROPERTY_PROCESS_ID, transferTerminationMessage.getProcessId());\n+                .add(DSPACE_PROPERTY_PROVIDER_PID, transferTerminationMessage.getProviderPid());\n \n         addIfNotNull(transferTerminationMessage.getCode(), DSPACE_PROPERTY_CODE, builder);\n         addIfNotNull(transferTerminationMessage.getReason(), DSPACE_PROPERTY_REASON, builder);\n```\n\nFilename: data-protocols/dsp/dsp-transfer-process/dsp-transfer-process-transform/src/main/java/org/eclipse/edc/protocol/dsp/transferprocess/transform/type/to/JsonObjectToTransferRequestMessageTransformer.java:\n```\n@@ -23,7 +23,6 @@\nimport org.jetbrains.annotations.Nullable;\n \n import static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.DCT_FORMAT_ATTRIBUTE;\n-import static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.DEPRECATED_DCT_FORMAT_ATTRIBUTE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CALLBACK_ADDRESS;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspTransferProcessPropertyAndTypeNames.DSPACE_PROPERTY_CONTRACT_AGREEMENT_ID;\n\n@@ -52,10 +51,8 @@\npublic JsonObjectToTransferRequestMessageTransformer() {\n         visitProperties(messageObject, k -> switch (k) {\n             case DSPACE_PROPERTY_CONTRACT_AGREEMENT_ID -> v -> builder.contractId(transformString(v, context));\n             case DSPACE_PROPERTY_CALLBACK_ADDRESS -> v -> builder.callbackAddress(transformString(v, context));\n-            case DSPACE_PROPERTY_DATA_ADDRESS ->\n-                    v -> builder.dataDestination(transformObject(v, DataAddress.class, context));\n-            case DCT_FORMAT_ATTRIBUTE, DEPRECATED_DCT_FORMAT_ATTRIBUTE ->\n-                    v -> builder.transferType(transformString(v, context));\n+            case DSPACE_PROPERTY_DATA_ADDRESS -> v -> builder.dataDestination(transformObject(v, DataAddress.class, context));\n+            case DCT_FORMAT_ATTRIBUTE -> v -> builder.transferType(transformString(v, context));\n             default -> doNothing();\n         });\n```\n\nFilename: data-protocols/dsp/dsp-transfer-process/dsp-transfer-process-transform/src/test/java/org/eclipse/edc/protocol/dsp/transferprocess/transform/from/JsonObjectFromTransferCompletionMessageTransformerTest.java:\n```\n@@ -26,7 +26,6 @@\nimport static org.assertj.core.api.Assertions.assertThat;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_PID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspTransferProcessPropertyAndTypeNames.DSPACE_TYPE_TRANSFER_COMPLETION_MESSAGE;\n import static org.mockito.ArgumentMatchers.anyString;\n\n@@ -58,7 +57,6 @@\nvoid transformTransferCompletionMessage() {\n         assertThat(result.getString(JsonLdKeywords.TYPE)).isEqualTo(DSPACE_TYPE_TRANSFER_COMPLETION_MESSAGE);\n         assertThat(result.getString(DSPACE_PROPERTY_CONSUMER_PID)).isEqualTo(\"consumerPid\");\n         assertThat(result.getString(DSPACE_PROPERTY_PROVIDER_PID)).isEqualTo(\"providerPid\");\n-        assertThat(result.getString(DSPACE_PROPERTY_PROCESS_ID)).isEqualTo(\"processId\");\n \n         verify(context, never()).reportProblem(anyString());\n     }\n```\n\nFilename: data-protocols/dsp/dsp-transfer-process/dsp-transfer-process-transform/src/test/java/org/eclipse/edc/protocol/dsp/transferprocess/transform/from/JsonObjectFromTransferRequestMessageTransformerTest.java:\n```\n@@ -29,10 +29,8 @@\nimport static org.assertj.core.api.Assertions.assertThat;\n import static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.DCT_FORMAT_ATTRIBUTE;\n-import static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.DEPRECATED_DCT_FORMAT_ATTRIBUTE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CALLBACK_ADDRESS;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspTransferProcessPropertyAndTypeNames.DSPACE_PROPERTY_CONTRACT_AGREEMENT_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspTransferProcessPropertyAndTypeNames.DSPACE_PROPERTY_DATA_ADDRESS;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspTransferProcessPropertyAndTypeNames.DSPACE_TYPE_TRANSFER_REQUEST_MESSAGE;\n\n@@ -86,9 +84,7 @@\nvoid transformTransferRequestMessageWithDataAddress() {\n         assertThat(result.getJsonString(JsonLdKeywords.TYPE).getString()).isEqualTo(DSPACE_TYPE_TRANSFER_REQUEST_MESSAGE);\n         assertThat(result.getJsonString(DSPACE_PROPERTY_CONTRACT_AGREEMENT_ID).getString()).isEqualTo(contractId);\n         assertThat(result.getJsonString(DCT_FORMAT_ATTRIBUTE).getString()).isEqualTo(dataAddressType);\n-        assertThat(result.getJsonString(DEPRECATED_DCT_FORMAT_ATTRIBUTE).getString()).isEqualTo(dataAddressType);\n         assertThat(result.getJsonString(DSPACE_PROPERTY_CALLBACK_ADDRESS).getString()).isEqualTo(callbackAddress);\n-        assertThat(result.getJsonString(DSPACE_PROPERTY_PROCESS_ID).getString()).isEqualTo(\"processId\");\n         assertThat(result.getJsonString(DSPACE_PROPERTY_CONSUMER_PID).getString()).isEqualTo(\"consumerPid\");\n         assertThat(result.getJsonObject(DSPACE_PROPERTY_DATA_ADDRESS).getString(\"keyName\")).isEqualTo(dataAddressKey);\n```\n\nFilename: data-protocols/dsp/dsp-transfer-process/dsp-transfer-process-transform/src/test/java/org/eclipse/edc/protocol/dsp/transferprocess/transform/from/JsonObjectFromTransferStartMessageTransformerTest.java:\n```\n@@ -28,7 +28,6 @@\nimport static org.assertj.core.api.Assertions.assertThat;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_PID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspTransferProcessPropertyAndTypeNames.DSPACE_PROPERTY_DATA_ADDRESS;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspTransferProcessPropertyAndTypeNames.DSPACE_TYPE_TRANSFER_START_MESSAGE;\n\n@@ -51,7 +50,6 @@\nclass JsonObjectFromTransferStartMessageTransformerTest {\n     void transformTransferStartMessage() {\n         var dataAddress = DataAddress.Builder.newInstance().type(\"type\").build();\n         var message = TransferStartMessage.Builder.newInstance()\n-                .processId(\"processId\")\n                 .consumerPid(\"consumerPid\")\n                 .providerPid(\"providerPid\")\n                 .protocol(\"testProtocol\")\n\n@@ -65,7 +63,6 @@\nvoid transformTransferStartMessage() {\n \n         assertThat(result).isNotNull();\n         assertThat(result.getString(JsonLdKeywords.TYPE)).isEqualTo(DSPACE_TYPE_TRANSFER_START_MESSAGE);\n-        assertThat(result.getString(DSPACE_PROPERTY_PROCESS_ID)).isEqualTo(\"processId\");\n         assertThat(result.getString(DSPACE_PROPERTY_PROVIDER_PID)).isEqualTo(\"providerPid\");\n         assertThat(result.getString(DSPACE_PROPERTY_CONSUMER_PID)).isEqualTo(\"consumerPid\");\n         assertThat(result.getJsonObject(DSPACE_PROPERTY_DATA_ADDRESS)).isEqualTo(dataAddressJson);\n```\n\nFilename: data-protocols/dsp/dsp-transfer-process/dsp-transfer-process-transform/src/test/java/org/eclipse/edc/protocol/dsp/transferprocess/transform/from/JsonObjectFromTransferTerminationMessageTransformerTest.java:\n```\n@@ -27,7 +27,6 @@\nimport static org.assertj.core.api.Assertions.assertThat;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CODE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n-import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROCESS_ID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_PROVIDER_PID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_REASON;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspTransferProcessPropertyAndTypeNames.DSPACE_TYPE_TRANSFER_TERMINATION_MESSAGE;\n\n@@ -48,7 +47,6 @@\nclass JsonObjectFromTransferTerminationMessageTransformerTest {\n     @Test\n     void transformTransferTerminationMessage() {\n         var message = TransferTerminationMessage.Builder.newInstance()\n-                .processId(\"processId\")\n                 .consumerPid(\"consumerPid\")\n                 .providerPid(\"providerPid\")\n                 .protocol(\"dsp\")\n\n@@ -62,7 +60,6 @@\nvoid transformTransferTerminationMessage() {\n         assertThat(result.getJsonString(JsonLdKeywords.TYPE).getString()).isEqualTo(DSPACE_TYPE_TRANSFER_TERMINATION_MESSAGE);\n         assertThat(result.getJsonString(DSPACE_PROPERTY_CONSUMER_PID).getString()).isEqualTo(\"consumerPid\");\n         assertThat(result.getJsonString(DSPACE_PROPERTY_PROVIDER_PID).getString()).isEqualTo(\"providerPid\");\n-        assertThat(result.getJsonString(DSPACE_PROPERTY_PROCESS_ID).getString()).isEqualTo(\"processId\");\n         assertThat(result.getJsonString(DSPACE_PROPERTY_CODE).getString()).isEqualTo(\"testCode\");\n         assertThat(result.getJsonString(DSPACE_PROPERTY_REASON).getString()).isEqualTo(\"testReason\");\n```\n\nFilename: data-protocols/dsp/dsp-transfer-process/dsp-transfer-process-transform/src/test/java/org/eclipse/edc/protocol/dsp/transferprocess/transform/to/JsonObjectToTransferRequestMessageTransformerTest.java:\n```\n@@ -25,7 +25,6 @@\nimport static org.assertj.core.api.Assertions.assertThat;\n import static org.eclipse.edc.jsonld.spi.JsonLdKeywords.TYPE;\n import static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.DCT_FORMAT_ATTRIBUTE;\n-import static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.DEPRECATED_DCT_FORMAT_ATTRIBUTE;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CALLBACK_ADDRESS;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspPropertyAndTypeNames.DSPACE_PROPERTY_CONSUMER_PID;\n import static org.eclipse.edc.protocol.dsp.spi.type.DspTransferProcessPropertyAndTypeNames.DSPACE_PROPERTY_CONTRACT_AGREEMENT_ID;\n\n@@ -98,27 +97,6 @@\nvoid jsonObjectToTransferRequestWithDataAddress() {\n         verify(context, never()).reportProblem(anyString());\n     }\n \n-    @Deprecated(since = \"0.5.1\")\n-    @Test\n-    void jsonObjectToTransferRequestWithDataAddress_withDeprecatedDctNamespace() {\n-        var dataDestination = DataAddress.Builder.newInstance().type(\"any\").build();\n-        when(context.transform(any(), eq(DataAddress.class))).thenReturn(dataDestination);\n-        var json = Json.createObjectBuilder()\n-                .add(TYPE, DSPACE_TYPE_TRANSFER_REQUEST_MESSAGE)\n-                .add(DSPACE_PROPERTY_CONTRACT_AGREEMENT_ID, contractId)\n-                .add(DEPRECATED_DCT_FORMAT_ATTRIBUTE, destinationType)\n-                .add(DSPACE_PROPERTY_DATA_ADDRESS, createDataAddress())\n-                .add(DSPACE_PROPERTY_CALLBACK_ADDRESS, callbackAddress)\n-                .add(DSPACE_PROPERTY_CONSUMER_PID, \"processId\")\n-                .build();\n-\n-        var result = transformer.transform(getExpanded(json), context);\n-\n-        assertThat(result).isNotNull();\n-        assertThat(result.getTransferType()).isEqualTo(destinationType);\n-        verify(context, never()).reportProblem(anyString());\n-    }\n-\n     @Test\n     void shouldReturnNullAndReportError_whenConsumerPidNotSet() {\n         when(context.problem()).thenReturn(new ProblemBuilder(context));\n```\n\nFilename: extensions/common/api/control-api-configuration/src/main/resources/control-api-version.json:\n```\n@@ -1,8 +1,8 @@\n[\n   {\n-    \"version\": \"1.0.1\",\n+    \"version\": \"1.0.2\",\n     \"urlPath\": \"/v1\",\n-    \"lastUpdated\": \"2024-06-02T14:30:00Z\",\n+    \"lastUpdated\": \"2024-09-04T14:30:00Z\",\n     \"maturity\": \"stable\"\n   }\n-]\n\\ No newline at end of file\n+]\n```\n\nFilename: extensions/control-plane/api/management-api/contract-negotiation-api/src/main/java/org/eclipse/edc/connector/controlplane/api/management/contractnegotiation/ContractNegotiationApiExtension.java:\n```\n@@ -74,7 +74,7 @@\npublic void initialize(ServiceExtensionContext context) {\n         managementApiTransformerRegistry.register(new JsonObjectFromContractNegotiationTransformer(factory));\n         managementApiTransformerRegistry.register(new JsonObjectFromNegotiationStateTransformer(factory));\n \n-        validatorRegistry.register(CONTRACT_REQUEST_TYPE, ContractRequestValidator.instance(monitor));\n+        validatorRegistry.register(CONTRACT_REQUEST_TYPE, ContractRequestValidator.instance());\n         validatorRegistry.register(TERMINATE_NEGOTIATION_TYPE, TerminateNegotiationValidator.instance());\n \n         webService.registerResource(ApiContext.MANAGEMENT, new ContractNegotiationApiV2Controller(service, managementApiTransformerRegistry, monitor, validatorRegistry));\n```\n\nFilename: extensions/control-plane/api/management-api/contract-negotiation-api/src/main/java/org/eclipse/edc/connector/controlplane/api/management/contractnegotiation/v2/ContractNegotiationApiV2.java:\n```\n@@ -141,7 +141,6 @@\nrecord ContractRequestSchema(\n             String protocol,\n             @Schema(requiredMode = REQUIRED)\n             String counterPartyAddress,\n-            @Deprecated(since = \"0.5.1\")\n             @Schema(deprecated = true, description = \"please use policy.assigner instead\")\n             String providerId,\n             @Schema(requiredMode = REQUIRED)\n```\n\nFilename: extensions/control-plane/api/management-api/contract-negotiation-api/src/main/java/org/eclipse/edc/connector/controlplane/api/management/contractnegotiation/validation/ContractRequestValidator.java:\n```\n@@ -15,28 +15,23 @@\npackage org.eclipse.edc.connector.controlplane.api.management.contractnegotiation.validation;\n \n import jakarta.json.JsonObject;\n-import org.eclipse.edc.spi.monitor.Monitor;\n import org.eclipse.edc.validator.jsonobject.JsonObjectValidator;\n-import org.eclipse.edc.validator.jsonobject.validators.LogDeprecatedValue;\n import org.eclipse.edc.validator.jsonobject.validators.MandatoryIdNotBlank;\n import org.eclipse.edc.validator.jsonobject.validators.MandatoryObject;\n import org.eclipse.edc.validator.jsonobject.validators.MandatoryValue;\n import org.eclipse.edc.validator.jsonobject.validators.TypeIs;\n import org.eclipse.edc.validator.spi.Validator;\n \n import static org.eclipse.edc.connector.controlplane.contract.spi.types.negotiation.ContractRequest.CONTRACT_REQUEST_COUNTER_PARTY_ADDRESS;\n-import static org.eclipse.edc.connector.controlplane.contract.spi.types.negotiation.ContractRequest.CONTRACT_REQUEST_TYPE;\n import static org.eclipse.edc.connector.controlplane.contract.spi.types.negotiation.ContractRequest.POLICY;\n import static org.eclipse.edc.connector.controlplane.contract.spi.types.negotiation.ContractRequest.PROTOCOL;\n-import static org.eclipse.edc.connector.controlplane.contract.spi.types.negotiation.ContractRequest.PROVIDER_ID;\n import static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.ODRL_ASSIGNER_ATTRIBUTE;\n import static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.ODRL_POLICY_TYPE_OFFER;\n import static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.ODRL_TARGET_ATTRIBUTE;\n \n public class ContractRequestValidator {\n-    public static Validator<JsonObject> instance(Monitor monitor) {\n+    public static Validator<JsonObject> instance() {\n         return JsonObjectValidator.newValidator()\n-                .verify(PROVIDER_ID, path -> new LogDeprecatedValue(path, CONTRACT_REQUEST_TYPE, ODRL_ASSIGNER_ATTRIBUTE, monitor))\n                 .verify(CONTRACT_REQUEST_COUNTER_PARTY_ADDRESS, MandatoryValue::new)\n                 .verify(PROTOCOL, MandatoryValue::new)\n                 .verify(POLICY, MandatoryObject::new)\n```\n\nFilename: extensions/control-plane/api/management-api/contract-negotiation-api/src/test/java/org/eclipse/edc/connector/controlplane/api/management/contractnegotiation/BaseContractNegotiationApiTest.java:\n```\n@@ -67,7 +67,7 @@\nvoid setUp() {\n \n     @Test\n     void contractRequestExample() throws JsonProcessingException {\n-        var validator = ContractRequestValidator.instance(monitor);\n+        var validator = ContractRequestValidator.instance();\n \n         var jsonObject = objectMapper.readValue(CONTRACT_REQUEST_EXAMPLE, JsonObject.class);\n         assertThat(jsonObject).isNotNull();\n```\n\nFilename: extensions/control-plane/api/management-api/contract-negotiation-api/src/test/java/org/eclipse/edc/connector/controlplane/api/management/contractnegotiation/validation/ContractRequestValidatorTest.java:\n```\n@@ -25,14 +25,11 @@\nimport static jakarta.json.Json.createArrayBuilder;\n import static jakarta.json.Json.createObjectBuilder;\n-import static java.lang.String.format;\n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.InstanceOfAssertFactories.list;\n import static org.eclipse.edc.connector.controlplane.contract.spi.types.negotiation.ContractRequest.CONTRACT_REQUEST_COUNTER_PARTY_ADDRESS;\n-import static org.eclipse.edc.connector.controlplane.contract.spi.types.negotiation.ContractRequest.CONTRACT_REQUEST_TYPE;\n import static org.eclipse.edc.connector.controlplane.contract.spi.types.negotiation.ContractRequest.POLICY;\n import static org.eclipse.edc.connector.controlplane.contract.spi.types.negotiation.ContractRequest.PROTOCOL;\n-import static org.eclipse.edc.connector.controlplane.contract.spi.types.negotiation.ContractRequest.PROVIDER_ID;\n import static org.eclipse.edc.jsonld.spi.JsonLdKeywords.ID;\n import static org.eclipse.edc.jsonld.spi.JsonLdKeywords.TYPE;\n import static org.eclipse.edc.jsonld.spi.JsonLdKeywords.VALUE;\n\n@@ -41,12 +38,11 @@\nimport static org.eclipse.edc.jsonld.spi.PropertyAndTypeNames.ODRL_TARGET_ATTRIBUTE;\n import static org.eclipse.edc.junit.assertions.AbstractResultAssert.assertThat;\n import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.verify;\n \n class ContractRequestValidatorTest {\n \n     private final Monitor monitor = mock();\n-    private final Validator<JsonObject> validator = ContractRequestValidator.instance(monitor);\n+    private final Validator<JsonObject> validator = ContractRequestValidator.instance();\n \n     @Test\n     void shouldSuccess_whenObjectIsValid() {\n\n@@ -115,20 +111,6 @@\nvoid shouldFail_whenMandatoryPropertiesAreMissing() {\n                 .anySatisfy(violation -> assertThat(violation.path()).isEqualTo(PROTOCOL));\n     }\n \n-    @Test\n-    void shouldSucceed_whenDeprecatedProviderIdIsUsedWarningLogged() {\n-        var expectedLogMessage = format(\"The attribute %s has been deprecated in type %s, please use %s\",\n-                PROVIDER_ID, CONTRACT_REQUEST_TYPE, ODRL_ASSIGNER_ATTRIBUTE);\n-\n-        var input = Json.createObjectBuilder()\n-                .add(PROVIDER_ID, value(\"provider_id\"))\n-                .build();\n-\n-        validator.validate(input);\n-\n-        verify(monitor).warning(expectedLogMessage);\n-    }\n-\n     private JsonArrayBuilder value(String value) {\n         return createArrayBuilder().add(createObjectBuilder().add(VALUE, value));\n     }\n```\n\nFilename: extensions/control-plane/transfer/transfer-data-plane/README.md:\n```\n@@ -1,43 +0,0 @@\n-# Transfer Data Plane\n-\n-This extension provides services for delegating data transfer to the Data Plane. Especially two types of data transfers are supported:\n-\n-- Consumer Pull: data consumer pulls actively the data by hitting an endpoint exposed by the provider. This use-case is typically\n-  used in cases where the data provider wants to use its Data Plane as a http proxy for querying data to an API.\n-- Provider Push: if data request is successfully processed, then the provider pushes data from its data source to the consumer.\n-\n-## Background\n-\n-The Data Plane is the component performing the actual data exchange between the provider and the consumer. Once an agreement\n-is established between the consumer and the provider, then the consumer can trigger the data request that will initiate the data exchange.\n-When at this stage, the present extension is used for delegating the data transfer to the appropriate Data Plane instance.\n-\n-### Scope\n-\n-This extension is to be used for every data transfer use-case relying on the EDC data plane.\n-\n-### Use Cases\n-\n-#### Consumer pull\n-\n-Let us consider that a data provider wants to expose a REST API serving flight schedule data. This REST API takes in input\n-a set of query parameters which enables to restrict the amount of data returned in the response, e.g. departure date, boarding airport...\n-A consumer of this API will potentially be interested in hitting this API several times, potentially with different parameters, depending\n-on how the consumer backend application are exploiting the data.\n-\n-For this use-case, the Provider Push data transfer type would not be relevant, as it would require to establish a new contract before\n-the consumer send a new http request, which would potentially overload the Control Plane. The Consumer Pull data transfer comes handy in that case.\n-\n-To trigger this data transfer type, the destination type of the `DataRequest` must be set to `HttpProxy`.\n-\n-#### Provider push\n-\n-A consumer wants to perform a one-time transfer of a large amount of data stored in a S3 bucket on provider side, and\n-put these data into its Azure Blob Storage.\n-\n-## Technical Details\n-\n-### Interfaces\n-\n-This extension introduces a Control Plane endpoint used by the Data Plane for validating the access token received in input\n-of its public API. OpenApi documentation can be found [here](../../../../resources/openapi/yaml/transfer-data-plane.yaml).\n```\n\nFilename: extensions/control-plane/transfer/transfer-data-plane/build.gradle.kts:\n```\n@@ -1,51 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - initial API and implementation\n- *\n- */\n-\n-plugins {\n-    `java-library`\n-    id(libs.plugins.swagger.get().pluginId)\n-}\n-\n-dependencies {\n-    api(project(\":spi:common:core-spi\"))\n-    api(project(\":spi:control-plane:contract-spi\"))\n-    api(project(\":spi:control-plane:transfer-spi\"))\n-    api(project(\":spi:common:web-spi\"))\n-\n-    api(project(\":spi:control-plane:transfer-data-plane-spi\"))\n-    api(project(\":spi:data-plane:data-plane-spi\"))\n-    api(project(\":extensions:data-plane:data-plane-client\"))\n-    api(project(\":spi:data-plane-selector:data-plane-selector-spi\"))\n-\n-    implementation(project(\":spi:common:keys-spi\"))\n-    implementation(project(\":core:common:token-core\"))\n-\n-    api(libs.jakarta.rsApi)\n-    api(libs.nimbus.jwt)\n-    // Note: nimbus requires bouncycastle as mentioned in documentation:\n-    // https://www.javadoc.io/doc/com.nimbusds/nimbus-jose-jwt/7.2.1/com/nimbusds/jose/jwk/JWK.html#parseFromPEMEncodedObjects-java.lang.String-\n-    api(libs.bouncyCastle.bcpkixJdk18on)\n-\n-    testImplementation(project(\":core:common:junit\"))\n-    testImplementation(libs.jersey.multipart)\n-}\n-\n-edcBuild {\n-    swagger {\n-        apiGroup.set(\"control-api\")\n-    }\n-}\n-\n-\n-\n```\n\nFilename: extensions/control-plane/transfer/transfer-data-plane/src/main/java/org/eclipse/edc/connector/controlplane/transfer/dataplane/TransferDataPlaneCoreExtension.java:\n```\n@@ -1,133 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - initial API and implementation\n- *       Mercedes-Benz Tech Innovation GmbH - DataEncrypter can be provided by extensions\n- *\n- */\n-\n-package org.eclipse.edc.connector.controlplane.transfer.dataplane;\n-\n-import org.eclipse.edc.connector.controlplane.transfer.dataplane.api.ConsumerPullTransferTokenValidationApiController;\n-import org.eclipse.edc.connector.controlplane.transfer.dataplane.flow.ConsumerPullTransferDataFlowController;\n-import org.eclipse.edc.connector.controlplane.transfer.dataplane.flow.ProviderPushTransferDataFlowController;\n-import org.eclipse.edc.connector.controlplane.transfer.dataplane.proxy.ConsumerPullDataPlaneProxyResolver;\n-import org.eclipse.edc.connector.controlplane.transfer.dataplane.spi.security.DataEncrypter;\n-import org.eclipse.edc.connector.controlplane.transfer.dataplane.spi.token.ConsumerPullTokenExpirationDateFunction;\n-import org.eclipse.edc.connector.controlplane.transfer.dataplane.validation.ExpirationDateValidationRule;\n-import org.eclipse.edc.connector.controlplane.transfer.spi.flow.DataFlowManager;\n-import org.eclipse.edc.connector.dataplane.selector.spi.DataPlaneSelectorService;\n-import org.eclipse.edc.connector.dataplane.selector.spi.client.DataPlaneClientFactory;\n-import org.eclipse.edc.jwt.signer.spi.JwsSignerProvider;\n-import org.eclipse.edc.keys.spi.LocalPublicKeyService;\n-import org.eclipse.edc.keys.spi.PrivateKeyResolver;\n-import org.eclipse.edc.runtime.metamodel.annotation.Extension;\n-import org.eclipse.edc.runtime.metamodel.annotation.Inject;\n-import org.eclipse.edc.runtime.metamodel.annotation.Setting;\n-import org.eclipse.edc.spi.system.ServiceExtension;\n-import org.eclipse.edc.spi.system.ServiceExtensionContext;\n-import org.eclipse.edc.spi.types.TypeManager;\n-import org.eclipse.edc.token.JwtGenerationService;\n-import org.eclipse.edc.token.spi.TokenValidationRulesRegistry;\n-import org.eclipse.edc.token.spi.TokenValidationService;\n-import org.eclipse.edc.validator.spi.DataAddressValidatorRegistry;\n-import org.eclipse.edc.validator.spi.ValidationResult;\n-import org.eclipse.edc.web.spi.WebService;\n-import org.eclipse.edc.web.spi.configuration.ApiContext;\n-import org.eclipse.edc.web.spi.configuration.context.ControlApiUrl;\n-\n-import java.time.Clock;\n-\n-@Extension(value = TransferDataPlaneCoreExtension.NAME)\n-public class TransferDataPlaneCoreExtension implements ServiceExtension {\n-\n-    @Setting(value = \"Alias of private key used for signing tokens, retrieved from private key resolver\")\n-    public static final String TOKEN_SIGNER_PRIVATE_KEY_ALIAS = \"edc.transfer.proxy.token.signer.privatekey.alias\";\n-\n-    @Setting(value = \"Alias of public key used for verifying the tokens, retrieved from the vault\")\n-    public static final String TOKEN_VERIFIER_PUBLIC_KEY_ALIAS = \"edc.transfer.proxy.token.verifier.publickey.alias\";\n-\n-    public static final String NAME = \"Transfer Data Plane Core\";\n-    public static final String TRANSFER_DATAPLANE_TOKEN_CONTEXT = \"dataplane-transfer\";\n-\n-    @Inject\n-    private WebService webService;\n-\n-    @Inject\n-    private DataFlowManager dataFlowManager;\n-\n-    @Inject\n-    private Clock clock;\n-\n-    @Inject\n-    private DataEncrypter dataEncrypter;\n-\n-    @Inject\n-    private DataPlaneSelectorService selectorService;\n-\n-    @Inject\n-    private DataPlaneClientFactory clientFactory;\n-\n-    @Inject\n-    private ConsumerPullTokenExpirationDateFunction tokenExpirationDateFunction;\n-\n-    @Inject(required = false)\n-    private ControlApiUrl callbackUrl;\n-\n-    @Inject\n-    private TypeManager typeManager;\n-\n-    @Inject\n-    private LocalPublicKeyService publicKeyService;\n-\n-    @Inject\n-    private PrivateKeyResolver privateKeyResolver;\n-\n-    @Inject\n-    private DataAddressValidatorRegistry dataAddressValidatorRegistry;\n-\n-    @Inject\n-    private TokenValidationRulesRegistry tokenValidationRulesRegistry;\n-\n-    @Inject\n-    private TokenValidationService tokenValidationService;\n-    @Inject\n-    private JwsSignerProvider jwsSignerProvider;\n-\n-    @Override\n-    public String name() {\n-        return NAME;\n-    }\n-\n-    @Override\n-    public void initialize(ServiceExtensionContext context) {\n-        var monitor = context.getMonitor();\n-        monitor.warning(\"The transfer-data-plane extension has been deprecated, please switch to the Data Plane Signaling feature.\");\n-        var publicKeyAlias = context.getSetting(TOKEN_VERIFIER_PUBLIC_KEY_ALIAS, null);\n-        var privateKeyAlias = context.getSetting(TOKEN_SIGNER_PRIVATE_KEY_ALIAS, null);\n-\n-        if (publicKeyAlias != null && privateKeyAlias != null) {\n-            var controller = new ConsumerPullTransferTokenValidationApiController(tokenValidationService, dataEncrypter, typeManager, (i) -> publicKeyService.resolveKey(publicKeyAlias));\n-            webService.registerResource(ApiContext.CONTROL, controller);\n-\n-            var resolver = new ConsumerPullDataPlaneProxyResolver(dataEncrypter, typeManager, new JwtGenerationService(jwsSignerProvider), () -> privateKeyAlias, () -> publicKeyAlias, tokenExpirationDateFunction);\n-            dataFlowManager.register(new ConsumerPullTransferDataFlowController(selectorService, resolver));\n-        } else {\n-            monitor.info(\"One of these settings is not configured, so the connector won't be able to provide 'consumer-pull' transfers: [%s, %s]\"\n-                    .formatted(TOKEN_VERIFIER_PUBLIC_KEY_ALIAS, TOKEN_SIGNER_PRIVATE_KEY_ALIAS));\n-        }\n-\n-        tokenValidationRulesRegistry.addRule(TRANSFER_DATAPLANE_TOKEN_CONTEXT, new ExpirationDateValidationRule(clock));\n-\n-        dataFlowManager.register(new ProviderPushTransferDataFlowController(callbackUrl, selectorService, clientFactory));\n-        dataAddressValidatorRegistry.registerDestinationValidator(\"HttpProxy\", dataAddress -> ValidationResult.success());\n-    }\n-\n-}\n```\n\nFilename: extensions/control-plane/transfer/transfer-data-plane/src/main/java/org/eclipse/edc/connector/controlplane/transfer/dataplane/TransferDataPlaneDefaultServicesExtension.java:\n```\n@@ -1,62 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Bayerische Motoren Werke Aktiengesellschaft (BMW AG)\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Bayerische Motoren Werke Aktiengesellschaft (BMW AG) - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.controlplane.transfer.dataplane;\n-\n-import org.eclipse.edc.connector.controlplane.transfer.dataplane.security.NoopDataEncrypter;\n-import org.eclipse.edc.connector.controlplane.transfer.dataplane.spi.security.DataEncrypter;\n-import org.eclipse.edc.connector.controlplane.transfer.dataplane.spi.token.ConsumerPullTokenExpirationDateFunction;\n-import org.eclipse.edc.runtime.metamodel.annotation.Extension;\n-import org.eclipse.edc.runtime.metamodel.annotation.Inject;\n-import org.eclipse.edc.runtime.metamodel.annotation.Provider;\n-import org.eclipse.edc.runtime.metamodel.annotation.Setting;\n-import org.eclipse.edc.spi.result.Result;\n-import org.eclipse.edc.spi.system.ServiceExtension;\n-import org.eclipse.edc.spi.system.ServiceExtensionContext;\n-\n-import java.time.Clock;\n-import java.util.Date;\n-\n-/**\n- * Provides default service implementations for fallback\n- * Omitted {@link Extension since this module already contains {@link TransferDataPlaneCoreExtension }}\n- */\n-public class TransferDataPlaneDefaultServicesExtension implements ServiceExtension {\n-\n-    private static final String DEFAULT_TOKEN_VALIDITY_SECONDS = \"600\"; // 10min\n-    @Setting(value = \"Validity (in seconds) of tokens issued by the Control Plane for targeting the Data Plane public API.\", type = \"long\", defaultValue = DEFAULT_TOKEN_VALIDITY_SECONDS)\n-    private static final String TOKEN_VALIDITY_SECONDS = \"edc.transfer.proxy.token.validity.seconds\";\n-\n-    public static final String NAME = \"Transfer Data Plane Default Services\";\n-\n-    @Inject\n-    private Clock clock;\n-\n-    @Override\n-    public String name() {\n-        return NAME;\n-    }\n-\n-    @Provider(isDefault = true)\n-    public DataEncrypter getDataEncrypter(ServiceExtensionContext context) {\n-        context.getMonitor().warning(\"No DataEncrypter registered, a no-op implementation will be used, not suitable for production environments\");\n-        return new NoopDataEncrypter();\n-    }\n-\n-    @Provider(isDefault = true)\n-    public ConsumerPullTokenExpirationDateFunction tokenExpirationDateFunction(ServiceExtensionContext context) {\n-        var validity = context.getSetting(TOKEN_VALIDITY_SECONDS, Integer.parseInt(DEFAULT_TOKEN_VALIDITY_SECONDS));\n-        return (contentAddress, contractId) -> Result.success(Date.from(clock.instant().plusSeconds(validity)));\n-    }\n-}\n```\n\nFilename: extensions/control-plane/transfer/transfer-data-plane/src/main/java/org/eclipse/edc/connector/controlplane/transfer/dataplane/api/ConsumerPullTransferTokenValidationApi.java:\n```\n@@ -1,35 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - Initial implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.controlplane.transfer.dataplane.api;\n-\n-import io.swagger.v3.oas.annotations.OpenAPIDefinition;\n-import io.swagger.v3.oas.annotations.Operation;\n-import io.swagger.v3.oas.annotations.responses.ApiResponse;\n-import io.swagger.v3.oas.annotations.tags.Tag;\n-import org.eclipse.edc.spi.types.domain.DataAddress;\n-\n-@OpenAPIDefinition\n-@Tag(name = \"Consumer Pull Token Validation\")\n-public interface ConsumerPullTransferTokenValidationApi {\n-\n-    @Operation(description = \"Checks that the provided token has been signed by the present entity and asserts its validity. \" +\n-            \"If token is valid, then the data address contained in its claims is decrypted and returned back to the caller.\",\n-            responses = {\n-                    @ApiResponse(responseCode = \"200\", description = \"Token is valid\"),\n-                    @ApiResponse(responseCode = \"400\", description = \"Request was malformed\"),\n-                    @ApiResponse(responseCode = \"403\", description = \"Token is invalid\") }\n-    )\n-    DataAddress validate(String token);\n-}\n```\n\nFilename: extensions/control-plane/transfer/transfer-data-plane/src/main/java/org/eclipse/edc/connector/controlplane/transfer/dataplane/api/ConsumerPullTransferTokenValidationApiController.java:\n```\n@@ -1,77 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.controlplane.transfer.dataplane.api;\n-\n-import jakarta.ws.rs.GET;\n-import jakarta.ws.rs.HeaderParam;\n-import jakarta.ws.rs.Path;\n-import jakarta.ws.rs.Produces;\n-import jakarta.ws.rs.core.HttpHeaders;\n-import jakarta.ws.rs.core.MediaType;\n-import org.eclipse.edc.connector.controlplane.transfer.dataplane.spi.security.DataEncrypter;\n-import org.eclipse.edc.keys.spi.PublicKeyResolver;\n-import org.eclipse.edc.spi.iam.ClaimToken;\n-import org.eclipse.edc.spi.types.TypeManager;\n-import org.eclipse.edc.spi.types.domain.DataAddress;\n-import org.eclipse.edc.token.spi.TokenValidationService;\n-import org.eclipse.edc.web.spi.exception.InvalidRequestException;\n-import org.eclipse.edc.web.spi.exception.NotAuthorizedException;\n-\n-import static java.lang.String.format;\n-import static org.eclipse.edc.connector.controlplane.transfer.dataplane.spi.TransferDataPlaneConstants.DATA_ADDRESS;\n-\n-@Path(\"/token\")\n-public class ConsumerPullTransferTokenValidationApiController implements ConsumerPullTransferTokenValidationApi {\n-    private final TokenValidationService service;\n-    private final DataEncrypter dataEncrypter;\n-    private final TypeManager typeManager;\n-    private final PublicKeyResolver publicKeyResolver;\n-\n-    public ConsumerPullTransferTokenValidationApiController(TokenValidationService service, DataEncrypter dataEncrypter, TypeManager typeManager, PublicKeyResolver publicKeyResolver) {\n-        this.service = service;\n-        this.dataEncrypter = dataEncrypter;\n-        this.typeManager = typeManager;\n-        this.publicKeyResolver = publicKeyResolver;\n-    }\n-\n-    /**\n-     * Validate the token provided in input and decrypt the {@link DataAddress}\n-     * contained in its claims.\n-     *\n-     * @param token Input token.\n-     * @return Decrypted DataAddress contained in the input token claims.\n-     */\n-    @GET\n-    @Produces({ MediaType.APPLICATION_JSON })\n-    @Override\n-    public DataAddress validate(@HeaderParam(HttpHeaders.AUTHORIZATION) String token) {\n-        return service.validate(token, publicKeyResolver)\n-                .map(this::extractDataAddressClaim)\n-                .map(this::toDataAddress)\n-                .orElseThrow(failure -> new NotAuthorizedException(\"Token validation failed: \" + failure.getFailureDetail()));\n-    }\n-\n-    String extractDataAddressClaim(ClaimToken claims) {\n-        var claim = claims.getClaim(DATA_ADDRESS);\n-        if (!(claim instanceof String)) {\n-            throw new InvalidRequestException(format(\"Missing claim `%s` in token\", DATA_ADDRESS));\n-        }\n-        return (String) claim;\n-    }\n-\n-    private DataAddress toDataAddress(String claim) {\n-        return typeManager.readValue(dataEncrypter.decrypt(claim), DataAddress.class);\n-    }\n-}\n```\n\nFilename: extensions/control-plane/transfer/transfer-data-plane/src/main/java/org/eclipse/edc/connector/controlplane/transfer/dataplane/flow/ConsumerPullTransferDataFlowController.java:\n```\n@@ -1,98 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.controlplane.transfer.dataplane.flow;\n-\n-import org.eclipse.edc.connector.controlplane.asset.spi.domain.Asset;\n-import org.eclipse.edc.connector.controlplane.transfer.dataplane.proxy.ConsumerPullDataPlaneProxyResolver;\n-import org.eclipse.edc.connector.controlplane.transfer.spi.flow.DataFlowController;\n-import org.eclipse.edc.connector.controlplane.transfer.spi.types.DataFlowResponse;\n-import org.eclipse.edc.connector.controlplane.transfer.spi.types.TransferProcess;\n-import org.eclipse.edc.connector.dataplane.selector.spi.DataPlaneSelectorService;\n-import org.eclipse.edc.policy.model.Policy;\n-import org.eclipse.edc.spi.response.StatusResult;\n-import org.eclipse.edc.spi.types.domain.DataAddress;\n-import org.jetbrains.annotations.NotNull;\n-\n-import java.util.Optional;\n-import java.util.Set;\n-\n-import static java.lang.String.format;\n-import static org.eclipse.edc.connector.controlplane.transfer.dataplane.spi.TransferDataPlaneConstants.HTTP_PROXY;\n-import static org.eclipse.edc.spi.response.ResponseStatus.FATAL_ERROR;\n-import static org.eclipse.edc.spi.response.StatusResult.failure;\n-import static org.eclipse.edc.spi.types.domain.transfer.FlowType.PULL;\n-\n-@Deprecated(since = \"0.5.1\")\n-public class ConsumerPullTransferDataFlowController implements DataFlowController {\n-\n-    private final DataPlaneSelectorService selectorService;\n-    private final ConsumerPullDataPlaneProxyResolver resolver;\n-\n-    private final Set<String> transferTypes = Set.of(\"%s-%s\".formatted(\"HttpData\", PULL));\n-\n-    public ConsumerPullTransferDataFlowController(DataPlaneSelectorService selectorService, ConsumerPullDataPlaneProxyResolver resolver) {\n-        this.selectorService = selectorService;\n-        this.resolver = resolver;\n-    }\n-\n-    @Override\n-    public boolean canHandle(TransferProcess transferProcess) {\n-        // Backward compatibility: can handle if destination type is `HttpProxy` or the transfer type is `Http-PULL`\n-        return HTTP_PROXY.equals(transferProcess.getDestinationType()) ||\n-                (Optional.ofNullable(transferProcess.getTransferType()).map(transferTypes::contains).orElse(false));\n-    }\n-\n-    @Override\n-    public @NotNull StatusResult<DataFlowResponse> start(TransferProcess transferProcess, Policy policy) {\n-        var contentAddress = transferProcess.getContentDataAddress();\n-\n-        return Optional.ofNullable(selectorService.select(contentAddress, destinationAddress(transferProcess)))\n-                .map(instance -> resolver.toDataAddress(transferProcess, contentAddress, instance)\n-                        .map(this::toResponse)\n-                        .map(StatusResult::success)\n-                        .orElse(failure -> failure(FATAL_ERROR, \"Failed to generate proxy: \" + failure.getFailureDetail())))\n-                .orElse(failure(FATAL_ERROR, format(\"Failed to find DataPlaneInstance for source/destination: %s/%s\", contentAddress.getType(), HTTP_PROXY)));\n-    }\n-\n-    @Override\n-    public StatusResult<Void> suspend(TransferProcess transferProcess) {\n-        throw new RuntimeException(\"not implemented\");\n-    }\n-\n-    @Override\n-    public StatusResult<Void> terminate(TransferProcess transferProcess) {\n-        return StatusResult.success();\n-    }\n-\n-    @Override\n-    public Set<String> transferTypesFor(Asset asset) {\n-        return transferTypes;\n-    }\n-\n-    // Shim translation from \"Http-PULL\" to HttpProxy dataAddress\n-    private DataAddress destinationAddress(TransferProcess transferProcess) {\n-        if (transferTypes.contains(transferProcess.getDestinationType())) {\n-            var dadBuilder = DataAddress.Builder.newInstance();\n-            transferProcess.getDataDestination().getProperties().forEach(dadBuilder::property);\n-            return dadBuilder.type(HTTP_PROXY).build();\n-        } else {\n-            return transferProcess.getDataDestination();\n-        }\n-    }\n-\n-    private DataFlowResponse toResponse(DataAddress address) {\n-        return DataFlowResponse.Builder.newInstance().dataAddress(address).build();\n-    }\n-}\n```\n\nFilename: extensions/control-plane/transfer/transfer-data-plane/src/main/java/org/eclipse/edc/connector/controlplane/transfer/dataplane/flow/ProviderPushTransferDataFlowController.java:\n```\n@@ -1,116 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.controlplane.transfer.dataplane.flow;\n-\n-import org.eclipse.edc.connector.controlplane.asset.spi.domain.Asset;\n-import org.eclipse.edc.connector.controlplane.transfer.spi.flow.DataFlowController;\n-import org.eclipse.edc.connector.controlplane.transfer.spi.types.DataFlowResponse;\n-import org.eclipse.edc.connector.controlplane.transfer.spi.types.TransferProcess;\n-import org.eclipse.edc.connector.dataplane.selector.spi.DataPlaneSelectorService;\n-import org.eclipse.edc.connector.dataplane.selector.spi.client.DataPlaneClientFactory;\n-import org.eclipse.edc.connector.dataplane.selector.spi.instance.DataPlaneInstance;\n-import org.eclipse.edc.policy.model.Policy;\n-import org.eclipse.edc.spi.response.ResponseStatus;\n-import org.eclipse.edc.spi.response.StatusResult;\n-import org.eclipse.edc.spi.types.domain.transfer.DataFlowStartMessage;\n-import org.eclipse.edc.web.spi.configuration.context.ControlApiUrl;\n-import org.jetbrains.annotations.NotNull;\n-\n-import java.util.Collection;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.UUID;\n-import java.util.function.Predicate;\n-\n-import static java.util.stream.Collectors.toSet;\n-import static org.eclipse.edc.connector.controlplane.transfer.dataplane.spi.TransferDataPlaneConstants.HTTP_PROXY;\n-import static org.eclipse.edc.spi.types.domain.transfer.FlowType.PULL;\n-import static org.eclipse.edc.spi.types.domain.transfer.FlowType.PUSH;\n-\n-@Deprecated(since = \"0.5.1\")\n-public class ProviderPushTransferDataFlowController implements DataFlowController {\n-\n-    private final ControlApiUrl callbackUrl;\n-    private final DataPlaneSelectorService selectorClient;\n-    private final DataPlaneClientFactory clientFactory;\n-\n-    private final Set<String> transferTypes = Set.of(\"%s-%s\".formatted(\"HttpData\", PULL));\n-\n-    public ProviderPushTransferDataFlowController(ControlApiUrl callbackUrl, DataPlaneSelectorService selectorClient, DataPlaneClientFactory clientFactory) {\n-        this.callbackUrl = callbackUrl;\n-        this.selectorClient = selectorClient;\n-        this.clientFactory = clientFactory;\n-    }\n-\n-    @Override\n-    public boolean canHandle(TransferProcess transferProcess) {\n-        // Backward compatibility: adds check if a transfer type is provided, it should not be Http-PULL\n-        return !HTTP_PROXY.equals(transferProcess.getDestinationType()) &&\n-                (Optional.ofNullable(transferProcess.getTransferType()).map(type -> !transferTypes.contains(type)).orElse(true));\n-\n-    }\n-\n-    @Override\n-    public @NotNull StatusResult<DataFlowResponse> start(TransferProcess transferProcess, Policy policy) {\n-        var dataFlowRequest = DataFlowStartMessage.Builder.newInstance()\n-                .id(UUID.randomUUID().toString())\n-                .processId(transferProcess.getId())\n-                .sourceDataAddress(transferProcess.getContentDataAddress())\n-                .destinationDataAddress(transferProcess.getDataDestination())\n-                .flowType(PUSH)\n-                .callbackAddress(callbackUrl != null ? callbackUrl.get() : null)\n-                .build();\n-\n-        var dataPlaneInstance = selectorClient.select(transferProcess.getContentDataAddress(), transferProcess.getDataDestination());\n-\n-        var dataPlaneInstanceId = dataPlaneInstance != null ? dataPlaneInstance.getId() : null;\n-        return clientFactory.createClient(dataPlaneInstance)\n-                .start(dataFlowRequest)\n-                .map(it -> DataFlowResponse.Builder.newInstance().dataPlaneId(dataPlaneInstanceId).build());\n-    }\n-\n-    @Override\n-    public StatusResult<Void> suspend(TransferProcess transferProcess) {\n-        throw new RuntimeException(\"not implemented\");\n-    }\n-\n-    @Override\n-    public StatusResult<Void> terminate(TransferProcess transferProcess) {\n-        return selectorClient.getAll().getContent().stream() // result is not evaluated because this class is deprecated\n-                .filter(dataPlaneInstanceFilter(transferProcess))\n-                .map(clientFactory::createClient)\n-                .map(client -> client.terminate(transferProcess.getId()))\n-                .reduce(StatusResult::merge)\n-                .orElse(StatusResult.failure(ResponseStatus.FATAL_ERROR, \"Failed to select the data plane for terminating the transfer process %s\".formatted(transferProcess.getId())));\n-    }\n-\n-    @Override\n-    public Set<String> transferTypesFor(Asset asset) {\n-        return selectorClient.getAll().getContent().stream() // result is not evaluated because this class is deprecated\n-                .filter(it -> it.getAllowedSourceTypes().contains(asset.getDataAddress().getType()))\n-                .map(DataPlaneInstance::getAllowedDestTypes)\n-                .flatMap(Collection::stream)\n-                .map(it -> \"%s-%s\".formatted(it, PUSH))\n-                .collect(toSet());\n-    }\n-\n-    private Predicate<DataPlaneInstance> dataPlaneInstanceFilter(TransferProcess transferProcess) {\n-        if (transferProcess.getDataPlaneId() != null) {\n-            return (dataPlaneInstance -> dataPlaneInstance.getId().equals(transferProcess.getDataPlaneId()));\n-        } else {\n-            return (d) -> true;\n-        }\n-    }\n-}\n```\n\nFilename: extensions/control-plane/transfer/transfer-data-plane/src/main/java/org/eclipse/edc/connector/controlplane/transfer/dataplane/proxy/ConsumerPullDataPlaneProxyResolver.java:\n```\n@@ -1,93 +0,0 @@\n-/*\n- *  Copyright (c) 2023 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.controlplane.transfer.dataplane.proxy;\n-\n-import jakarta.ws.rs.core.HttpHeaders;\n-import org.eclipse.edc.connector.controlplane.transfer.dataplane.spi.security.DataEncrypter;\n-import org.eclipse.edc.connector.controlplane.transfer.dataplane.spi.token.ConsumerPullTokenExpirationDateFunction;\n-import org.eclipse.edc.connector.controlplane.transfer.spi.types.TransferProcess;\n-import org.eclipse.edc.connector.dataplane.selector.spi.instance.DataPlaneInstance;\n-import org.eclipse.edc.spi.iam.TokenRepresentation;\n-import org.eclipse.edc.spi.result.Result;\n-import org.eclipse.edc.spi.types.TypeManager;\n-import org.eclipse.edc.spi.types.domain.DataAddress;\n-import org.eclipse.edc.spi.types.domain.edr.EndpointDataReference;\n-import org.eclipse.edc.token.spi.KeyIdDecorator;\n-import org.eclipse.edc.token.spi.TokenGenerationService;\n-\n-import java.util.Optional;\n-import java.util.function.Supplier;\n-\n-import static org.eclipse.edc.spi.constants.CoreConstants.EDC_NAMESPACE;\n-\n-@Deprecated(since = \"0.5.1\")\n-public class ConsumerPullDataPlaneProxyResolver {\n-\n-    private static final String PUBLIC_API_URL_PROPERTY_DEPRECATED = \"publicApiUrl\";\n-    private static final String PUBLIC_API_URL_PROPERTY = EDC_NAMESPACE + \"publicApiUrl\";\n-\n-    private final DataEncrypter dataEncrypter;\n-    private final TypeManager typeManager;\n-    private final TokenGenerationService tokenGenerationService;\n-    private final Supplier<String> privateKeyIdSupplier;\n-    private final Supplier<String> publicKeyIdSupplier;\n-    private final ConsumerPullTokenExpirationDateFunction tokenExpirationDateFunction;\n-\n-    public ConsumerPullDataPlaneProxyResolver(DataEncrypter dataEncrypter, TypeManager typeManager, TokenGenerationService tokenGenerationService,\n-                                              Supplier<String> privateKeyIdSupplier, Supplier<String> publicKeyIdSupplier,\n-                                              ConsumerPullTokenExpirationDateFunction tokenExpirationDateFunction) {\n-        this.dataEncrypter = dataEncrypter;\n-        this.typeManager = typeManager;\n-        this.tokenExpirationDateFunction = tokenExpirationDateFunction;\n-        this.tokenGenerationService = tokenGenerationService;\n-        this.privateKeyIdSupplier = privateKeyIdSupplier;\n-        this.publicKeyIdSupplier = publicKeyIdSupplier;\n-    }\n-\n-    private static Object getPublicApiUrl(DataPlaneInstance instance) {\n-        return Optional.ofNullable(instance.getProperties().get(PUBLIC_API_URL_PROPERTY))\n-                .orElseGet(() -> instance.getProperties().get(PUBLIC_API_URL_PROPERTY_DEPRECATED));\n-    }\n-\n-    public Result<DataAddress> toDataAddress(TransferProcess transferProcess, DataAddress address, DataPlaneInstance instance) {\n-        return resolveProxyUrl(instance)\n-                .compose(proxyUrl -> generateAccessToken(address, transferProcess.getContractId())\n-                        .map(token -> DataAddress.Builder.newInstance()\n-                                .type(EndpointDataReference.EDR_SIMPLE_TYPE)\n-                                .property(EndpointDataReference.ID, transferProcess.getCorrelationId())\n-                                .property(EndpointDataReference.CONTRACT_ID, transferProcess.getContractId())\n-                                .property(EndpointDataReference.ENDPOINT, proxyUrl)\n-                                .property(EndpointDataReference.AUTH_KEY, HttpHeaders.AUTHORIZATION)\n-                                .property(EndpointDataReference.AUTH_CODE, token)\n-                                .build()));\n-    }\n-\n-    private Result<String> resolveProxyUrl(DataPlaneInstance instance) {\n-        return Optional.ofNullable(getPublicApiUrl(instance))\n-                .map(url -> Result.success((String) url))\n-                .orElse(Result.failure(String.format(\"Missing property `%s` (deprecated: `%s`) in DataPlaneInstance\", PUBLIC_API_URL_PROPERTY, PUBLIC_API_URL_PROPERTY_DEPRECATED)));\n-    }\n-\n-    private Result<String> generateAccessToken(DataAddress source, String contractId) {\n-        var encryptedDataAddress = dataEncrypter.encrypt(typeManager.writeValueAsString(source));\n-        return tokenExpirationDateFunction.expiresAt(source, contractId)\n-                .compose(expiration -> {\n-                    var keyIdDecorator = new KeyIdDecorator(publicKeyIdSupplier.get());\n-                    var dataAddressDecorator = new ConsumerPullDataPlaneProxyTokenDecorator(expiration, encryptedDataAddress);\n-                    return tokenGenerationService.generate(privateKeyIdSupplier.get(), keyIdDecorator, dataAddressDecorator);\n-                })\n-                .map(TokenRepresentation::getToken);\n-    }\n-}\n```\n\nFilename: extensions/control-plane/transfer/transfer-data-plane/src/main/java/org/eclipse/edc/connector/controlplane/transfer/dataplane/proxy/ConsumerPullDataPlaneProxyTokenDecorator.java:\n```\n@@ -1,45 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.controlplane.transfer.dataplane.proxy;\n-\n-import org.eclipse.edc.spi.iam.TokenParameters;\n-import org.eclipse.edc.token.spi.TokenDecorator;\n-\n-import java.util.Date;\n-\n-import static com.nimbusds.jwt.JWTClaimNames.EXPIRATION_TIME;\n-import static org.eclipse.edc.connector.controlplane.transfer.dataplane.spi.TransferDataPlaneConstants.DATA_ADDRESS;\n-\n-/**\n- * Decorator for access token used in input of Data Plane public API. The token is composed of:\n- * - a contract id (used to check if contract between consumer and provider is still valid).\n- * - the address of the data source formatted as an encrypted string.\n- */\n-class ConsumerPullDataPlaneProxyTokenDecorator implements TokenDecorator {\n-\n-    private final Date expirationDate;\n-    private final String encryptedDataAddress;\n-\n-    ConsumerPullDataPlaneProxyTokenDecorator(Date expirationDate, String encryptedDataAddress) {\n-        this.expirationDate = expirationDate;\n-        this.encryptedDataAddress = encryptedDataAddress;\n-    }\n-\n-    @Override\n-    public TokenParameters.Builder decorate(TokenParameters.Builder tokenParameters) {\n-        return tokenParameters.claims(EXPIRATION_TIME, expirationDate)\n-                .claims(DATA_ADDRESS, encryptedDataAddress);\n-    }\n-}\n```\n\nFilename: extensions/control-plane/transfer/transfer-data-plane/src/main/java/org/eclipse/edc/connector/controlplane/transfer/dataplane/security/NoopDataEncrypter.java:\n```\n@@ -1,33 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - Initial implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.controlplane.transfer.dataplane.security;\n-\n-\n-import org.eclipse.edc.connector.controlplane.transfer.dataplane.spi.security.DataEncrypter;\n-\n-/**\n- * No-op implementation of {@link DataEncrypter}.\n- */\n-public class NoopDataEncrypter implements DataEncrypter {\n-    @Override\n-    public String encrypt(String raw) {\n-        return raw;\n-    }\n-\n-    @Override\n-    public String decrypt(String encrypted) {\n-        return encrypted;\n-    }\n-}\n```\n\nFilename: extensions/control-plane/transfer/transfer-data-plane/src/main/java/org/eclipse/edc/connector/controlplane/transfer/dataplane/validation/ExpirationDateValidationRule.java:\n```\n@@ -1,53 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.controlplane.transfer.dataplane.validation;\n-\n-import org.eclipse.edc.spi.iam.ClaimToken;\n-import org.eclipse.edc.spi.result.Result;\n-import org.eclipse.edc.token.spi.TokenValidationRule;\n-import org.jetbrains.annotations.NotNull;\n-import org.jetbrains.annotations.Nullable;\n-\n-import java.time.Clock;\n-import java.util.Map;\n-\n-import static com.nimbusds.jwt.JWTClaimNames.EXPIRATION_TIME;\n-\n-/**\n- * Assert that token containing these claims is not expired yet.\n- */\n-public class ExpirationDateValidationRule implements TokenValidationRule {\n-\n-    private final Clock clock;\n-\n-    public ExpirationDateValidationRule(Clock clock) {\n-        this.clock = clock;\n-    }\n-\n-    @Override\n-    public Result<Void> checkRule(@NotNull ClaimToken toVerify, @Nullable Map<String, Object> additional) {\n-        var expiration = toVerify.getInstantClaim(EXPIRATION_TIME);\n-        if (expiration == null) {\n-            return Result.failure(\"Missing expiration time in token\");\n-        }\n-\n-        // check contract expiration date\n-        if (clock.instant().isAfter(expiration)) {\n-            return Result.failure(\"Token has expired on \" + expiration);\n-        }\n-\n-        return Result.success();\n-    }\n-}\n```\n\nFilename: extensions/control-plane/transfer/transfer-data-plane/src/main/resources/META-INF/services/org.eclipse.edc.spi.system.ServiceExtension:\n```\n@@ -1,16 +0,0 @@\n-#\n-#  Copyright (c) 2022 Amadeus\n-#\n-#  This program and the accompanying materials are made available under the\n-#  terms of the Apache License, Version 2.0 which is available at\n-#  https://www.apache.org/licenses/LICENSE-2.0\n-#\n-#  SPDX-License-Identifier: Apache-2.0\n-#\n-#  Contributors:\n-#       Amadeus - initial API and implementation\n-#\n-#\n-\n-org.eclipse.edc.connector.controlplane.transfer.dataplane.TransferDataPlaneCoreExtension\n-org.eclipse.edc.connector.controlplane.transfer.dataplane.TransferDataPlaneDefaultServicesExtension\n\\ No newline at end of file\n```\n\nFilename: extensions/control-plane/transfer/transfer-data-plane/src/test/java/org/eclipse/edc/connector/controlplane/transfer/dataplane/TransferDataPlaneCoreExtensionTest.java:\n```\n@@ -1,99 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - Initial implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.controlplane.transfer.dataplane;\n-\n-import org.eclipse.edc.connector.controlplane.transfer.dataplane.api.ConsumerPullTransferTokenValidationApiController;\n-import org.eclipse.edc.connector.controlplane.transfer.dataplane.flow.ConsumerPullTransferDataFlowController;\n-import org.eclipse.edc.connector.controlplane.transfer.dataplane.flow.ProviderPushTransferDataFlowController;\n-import org.eclipse.edc.connector.controlplane.transfer.spi.flow.DataFlowManager;\n-import org.eclipse.edc.junit.extensions.DependencyInjectionExtension;\n-import org.eclipse.edc.spi.monitor.Monitor;\n-import org.eclipse.edc.spi.security.Vault;\n-import org.eclipse.edc.spi.system.ServiceExtensionContext;\n-import org.eclipse.edc.spi.system.configuration.Config;\n-import org.eclipse.edc.web.spi.WebService;\n-import org.eclipse.edc.web.spi.configuration.ApiContext;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.ExtendWith;\n-\n-import java.io.IOException;\n-import java.util.Objects;\n-\n-import static org.eclipse.edc.connector.controlplane.transfer.dataplane.TransferDataPlaneCoreExtension.TOKEN_SIGNER_PRIVATE_KEY_ALIAS;\n-import static org.eclipse.edc.connector.controlplane.transfer.dataplane.TransferDataPlaneCoreExtension.TOKEN_VERIFIER_PUBLIC_KEY_ALIAS;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.eq;\n-import static org.mockito.ArgumentMatchers.isA;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.never;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.verifyNoInteractions;\n-import static org.mockito.Mockito.when;\n-\n-@ExtendWith(DependencyInjectionExtension.class)\n-class TransferDataPlaneCoreExtensionTest {\n-\n-    private final Vault vault = mock();\n-    private final WebService webService = mock();\n-    private final DataFlowManager dataFlowManager = mock();\n-    private final Monitor monitor = mock();\n-\n-    @BeforeEach\n-    public void setUp(ServiceExtensionContext context) {\n-        context.registerService(WebService.class, webService);\n-        context.registerService(DataFlowManager.class, dataFlowManager);\n-        context.registerService(Vault.class, vault);\n-\n-        when(context.getMonitor()).thenReturn(monitor);\n-    }\n-\n-    @Test\n-    void verifyInitializeSuccess(TransferDataPlaneCoreExtension extension, ServiceExtensionContext context) throws IOException {\n-        var publicKeyAlias = \"publicKey\";\n-        var privateKeyAlias = \"privateKey\";\n-        var config = mock(Config.class);\n-        when(context.getConfig()).thenReturn(config);\n-        when(config.getString(TOKEN_VERIFIER_PUBLIC_KEY_ALIAS, null)).thenReturn(publicKeyAlias);\n-        when(config.getString(TOKEN_SIGNER_PRIVATE_KEY_ALIAS, null)).thenReturn(privateKeyAlias);\n-        when(vault.resolveSecret(publicKeyAlias)).thenReturn(publicKeyPem());\n-\n-        extension.initialize(context);\n-\n-        verify(dataFlowManager).register(any(ConsumerPullTransferDataFlowController.class));\n-        verify(dataFlowManager).register(any(ProviderPushTransferDataFlowController.class));\n-        verify(webService).registerResource(eq(ApiContext.CONTROL), any(ConsumerPullTransferTokenValidationApiController.class));\n-    }\n-\n-    @Test\n-    void shouldNotRegisterConsumerPullControllers_whenSettingsAreMissing(TransferDataPlaneCoreExtension extension, ServiceExtensionContext context) {\n-        var config = mock(Config.class);\n-        when(context.getConfig()).thenReturn(config);\n-        when(config.getString(TOKEN_VERIFIER_PUBLIC_KEY_ALIAS, null)).thenReturn(null);\n-        when(config.getString(TOKEN_SIGNER_PRIVATE_KEY_ALIAS, null)).thenReturn(null);\n-\n-        extension.initialize(context);\n-\n-        verify(dataFlowManager, never()).register(isA(ConsumerPullTransferDataFlowController.class));\n-        verifyNoInteractions(webService);\n-        verify(monitor).info(any(String.class));\n-    }\n-\n-    private String publicKeyPem() throws IOException {\n-        try (var resource = TransferDataPlaneCoreExtensionTest.class.getClassLoader().getResourceAsStream(\"rsa-pubkey.pem\")) {\n-            return new String(Objects.requireNonNull(resource).readAllBytes());\n-        }\n-    }\n-}\n```\n\nFilename: extensions/control-plane/transfer/transfer-data-plane/src/test/java/org/eclipse/edc/connector/controlplane/transfer/dataplane/api/ConsumerPullTransferTokenValidationApiControllerTest.java:\n```\n@@ -1,105 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - Initial implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.controlplane.transfer.dataplane.api;\n-\n-import org.eclipse.edc.connector.controlplane.transfer.dataplane.spi.security.DataEncrypter;\n-import org.eclipse.edc.json.JacksonTypeManager;\n-import org.eclipse.edc.keys.spi.PublicKeyResolver;\n-import org.eclipse.edc.spi.iam.ClaimToken;\n-import org.eclipse.edc.spi.result.Result;\n-import org.eclipse.edc.spi.types.TypeManager;\n-import org.eclipse.edc.spi.types.domain.DataAddress;\n-import org.eclipse.edc.token.spi.TokenValidationService;\n-import org.eclipse.edc.web.spi.exception.InvalidRequestException;\n-import org.eclipse.edc.web.spi.exception.NotAuthorizedException;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-\n-import java.util.Map;\n-import java.util.UUID;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n-import static org.eclipse.edc.connector.controlplane.transfer.dataplane.spi.TransferDataPlaneConstants.DATA_ADDRESS;\n-import static org.mockito.ArgumentMatchers.anyString;\n-import static org.mockito.ArgumentMatchers.eq;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.never;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.when;\n-\n-class ConsumerPullTransferTokenValidationApiControllerTest {\n-\n-    private static final TypeManager TYPE_MANAGER = new JacksonTypeManager();\n-\n-    private final DataEncrypter encrypterMock = mock(DataEncrypter.class);\n-    private final TokenValidationService tokenValidationServiceMock = mock(TokenValidationService.class);\n-    private final PublicKeyResolver publicKeyResolver = mock();\n-    private ConsumerPullTransferTokenValidationApiController controller;\n-\n-    @BeforeEach\n-    void setUp() {\n-        controller = new ConsumerPullTransferTokenValidationApiController(tokenValidationServiceMock, encrypterMock, TYPE_MANAGER, publicKeyResolver);\n-    }\n-\n-    @Test\n-    void verifyValidateSuccess() {\n-        var token = UUID.randomUUID().toString();\n-        var encryptedDataAddress = UUID.randomUUID().toString();\n-        var decryptedDataAddress = DataAddress.Builder.newInstance().type(UUID.randomUUID().toString()).build();\n-        var claims = ClaimToken.Builder.newInstance()\n-                .claims(Map.of(\n-                                \"key1\", \"value1\",\n-                                DATA_ADDRESS, encryptedDataAddress\n-                        )\n-                )\n-                .build();\n-\n-        when(tokenValidationServiceMock.validate(token, publicKeyResolver)).thenReturn(Result.success(claims));\n-        when(encrypterMock.decrypt(encryptedDataAddress)).thenReturn(TYPE_MANAGER.writeValueAsString(decryptedDataAddress));\n-\n-        var responseAddress = controller.validate(token);\n-        assertThat(responseAddress.getType()).isEqualTo(decryptedDataAddress.getType());\n-\n-        verify(tokenValidationServiceMock).validate(anyString(), eq(publicKeyResolver));\n-        verify(encrypterMock).decrypt(anyString());\n-    }\n-\n-    @Test\n-    void verifyTokenValidationFailureThrowsException() {\n-        var token = UUID.randomUUID().toString();\n-        var errorMsg = UUID.randomUUID().toString();\n-\n-        when(tokenValidationServiceMock.validate(token, publicKeyResolver)).thenReturn(Result.failure(errorMsg));\n-\n-        assertThatExceptionOfType(NotAuthorizedException.class).isThrownBy(() -> controller.validate(token));\n-\n-        verify(encrypterMock, never()).decrypt(anyString());\n-    }\n-\n-    @Test\n-    void verifyMissingAddressThrowsException() {\n-        var token = UUID.randomUUID().toString();\n-        var claims = ClaimToken.Builder.newInstance()\n-                .claims(Map.of(\"key1\", \"value1\"))\n-                .build();\n-\n-        when(tokenValidationServiceMock.validate(token, publicKeyResolver)).thenReturn(Result.success(claims));\n-\n-        assertThatExceptionOfType(InvalidRequestException.class).isThrownBy(() -> controller.validate(token));\n-\n-        verify(encrypterMock, never()).decrypt(anyString());\n-    }\n-}\n```\n\nFilename: extensions/control-plane/transfer/transfer-data-plane/src/test/java/org/eclipse/edc/connector/controlplane/transfer/dataplane/flow/ConsumerPullTransferDataFlowControllerTest.java:\n```\n@@ -1,166 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - Initial implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.controlplane.transfer.dataplane.flow;\n-\n-import org.eclipse.edc.connector.controlplane.asset.spi.domain.Asset;\n-import org.eclipse.edc.connector.controlplane.transfer.dataplane.proxy.ConsumerPullDataPlaneProxyResolver;\n-import org.eclipse.edc.connector.controlplane.transfer.spi.types.TransferProcess;\n-import org.eclipse.edc.connector.dataplane.selector.spi.DataPlaneSelectorService;\n-import org.eclipse.edc.connector.dataplane.selector.spi.instance.DataPlaneInstance;\n-import org.eclipse.edc.policy.model.Policy;\n-import org.eclipse.edc.spi.result.Failure;\n-import org.eclipse.edc.spi.result.Result;\n-import org.eclipse.edc.spi.types.domain.DataAddress;\n-import org.junit.jupiter.api.Test;\n-\n-import java.util.UUID;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.eclipse.edc.connector.controlplane.transfer.dataplane.spi.TransferDataPlaneConstants.HTTP_PROXY;\n-import static org.eclipse.edc.junit.assertions.AbstractResultAssert.assertThat;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.argThat;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.when;\n-\n-class ConsumerPullTransferDataFlowControllerTest {\n-\n-    private final DataPlaneSelectorService selectorService = mock();\n-    private final ConsumerPullDataPlaneProxyResolver resolver = mock();\n-\n-    private final ConsumerPullTransferDataFlowController flowController = new ConsumerPullTransferDataFlowController(selectorService, resolver);\n-\n-    private static final String HTTP_DATA_PULL = \"HttpData-PULL\";\n-\n-    @Test\n-    void verifyCanHandle() {\n-        assertThat(flowController.canHandle(transferProcess(HTTP_PROXY))).isTrue();\n-        assertThat(flowController.canHandle(transferProcess(HTTP_DATA_PULL, HTTP_DATA_PULL))).isTrue();\n-        assertThat(flowController.canHandle(transferProcess(HTTP_DATA_PULL, null))).isFalse();\n-        assertThat(flowController.canHandle(transferProcess(\"not-http-proxy\"))).isFalse();\n-    }\n-\n-    @Test\n-    void initiateFlow_success() {\n-        var proxyAddress = dataAddress();\n-        var instance = mock(DataPlaneInstance.class);\n-        var transferProcess = transferProcessBuilder(HTTP_PROXY)\n-                .contentDataAddress(dataAddress())\n-                .build();\n-\n-        when(selectorService.select(any(), argThat(destination -> destination.getType().equals(HTTP_PROXY)))).thenReturn(instance);\n-        when(resolver.toDataAddress(any(), any(), any())).thenReturn(Result.success(proxyAddress));\n-\n-        var result = flowController.start(transferProcess, null);\n-\n-        assertThat(result).isSucceeded().satisfies(response -> {\n-            assertThat(response.getDataAddress()).isEqualTo(proxyAddress);\n-        });\n-    }\n-\n-    @Test\n-    void initiateFlow_success_withTransferType() {\n-        var proxyAddress = dataAddress();\n-        var instance = mock(DataPlaneInstance.class);\n-        var transferProcess = transferProcessBuilder(HTTP_PROXY)\n-                .transferType(HTTP_DATA_PULL)\n-                .contentDataAddress(dataAddress())\n-                .build();\n-\n-        when(selectorService.select(any(), argThat(destination -> destination.getType().equals(HTTP_PROXY)))).thenReturn(instance);\n-        when(resolver.toDataAddress(any(), any(), any())).thenReturn(Result.success(proxyAddress));\n-\n-        var result = flowController.start(transferProcess, null);\n-\n-        assertThat(result).isSucceeded().satisfies(response -> {\n-            assertThat(response.getDataAddress()).isEqualTo(proxyAddress);\n-        });\n-    }\n-\n-    @Test\n-    void initiateFlow_returnsFailureIfNoDataPlaneInstance() {\n-        var transferProcess = transferProcessBuilder(HTTP_PROXY)\n-                .contentDataAddress(dataAddress())\n-                .build();\n-\n-        var result = flowController.start(transferProcess, null);\n-\n-\n-        assertThat(result).isFailed().extracting(Failure::getFailureDetail).asString()\n-                .isEqualTo(String.format(\"Failed to find DataPlaneInstance for source/destination: %s/%s\", transferProcess.getContentDataAddress().getType(), HTTP_PROXY));\n-    }\n-\n-    @Test\n-    void initiateFlow_returnsFailureIfAddressResolutionFails() {\n-        var errorMsg = \"Test Error Message\";\n-        var instance = mock(DataPlaneInstance.class);\n-        var transferProcess = transferProcessBuilder(HTTP_PROXY)\n-                .contentDataAddress(dataAddress())\n-                .build();\n-\n-        when(selectorService.select(any(), argThat(destination -> destination.getType().equals(HTTP_PROXY)))).thenReturn(instance);\n-        when(resolver.toDataAddress(any(), any(), any())).thenReturn(Result.failure(errorMsg));\n-\n-        var result = flowController.start(transferProcess, Policy.Builder.newInstance().build());\n-\n-        assertThat(result).isFailed().extracting(Failure::getFailureDetail).asString().contains(errorMsg);\n-    }\n-\n-    @Test\n-    void terminate_shouldAlwaysReturnSuccess() {\n-        var transferProcess = transferProcessBuilder(HTTP_PROXY)\n-                .contentDataAddress(dataAddress())\n-                .build();\n-\n-        var result = flowController.terminate(transferProcess);\n-\n-        assertThat(result).isSucceeded();\n-    }\n-\n-    @Test\n-    void transferTypes_shouldReturnHttpPull() {\n-        var asset = Asset.Builder.newInstance().dataAddress(DataAddress.Builder.newInstance().type(\"any\").build()).build();\n-\n-        var transferTypes = flowController.transferTypesFor(asset);\n-\n-        assertThat(transferTypes).hasSize(1).contains(HTTP_DATA_PULL);\n-    }\n-\n-    private TransferProcess transferProcess(String destinationType) {\n-        return transferProcess(destinationType, null);\n-    }\n-\n-    private TransferProcess.Builder transferProcessBuilder(String destinationType) {\n-        return TransferProcess.Builder.newInstance()\n-                .correlationId(UUID.randomUUID().toString())\n-                .protocol(\"protocol\")\n-                .contractId(UUID.randomUUID().toString())\n-                .assetId(UUID.randomUUID().toString())\n-                .counterPartyAddress(\"test.connector.address\")\n-                .dataDestination(DataAddress.Builder.newInstance().type(destinationType).build());\n-    }\n-\n-    private TransferProcess transferProcess(String destinationType, String transferType) {\n-        return transferProcessBuilder(destinationType)\n-                .transferType(transferType)\n-                .dataDestination(DataAddress.Builder.newInstance().type(destinationType).build())\n-                .build();\n-    }\n-\n-    private DataAddress dataAddress() {\n-        return DataAddress.Builder.newInstance().type(UUID.randomUUID().toString()).build();\n-    }\n-\n-}\n```\n\nFilename: extensions/control-plane/transfer/transfer-data-plane/src/test/java/org/eclipse/edc/connector/controlplane/transfer/dataplane/flow/ProviderPushTransferDataFlowControllerTest.java:\n```\n@@ -1,234 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - Initial implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.controlplane.transfer.dataplane.flow;\n-\n-import org.eclipse.edc.connector.controlplane.asset.spi.domain.Asset;\n-import org.eclipse.edc.connector.controlplane.transfer.spi.types.DataFlowResponse;\n-import org.eclipse.edc.connector.controlplane.transfer.spi.types.TransferProcess;\n-import org.eclipse.edc.connector.dataplane.selector.spi.DataPlaneSelectorService;\n-import org.eclipse.edc.connector.dataplane.selector.spi.client.DataPlaneClient;\n-import org.eclipse.edc.connector.dataplane.selector.spi.client.DataPlaneClientFactory;\n-import org.eclipse.edc.connector.dataplane.selector.spi.instance.DataPlaneInstance;\n-import org.eclipse.edc.policy.model.Policy;\n-import org.eclipse.edc.spi.response.ResponseStatus;\n-import org.eclipse.edc.spi.response.StatusResult;\n-import org.eclipse.edc.spi.result.ServiceResult;\n-import org.eclipse.edc.spi.types.domain.DataAddress;\n-import org.eclipse.edc.spi.types.domain.transfer.DataFlowResponseMessage;\n-import org.eclipse.edc.spi.types.domain.transfer.DataFlowStartMessage;\n-import org.jetbrains.annotations.NotNull;\n-import org.junit.jupiter.api.Test;\n-import org.mockito.ArgumentCaptor;\n-\n-import java.net.URI;\n-import java.util.List;\n-import java.util.UUID;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.eclipse.edc.connector.controlplane.transfer.dataplane.spi.TransferDataPlaneConstants.HTTP_PROXY;\n-import static org.eclipse.edc.junit.assertions.AbstractResultAssert.assertThat;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.when;\n-\n-class ProviderPushTransferDataFlowControllerTest {\n-\n-    private static final String HTTP_DATA_PULL = \"HttpData-PULL\";\n-    private final DataPlaneClient dataPlaneClient = mock();\n-    private final DataPlaneClientFactory dataPlaneClientFactory = mock();\n-    private final DataPlaneSelectorService selectorService = mock();\n-    private final ProviderPushTransferDataFlowController flowController =\n-            new ProviderPushTransferDataFlowController(() -> URI.create(\"http://localhost\"), selectorService, dataPlaneClientFactory);\n-\n-    @NotNull\n-    private static DataPlaneInstance.Builder dataPlaneInstanceBuilder() {\n-        return DataPlaneInstance.Builder.newInstance().url(\"http://any\");\n-    }\n-\n-    @Test\n-    void canHandle() {\n-        assertThat(flowController.canHandle(transferProcess(HTTP_PROXY))).isFalse();\n-        assertThat(flowController.canHandle(transferProcess(HTTP_PROXY))).isFalse();\n-        assertThat(flowController.canHandle(transferProcess(HTTP_DATA_PULL, HTTP_DATA_PULL))).isFalse();\n-        assertThat(flowController.canHandle(transferProcess(\"not-http-proxy\"))).isTrue();\n-    }\n-\n-    @Test\n-    void initiateFlow_transferSuccess() {\n-        var source = testDataAddress();\n-        var transferProcess = transferProcessBuilder(\"test\")\n-                .contentDataAddress(testDataAddress())\n-                .build();\n-\n-        when(dataPlaneClient.start(any(DataFlowStartMessage.class))).thenReturn(StatusResult.success(mock(DataFlowResponseMessage.class)));\n-        var dataPlaneInstance = createDataPlaneInstance();\n-        when(selectorService.select(any(), any())).thenReturn(dataPlaneInstance);\n-        when(dataPlaneClientFactory.createClient(any())).thenReturn(dataPlaneClient);\n-\n-        var result = flowController.start(transferProcess, Policy.Builder.newInstance().build());\n-\n-        assertThat(result).isSucceeded().extracting(DataFlowResponse::getDataPlaneId).isEqualTo(dataPlaneInstance.getId());\n-        var captor = ArgumentCaptor.forClass(DataFlowStartMessage.class);\n-        verify(dataPlaneClient).start(captor.capture());\n-        var captured = captor.getValue();\n-        assertThat(captured.getProcessId()).isEqualTo(transferProcess.getId());\n-        assertThat(captured.getSourceDataAddress()).usingRecursiveComparison().isEqualTo(source);\n-        assertThat(captured.getDestinationDataAddress()).usingRecursiveComparison().isEqualTo(transferProcess.getDataDestination());\n-        assertThat(captured.getProperties()).isEmpty();\n-        assertThat(captured.getCallbackAddress()).isNotNull();\n-    }\n-\n-    @Test\n-    void initiateFlow_transferSuccess_withoutDataPlane() {\n-        var source = testDataAddress();\n-        var transferProcess = transferProcessBuilder(\"test\")\n-                .contentDataAddress(testDataAddress())\n-                .build();\n-\n-        when(dataPlaneClient.start(any(DataFlowStartMessage.class))).thenReturn(StatusResult.success(mock(DataFlowResponseMessage.class)));\n-        when(selectorService.select(any(), any())).thenReturn(null);\n-        when(dataPlaneClientFactory.createClient(any())).thenReturn(dataPlaneClient);\n-\n-        var result = flowController.start(transferProcess, Policy.Builder.newInstance().build());\n-\n-        assertThat(result).isSucceeded().extracting(DataFlowResponse::getDataPlaneId).isNull();\n-        var captor = ArgumentCaptor.forClass(DataFlowStartMessage.class);\n-        verify(dataPlaneClient).start(captor.capture());\n-        var captured = captor.getValue();\n-        assertThat(captured.getProcessId()).isEqualTo(transferProcess.getId());\n-        assertThat(captured.getSourceDataAddress()).usingRecursiveComparison().isEqualTo(source);\n-        assertThat(captured.getDestinationDataAddress()).usingRecursiveComparison().isEqualTo(transferProcess.getDataDestination());\n-        assertThat(captured.getProperties()).isEmpty();\n-        assertThat(captured.getCallbackAddress()).isNotNull();\n-    }\n-\n-    @Test\n-    void initiateFlow_returnFailedResultIfTransferFails() {\n-        var errorMsg = \"error\";\n-        var transferProcess = transferProcessBuilder(\"test\")\n-                .contentDataAddress(testDataAddress())\n-                .build();\n-\n-        when(dataPlaneClient.start(any())).thenReturn(StatusResult.failure(ResponseStatus.FATAL_ERROR, errorMsg));\n-        var dataPlaneInstance = createDataPlaneInstance();\n-        when(selectorService.select(any(), any())).thenReturn(dataPlaneInstance);\n-        when(dataPlaneClientFactory.createClient(any())).thenReturn(dataPlaneClient);\n-\n-        var result = flowController.start(transferProcess, Policy.Builder.newInstance().build());\n-\n-        verify(dataPlaneClient).start(any());\n-\n-        assertThat(result.failed()).isTrue();\n-        assertThat(result.getFailureMessages()).allSatisfy(s -> assertThat(s).contains(errorMsg));\n-    }\n-\n-    @Test\n-    void terminate_shouldCallTerminate() {\n-        var transferProcess = transferProcessBuilder(\"test\")\n-                .id(\"transferProcessId\")\n-                .contentDataAddress(testDataAddress())\n-                .build();\n-        when(dataPlaneClient.terminate(any())).thenReturn(StatusResult.success());\n-        var dataPlaneInstance = createDataPlaneInstance();\n-        when(dataPlaneClientFactory.createClient(any())).thenReturn(dataPlaneClient);\n-        when(selectorService.getAll()).thenReturn(ServiceResult.success(List.of(dataPlaneInstance)));\n-\n-        var result = flowController.terminate(transferProcess);\n-\n-        assertThat(result).isSucceeded();\n-        verify(dataPlaneClient).terminate(\"transferProcessId\");\n-    }\n-\n-    @Test\n-    void terminate_shouldCallTerminateOnTheRightDataPlane() {\n-        var dataPlaneInstance = createDataPlaneInstance();\n-        var mockedDataPlane = mock(DataPlaneInstance.class);\n-        var transferProcess = transferProcessBuilder(\"test\")\n-                .id(\"transferProcessId\")\n-                .contentDataAddress(testDataAddress())\n-                .dataPlaneId(dataPlaneInstance.getId())\n-                .build();\n-        when(mockedDataPlane.getId()).thenReturn(\"notValidId\");\n-        when(dataPlaneClient.terminate(any())).thenReturn(StatusResult.success());\n-        when(dataPlaneClientFactory.createClient(any())).thenReturn(dataPlaneClient);\n-        when(selectorService.getAll()).thenReturn(ServiceResult.success(List.of(dataPlaneInstance, mockedDataPlane)));\n-\n-        var result = flowController.terminate(transferProcess);\n-\n-        assertThat(result).isSucceeded();\n-        verify(dataPlaneClient).terminate(\"transferProcessId\");\n-        verify(mockedDataPlane).getId();\n-    }\n-\n-    @Test\n-    void terminate_shouldFail_withInvalidDataPlaneId() {\n-        var dataPlaneInstance = createDataPlaneInstance();\n-        var transferProcess = transferProcessBuilder(\"test\")\n-                .id(\"transferProcessId\")\n-                .contentDataAddress(testDataAddress())\n-                .dataPlaneId(\"invalid\")\n-                .build();\n-        when(dataPlaneClient.terminate(any())).thenReturn(StatusResult.success());\n-        when(dataPlaneClientFactory.createClient(any())).thenReturn(dataPlaneClient);\n-        when(selectorService.getAll()).thenReturn(ServiceResult.success(List.of(dataPlaneInstance)));\n-\n-        var result = flowController.terminate(transferProcess);\n-\n-        assertThat(result).isFailed().detail().contains(\"Failed to select the data plane for terminating the transfer process\");\n-    }\n-\n-    @Test\n-    void transferTypes_shouldReturnTypesForSpecifiedAsset() {\n-        when(selectorService.getAll()).thenReturn(ServiceResult.success(List.of(\n-                dataPlaneInstanceBuilder().allowedSourceType(\"TargetSrc\").allowedDestType(\"TargetDest\").build(),\n-                dataPlaneInstanceBuilder().allowedSourceType(\"TargetSrc\").allowedDestType(\"AnotherTargetDest\").build(),\n-                dataPlaneInstanceBuilder().allowedSourceType(\"AnotherSrc\").allowedDestType(\"ThisWontBeListed\").build()\n-        )));\n-        var asset = Asset.Builder.newInstance().dataAddress(DataAddress.Builder.newInstance().type(\"TargetSrc\").build()).build();\n-\n-        var transferTypes = flowController.transferTypesFor(asset);\n-\n-        assertThat(transferTypes).containsExactly(\"TargetDest-PUSH\", \"AnotherTargetDest-PUSH\");\n-    }\n-\n-    private DataPlaneInstance createDataPlaneInstance() {\n-        return dataPlaneInstanceBuilder().build();\n-    }\n-\n-    private DataAddress testDataAddress() {\n-        return DataAddress.Builder.newInstance().type(\"test-type\").build();\n-    }\n-\n-    private TransferProcess transferProcess(String destinationType) {\n-        return transferProcess(destinationType, null);\n-    }\n-\n-    private TransferProcess transferProcess(String destinationType, String transferType) {\n-        return transferProcessBuilder(destinationType)\n-                .transferType(transferType)\n-                .build();\n-    }\n-\n-    private TransferProcess.Builder transferProcessBuilder(String destinationType) {\n-        return TransferProcess.Builder.newInstance()\n-                .correlationId(UUID.randomUUID().toString())\n-                .protocol(\"test-protocol\")\n-                .contractId(UUID.randomUUID().toString())\n-                .assetId(UUID.randomUUID().toString())\n-                .counterPartyAddress(\"test.connector.address\")\n-                .dataDestination(DataAddress.Builder.newInstance().type(destinationType).build());\n-    }\n-}\n```\n\nFilename: extensions/control-plane/transfer/transfer-data-plane/src/test/java/org/eclipse/edc/connector/controlplane/transfer/dataplane/proxy/ConsumerPullDataPlaneProxyResolverTest.java:\n```\n@@ -1,177 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.controlplane.transfer.dataplane.proxy;\n-\n-import jakarta.ws.rs.core.HttpHeaders;\n-import org.eclipse.edc.connector.controlplane.transfer.dataplane.spi.security.DataEncrypter;\n-import org.eclipse.edc.connector.controlplane.transfer.dataplane.spi.token.ConsumerPullTokenExpirationDateFunction;\n-import org.eclipse.edc.connector.controlplane.transfer.spi.types.TransferProcess;\n-import org.eclipse.edc.connector.dataplane.selector.spi.instance.DataPlaneInstance;\n-import org.eclipse.edc.json.JacksonTypeManager;\n-import org.eclipse.edc.spi.iam.TokenParameters;\n-import org.eclipse.edc.spi.iam.TokenRepresentation;\n-import org.eclipse.edc.spi.result.Result;\n-import org.eclipse.edc.spi.types.TypeManager;\n-import org.eclipse.edc.spi.types.domain.DataAddress;\n-import org.eclipse.edc.spi.types.domain.edr.EndpointDataReference;\n-import org.eclipse.edc.token.spi.TokenDecorator;\n-import org.eclipse.edc.token.spi.TokenGenerationService;\n-import org.junit.jupiter.api.Test;\n-import org.mockito.ArgumentCaptor;\n-\n-import java.sql.Date;\n-import java.time.Instant;\n-import java.util.UUID;\n-\n-import static com.nimbusds.jwt.JWTClaimNames.EXPIRATION_TIME;\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.eclipse.edc.connector.controlplane.transfer.dataplane.spi.TransferDataPlaneConstants.DATA_ADDRESS;\n-import static org.eclipse.edc.connector.controlplane.transfer.dataplane.spi.TransferDataPlaneConstants.HTTP_PROXY;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.anyString;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.when;\n-\n-class ConsumerPullDataPlaneProxyResolverTest {\n-\n-    private static final TypeManager TYPE_MANAGER = new JacksonTypeManager();\n-\n-    private final DataEncrypter dataEncrypter = mock();\n-    private final TokenGenerationService tokenGenerationService = mock();\n-    private final ConsumerPullTokenExpirationDateFunction tokenExpirationDateFunction = mock();\n-\n-    private final ConsumerPullDataPlaneProxyResolver resolver = new ConsumerPullDataPlaneProxyResolver(dataEncrypter, TYPE_MANAGER, tokenGenerationService, () -> \"test-private-key\", () -> \"test-public-key\", tokenExpirationDateFunction);\n-\n-    private static DataAddress dataAddress() {\n-        return DataAddress.Builder.newInstance().type(UUID.randomUUID().toString()).build();\n-    }\n-\n-    @Test\n-    void verifyToDataAddressSuccess() {\n-        var address = dataAddress();\n-        var encryptedAddress = \"encryptedAddress\";\n-        var expiration = Date.from(Instant.now().plusSeconds(100));\n-        var proxyUrl = \"test.proxy.url\";\n-        var token = \"token-test\";\n-        var instance = DataPlaneInstance.Builder.newInstance()\n-                .id(UUID.randomUUID().toString())\n-                .url(\"http://some.test.url\")\n-                .property(\"publicApiUrl\", proxyUrl)\n-                .build();\n-        var transferProcess = transferProcessBuilder().build();\n-\n-        var captor = ArgumentCaptor.forClass(TokenDecorator[].class);\n-        when(dataEncrypter.encrypt(TYPE_MANAGER.writeValueAsString(address))).thenReturn(encryptedAddress);\n-        when(tokenExpirationDateFunction.expiresAt(address, transferProcess.getContractId())).thenReturn(Result.success(expiration));\n-        when(tokenGenerationService.generate(anyString(), captor.capture()))\n-                .thenReturn(Result.success(TokenRepresentation.Builder.newInstance().token(token).build()));\n-\n-        var result = resolver.toDataAddress(transferProcess, address, instance);\n-\n-        assertThat(result.succeeded()).isTrue();\n-        var proxyAddress = result.getContent();\n-        assertThat(proxyAddress.getType()).isEqualTo(EndpointDataReference.EDR_SIMPLE_TYPE);\n-        assertThat(proxyAddress.getProperties())\n-                .containsEntry(EndpointDataReference.ID, transferProcess.getCorrelationId())\n-                .containsEntry(EndpointDataReference.CONTRACT_ID, transferProcess.getContractId())\n-                .containsEntry(EndpointDataReference.ENDPOINT, proxyUrl)\n-                .containsEntry(EndpointDataReference.AUTH_KEY, HttpHeaders.AUTHORIZATION)\n-                .containsEntry(EndpointDataReference.AUTH_CODE, token);\n-\n-        var decorators = captor.getValue();\n-\n-        assertThat(decorators)\n-                .anySatisfy(decorator -> {\n-                    var builder = TokenParameters.Builder.newInstance();\n-                    decorator.decorate(builder);\n-                    assertThat(builder.build().getClaims())\n-                            .containsEntry(DATA_ADDRESS, encryptedAddress)\n-                            .containsEntry(EXPIRATION_TIME, expiration);\n-                });\n-\n-        assertThat(decorators).anySatisfy(decorator -> {\n-            var builder = TokenParameters.Builder.newInstance();\n-            decorator.decorate(builder);\n-            assertThat(builder.build().getHeaders())\n-                    .containsEntry(\"kid\", \"test-public-key\");\n-        });\n-    }\n-\n-    @Test\n-    void verifyToDataAddressReturnsFailureIfMissingPublicApiUrl() {\n-        var instance = DataPlaneInstance.Builder.newInstance()\n-                .id(UUID.randomUUID().toString())\n-                .url(\"http://some.test.url\")\n-                .build();\n-        var transferProcess = transferProcessBuilder().build();\n-\n-        var result = resolver.toDataAddress(transferProcess, dataAddress(), instance);\n-\n-        assertThat(result.failed()).isTrue();\n-        assertThat(result.getFailureDetail()).isEqualTo(\"Missing property `https://w3id.org/edc/v0.0.1/ns/publicApiUrl` (deprecated: `publicApiUrl`) in DataPlaneInstance\");\n-    }\n-\n-    @Test\n-    void verifyToDataAddressReturnsFailureIfTokenExpirationDateFunctionFails() {\n-        var address = dataAddress();\n-        var errorMsg = \"error test\";\n-        var instance = DataPlaneInstance.Builder.newInstance()\n-                .id(UUID.randomUUID().toString())\n-                .url(\"http://some.test.url\")\n-                .property(\"publicApiUrl\", \"test.proxy.url\")\n-                .build();\n-        var transferProcess = transferProcessBuilder().build();\n-\n-        when(dataEncrypter.encrypt(TYPE_MANAGER.writeValueAsString(address))).thenReturn(\"encryptedAddress\");\n-        when(tokenExpirationDateFunction.expiresAt(any(), any())).thenReturn(Result.failure(errorMsg));\n-\n-        var result = resolver.toDataAddress(transferProcess, address, instance);\n-\n-        assertThat(result.failed()).isTrue();\n-        assertThat(result.getFailureDetail()).contains(errorMsg);\n-    }\n-\n-    @Test\n-    void verifyToDataAddressReturnsFailureIfTokenGenerationFails() {\n-        var address = dataAddress();\n-        var errorMsg = \"error test\";\n-        var transferProcess = transferProcessBuilder().build();\n-        var expiration = Date.from(Instant.now().plusSeconds(100));\n-        var instance = DataPlaneInstance.Builder.newInstance()\n-                .id(UUID.randomUUID().toString())\n-                .url(\"http://some.test.url\")\n-                .property(\"publicApiUrl\", \"test.proxy.url\")\n-                .build();\n-\n-        when(dataEncrypter.encrypt(TYPE_MANAGER.writeValueAsString(address))).thenReturn(\"encryptedAddress\");\n-        when(tokenExpirationDateFunction.expiresAt(address, transferProcess.getContractId())).thenReturn(Result.success(expiration));\n-        when(tokenGenerationService.generate(anyString(), any(TokenDecorator[].class))).thenReturn(Result.failure(errorMsg));\n-\n-        var result = resolver.toDataAddress(transferProcess, address, instance);\n-\n-        assertThat(result.failed()).isTrue();\n-        assertThat(result.getFailureDetail()).contains(errorMsg);\n-    }\n-\n-    private TransferProcess.Builder transferProcessBuilder() {\n-        return TransferProcess.Builder.newInstance()\n-                .correlationId(UUID.randomUUID().toString())\n-                .protocol(\"test-protocol\")\n-                .contractId(UUID.randomUUID().toString())\n-                .assetId(UUID.randomUUID().toString())\n-                .counterPartyAddress(\"test.connector.address\")\n-                .dataDestination(DataAddress.Builder.newInstance().type(HTTP_PROXY).build());\n-    }\n-}\n```\n\nFilename: extensions/control-plane/transfer/transfer-data-plane/src/test/java/org/eclipse/edc/connector/controlplane/transfer/dataplane/proxy/ConsumerPullDataPlaneProxyTokenDecoratorTest.java:\n```\n@@ -1,59 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.controlplane.transfer.dataplane.proxy;\n-\n-import org.eclipse.edc.spi.iam.TokenParameters;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-\n-import java.time.Instant;\n-import java.util.Date;\n-import java.util.HashMap;\n-import java.util.UUID;\n-import java.util.concurrent.ThreadLocalRandom;\n-\n-import static com.nimbusds.jwt.JWTClaimNames.EXPIRATION_TIME;\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.eclipse.edc.connector.controlplane.transfer.dataplane.spi.TransferDataPlaneConstants.DATA_ADDRESS;\n-\n-class ConsumerPullDataPlaneProxyTokenDecoratorTest {\n-\n-    private Date expiration;\n-    private String encryptedDataAddress;\n-\n-    private ConsumerPullDataPlaneProxyTokenDecorator decorator;\n-\n-    @BeforeEach\n-    public void setUp() {\n-        expiration = Date.from(Instant.now().plusSeconds(ThreadLocalRandom.current().nextInt(1, 10)));\n-        encryptedDataAddress = UUID.randomUUID().toString();\n-        decorator = new ConsumerPullDataPlaneProxyTokenDecorator(expiration, encryptedDataAddress);\n-    }\n-\n-    @Test\n-    void verifyDecorate() {\n-\n-        var headers = new HashMap<String, Object>();\n-        var claims = new HashMap<String, Object>();\n-        var b = TokenParameters.Builder.newInstance();\n-        decorator.decorate(b);\n-\n-\n-        assertThat(b.build().getHeaders()).isEmpty();\n-        assertThat(b.build().getClaims())\n-                .containsEntry(DATA_ADDRESS, encryptedDataAddress)\n-                .containsEntry(EXPIRATION_TIME, expiration);\n-    }\n-}\n\\ No newline at end of file\n```\n\nFilename: extensions/control-plane/transfer/transfer-data-plane/src/test/java/org/eclipse/edc/connector/controlplane/transfer/dataplane/validation/ExpirationDateValidationRuleTest.java:\n```\n@@ -1,67 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Bayerische Motoren Werke Aktiengesellschaft (BMW AG)\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Bayerische Motoren Werke Aktiengesellschaft (BMW AG) - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.controlplane.transfer.dataplane.validation;\n-\n-import org.eclipse.edc.spi.iam.ClaimToken;\n-import org.eclipse.edc.spi.result.Result;\n-import org.junit.jupiter.api.Test;\n-\n-import java.sql.Date;\n-import java.time.Clock;\n-import java.time.Instant;\n-\n-import static com.nimbusds.jwt.JWTClaimNames.EXPIRATION_TIME;\n-import static java.time.ZoneOffset.UTC;\n-import static java.util.Collections.emptyMap;\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-class ExpirationDateValidationRuleTest {\n-\n-    private final Instant now = Instant.now();\n-    private final ExpirationDateValidationRule rule = new ExpirationDateValidationRule(Clock.fixed(now, UTC));\n-\n-    @Test\n-    void failsWithoutExpiration() {\n-        var token = ClaimToken.Builder.newInstance().build();\n-\n-        var result = rule.checkRule(token, emptyMap());\n-\n-        assertThat(result).matches(Result::failed)\n-                .extracting(Result::getFailureDetail).isEqualTo(\"Missing expiration time in token\");\n-    }\n-\n-    @Test\n-    void failsIfTokenIsExpired() {\n-        var token = ClaimToken.Builder.newInstance()\n-                .claim(EXPIRATION_TIME, Date.from(now))\n-                .build();\n-\n-        var result = rule.checkRule(token, emptyMap());\n-\n-        assertThat(result).matches(Result::failed)\n-                .extracting(Result::getFailureDetail).asString().startsWith(\"Token has expired on\");\n-    }\n-\n-    @Test\n-    void succeedIfTokenIsNotExpired() {\n-        var token = ClaimToken.Builder.newInstance()\n-                .claim(EXPIRATION_TIME, Date.from(now.plusMillis(1)))\n-                .build();\n-\n-        var result = rule.checkRule(token, emptyMap());\n-\n-        assertThat(result).matches(Result::succeeded);\n-    }\n-}\n\\ No newline at end of file\n```\n\nFilename: extensions/control-plane/transfer/transfer-data-plane/src/test/resources/rsa-pubkey.pem:\n```\n@@ -1,9 +0,0 @@\n------BEGIN PUBLIC KEY-----\n-MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAi4zQvCGMlQ0N7wsKIU8N\n-5aExdhxPPiFqUvV27+WtbPdREEVAmOESUeW00+JO2EBSjuIf4ny4yCRhykr8CjqQ\n-HFN+ehXaTjw8HyOK7izbExdMe0Bb+SoNcduYL6KRLqUp4QF5fym0vTulRPQ/lT3n\n-IVUfh4BoEasiWc+cP/7y0qDtsjmiDlPUTRi6UJJHDOokS1P800weSRbDMQmX3zFO\n-+fztK6zklnbBhuZHjmnuIvqKncFvAgs2ZQkuYEhz/dWAqs5Jepyy4S7SZ4stvHzJ\n-zpwimRHWJEm0XEK56wrGt7V5j63fXvl72KpncWyNHm+2Obru1OrPBGaHm0kNZnCi\n-jwIDAQAB\n------END PUBLIC KEY-----\n\\ No newline at end of file\n```\n\nFilename: extensions/data-plane/data-plane-client-embedded/build.gradle.kts:\n```\n@@ -1,32 +0,0 @@\n-/*\n- *  Copyright (c) 2024 Bayerische Motoren Werke Aktiengesellschaft (BMW AG)\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Bayerische Motoren Werke Aktiengesellschaft (BMW AG) - initial API and implementation\n- *\n- */\n-\n-\n-plugins {\n-    `java-library`\n-}\n-\n-dependencies {\n-    api(project(\":spi:data-plane:data-plane-spi\"))\n-    api(project(\":spi:data-plane-selector:data-plane-selector-spi\"))\n-\n-    implementation(libs.opentelemetry.instrumentation.annotations)\n-\n-    testImplementation(project(\":core:common:junit\"))\n-    testImplementation(libs.restAssured)\n-    testImplementation(libs.mockserver.netty)\n-    testImplementation(libs.mockserver.client)\n-}\n-\n-\n```\n\nFilename: extensions/data-plane/data-plane-client/build.gradle.kts:\n```\n@@ -1,39 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Microsoft Corporation\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Microsoft Corporation - initial API and implementation\n- *       Bayerische Motoren Werke Aktiengesellschaft (BMW AG) - improvements\n- *\n- */\n-\n-\n-plugins {\n-    `java-library`\n-}\n-\n-dependencies {\n-    api(project(\":spi:common:auth-spi\"))\n-    api(project(\":spi:common:http-spi\"))\n-    api(project(\":spi:data-plane:data-plane-spi\"))\n-    api(project(\":spi:data-plane-selector:data-plane-selector-spi\"))\n-    implementation(project(\":core:common:lib:util-lib\"))\n-    implementation(project(\":extensions:data-plane:data-plane-client-embedded\"))\n-\n-    implementation(libs.opentelemetry.instrumentation.annotations)\n-\n-    testImplementation(project(\":core:common:junit\"))\n-    testImplementation(libs.restAssured)\n-    testImplementation(libs.mockserver.netty)\n-    testImplementation(libs.mockserver.client)\n-\n-    testImplementation(testFixtures(project(\":core:common:lib:http-lib\")))\n-}\n-\n-\n```\n\nFilename: extensions/data-plane/data-plane-client/src/main/java/org/eclipse/edc/connector/dataplane/client/DataPlaneClientExtension.java:\n```\n@@ -1,68 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Microsoft Corporation\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Microsoft Corporation - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.dataplane.client;\n-\n-import org.eclipse.edc.connector.dataplane.selector.spi.client.DataPlaneClientFactory;\n-import org.eclipse.edc.connector.dataplane.spi.manager.DataPlaneManager;\n-import org.eclipse.edc.http.spi.ControlApiHttpClient;\n-import org.eclipse.edc.runtime.metamodel.annotation.Extension;\n-import org.eclipse.edc.runtime.metamodel.annotation.Inject;\n-import org.eclipse.edc.runtime.metamodel.annotation.Provider;\n-import org.eclipse.edc.spi.system.ServiceExtension;\n-import org.eclipse.edc.spi.system.ServiceExtensionContext;\n-import org.eclipse.edc.spi.types.TypeManager;\n-\n-import java.util.Objects;\n-\n-/**\n- * This extension provides the Data Plane API:\n- * - Control API: set of endpoints to trigger/monitor/cancel data transfers that should be accessible only from the Control Plane.\n- * - Public API: generic endpoint open to other participants of the Dataspace and used to proxy a data request to the actual data source.\n- *\n- * @deprecated replaced by data-plane-signaling.\n- */\n-@Extension(value = DataPlaneClientExtension.NAME)\n-@Deprecated(since = \"0.6.0\")\n-public class DataPlaneClientExtension implements ServiceExtension {\n-    public static final String NAME = \"DEPRECATED: Data Plane Client\";\n-\n-    @Inject(required = false)\n-    private DataPlaneManager dataPlaneManager;\n-    @Inject(required = false)\n-    private ControlApiHttpClient httpClient;\n-    @Inject\n-    private TypeManager typeManager;\n-\n-    @Override\n-    public String name() {\n-        return NAME;\n-    }\n-\n-    @Provider\n-    public DataPlaneClientFactory dataPlaneClientFactory(ServiceExtensionContext context) {\n-        context.getMonitor().warning(\"the `data-plane-client` extension has been deprecated, please switch to data-plane-signaling\");\n-        if (dataPlaneManager != null) {\n-            // Data plane manager is embedded in the current runtime\n-            context.getMonitor().debug(() -> \"Using embedded Data Plane client.\");\n-            return instance -> new EmbeddedDataPlaneClient(dataPlaneManager);\n-        }\n-\n-        context.getMonitor().debug(() -> \"Using remote Data Plane client.\");\n-        Objects.requireNonNull(httpClient, \"To use remote Data Plane client, a ControlApiHttpClient instance must be registered\");\n-        return instance -> new RemoteDataPlaneClient(httpClient, typeManager.getMapper(), instance);\n-    }\n-}\n-\n-\n```\n\nFilename: extensions/data-plane/data-plane-client/src/main/java/org/eclipse/edc/connector/dataplane/client/RemoteDataPlaneClient.java:\n```\n@@ -1,86 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.dataplane.client;\n-\n-import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import io.opentelemetry.instrumentation.annotations.WithSpan;\n-import okhttp3.MediaType;\n-import okhttp3.Request;\n-import okhttp3.RequestBody;\n-import org.eclipse.edc.connector.dataplane.selector.spi.client.DataPlaneClient;\n-import org.eclipse.edc.connector.dataplane.selector.spi.instance.DataPlaneInstance;\n-import org.eclipse.edc.connector.dataplane.spi.manager.DataPlaneManager;\n-import org.eclipse.edc.http.spi.ControlApiHttpClient;\n-import org.eclipse.edc.spi.EdcException;\n-import org.eclipse.edc.spi.response.StatusResult;\n-import org.eclipse.edc.spi.types.domain.transfer.DataFlowResponseMessage;\n-import org.eclipse.edc.spi.types.domain.transfer.DataFlowStartMessage;\n-\n-import static org.eclipse.edc.spi.response.ResponseStatus.FATAL_ERROR;\n-\n-/**\n- * Implementation of a {@link DataPlaneClient} that uses a remote {@link DataPlaneManager} accessible from a REST API.\n- *\n- * @deprecated replaced by data-plane-signaling.\n- */\n-@Deprecated(since = \"0.6.0\")\n-public class RemoteDataPlaneClient implements DataPlaneClient {\n-    public static final MediaType TYPE_JSON = MediaType.parse(\"application/json\");\n-    private final ControlApiHttpClient httpClient;\n-    private final ObjectMapper mapper;\n-    private final DataPlaneInstance dataPlane;\n-\n-    public RemoteDataPlaneClient(ControlApiHttpClient httpClient, ObjectMapper mapper, DataPlaneInstance dataPlane) {\n-        this.httpClient = httpClient;\n-        this.mapper = mapper;\n-        this.dataPlane = dataPlane;\n-    }\n-\n-    @WithSpan\n-    @Override\n-    public StatusResult<DataFlowResponseMessage> start(DataFlowStartMessage dataFlowStartMessage) {\n-        RequestBody body;\n-        try {\n-            body = RequestBody.create(mapper.writeValueAsString(dataFlowStartMessage), TYPE_JSON);\n-        } catch (JsonProcessingException e) {\n-            throw new EdcException(e);\n-        }\n-        var builder = new Request.Builder().post(body).url(dataPlane.getUrl());\n-\n-        return httpClient.execute(builder)\n-                .map(it -> StatusResult.success(DataFlowResponseMessage.Builder.newInstance().build()))\n-                .orElse(f -> StatusResult.failure(FATAL_ERROR, f.getFailureDetail()));\n-    }\n-\n-    @Override\n-    public StatusResult<Void> suspend(String transferProcessId) {\n-        throw new RuntimeException(\"not implemented\");\n-    }\n-\n-    @Override\n-    public StatusResult<Void> terminate(String transferProcessId) {\n-        var builder = new Request.Builder().delete().url(dataPlane.getUrl() + \"/\" + transferProcessId);\n-\n-        return httpClient.execute(builder)\n-                .map(it -> StatusResult.success())\n-                .orElse(f -> StatusResult.failure(FATAL_ERROR, f.getFailureDetail()));\n-    }\n-\n-    @Override\n-    public StatusResult<Void> checkAvailability() {\n-        throw new UnsupportedOperationException(\"feature not implemented for deprecated client\");\n-    }\n-}\n```\n\nFilename: extensions/data-plane/data-plane-client/src/main/resources/META-INF/services/org.eclipse.edc.spi.system.ServiceExtension:\n```\n@@ -1 +0,0 @@\n-org.eclipse.edc.connector.dataplane.client.DataPlaneClientExtension\n```\n\nFilename: extensions/data-plane/data-plane-client/src/test/java/org/eclipse/edc/connector/dataplane/client/DataPlaneClientExtensionTest.java:\n```\n@@ -1,68 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.dataplane.client;\n-\n-import dev.failsafe.RetryPolicy;\n-import org.eclipse.edc.boot.system.injection.ObjectFactory;\n-import org.eclipse.edc.connector.dataplane.selector.spi.instance.DataPlaneInstance;\n-import org.eclipse.edc.connector.dataplane.spi.manager.DataPlaneManager;\n-import org.eclipse.edc.http.spi.EdcHttpClient;\n-import org.eclipse.edc.json.JacksonTypeManager;\n-import org.eclipse.edc.junit.extensions.DependencyInjectionExtension;\n-import org.eclipse.edc.spi.system.ServiceExtensionContext;\n-import org.eclipse.edc.spi.types.TypeManager;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.ExtendWith;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.mockito.Mockito.mock;\n-\n-@ExtendWith(DependencyInjectionExtension.class)\n-class DataPlaneClientExtensionTest {\n-\n-    @BeforeEach\n-    void setUp(ServiceExtensionContext context) {\n-        context.registerService(TypeManager.class, new JacksonTypeManager());\n-    }\n-\n-    @Test\n-    void verifyReturnEmbeddedClient(ServiceExtensionContext context, ObjectFactory factory) {\n-        context.registerService(DataPlaneManager.class, mock(DataPlaneManager.class));\n-\n-        var extension = factory.constructInstance(DataPlaneClientExtension.class);\n-\n-        var client = extension.dataPlaneClientFactory(context).createClient(createDataPlaneInstance());\n-\n-        assertThat(client).isInstanceOf(EmbeddedDataPlaneClient.class);\n-    }\n-\n-    @Test\n-    void verifyReturnRemoteClient(ServiceExtensionContext context, ObjectFactory factory) {\n-        context.registerService(DataPlaneManager.class, null);\n-        context.registerService(EdcHttpClient.class, mock(EdcHttpClient.class));\n-        context.registerService(RetryPolicy.class, mock(RetryPolicy.class));\n-\n-        var extension = factory.constructInstance(DataPlaneClientExtension.class);\n-\n-        var client = extension.dataPlaneClientFactory(context).createClient(createDataPlaneInstance());\n-\n-        assertThat(client).isInstanceOf(RemoteDataPlaneClient.class);\n-    }\n-\n-    private DataPlaneInstance createDataPlaneInstance() {\n-        return DataPlaneInstance.Builder.newInstance().url(\"http://any\").build();\n-    }\n-}\n```\n\nFilename: extensions/data-plane/data-plane-client/src/test/java/org/eclipse/edc/connector/dataplane/client/RemoteDataPlaneClientTest.java:\n```\n@@ -1,167 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.dataplane.client;\n-\n-import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import org.eclipse.edc.connector.dataplane.selector.spi.client.DataPlaneClient;\n-import org.eclipse.edc.connector.dataplane.selector.spi.instance.DataPlaneInstance;\n-import org.eclipse.edc.connector.dataplane.spi.response.TransferErrorResponse;\n-import org.eclipse.edc.http.client.ControlApiHttpClientImpl;\n-import org.eclipse.edc.http.spi.ControlApiHttpClient;\n-import org.eclipse.edc.json.JacksonTypeManager;\n-import org.eclipse.edc.spi.response.ResponseStatus;\n-import org.eclipse.edc.spi.types.domain.DataAddress;\n-import org.eclipse.edc.spi.types.domain.transfer.DataFlowStartMessage;\n-import org.junit.jupiter.api.AfterAll;\n-import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.api.Test;\n-import org.mockserver.integration.ClientAndServer;\n-import org.mockserver.model.HttpRequest;\n-import org.mockserver.model.HttpResponse;\n-import org.mockserver.model.HttpStatusCode;\n-import org.mockserver.model.MediaType;\n-import org.mockserver.verify.VerificationTimes;\n-\n-import java.util.List;\n-import java.util.UUID;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.eclipse.edc.http.client.testfixtures.HttpTestUtils.testHttpClient;\n-import static org.eclipse.edc.junit.assertions.AbstractResultAssert.assertThat;\n-import static org.eclipse.edc.util.io.Ports.getFreePort;\n-import static org.mockito.Mockito.mock;\n-import static org.mockserver.integration.ClientAndServer.startClientAndServer;\n-import static org.mockserver.matchers.Times.once;\n-import static org.mockserver.model.HttpRequest.request;\n-import static org.mockserver.model.HttpResponse.response;\n-import static org.mockserver.model.HttpStatusCode.CONFLICT_409;\n-import static org.mockserver.model.HttpStatusCode.NO_CONTENT_204;\n-import static org.mockserver.stop.Stop.stopQuietly;\n-\n-class RemoteDataPlaneClientTest {\n-\n-    private static final ObjectMapper MAPPER = new JacksonTypeManager().getMapper();\n-\n-    private static final int DATA_PLANE_API_PORT = getFreePort();\n-    private static final String DATA_PLANE_PATH = \"/transfer\";\n-    private static final String DATA_PLANE_API_URI = \"http://localhost:\" + DATA_PLANE_API_PORT + DATA_PLANE_PATH;\n-    private static ClientAndServer dataPlane;\n-    private final DataPlaneInstance instance = DataPlaneInstance.Builder.newInstance().url(DATA_PLANE_API_URI).build();\n-    private final ControlApiHttpClient httpClient = new ControlApiHttpClientImpl(testHttpClient(), mock());\n-\n-    private final DataPlaneClient dataPlaneClient = new RemoteDataPlaneClient(httpClient, MAPPER, instance);\n-\n-    @BeforeAll\n-    public static void setUp() {\n-        dataPlane = startClientAndServer(DATA_PLANE_API_PORT);\n-    }\n-\n-    @AfterAll\n-    public static void tearDown() {\n-        stopQuietly(dataPlane);\n-    }\n-\n-    @AfterEach\n-    public void resetMockServer() {\n-        dataPlane.reset();\n-    }\n-\n-    @Test\n-    void transfer_verifyReturnFatalErrorIfReceiveResponseWithNullBody() throws JsonProcessingException {\n-        var flowRequest = createDataFlowRequest();\n-\n-        var httpRequest = new HttpRequest().withPath(DATA_PLANE_PATH).withBody(MAPPER.writeValueAsString(flowRequest));\n-        dataPlane.when(request()).respond(response().withStatusCode(HttpStatusCode.BAD_REQUEST_400.code()));\n-\n-        var result = dataPlaneClient.start(flowRequest);\n-\n-        dataPlane.verify(httpRequest);\n-\n-        assertThat(result).isFailed().satisfies(failure -> {\n-            assertThat(failure.status()).isEqualTo(ResponseStatus.FATAL_ERROR);\n-            assertThat(failure.getMessages()).anySatisfy(s -> assertThat(s).contains(\"400\"));\n-        });\n-    }\n-\n-    @Test\n-    void transfer_verifyReturnFatalErrorIfReceiveErrorInResponse() throws JsonProcessingException {\n-        var flowRequest = createDataFlowRequest();\n-\n-        var httpRequest = new HttpRequest().withPath(DATA_PLANE_PATH).withBody(MAPPER.writeValueAsString(flowRequest));\n-        var errorMsg = UUID.randomUUID().toString();\n-        dataPlane.when(httpRequest, once()).respond(withResponse(errorMsg));\n-\n-        var result = dataPlaneClient.start(flowRequest);\n-\n-        dataPlane.verify(httpRequest);\n-\n-        assertThat(result).isFailed().satisfies(failure -> {\n-            assertThat(failure.status()).isEqualTo(ResponseStatus.FATAL_ERROR);\n-            assertThat(failure.getMessages()).anySatisfy(s -> assertThat(s).contains(\"404\"));\n-        });\n-    }\n-\n-    @Test\n-    void transfer_verifyTransferSuccess() throws JsonProcessingException {\n-        var flowRequest = createDataFlowRequest();\n-\n-        var httpRequest = new HttpRequest().withPath(DATA_PLANE_PATH).withBody(MAPPER.writeValueAsString(flowRequest));\n-        dataPlane.when(httpRequest, once()).respond(response().withStatusCode(HttpStatusCode.OK_200.code()));\n-\n-        var result = dataPlaneClient.start(flowRequest);\n-\n-        dataPlane.verify(httpRequest, VerificationTimes.once());\n-\n-        assertThat(result.succeeded()).isTrue();\n-    }\n-\n-    @Test\n-    void terminate_shouldCallTerminateOnAllTheAvailableDataPlanes() {\n-        var httpRequest = new HttpRequest().withMethod(\"DELETE\").withPath(DATA_PLANE_PATH + \"/processId\");\n-        dataPlane.when(httpRequest, once()).respond(response().withStatusCode(NO_CONTENT_204.code()));\n-\n-        var result = dataPlaneClient.terminate(\"processId\");\n-\n-        assertThat(result).isSucceeded();\n-        dataPlane.verify(httpRequest, VerificationTimes.once());\n-    }\n-\n-    @Test\n-    void terminate_shouldFail_whenConflictResponse() {\n-        var httpRequest = new HttpRequest().withMethod(\"DELETE\").withPath(DATA_PLANE_PATH + \"/processId\");\n-        dataPlane.when(httpRequest, once()).respond(response().withStatusCode(CONFLICT_409.code()));\n-\n-        var result = dataPlaneClient.terminate(\"processId\");\n-\n-        assertThat(result).isFailed();\n-    }\n-\n-    private HttpResponse withResponse(String errorMsg) throws JsonProcessingException {\n-        return response().withStatusCode(HttpStatusCode.BAD_REQUEST_400.code())\n-                .withBody(MAPPER.writeValueAsString(new TransferErrorResponse(List.of(errorMsg))), MediaType.APPLICATION_JSON);\n-    }\n-\n-    private DataFlowStartMessage createDataFlowRequest() {\n-        return DataFlowStartMessage.Builder.newInstance()\n-                .id(\"123\")\n-                .processId(\"456\")\n-                .sourceDataAddress(DataAddress.Builder.newInstance().type(\"test\").build())\n-                .destinationDataAddress(DataAddress.Builder.newInstance().type(\"test\").build())\n-                .build();\n-    }\n-\n-}\n```\n\nFilename: extensions/data-plane/data-plane-control-api/README.md:\n```\n@@ -1,72 +0,0 @@\n-# Data Plane API\n-\n-This extension provides the interfaces and implementations for the Data Plane API, which are respectively:\n-\n-- the Control API which is used by the Control Plane to delegate the data transfer to its Data Plane,\n-- the Public API which is essentially a data proxy enabling a consumer to actively query data out from the provider data source.\n-\n-### Scope\n-\n-These APIs have been designed to support the different data transfer types that the Data Plane must support, which are:\n-\n-- Consumer Data Pull: the consumer backend applications use the Data Plane to proxy data request until the provided data source.\n-  This data transfer type is exclusively built around the Public API of the Data Plane.\n-- Provider Push and Streaming: once contract is agreed by both participants, the Control Plane of the provider delegates\n-  the data transfer to its Data Plane through the Control API.\n-\n-### Use Cases\n-\n-#### Use Case #1\n-\n-Provider wants to expose a Rest API taking as input some query parameters that restrict the amount of data returned for each query.\n-Here it is not feasible for the data consumer to negotiate a contract for each query that will hit the provider data source API.\n-Here the approach for the consumer would then be to\n-[negotiate with the provider the possibility to access the data source through a proxy](../../control-plane/data-plane-transfer/data-plane-transfer-sync/).\n-If the negotiation ends successfully, the consumer will be provided an access token that its backend applications can then use when querying the Data Plane public API.\n-\n-This approach enables the consumer backend application to pass directly the query parameters, path parameters and body\n-in the request to Data Plane public API. If the provider data source allows it, these parameters will then be conveyed until the data source.\n-\n-### Use Case #2\n-\n-Provider exposes some data located in a Cloud storage, such as AWS S3 or Azure storage. Consumer wants to copy these data\n-into its own storage system (which can be of a different type than the one of the provider). Here the consumer will negotiate a\n-_simple_ data transfer, by notifying to which location the data should be copied. Once contract is agreed between both parties,\n-the provider will automatically trigger the data transfer by delegating the data copy to is Data Plane system, through its Control API.\n-\n-## Technical Details\n-\n-### Interfaces\n-\n-OpenApi documentation can be found [here](../../../resources/openapi/yaml/data-plane-api.yaml).\n-\n-### Dependencies\n-\n-_Provide some information about dependencies, e.g., used extensions._\n-\n-| Name    | Description                                  |\n-|:--------|:---------------------------------------------|\n-| web-spi | Essentially for the Controllers registration |\n-\n-## Design Principles\n-\n-Both public and control APIs rely on the `DataPlaneManager` for executing the actual data transfer, see [Data Plane Framework](../../../core/data-plane/data-plane-framework/README.md) for more details.\n-\n-The Data Plane public API takes an access token in input from the `Authorization` header, which is validated and decode by calling the\n-validation server. If the validation is successful, then the Data Plane is executed in order to query the data from the data address returned by the validation server.\n-As mentioned earlier, the Data Plane public API is essentially a data proxy, which by definition will convey the information from the request (query parameters, path information, request body)\n-into the `DataPlaneManager` through the `DataFlowRequest` properties. If the data source allows it, then the request information will\n-be used in the request to the actual data source.\n-\n-### Security\n-\n-Data Plane public API is, by nature, opened to external incoming http calls. Because it accepts any set of query params, path parameters and request body,\n-it could be used by malicious attackers to attempt an attack e.g. DDoS.\n-\n-By default, Jetty, which is the embedded HTTP server in the EDC, provides some security against this:\n-\n-- max request header size of 8 KB: every call whose request header size is larger is discarded,\n-- max form content size of 200 KB: every form request call whose body is larger than this is discarded,\n-- max form content keys of 1000: every form request call which contains more keys is discarded.\n-\n-No other limits are implemented as of now, so we strongly recommend putting a reverse proxy in front of the Data Plane public API, such as Nginx, configured to block malicious calls.\n\\ No newline at end of file\n```\n\nFilename: extensions/data-plane/data-plane-control-api/build.gradle.kts:\n```\n@@ -1,41 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Microsoft Corporation\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Microsoft Corporation - initial API and implementation\n- *       Bayerische Motoren Werke Aktiengesellschaft (BMW AG) - improvements\n- *       Mercedes-Benz Tech Innovation GmbH - publish public api context into dedicated swagger hub page\n- *\n- */\n-\n-\n-plugins {\n-    `java-library`\n-    id(libs.plugins.swagger.get().pluginId)\n-}\n-\n-dependencies {\n-    api(project(\":spi:common:web-spi\"))\n-    api(project(\":spi:data-plane:data-plane-spi\"))\n-\n-    implementation(libs.jakarta.rsApi)\n-\n-    testImplementation(project(\":extensions:common:http\"))\n-    testImplementation(project(\":core:common:junit\"))\n-    testImplementation(libs.jersey.multipart)\n-    testImplementation(libs.restAssured)\n-    testImplementation(testFixtures(project(\":extensions:common:http:jersey-core\")))\n-}\n-edcBuild {\n-    swagger {\n-        apiGroup.set(\"control-api\")\n-    }\n-}\n-\n-\n```\n\nFilename: extensions/data-plane/data-plane-control-api/src/main/java/org/eclipse/edc/connector/dataplane/api/DataPlaneControlApiExtension.java:\n```\n@@ -1,53 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Microsoft Corporation\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Microsoft Corporation - initial API and implementation\n- *       Mercedes-Benz Tech Innovation GmbH - publish public api context into dedicated swagger hub page\n- *\n- */\n-\n-package org.eclipse.edc.connector.dataplane.api;\n-\n-import org.eclipse.edc.connector.dataplane.api.controller.DataPlaneControlApiController;\n-import org.eclipse.edc.connector.dataplane.spi.manager.DataPlaneManager;\n-import org.eclipse.edc.runtime.metamodel.annotation.Extension;\n-import org.eclipse.edc.runtime.metamodel.annotation.Inject;\n-import org.eclipse.edc.spi.system.ServiceExtension;\n-import org.eclipse.edc.spi.system.ServiceExtensionContext;\n-import org.eclipse.edc.web.spi.WebService;\n-import org.eclipse.edc.web.spi.configuration.ApiContext;\n-\n-/**\n- * This extension provides set of endpoints to trigger/monitor/cancel data transfers that should be accessible only\n- * by the Control Plane.\n- *\n- * @deprecated please use data-plane signaling feature.\n- */\n-@Extension(value = DataPlaneControlApiExtension.NAME)\n-@Deprecated(since = \"0.6.0\")\n-public class DataPlaneControlApiExtension implements ServiceExtension {\n-    public static final String NAME = \"Data Plane Control API\";\n-\n-    @Inject\n-    private DataPlaneManager dataPlaneManager;\n-\n-    @Inject\n-    private WebService webService;\n-\n-    @Override\n-    public String name() {\n-        return NAME;\n-    }\n-\n-    @Override\n-    public void initialize(ServiceExtensionContext context) {\n-        webService.registerResource(ApiContext.CONTROL, new DataPlaneControlApiController(dataPlaneManager));\n-    }\n-}\n```\n\nFilename: extensions/data-plane/data-plane-control-api/src/main/java/org/eclipse/edc/connector/dataplane/api/controller/DataPlaneControlApi.java:\n```\n@@ -1,52 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - Initial implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.dataplane.api.controller;\n-\n-import io.swagger.v3.oas.annotations.OpenAPIDefinition;\n-import io.swagger.v3.oas.annotations.Operation;\n-import io.swagger.v3.oas.annotations.responses.ApiResponse;\n-import io.swagger.v3.oas.annotations.tags.Tag;\n-import jakarta.ws.rs.container.AsyncResponse;\n-import org.eclipse.edc.connector.dataplane.spi.DataFlowStates;\n-import org.eclipse.edc.spi.types.domain.transfer.DataFlowStartMessage;\n-\n-@OpenAPIDefinition\n-@Tag(name = \"Data Plane control API\",\n-        description = \"Api targeted by the Control Plane to delegate a data transfer (Provider Push or Streaming) \" +\n-                \"to the Data Plane after the contract has been successfully negotiated and agreed between the two participants. \")\n-public interface DataPlaneControlApi {\n-\n-    @Operation(description = \"Initiates a data transfer for the given request. The transfer will be performed asynchronously.\",\n-            responses = {\n-                    @ApiResponse(responseCode = \"400\", description = \"Failed to validate request\"),\n-                    @ApiResponse(responseCode = \"200\", description = \"Data transfer initiated\"),\n-            }\n-    )\n-    void initiateTransfer(DataFlowStartMessage request, AsyncResponse response);\n-\n-    @Operation(description = \"Get the current state of a data transfer.\",\n-            responses = @ApiResponse(responseCode = \"200\", description = \"Missing access token\")\n-    )\n-    DataFlowStates getTransferState(String transferProcessId);\n-\n-    @Operation(description = \"Terminates a data transfer.\",\n-            responses = {\n-                    @ApiResponse(responseCode = \"204\", description = \"Data transfer terminated\"),\n-                    @ApiResponse(responseCode = \"404\", description = \"Data transfer not handled by the data plane\"),\n-                    @ApiResponse(responseCode = \"409\", description = \"Cannot terminate the transfer\"),\n-            }\n-    )\n-    void terminateTransfer(String transferProcessId, AsyncResponse response);\n-}\n```\n\nFilename: extensions/data-plane/data-plane-control-api/src/main/java/org/eclipse/edc/connector/dataplane/api/controller/DataPlaneControlApiController.java:\n```\n@@ -1,87 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Microsoft Corporation\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Microsoft Corporation - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.dataplane.api.controller;\n-\n-import jakarta.ws.rs.Consumes;\n-import jakarta.ws.rs.DELETE;\n-import jakarta.ws.rs.GET;\n-import jakarta.ws.rs.POST;\n-import jakarta.ws.rs.Path;\n-import jakarta.ws.rs.PathParam;\n-import jakarta.ws.rs.Produces;\n-import jakarta.ws.rs.container.AsyncResponse;\n-import jakarta.ws.rs.container.Suspended;\n-import jakarta.ws.rs.core.MediaType;\n-import jakarta.ws.rs.core.Response;\n-import org.eclipse.edc.connector.dataplane.spi.DataFlowStates;\n-import org.eclipse.edc.connector.dataplane.spi.manager.DataPlaneManager;\n-import org.eclipse.edc.connector.dataplane.spi.response.TransferErrorResponse;\n-import org.eclipse.edc.spi.types.domain.transfer.DataFlowStartMessage;\n-\n-import java.util.List;\n-\n-import static jakarta.ws.rs.core.Response.status;\n-import static java.lang.String.format;\n-\n-@Path(\"/transfer\")\n-@Consumes({ MediaType.APPLICATION_JSON })\n-@Produces({ MediaType.APPLICATION_JSON })\n-public class DataPlaneControlApiController implements DataPlaneControlApi {\n-    private final DataPlaneManager dataPlaneManager;\n-\n-    public DataPlaneControlApiController(DataPlaneManager dataPlaneManager) {\n-        this.dataPlaneManager = dataPlaneManager;\n-    }\n-\n-    @POST\n-    @Override\n-    public void initiateTransfer(DataFlowStartMessage request, @Suspended AsyncResponse response) {\n-        // TODO token authentication\n-        var result = dataPlaneManager.validate(request);\n-        if (result.succeeded()) {\n-            dataPlaneManager.start(request);\n-            response.resume(Response.ok().build());\n-        } else {\n-            var resp = result.getFailureMessages().isEmpty() ?\n-                    badRequest(format(\"Failed to validate request: %s\", request.getId())) :\n-                    badRequest(result.getFailureMessages());\n-            response.resume(resp);\n-        }\n-    }\n-\n-    @GET\n-    @Override\n-    @Path(\"/{transferProcessId}\")\n-    public DataFlowStates getTransferState(@PathParam(\"transferProcessId\") String transferProcessId) {\n-        return dataPlaneManager.getTransferState(transferProcessId);\n-    }\n-\n-    @DELETE\n-    @Path(\"/{transferProcessId}\")\n-    @Override\n-    public void terminateTransfer(@PathParam(\"transferProcessId\") String transferProcessId, @Suspended AsyncResponse response) {\n-        dataPlaneManager.terminate(transferProcessId)\n-                .onSuccess(r -> response.resume(Response.noContent().build()))\n-                .onFailure(f -> response.resume(badRequest(List.of(\"Cannot terminate transfer: \" + f.getFailureDetail()))));\n-    }\n-\n-    private Response badRequest(String error) {\n-        return badRequest(List.of(error));\n-    }\n-\n-    private Response badRequest(List<String> errors) {\n-        return status(Response.Status.BAD_REQUEST).entity(new TransferErrorResponse(errors)).build();\n-    }\n-}\n```\n\nFilename: extensions/data-plane/data-plane-control-api/src/main/resources/META-INF/services/org.eclipse.edc.spi.system.ServiceExtension:\n```\n@@ -1 +0,0 @@\n-org.eclipse.edc.connector.dataplane.api.DataPlaneControlApiExtension\n```\n\nFilename: extensions/data-plane/data-plane-control-api/src/test/java/org/eclipse/edc/connector/dataplane/api/controller/DataPlaneControlApiControllerTest.java:\n```\n@@ -1,131 +0,0 @@\n-/*\n- *  Copyright (c) 2023 Bayerische Motoren Werke Aktiengesellschaft (BMW AG)\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Bayerische Motoren Werke Aktiengesellschaft (BMW AG) - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.dataplane.api.controller;\n-\n-import io.restassured.http.ContentType;\n-import io.restassured.specification.RequestSpecification;\n-import jakarta.ws.rs.core.HttpHeaders;\n-import jakarta.ws.rs.core.Response;\n-import org.eclipse.edc.connector.dataplane.spi.manager.DataPlaneManager;\n-import org.eclipse.edc.junit.annotations.ApiTest;\n-import org.eclipse.edc.spi.response.StatusResult;\n-import org.eclipse.edc.spi.result.Result;\n-import org.eclipse.edc.spi.types.domain.DataAddress;\n-import org.eclipse.edc.spi.types.domain.transfer.DataFlowStartMessage;\n-import org.eclipse.edc.web.jersey.testfixtures.RestControllerTestBase;\n-import org.hamcrest.CoreMatchers;\n-import org.junit.jupiter.api.Test;\n-\n-import java.util.List;\n-import java.util.UUID;\n-\n-import static io.restassured.RestAssured.given;\n-import static org.eclipse.edc.spi.response.ResponseStatus.FATAL_ERROR;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.isA;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.never;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.when;\n-\n-@ApiTest\n-class DataPlaneControlApiControllerTest extends RestControllerTestBase {\n-\n-    private final DataPlaneManager manager = mock();\n-\n-    @Test\n-    void should_callDataPlaneManager_if_requestIsValid() {\n-        var flowRequest = DataFlowStartMessage.Builder.newInstance()\n-                .id(UUID.randomUUID().toString())\n-                .processId(UUID.randomUUID().toString())\n-                .sourceDataAddress(testDestAddress())\n-                .destinationDataAddress(testDestAddress())\n-                .build();\n-\n-        when(manager.validate(isA(DataFlowStartMessage.class))).thenReturn(Result.success(Boolean.TRUE));\n-\n-        baseRequest()\n-                .contentType(ContentType.JSON)\n-                .body(flowRequest)\n-                .post(\"/transfer\")\n-                .then()\n-                .statusCode(Response.Status.OK.getStatusCode());\n-\n-        verify(manager).start(isA(DataFlowStartMessage.class));\n-    }\n-\n-    @Test\n-    void should_returnBadRequest_if_requestIsInValid() {\n-        var errorMsg = \"test error message\";\n-        var flowRequest = DataFlowStartMessage.Builder.newInstance()\n-                .id(UUID.randomUUID().toString())\n-                .processId(UUID.randomUUID().toString())\n-                .sourceDataAddress(testDestAddress())\n-                .destinationDataAddress(testDestAddress())\n-                .build();\n-\n-        when(manager.validate(isA(DataFlowStartMessage.class))).thenReturn(Result.failure(errorMsg));\n-\n-        baseRequest()\n-                .contentType(ContentType.JSON)\n-                .body(flowRequest)\n-                .post(\"/transfer\")\n-                .then()\n-                .statusCode(Response.Status.BAD_REQUEST.getStatusCode())\n-                .body(\"errors\", CoreMatchers.equalTo(List.of(errorMsg)));\n-\n-        verify(manager, never()).start(any());\n-    }\n-\n-    @Test\n-    void delete_shouldReturnOk_whenTerminationSucceeds() {\n-        when(manager.terminate(any())).thenReturn(StatusResult.success());\n-\n-        baseRequest()\n-                .delete(\"/transfer/transferId\")\n-                .then()\n-                .statusCode(204);\n-\n-        verify(manager).terminate(\"transferId\");\n-    }\n-\n-    @Test\n-    void delete_shouldReturnError_whenTerminationFails() {\n-        when(manager.terminate(any())).thenReturn(StatusResult.failure(FATAL_ERROR));\n-\n-        baseRequest()\n-                .delete(\"/transfer/transferId\")\n-                .then()\n-                .statusCode(400);\n-\n-        verify(manager).terminate(\"transferId\");\n-    }\n-\n-    @Override\n-    protected Object controller() {\n-        return new DataPlaneControlApiController(manager);\n-    }\n-\n-    private RequestSpecification baseRequest() {\n-        return given()\n-                .baseUri(\"http://localhost:\" + port)\n-                .header(HttpHeaders.AUTHORIZATION, \"auth\")\n-                .when();\n-    }\n-\n-    private DataAddress testDestAddress() {\n-        return DataAddress.Builder.newInstance().type(\"test\").build();\n-    }\n-}\n```\n\nFilename: extensions/data-plane/data-plane-integration-tests/build.gradle.kts:\n```\n@@ -26,6 +26,7 @@\ndependencies {\n \n     testImplementation(project(\":core:common:connector-core\"))\n     testImplementation(project(\":core:common:junit\"))\n+    testImplementation(project(\":extensions:common:json-ld\"))\n     testImplementation(testFixtures(project(\":extensions:data-plane:data-plane-http\")))\n }\n```\n\nFilename: extensions/data-plane/data-plane-integration-tests/src/test/java/org/eclipse/edc/connector/dataplane/http/DataPlaneHttpIntegrationTests.java:\n```\n@@ -14,20 +14,23 @@\npackage org.eclipse.edc.connector.dataplane.http;\n \n-import com.fasterxml.jackson.databind.node.ObjectNode;\n import io.netty.handler.codec.http.HttpHeaderNames;\n import io.netty.handler.codec.http.HttpMethod;\n import io.restassured.http.ContentType;\n+import io.restassured.response.Response;\n+import jakarta.json.Json;\n+import jakarta.json.JsonArrayBuilder;\n+import jakarta.json.JsonObject;\n+import jakarta.json.JsonObjectBuilder;\n import org.apache.http.HttpStatus;\n import org.eclipse.edc.connector.dataplane.http.spi.HttpDataAddress;\n import org.eclipse.edc.connector.dataplane.spi.DataFlowStates;\n-import org.eclipse.edc.connector.dataplane.spi.schema.DataFlowRequestSchema;\n+import org.eclipse.edc.connector.dataplane.spi.iam.DataPlaneAuthorizationService;\n import org.eclipse.edc.junit.annotations.ComponentTest;\n import org.eclipse.edc.junit.extensions.EmbeddedRuntime;\n import org.eclipse.edc.junit.extensions.RuntimeExtension;\n import org.eclipse.edc.junit.extensions.RuntimePerClassExtension;\n-import org.eclipse.edc.spi.types.TypeManager;\n-import org.eclipse.edc.spi.types.domain.transfer.DataFlowStartMessage;\n+import org.eclipse.edc.spi.result.Result;\n import org.junit.jupiter.api.AfterAll;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeAll;\n\n@@ -45,10 +48,8 @@\nimport java.nio.charset.StandardCharsets;\n import java.time.Duration;\n-import java.util.HashMap;\n import java.util.Map;\n import java.util.UUID;\n-import java.util.stream.Collectors;\n \n import static io.netty.handler.codec.http.HttpHeaderNames.AUTHORIZATION;\n import static io.restassured.RestAssured.given;\n\n@@ -57,11 +58,15 @@\nimport static java.lang.String.valueOf;\n import static java.util.Collections.emptyMap;\n import static org.awaitility.Awaitility.await;\n-import static org.eclipse.edc.connector.dataplane.http.testfixtures.TestFunctions.createRequest;\n import static org.eclipse.edc.connector.dataplane.spi.DataFlowStates.NOTIFIED;\n+import static org.eclipse.edc.spi.constants.CoreConstants.EDC_NAMESPACE;\n+import static org.eclipse.edc.spi.types.domain.transfer.DataFlowStartMessage.EDC_DATA_FLOW_START_MESSAGE_TYPE;\n import static org.eclipse.edc.util.io.Ports.getFreePort;\n import static org.hamcrest.CoreMatchers.equalTo;\n import static org.hamcrest.Matchers.containsString;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n import static org.mockserver.integration.ClientAndServer.startClientAndServer;\n import static org.mockserver.matchers.Times.exactly;\n import static org.mockserver.matchers.Times.once;\n\n@@ -76,34 +81,24 @@\nimport static org.mockserver.model.Parameter.param;\n import static org.mockserver.stop.Stop.stopQuietly;\n \n-/**\n- * System Test for Data Plane HTTP extension.\n- */\n+\n @ComponentTest\n public class DataPlaneHttpIntegrationTests {\n \n-    private static final int VALIDATION_API_PORT = getFreePort();\n-    private static final String VALIDATION_API_HOST = \"http://localhost:\" + VALIDATION_API_PORT;\n     private static final int PUBLIC_API_PORT = getFreePort();\n     private static final int CONTROL_API_PORT = getFreePort();\n     private static final int HTTP_SOURCE_API_PORT = getFreePort();\n     private static final int HTTP_SINK_API_PORT = getFreePort();\n-    private static final String CONTROL_API_HOST = \"http://localhost:\" + CONTROL_API_PORT;\n     private static final String HTTP_SOURCE_API_HOST = \"http://localhost:\" + HTTP_SOURCE_API_PORT;\n     private static final String HTTP_SINK_API_HOST = \"http://localhost:\" + HTTP_SINK_API_PORT;\n     private static final String CONTROL_PATH = \"/control\";\n     private static final String PUBLIC_PATH = \"/public\";\n     private static final String PUBLIC_API_HOST = \"http://localhost:\" + PUBLIC_API_PORT;\n-    private static final String TRANSFER_PATH = format(\"%s/transfer\", CONTROL_PATH);\n-    private static final String TRANSFER_RESULT_PATH = format(\"%s/{processId}\", TRANSFER_PATH);\n-    private static final String PROCESS_ID = \"processId\";\n-    private static final String HTTP_API_PATH = \"sample\";\n     private static final String AUTH_HEADER_KEY = AUTHORIZATION.toString();\n     private static final String SOURCE_AUTH_VALUE = \"source-auth-key\";\n     private static final String SINK_AUTH_VALUE = \"sink-auth-key\";\n     private static ClientAndServer httpSourceMockServer;\n     private static ClientAndServer httpSinkMockServer;\n-    private static ClientAndServer validationApiMockServer;\n     private final Duration timeout = Duration.ofSeconds(30);\n \n     private static final EmbeddedRuntime RUNTIME = new EmbeddedRuntime(\n\n@@ -113,51 +108,47 @@\npublic class DataPlaneHttpIntegrationTests {\n                     \"web.http.public.path\", PUBLIC_PATH,\n                     \"web.http.control.port\", valueOf(CONTROL_API_PORT),\n                     \"web.http.control.path\", CONTROL_PATH,\n-                    \"edc.dataplane.token.validation.endpoint\", VALIDATION_API_HOST,\n                     \"edc.core.retry.retries.max\", \"0\"\n             ),\n-            \":extensions:common:metrics:micrometer-core\",\n             \":core:data-plane:data-plane-core\",\n             \":extensions:common:api:control-api-configuration\",\n             \":extensions:common:http\",\n             \":extensions:common:json-ld\",\n             \":extensions:common:configuration:configuration-filesystem\",\n             \":extensions:control-plane:api:control-plane-api-client\",\n             \":extensions:data-plane:data-plane-http\",\n-            \":extensions:data-plane:data-plane-control-api\",\n-            \":extensions:data-plane:data-plane-public-api\"\n-    );\n+            \":extensions:data-plane:data-plane-public-api-v2\",\n+            \":extensions:data-plane:data-plane-signaling:data-plane-signaling-api\"\n+    ).registerServiceMock(DataPlaneAuthorizationService.class, mock());\n \n     @BeforeAll\n     public static void setUp() {\n         httpSourceMockServer = startClientAndServer(HTTP_SOURCE_API_PORT);\n         httpSinkMockServer = startClientAndServer(HTTP_SINK_API_PORT);\n-        validationApiMockServer = startClientAndServer(VALIDATION_API_PORT);\n     }\n \n     @AfterAll\n     public static void tearDown() {\n         stopQuietly(httpSourceMockServer);\n         stopQuietly(httpSinkMockServer);\n-        stopQuietly(validationApiMockServer);\n     }\n \n     @AfterEach\n     public void resetMockServer() {\n         httpSourceMockServer.reset();\n         httpSinkMockServer.reset();\n-        validationApiMockServer.reset();\n     }\n \n     @Nested\n     class Pull {\n \n+        private static final String HTTP_API_PATH = \"sample\";\n+\n         @RegisterExtension\n         static RuntimeExtension dataPlane = new RuntimePerClassExtension(RUNTIME);\n \n         @Test\n-        void transfer_pull_withSourceQueryParamsAndPath_success(TypeManager typeManager) {\n-            // prepare data source and validation servers\n+        void transfer_pull_withSourceQueryParamsAndPath_success(DataPlaneAuthorizationService dataPlaneAuthorizationService) {\n             var token = UUID.randomUUID().toString();\n             var responseBody = \"some info\";\n             var queryParams = Map.of(\n\n@@ -168,11 +159,7 @@\nvoid transfer_pull_withSourceQueryParamsAndPath_success(TypeManager typeManager)\n \n             var sourceRequest = getRequest(queryParams, HTTP_API_PATH);\n             httpSourceMockServer.when(sourceRequest, once()).respond(successfulResponse(responseBody, PLAIN_TEXT_UTF_8));\n-\n-            // prepare validation server of the control plane\n-            var validationRequest = request().withMethod(HttpMethod.GET.name()).withHeader(AUTH_HEADER_KEY, token);\n-            validationApiMockServer.when(validationRequest, once())\n-                    .respond(successfulResponse(typeManager.writeValueAsString(sourceDataAddress), PLAIN_TEXT_UTF_8));\n+            when(dataPlaneAuthorizationService.authorize(any(), any())).thenReturn(Result.success(sourceDataAddress));\n \n             given()\n                     .baseUri(PUBLIC_API_HOST)\n\n@@ -190,31 +177,15 @@\nvoid transfer_pull_withSourceQueryParamsAndPath_success(TypeManager typeManager)\n         }\n \n         @Test\n-        void transfer_invalidInput_failure(TypeManager typeManager) {\n-            var processId = UUID.randomUUID().toString();\n-            var invalidRequest = transferRequestPayload(processId, typeManager).remove(\"processId\");\n-\n-            given()\n-                    .baseUri(CONTROL_API_HOST)\n-                    .contentType(ContentType.JSON)\n-                    .body(invalidRequest)\n-                    .when()\n-                    .post(TRANSFER_PATH)\n-                    .then()\n-                    .assertThat().statusCode(HttpStatus.SC_BAD_REQUEST);\n-        }\n-\n-        @Test\n-        void shouldProxyMethodAndBody_whenSet(TypeManager typeManager) {\n+        void shouldProxyMethodAndBody_whenSet(DataPlaneAuthorizationService dataPlaneAuthorizationService) {\n             var sourceAddress = HttpDataAddress.Builder.newInstance()\n                     .baseUrl(HTTP_SOURCE_API_HOST)\n                     .proxyMethod(TRUE.toString())\n                     .proxyPath(TRUE.toString())\n                     .proxyBody(TRUE.toString())\n                     .build();\n             httpSourceMockServer.when(request(), once()).respond(successfulResponse(\"any\", PLAIN_TEXT_UTF_8));\n-            validationApiMockServer.when(request(), once())\n-                    .respond(successfulResponse(typeManager.writeValueAsString(sourceAddress), PLAIN_TEXT_UTF_8));\n+            when(dataPlaneAuthorizationService.authorize(any(), any())).thenReturn(Result.success(sourceAddress));\n \n             given()\n                     .baseUri(PUBLIC_API_HOST)\n\n@@ -229,6 +200,16 @@\nvoid shouldProxyMethodAndBody_whenSet(TypeManager typeManager) {\n \n             httpSourceMockServer.verify(request().withMethod(\"PUT\").withBody(\"body\"), VerificationTimes.once());\n         }\n+\n+        private HttpDataAddress sourceDataAddress() {\n+            return HttpDataAddress.Builder.newInstance()\n+                    .baseUrl(HTTP_SOURCE_API_HOST)\n+                    .proxyPath(TRUE.toString())\n+                    .proxyQueryParams(TRUE.toString())\n+                    .authKey(AUTH_HEADER_KEY)\n+                    .authCode(SOURCE_AUTH_VALUE)\n+                    .build();\n+        }\n     }\n \n     @Nested\n\n@@ -238,104 +219,112 @@\nclass Push {\n         static RuntimeExtension dataPlane = new RuntimePerClassExtension(RUNTIME);\n \n         @Test\n-        void transfer_toHttpSink_success(TypeManager typeManager) {\n+        void transfer_toHttpSink_success() {\n             var body = UUID.randomUUID().toString();\n             var processId = UUID.randomUUID().toString();\n-            httpSourceMockServer.when(getRequest(HTTP_API_PATH), once()).respond(successfulResponse(body, APPLICATION_JSON));\n-\n-            // HTTP Sink Request & Response\n+            httpSourceMockServer.when(getRequest(\"\"), once()).respond(successfulResponse(body, APPLICATION_JSON));\n             httpSinkMockServer.when(request(), once()).respond(successfulResponse());\n \n-            initiateTransfer(transferRequestPayload(processId, typeManager));\n+            initiate(transferRequestPayload(processId))\n+                    .then()\n+                    .assertThat().statusCode(HttpStatus.SC_OK);\n \n             await().atMost(timeout).untilAsserted(() -> expectState(processId, NOTIFIED));\n-            // Verify HTTP Source server called exactly once.\n-            httpSourceMockServer.verify(getRequest(HTTP_API_PATH), VerificationTimes.once());\n-            // Verify HTTP Sink server called exactly once.\n+            httpSourceMockServer.verify(getRequest(\"\"), VerificationTimes.once());\n             httpSinkMockServer.verify(postRequest(body, APPLICATION_JSON), VerificationTimes.once());\n         }\n \n         @Test\n-        void transfer_toHttpSink_withSourceQueryParams_success(TypeManager typeManager) {\n-            // HTTP Source Request & Response\n+        void transfer_toHttpSink_withSourcePathAndQueryParams_success() {\n             var body = UUID.randomUUID().toString();\n             var processId = UUID.randomUUID().toString();\n             var queryParams = Map.of(\n                     \"param1\", \"any value\",\n                     \"param2\", \"any other value\"\n             );\n \n-            httpSourceMockServer.when(getRequest(queryParams, HTTP_API_PATH), once()).respond(successfulResponse(body, APPLICATION_OCTET_STREAM));\n-\n-            // HTTP Sink Request & Response\n+            httpSourceMockServer.when(getRequest(queryParams, \"path\"), once()).respond(successfulResponse(body, APPLICATION_OCTET_STREAM));\n             httpSinkMockServer.when(postRequest(body, APPLICATION_OCTET_STREAM), once()).respond(successfulResponse());\n \n-            initiateTransfer(transferRequestPayload(processId, queryParams, typeManager));\n+            var sourceDataAddress = Json.createObjectBuilder()\n+                    .add(\"@type\", \"dspace:DataAddress\")\n+                    .add(\"dspace:endpointType\", \"HttpData\")\n+                    .add(\"dspace:endpointProperties\", sourceAddressProperties()\n+                            .add(dspaceProperty(EDC_NAMESPACE + \"path\", \"path\"))\n+                            .add(dspaceProperty(EDC_NAMESPACE + \"queryParams\", \"param1=any value&param2=any other value\"))\n+                    );\n+\n+            initiate(transferRequestPayload(processId, sourceDataAddress))\n+                    .then()\n+                    .assertThat().statusCode(HttpStatus.SC_OK);\n \n             await().atMost(timeout).untilAsserted(() -> expectState(processId, NOTIFIED));\n-            // Verify HTTP Source server called exactly once.\n-            httpSourceMockServer.verify(getRequest(queryParams, HTTP_API_PATH), VerificationTimes.once());\n-            // Verify HTTP Sink server called exactly once.\n+            httpSourceMockServer.verify(getRequest(queryParams, \"path\"), VerificationTimes.once());\n             httpSinkMockServer.verify(postRequest(body, APPLICATION_OCTET_STREAM), VerificationTimes.once());\n         }\n \n         @Test\n-        void transfer_toHttpSink_sourceNotAvailable_noInteractionWithSink(TypeManager typeManager) {\n+        void transfer_toHttpSink_sourceNotAvailable_noInteractionWithSink() {\n             var processId = UUID.randomUUID().toString();\n-            // HTTP Source Request & Error Response\n-            httpSourceMockServer.when(getRequest(HTTP_API_PATH)).error(withDropConnection());\n+            httpSourceMockServer.when(getRequest(\"\")).error(withDropConnection());\n \n-            initiateTransfer(transferRequestPayload(processId, typeManager));\n+            initiate(transferRequestPayload(processId))\n+                    .then()\n+                    .assertThat().statusCode(HttpStatus.SC_OK);\n \n             await().atMost(timeout).untilAsserted(() -> expectState(processId, NOTIFIED));\n-            // Verify HTTP Source server called at lest once.\n-            httpSourceMockServer.verify(getRequest(HTTP_API_PATH), VerificationTimes.atLeast(1));\n-            // Verify zero interaction with HTTP Sink.\n+            httpSourceMockServer.verify(getRequest(\"\"), VerificationTimes.atLeast(1));\n             httpSinkMockServer.verifyZeroInteractions();\n         }\n \n         /**\n          * Validate if intermittently source is dropping connection than DPF server retries to fetch data.\n          */\n         @Test\n-        void transfer_toHttpSink_sourceTemporaryDropConnection_success(TypeManager typeManager) {\n+        void transfer_toHttpSink_sourceTemporaryDropConnection_success() {\n             var processId = UUID.randomUUID().toString();\n-            // First two calls to HTTP Source returns a failure response.\n-            httpSourceMockServer.when(getRequest(HTTP_API_PATH), exactly(2)).error(withDropConnection());\n+            httpSourceMockServer.when(getRequest(\"\"), exactly(2)).error(withDropConnection());\n \n-            // Next call to HTTP Source returns a valid response.\n             var body = UUID.randomUUID().toString();\n-            httpSourceMockServer.when(getRequest(HTTP_API_PATH), once()).respond(successfulResponse(body, PLAIN_TEXT_UTF_8));\n+            httpSourceMockServer.when(getRequest(\"\"), once()).respond(successfulResponse(body, PLAIN_TEXT_UTF_8));\n \n-            // HTTP Sink Request & Response\n             httpSinkMockServer.when(postRequest(body, APPLICATION_OCTET_STREAM), once()).respond(successfulResponse());\n \n-            initiateTransfer(transferRequestPayload(processId, typeManager));\n+            initiate(transferRequestPayload(processId))\n+                    .then()\n+                    .assertThat().statusCode(HttpStatus.SC_OK);\n \n             await().atMost(timeout).untilAsserted(() -> expectState(processId, NOTIFIED));\n-            // Verify HTTP Source server called exactly 3 times.\n-            httpSourceMockServer.verify(getRequest(HTTP_API_PATH), VerificationTimes.exactly(3));\n-            // Verify HTTP Sink server called exactly once.\n+            httpSourceMockServer.verify(getRequest(\"\"), VerificationTimes.exactly(3));\n             httpSinkMockServer.verify(postRequest(body, PLAIN_TEXT_UTF_8), VerificationTimes.once());\n         }\n \n-        private void initiateTransfer(Object payload) {\n-            given()\n-                    .baseUri(CONTROL_API_HOST)\n+        @Test\n+        void transfer_invalidInput_failure() {\n+            var processId = UUID.randomUUID().toString();\n+            var validRequest = transferRequestPayload(processId);\n+            var invalidRequest = Json.createObjectBuilder(validRequest).remove(\"transferTypeDestination\").build();\n+\n+            initiate(invalidRequest)\n+                    .then()\n+                    .assertThat().statusCode(HttpStatus.SC_BAD_REQUEST);\n+        }\n+\n+        private Response initiate(JsonObject payload) {\n+            return given()\n+                    .port(CONTROL_API_PORT)\n                     .contentType(ContentType.JSON)\n                     .body(payload)\n                     .when()\n-                    .post(TRANSFER_PATH)\n-                    .then()\n-                    .assertThat().statusCode(HttpStatus.SC_OK);\n+                    .post(\"/control/v1/dataflows\");\n         }\n \n         private void expectState(String processId, DataFlowStates expectedState) {\n             given()\n-                    .baseUri(CONTROL_API_HOST)\n-                    .pathParam(PROCESS_ID, processId)\n+                    .port(CONTROL_API_PORT)\n                     .when()\n-                    .get(TRANSFER_RESULT_PATH)\n+                    .pathParam(\"id\", processId)\n+                    .get(\"/control/v1/dataflows/{id}/state\")\n                     .then()\n                     .assertThat().statusCode(HttpStatus.SC_OK)\n                     .body(containsString(expectedState.name()));\n\n@@ -345,59 +334,51 @@\nprivate HttpError withDropConnection() {\n             return error()\n                     .withDropConnection(true);\n         }\n-    }\n \n-    /**\n-     * Request payload to initiate DPF transfer.\n-     *\n-     * @param processId ProcessID of transfer.See {@link DataFlowStartMessage}\n-     * @return JSON object. see {@link ObjectNode}.\n-     */\n-    private ObjectNode transferRequestPayload(String processId, TypeManager typeManager) {\n-        return transferRequestPayload(processId, emptyMap(), typeManager);\n-    }\n+        private JsonObject transferRequestPayload(String processId) {\n+            return transferRequestPayload(processId, sourceAddress());\n+        }\n \n-    /**\n-     * Request payload with query params to initiate DPF transfer.\n-     *\n-     * @param processId   ProcessID of transfer.See {@link DataFlowStartMessage}\n-     * @param queryParams Query params name and value as key-value entries.\n-     * @return JSON object. see {@link ObjectNode}.\n-     */\n-    private ObjectNode transferRequestPayload(String processId, Map<String, String> queryParams, TypeManager typeManager) {\n-        var requestProperties = new HashMap<String, String>();\n-        requestProperties.put(DataFlowRequestSchema.METHOD, HttpMethod.GET.name());\n-        requestProperties.put(DataFlowRequestSchema.PATH, HTTP_API_PATH);\n-\n-        if (!queryParams.isEmpty()) {\n-            requestProperties.put(DataFlowRequestSchema.QUERY_PARAMS, queryParams.entrySet()\n-                    .stream()\n-                    .map(entry -> entry.getKey() + \"=\" + entry.getValue())\n-                    .collect(Collectors.joining(\"&\")));\n+        private JsonObject transferRequestPayload(String processId, JsonObjectBuilder sourceDataAddress) {\n+            return Json.createObjectBuilder()\n+                    .add(\"@context\", Json.createObjectBuilder().add(\"@vocab\", EDC_NAMESPACE).add(\"dspace\", \"https://w3id.org/dspace/v0.8/\"))\n+                    .add(\"@type\", EDC_DATA_FLOW_START_MESSAGE_TYPE)\n+                    .add(\"@id\", UUID.randomUUID().toString())\n+                    .add(\"processId\", processId)\n+                    .add(\"sourceDataAddress\", sourceDataAddress)\n+                    .add(\"destinationDataAddress\", Json.createObjectBuilder()\n+                            .add(\"dspace:endpointType\", \"HttpData\")\n+                            .add(\"dspace:endpointProperties\", Json.createArrayBuilder()\n+                                    .add(dspaceProperty(EDC_NAMESPACE + \"baseUrl\", HTTP_SINK_API_HOST))\n+                                    .add(dspaceProperty(EDC_NAMESPACE + \"authKey\", AUTH_HEADER_KEY))\n+                                    .add(dspaceProperty(EDC_NAMESPACE + \"authCode\", SINK_AUTH_VALUE))\n+                            )\n+                    )\n+                    .add(\"flowType\", \"PUSH\")\n+                    .add(\"transferTypeDestination\", \"HttpData-PUSH\")\n+                    .build();\n         }\n \n-        var destinationDataAddress = HttpDataAddress.Builder.newInstance()\n-                .baseUrl(HTTP_SINK_API_HOST)\n-                .authKey(AUTH_HEADER_KEY)\n-                .authCode(SINK_AUTH_VALUE)\n-                .build();\n+        private JsonObjectBuilder sourceAddress() {\n+            return Json.createObjectBuilder()\n+                    .add(\"@type\", \"dspace:DataAddress\")\n+                    .add(\"dspace:endpointType\", \"HttpData\")\n+                    .add(\"dspace:endpointProperties\", sourceAddressProperties());\n+        }\n \n-        // Create valid dataflow request instance.\n-        var request = createRequest(requestProperties, sourceDataAddress(), destinationDataAddress)\n-                .processId(processId)\n-                .build();\n+        private JsonArrayBuilder sourceAddressProperties() {\n+            return Json.createArrayBuilder()\n+                    .add(dspaceProperty(EDC_NAMESPACE + \"baseUrl\", HTTP_SOURCE_API_HOST))\n+                    .add(dspaceProperty(EDC_NAMESPACE + \"authKey\", AUTH_HEADER_KEY))\n+                    .add(dspaceProperty(EDC_NAMESPACE + \"authCode\", SOURCE_AUTH_VALUE));\n+        }\n \n-        return typeManager.getMapper().convertValue(request, ObjectNode.class);\n-    }\n+        private JsonObjectBuilder dspaceProperty(String name, String value) {\n+            return Json.createObjectBuilder()\n+                    .add(\"dspace:name\", name)\n+                    .add(\"dspace:value\", value);\n+        }\n \n-    private HttpDataAddress sourceDataAddress() {\n-        return HttpDataAddress.Builder.newInstance()\n-                .baseUrl(HTTP_SOURCE_API_HOST)\n-                .proxyPath(TRUE.toString())\n-                .proxyQueryParams(TRUE.toString())\n-                .authKey(AUTH_HEADER_KEY)\n-                .authCode(SOURCE_AUTH_VALUE)\n-                .build();\n     }\n \n     /**\n\n@@ -420,7 +401,7 @@\nprivate HttpRequest getRequest(Map<String, String> queryParams, String path) {\n         var paramsList = queryParams.entrySet()\n                 .stream()\n                 .map(entry -> param(entry.getKey(), entry.getValue()))\n-                .collect(Collectors.toList());\n+                .toList();\n \n         request.withQueryStringParameters(new Parameters(paramsList).withKeyMatchStyle(MATCHING_KEY));\n```\n\nFilename: extensions/data-plane/data-plane-public-api/README.md:\n```\n@@ -1 +0,0 @@\n-# Data Plane Public API\n```\n\nFilename: extensions/data-plane/data-plane-public-api/build.gradle.kts:\n```\n@@ -1,48 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Microsoft Corporation\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Microsoft Corporation - initial API and implementation\n- *       Bayerische Motoren Werke Aktiengesellschaft (BMW AG) - improvements\n- *       Mercedes-Benz Tech Innovation GmbH - publish public api context into dedicated swagger hub page\n- *\n- */\n-\n-\n-plugins {\n-    `java-library`\n-    id(libs.plugins.swagger.get().pluginId)\n-}\n-\n-dependencies {\n-    api(project(\":spi:common:http-spi\"))\n-    api(project(\":spi:common:web-spi\"))\n-    api(project(\":spi:data-plane:data-plane-spi\"))\n-    implementation(project(\":core:common:lib:util-lib\"))\n-\n-    implementation(project(\":core:data-plane:data-plane-util\"))\n-    implementation(libs.jakarta.rsApi)\n-\n-    testImplementation(project(\":extensions:common:http\"))\n-    testImplementation(project(\":core:common:junit\"))\n-    testImplementation(libs.jersey.multipart)\n-    testImplementation(libs.restAssured)\n-    testImplementation(libs.mockserver.netty)\n-    testImplementation(libs.mockserver.client)\n-\n-    testImplementation(testFixtures(project(\":core:common:lib:http-lib\")))\n-    testImplementation(testFixtures(project(\":extensions:common:http:jersey-core\")))\n-}\n-edcBuild {\n-    swagger {\n-        apiGroup.set(\"public-api\")\n-    }\n-}\n-\n-\n```\n\nFilename: extensions/data-plane/data-plane-public-api/src/main/java/org/eclipse/edc/connector/dataplane/api/DataPlanePublicApiExtension.java:\n```\n@@ -1,108 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Microsoft Corporation\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Microsoft Corporation - initial API and implementation\n- *       Mercedes-Benz Tech Innovation GmbH - publish public api context into dedicated swagger hub page\n- *\n- */\n-\n-package org.eclipse.edc.connector.dataplane.api;\n-\n-import org.eclipse.edc.connector.dataplane.api.controller.DataPlanePublicApiController;\n-import org.eclipse.edc.connector.dataplane.api.validation.ConsumerPullTransferDataAddressResolver;\n-import org.eclipse.edc.connector.dataplane.spi.pipeline.PipelineService;\n-import org.eclipse.edc.http.spi.EdcHttpClient;\n-import org.eclipse.edc.runtime.metamodel.annotation.Extension;\n-import org.eclipse.edc.runtime.metamodel.annotation.Inject;\n-import org.eclipse.edc.runtime.metamodel.annotation.Setting;\n-import org.eclipse.edc.runtime.metamodel.annotation.SettingContext;\n-import org.eclipse.edc.spi.system.ExecutorInstrumentation;\n-import org.eclipse.edc.spi.system.ServiceExtension;\n-import org.eclipse.edc.spi.system.ServiceExtensionContext;\n-import org.eclipse.edc.spi.types.TypeManager;\n-import org.eclipse.edc.web.spi.WebServer;\n-import org.eclipse.edc.web.spi.WebService;\n-import org.eclipse.edc.web.spi.configuration.ApiContext;\n-import org.eclipse.edc.web.spi.configuration.WebServiceConfigurer;\n-import org.eclipse.edc.web.spi.configuration.WebServiceSettings;\n-\n-import java.util.concurrent.Executors;\n-\n-/**\n- * This extension provides generic endpoints which are open to public participants of the Dataspace to execute\n- * requests on the actual data source.\n- *\n- * @deprecated will be replaced by v2.\n- */\n-@Extension(value = DataPlanePublicApiExtension.NAME)\n-@Deprecated(since = \"0.6.0\")\n-public class DataPlanePublicApiExtension implements ServiceExtension {\n-    public static final String NAME = \"Data Plane Public API\";\n-\n-    @SettingContext(\"Public API context setting key\")\n-    private static final String PUBLIC_CONFIG_KEY = \"web.http.\" + ApiContext.PUBLIC;\n-\n-    @Setting(value = \"Token validation server endpoint\", required = true)\n-    private static final String CONTROL_PLANE_VALIDATION_ENDPOINT = \"edc.dataplane.token.validation.endpoint\";\n-\n-    private static final int DEFAULT_THREAD_POOL = 10;\n-\n-    private static final WebServiceSettings PUBLIC_SETTINGS = WebServiceSettings.Builder.newInstance()\n-            .apiConfigKey(PUBLIC_CONFIG_KEY)\n-            .contextAlias(ApiContext.PUBLIC)\n-            .defaultPath(\"/api/v1/public\")\n-            .defaultPort(8185)\n-            .name(NAME)\n-            .build();\n-\n-    @Inject\n-    private WebServer webServer;\n-\n-    @Inject\n-    private WebServiceConfigurer webServiceConfigurer;\n-\n-    @Inject\n-    private PipelineService pipelineService;\n-\n-    @Inject\n-    private WebService webService;\n-\n-    @Inject\n-    private EdcHttpClient httpClient;\n-\n-    @Inject\n-    private TypeManager typeManager;\n-\n-    @Inject\n-    private ExecutorInstrumentation executorInstrumentation;\n-\n-    @Override\n-    public String name() {\n-        return NAME;\n-    }\n-\n-    @Override\n-    public void initialize(ServiceExtensionContext context) {\n-        var config = context.getConfig(PUBLIC_CONFIG_KEY);\n-        var validationEndpoint = context.getConfig().getString(CONTROL_PLANE_VALIDATION_ENDPOINT);\n-        var dataAddressResolver = new ConsumerPullTransferDataAddressResolver(httpClient, validationEndpoint, typeManager.getMapper());\n-        webServiceConfigurer.configure(config, webServer, PUBLIC_SETTINGS);\n-        var executorService = executorInstrumentation.instrument(\n-                Executors.newFixedThreadPool(DEFAULT_THREAD_POOL),\n-                \"Data plane proxy transfers\"\n-        );\n-        var monitor = context.getMonitor().withPrefix(\"DataPlane Public API\");\n-        var publicApiController = new DataPlanePublicApiController(pipelineService, dataAddressResolver, executorService, monitor);\n-        webService.registerResource(ApiContext.PUBLIC, publicApiController);\n-\n-        monitor.warning(\"This public API controller is scheduled for removal. Please consider upgrading your deployment \" +\n-                \"to the data-plane-public-api-v2 module. The Data Plane Public API will then be available under at /v2/ prefix.\");\n-    }\n-}\n```\n\nFilename: extensions/data-plane/data-plane-public-api/src/main/java/org/eclipse/edc/connector/dataplane/api/controller/ContainerRequestContextApi.java:\n```\n@@ -1,68 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.dataplane.api.controller;\n-\n-import jakarta.ws.rs.container.ContainerRequestContext;\n-\n-import java.util.Map;\n-\n-/**\n- * Wrapper around {@link ContainerRequestContext} enabling mocking.\n- */\n-public interface ContainerRequestContextApi {\n-\n-    /**\n-     * Get the request headers. Note that if more than one value is associated to a specific header,\n-     * only the first one is retained.\n-     *\n-     * @return Headers map.\n-     */\n-    Map<String, String> headers();\n-\n-    /**\n-     * Format query of the request as string, e.g. \"hello=world\\&amp;foo=bar\".\n-     *\n-     * @return Query param string.\n-     */\n-    String queryParams();\n-\n-    /**\n-     * Format the request body into a string.\n-     *\n-     * @return Request body.\n-     */\n-    String body();\n-\n-    /**\n-     * Get the media type from incoming request.\n-     *\n-     * @return Media type.\n-     */\n-    String mediaType();\n-\n-    /**\n-     * Return request path, e.g. \"hello/world/foo/bar\".\n-     *\n-     * @return Path string.\n-     */\n-    String path();\n-\n-    /**\n-     * Get http method from the incoming request, e.g. \"GET\", \"POST\"...\n-     *\n-     * @return Http method.\n-     */\n-    String method();\n-}\n```\n\nFilename: extensions/data-plane/data-plane-public-api/src/main/java/org/eclipse/edc/connector/dataplane/api/controller/ContainerRequestContextApiImpl.java:\n```\n@@ -1,108 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.dataplane.api.controller;\n-\n-import jakarta.ws.rs.container.ContainerRequestContext;\n-import jakarta.ws.rs.core.MediaType;\n-import org.eclipse.edc.spi.EdcException;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-/**\n- * This class provides a set of API wrapping a {@link ContainerRequestContext}.\n- */\n-public class ContainerRequestContextApiImpl implements ContainerRequestContextApi {\n-\n-    private static final String QUERY_PARAM_SEPARATOR = \"&\";\n-\n-    private final ContainerRequestContext context;\n-\n-    public ContainerRequestContextApiImpl(ContainerRequestContext context) {\n-        this.context = context;\n-    }\n-\n-    @Override\n-    public Map<String, String> headers() {\n-        return context.getHeaders().entrySet()\n-                .stream()\n-                .filter(entry -> !entry.getValue().isEmpty())\n-                .collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().get(0)));\n-    }\n-\n-    @Override\n-    public String queryParams() {\n-        return context.getUriInfo().getQueryParameters().entrySet()\n-                .stream()\n-                .map(entry -> new QueryParam(entry.getKey(), entry.getValue()))\n-                .filter(QueryParam::isValid)\n-                .map(QueryParam::toString)\n-                .collect(Collectors.joining(QUERY_PARAM_SEPARATOR));\n-    }\n-\n-    @Override\n-    public String body() {\n-        try (BufferedReader br = new BufferedReader(new InputStreamReader(context.getEntityStream()))) {\n-            return br.lines().collect(Collectors.joining(\"\\n\"));\n-        } catch (IOException e) {\n-            throw new EdcException(\"Failed to read request body: \" + e.getMessage());\n-        }\n-    }\n-\n-    @Override\n-    public String path() {\n-        var pathInfo = context.getUriInfo().getPath();\n-        return pathInfo.startsWith(\"/\") ? pathInfo.substring(1) : pathInfo;\n-    }\n-\n-    @Override\n-    public String mediaType() {\n-        return Optional.ofNullable(context.getMediaType())\n-                .map(MediaType::toString)\n-                .orElse(null);\n-    }\n-\n-    @Override\n-    public String method() {\n-        return context.getMethod();\n-    }\n-\n-    private static final class QueryParam {\n-\n-        private final String key;\n-        private final List<String> values;\n-        private final boolean valid;\n-\n-        private QueryParam(String key, List<String> values) {\n-            this.key = key;\n-            this.values = values;\n-            this.valid = key != null && values != null && !values.isEmpty();\n-        }\n-\n-        public boolean isValid() {\n-            return valid;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return valid ? key + \"=\" + values.get(0) : \"\";\n-        }\n-    }\n-}\n```\n\nFilename: extensions/data-plane/data-plane-public-api/src/main/java/org/eclipse/edc/connector/dataplane/api/controller/DataFlowRequestSupplier.java:\n```\n@@ -1,73 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.dataplane.api.controller;\n-\n-import org.eclipse.edc.connector.dataplane.util.sink.AsyncStreamingDataSink;\n-import org.eclipse.edc.spi.types.domain.DataAddress;\n-import org.eclipse.edc.spi.types.domain.transfer.DataFlowStartMessage;\n-import org.eclipse.edc.spi.types.domain.transfer.FlowType;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.UUID;\n-import java.util.function.BiFunction;\n-\n-import static org.eclipse.edc.connector.dataplane.spi.schema.DataFlowRequestSchema.BODY;\n-import static org.eclipse.edc.connector.dataplane.spi.schema.DataFlowRequestSchema.MEDIA_TYPE;\n-import static org.eclipse.edc.connector.dataplane.spi.schema.DataFlowRequestSchema.METHOD;\n-import static org.eclipse.edc.connector.dataplane.spi.schema.DataFlowRequestSchema.PATH;\n-import static org.eclipse.edc.connector.dataplane.spi.schema.DataFlowRequestSchema.QUERY_PARAMS;\n-\n-public class DataFlowRequestSupplier implements BiFunction<ContainerRequestContextApi, DataAddress, DataFlowStartMessage> {\n-\n-    /**\n-     * Put all properties of the incoming request (method, request body, query params...) into a map.\n-     */\n-    private static Map<String, String> createProps(ContainerRequestContextApi contextApi) {\n-        var props = new HashMap<String, String>();\n-        props.put(METHOD, contextApi.method());\n-        props.put(QUERY_PARAMS, contextApi.queryParams());\n-        props.put(PATH, contextApi.path());\n-        Optional.ofNullable(contextApi.mediaType())\n-                .ifPresent(mediaType -> {\n-                    props.put(MEDIA_TYPE, mediaType);\n-                    props.put(BODY, contextApi.body());\n-                });\n-        return props;\n-    }\n-\n-    /**\n-     * Create a {@link DataFlowStartMessage} based on incoming request and claims decoded from the access token.\n-     *\n-     * @param contextApi  Api for accessing request properties.\n-     * @param dataAddress Source data address.\n-     * @return DataFlowRequest\n-     */\n-    @Override\n-    public DataFlowStartMessage apply(ContainerRequestContextApi contextApi, DataAddress dataAddress) {\n-        var props = createProps(contextApi);\n-        return DataFlowStartMessage.Builder.newInstance()\n-                .processId(UUID.randomUUID().toString())\n-                .sourceDataAddress(dataAddress)\n-                .flowType(FlowType.PULL)\n-                .destinationDataAddress(DataAddress.Builder.newInstance()\n-                        .type(AsyncStreamingDataSink.TYPE)\n-                        .build())\n-                .id(UUID.randomUUID().toString())\n-                .properties(props)\n-                .build();\n-    }\n-}\n```\n\nFilename: extensions/data-plane/data-plane-public-api/src/main/java/org/eclipse/edc/connector/dataplane/api/controller/DataPlanePublicApi.java:\n```\n@@ -1,90 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - Initial implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.dataplane.api.controller;\n-\n-import io.swagger.v3.oas.annotations.OpenAPIDefinition;\n-import io.swagger.v3.oas.annotations.Operation;\n-import io.swagger.v3.oas.annotations.responses.ApiResponse;\n-import io.swagger.v3.oas.annotations.tags.Tag;\n-import jakarta.ws.rs.container.AsyncResponse;\n-import jakarta.ws.rs.container.ContainerRequestContext;\n-\n-@OpenAPIDefinition\n-@Tag(name = \"Data Plane public API\",\n-        description = \"The public API of the Data Plane is a data proxy enabling a data consumer to actively query\" +\n-                \"data from the provider data source (e.g. backend Rest API, internal database...) through its Data Plane\" +\n-                \"instance. Thus the Data Plane is the only entry/output door for the data, which avoids the provider to expose\" +\n-                \"directly its data externally.\" +\n-                \"The Data Plane public API being a proxy, it supports all verbs (i.e. GET, POST, PUT, PATCH, DELETE), which\" +\n-                \"can then conveyed until the data source is required. This is especially useful when the actual data source\" +\n-                \"is a Rest API itself.\" +\n-                \"In the same manner, any set of arbitrary query parameters, path parameters and request body are supported \" +\n-                \"(in the limits fixed by the HTTP server) and can also conveyed to the actual data source.\")\n-@Deprecated(since = \"0.6.0\")\n-public interface DataPlanePublicApi {\n-\n-    @Operation(description = \"Send `GET` data query to the Data Plane.\",\n-            responses = {\n-                    @ApiResponse(responseCode = \"400\", description = \"Missing access token\"),\n-                    @ApiResponse(responseCode = \"403\", description = \"Access token is expired or invalid\"),\n-                    @ApiResponse(responseCode = \"500\", description = \"Failed to transfer data\")\n-            },\n-            deprecated = true\n-    )\n-    @Deprecated(since = \"0.5.1\")\n-    void get(ContainerRequestContext context, AsyncResponse response);\n-\n-    @Operation(description = \"Send `POST` data query to the Data Plane.\",\n-            responses = {\n-                    @ApiResponse(responseCode = \"400\", description = \"Missing access token\"),\n-                    @ApiResponse(responseCode = \"403\", description = \"Access token is expired or invalid\"),\n-                    @ApiResponse(responseCode = \"500\", description = \"Failed to transfer data\")\n-            },\n-            deprecated = true\n-    )\n-    @Deprecated(since = \"0.5.1\")\n-    void post(ContainerRequestContext context, AsyncResponse response);\n-\n-    @Operation(description = \"Send `PUT` data query to the Data Plane.\",\n-            responses = {\n-                    @ApiResponse(responseCode = \"400\", description = \"Missing access token\"),\n-                    @ApiResponse(responseCode = \"403\", description = \"Access token is expired or invalid\"),\n-                    @ApiResponse(responseCode = \"500\", description = \"Failed to transfer data\")\n-            },\n-            deprecated = true\n-    )\n-    @Deprecated(since = \"0.5.1\")\n-    void put(ContainerRequestContext context, AsyncResponse response);\n-\n-    @Operation(description = \"Send `DELETE` data query to the Data Plane.\",\n-            responses = {\n-                    @ApiResponse(responseCode = \"400\", description = \"Missing access token\"),\n-                    @ApiResponse(responseCode = \"403\", description = \"Access token is expired or invalid\"),\n-                    @ApiResponse(responseCode = \"500\", description = \"Failed to transfer data\")\n-            }\n-    )\n-    void delete(ContainerRequestContext context, AsyncResponse response);\n-\n-    @Operation(description = \"Send `PATCH` data query to the Data Plane.\",\n-            responses = {\n-                    @ApiResponse(responseCode = \"400\", description = \"Missing access token\"),\n-                    @ApiResponse(responseCode = \"403\", description = \"Access token is expired or invalid\"),\n-                    @ApiResponse(responseCode = \"500\", description = \"Failed to transfer data\")\n-            },\n-            deprecated = true\n-    )\n-    @Deprecated(since = \"0.5.1\")\n-    void patch(ContainerRequestContext context, AsyncResponse response);\n-}\n```\n\nFilename: extensions/data-plane/data-plane-public-api/src/main/java/org/eclipse/edc/connector/dataplane/api/controller/DataPlanePublicApiController.java:\n```\n@@ -1,168 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - initial API and implementation\n- *       Bayerische Motoren Werke Aktiengesellschaft (BMW AG) - improvements\n- *       Mercedes-Benz Tech Innovation GmbH - publish public api context into dedicated swagger hub page\n- *\n- */\n-\n-package org.eclipse.edc.connector.dataplane.api.controller;\n-\n-import jakarta.ws.rs.DELETE;\n-import jakarta.ws.rs.GET;\n-import jakarta.ws.rs.PATCH;\n-import jakarta.ws.rs.POST;\n-import jakarta.ws.rs.PUT;\n-import jakarta.ws.rs.Path;\n-import jakarta.ws.rs.Produces;\n-import jakarta.ws.rs.container.AsyncResponse;\n-import jakarta.ws.rs.container.ContainerRequestContext;\n-import jakarta.ws.rs.container.Suspended;\n-import jakarta.ws.rs.core.Context;\n-import jakarta.ws.rs.core.HttpHeaders;\n-import jakarta.ws.rs.core.Response;\n-import jakarta.ws.rs.core.StreamingOutput;\n-import org.eclipse.edc.connector.dataplane.spi.pipeline.PipelineService;\n-import org.eclipse.edc.connector.dataplane.spi.resolver.DataAddressResolver;\n-import org.eclipse.edc.connector.dataplane.spi.response.TransferErrorResponse;\n-import org.eclipse.edc.connector.dataplane.util.sink.AsyncStreamingDataSink;\n-import org.eclipse.edc.spi.monitor.Monitor;\n-\n-import java.util.List;\n-import java.util.concurrent.ExecutorService;\n-\n-import static jakarta.ws.rs.core.MediaType.APPLICATION_JSON;\n-import static jakarta.ws.rs.core.MediaType.WILDCARD;\n-import static jakarta.ws.rs.core.Response.Status.BAD_REQUEST;\n-import static jakarta.ws.rs.core.Response.Status.FORBIDDEN;\n-import static jakarta.ws.rs.core.Response.Status.INTERNAL_SERVER_ERROR;\n-import static jakarta.ws.rs.core.Response.status;\n-\n-@Path(\"{any:.*}\")\n-@Produces(WILDCARD)\n-@Deprecated(since = \"0.6.0\")\n-public class DataPlanePublicApiController implements DataPlanePublicApi {\n-\n-    private final PipelineService pipelineService;\n-    private final DataAddressResolver dataAddressResolver;\n-    private final DataFlowRequestSupplier requestSupplier;\n-    private final ExecutorService executorService;\n-    private final Monitor monitor;\n-\n-    public DataPlanePublicApiController(PipelineService pipelineService, DataAddressResolver dataAddressResolver,\n-                                        ExecutorService executorService, Monitor monitor) {\n-        this.pipelineService = pipelineService;\n-        this.dataAddressResolver = dataAddressResolver;\n-        this.monitor = monitor;\n-        this.requestSupplier = new DataFlowRequestSupplier();\n-        this.executorService = executorService;\n-    }\n-\n-    private static Response error(Response.Status status, String error) {\n-        return status(status).type(APPLICATION_JSON).entity(new TransferErrorResponse(List.of(error))).build();\n-    }\n-\n-    @GET\n-    @Override\n-    public void get(@Context ContainerRequestContext requestContext, @Suspended AsyncResponse response) {\n-        handle(requestContext, response);\n-    }\n-\n-    /**\n-     * Sends a {@link POST} request to the data source and returns data.\n-     *\n-     * @param requestContext Request context.\n-     * @param response       Data fetched from the data source.\n-     */\n-    @POST\n-    @Override\n-    public void post(@Context ContainerRequestContext requestContext, @Suspended AsyncResponse response) {\n-        handle(requestContext, response);\n-    }\n-\n-    /**\n-     * Sends a {@link PUT} request to the data source and returns data.\n-     *\n-     * @param requestContext Request context.\n-     * @param response       Data fetched from the data source.\n-     */\n-    @PUT\n-    @Override\n-    public void put(@Context ContainerRequestContext requestContext, @Suspended AsyncResponse response) {\n-        handle(requestContext, response);\n-    }\n-\n-    /**\n-     * Sends a {@link DELETE} request to the data source and returns data.\n-     *\n-     * @param requestContext Request context.\n-     * @param response       Data fetched from the data source.\n-     */\n-    @DELETE\n-    @Override\n-    public void delete(@Context ContainerRequestContext requestContext, @Suspended AsyncResponse response) {\n-        handle(requestContext, response);\n-    }\n-\n-    /**\n-     * Sends a {@link PATCH} request to the data source and returns data.\n-     *\n-     * @param requestContext Request context.\n-     * @param response       Data fetched from the data source.\n-     */\n-    @PATCH\n-    @Override\n-    public void patch(@Context ContainerRequestContext requestContext, @Suspended AsyncResponse response) {\n-        handle(requestContext, response);\n-    }\n-\n-    private void handle(ContainerRequestContext context, AsyncResponse response) {\n-\n-        monitor.warning(\"The DataPlane Public API is deprecated. Please consider upgrading to the /v2/ path. Your request will then be: %s\"\n-                .formatted(context.getUriInfo().getBaseUri() + \"v2/\" + context.getUriInfo().getPath()));\n-        var contextApi = new ContainerRequestContextApiImpl(context);\n-        var token = contextApi.headers().get(HttpHeaders.AUTHORIZATION);\n-        if (token == null) {\n-            response.resume(error(BAD_REQUEST, \"Missing token\"));\n-            return;\n-        }\n-\n-        var tokenValidation = dataAddressResolver.resolve(token);\n-        if (tokenValidation.failed()) {\n-            response.resume(error(FORBIDDEN, tokenValidation.getFailureDetail()));\n-            return;\n-        }\n-\n-        var dataAddress = tokenValidation.getContent();\n-        var dataFlowRequest = requestSupplier.apply(contextApi, dataAddress);\n-\n-        AsyncStreamingDataSink.AsyncResponseContext asyncResponseContext = callback -> {\n-            StreamingOutput output = t -> callback.outputStreamConsumer().accept(t);\n-            var resp = Response.ok(output).type(callback.mediaType()).build();\n-            return response.resume(resp);\n-        };\n-\n-        var sink = new AsyncStreamingDataSink(asyncResponseContext, executorService);\n-\n-        pipelineService.transfer(dataFlowRequest, sink)\n-                .whenComplete((result, throwable) -> {\n-                    if (throwable == null) {\n-                        if (result.failed()) {\n-                            response.resume(error(INTERNAL_SERVER_ERROR, result.getFailureDetail()));\n-                        }\n-                    } else {\n-                        var error = \"Unhandled exception occurred during data transfer: \" + throwable.getMessage();\n-                        response.resume(error(INTERNAL_SERVER_ERROR, error));\n-                    }\n-                });\n-    }\n-\n-}\n```\n\nFilename: extensions/data-plane/data-plane-public-api/src/main/java/org/eclipse/edc/connector/dataplane/api/validation/ConsumerPullTransferDataAddressResolver.java:\n```\n@@ -1,68 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.dataplane.api.validation;\n-\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import jakarta.ws.rs.core.HttpHeaders;\n-import okhttp3.Request;\n-import org.eclipse.edc.connector.dataplane.spi.resolver.DataAddressResolver;\n-import org.eclipse.edc.http.spi.EdcHttpClient;\n-import org.eclipse.edc.spi.result.Result;\n-import org.eclipse.edc.spi.types.domain.DataAddress;\n-\n-import java.io.IOException;\n-\n-import static java.lang.String.format;\n-\n-@Deprecated(since = \"0.6.0\")\n-public class ConsumerPullTransferDataAddressResolver implements DataAddressResolver {\n-\n-    private final EdcHttpClient httpClient;\n-    private final String endpoint;\n-    private final ObjectMapper mapper;\n-\n-    public ConsumerPullTransferDataAddressResolver(EdcHttpClient httpClient, String endpoint, ObjectMapper mapper) {\n-        this.httpClient = httpClient;\n-        this.endpoint = endpoint;\n-        this.mapper = mapper;\n-    }\n-\n-    /**\n-     * Resolves access token received in input of Data Plane public API (consumer pull) into the {@link DataAddress}\n-     * of the requested data.\n-     *\n-     * @param token Access token received in input of the Data Plane public API\n-     * @return Data address\n-     */\n-    @Override\n-    public Result<DataAddress> resolve(String token) {\n-        var request = new Request.Builder().url(endpoint).header(HttpHeaders.AUTHORIZATION, token).get().build();\n-        try (var response = httpClient.execute(request)) {\n-            var body = response.body();\n-            var stringBody = body != null ? body.string() : null;\n-            if (stringBody == null) {\n-                return Result.failure(\"Token validation server returned null body\");\n-            }\n-\n-            if (response.isSuccessful()) {\n-                return Result.success(mapper.readValue(stringBody, DataAddress.class));\n-            } else {\n-                return Result.failure(format(\"Call to token validation sever failed: %s - %s. %s\", response.code(), response.message(), stringBody));\n-            }\n-        } catch (IOException e) {\n-            return Result.failure(\"Unhandled exception occurred during call to token validation server: \" + e.getMessage());\n-        }\n-    }\n-}\n```\n\nFilename: extensions/data-plane/data-plane-public-api/src/main/resources/META-INF/services/org.eclipse.edc.spi.system.ServiceExtension:\n```\n@@ -1 +0,0 @@\n-org.eclipse.edc.connector.dataplane.api.DataPlanePublicApiExtension\n\\ No newline at end of file\n```\n\nFilename: extensions/data-plane/data-plane-public-api/src/test/java/org/eclipse/edc/connector/dataplane/api/controller/DataFlowStartMessageSupplierTest.java:\n```\n@@ -1,94 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.dataplane.api.controller;\n-\n-import jakarta.ws.rs.HttpMethod;\n-import jakarta.ws.rs.core.MediaType;\n-import org.eclipse.edc.connector.dataplane.spi.schema.DataFlowRequestSchema;\n-import org.eclipse.edc.connector.dataplane.util.sink.AsyncStreamingDataSink;\n-import org.eclipse.edc.spi.types.domain.DataAddress;\n-import org.junit.jupiter.api.Test;\n-\n-import java.util.Map;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.when;\n-\n-class DataFlowStartMessageSupplierTest {\n-\n-\n-    private final DataFlowRequestSupplier supplier = new DataFlowRequestSupplier();\n-\n-    private static DataAddress createDataAddress() {\n-        return DataAddress.Builder.newInstance().type(\"test-type\").build();\n-    }\n-\n-    @Test\n-    void verifyMapping_noInputBody() {\n-        var contextApi = mock(ContainerRequestContextApi.class);\n-        var address = createDataAddress();\n-\n-        var method = HttpMethod.GET;\n-        var queryParams = \"test-query-param\";\n-        var path = \"test-path\";\n-\n-        when(contextApi.method()).thenReturn(method);\n-        when(contextApi.queryParams()).thenReturn(queryParams);\n-        when(contextApi.path()).thenReturn(path);\n-\n-        var request = supplier.apply(contextApi, address);\n-\n-        assertThat(request.getId()).isNotBlank();\n-        assertThat(request.getDestinationDataAddress().getType()).isEqualTo(AsyncStreamingDataSink.TYPE);\n-        assertThat(request.getSourceDataAddress().getType()).isEqualTo(address.getType());\n-        assertThat(request.getProperties()).containsExactlyInAnyOrderEntriesOf(Map.of(\n-                DataFlowRequestSchema.PATH, path,\n-                DataFlowRequestSchema.METHOD, method,\n-                DataFlowRequestSchema.QUERY_PARAMS, queryParams\n-\n-        ));\n-    }\n-\n-    @Test\n-    void verifyMapping_withInputBody() {\n-        var contextApi = mock(ContainerRequestContextApi.class);\n-        var address = createDataAddress();\n-\n-        var method = HttpMethod.GET;\n-        var queryParams = \"test-query-param\";\n-        var path = \"test-path\";\n-        var body = \"Test request body\";\n-\n-        when(contextApi.method()).thenReturn(method);\n-        when(contextApi.queryParams()).thenReturn(queryParams);\n-        when(contextApi.path()).thenReturn(path);\n-        when(contextApi.mediaType()).thenReturn(MediaType.TEXT_PLAIN);\n-        when(contextApi.body()).thenReturn(body);\n-\n-        var request = supplier.apply(contextApi, address);\n-\n-        assertThat(request.getId()).isNotBlank();\n-        assertThat(request.getDestinationDataAddress().getType()).isEqualTo(AsyncStreamingDataSink.TYPE);\n-        assertThat(request.getSourceDataAddress().getType()).isEqualTo(address.getType());\n-        assertThat(request.getProperties()).containsExactlyInAnyOrderEntriesOf(Map.of(\n-                DataFlowRequestSchema.PATH, path,\n-                DataFlowRequestSchema.METHOD, method,\n-                DataFlowRequestSchema.QUERY_PARAMS, queryParams,\n-                DataFlowRequestSchema.BODY, body,\n-                DataFlowRequestSchema.MEDIA_TYPE, MediaType.TEXT_PLAIN\n-        ));\n-    }\n-}\n```\n\nFilename: extensions/data-plane/data-plane-public-api/src/test/java/org/eclipse/edc/connector/dataplane/api/controller/DataPlanePublicApiControllerTest.java:\n```\n@@ -1,190 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - initial API and implementation\n- *       Bayerische Motoren Werke Aktiengesellschaft (BMW AG) - improvements\n- *\n- */\n-\n-package org.eclipse.edc.connector.dataplane.api.controller;\n-\n-import io.restassured.specification.RequestSpecification;\n-import jakarta.ws.rs.core.Response;\n-import org.eclipse.edc.connector.dataplane.spi.pipeline.DataSource;\n-import org.eclipse.edc.connector.dataplane.spi.pipeline.PipelineService;\n-import org.eclipse.edc.connector.dataplane.spi.pipeline.StreamResult;\n-import org.eclipse.edc.connector.dataplane.spi.resolver.DataAddressResolver;\n-import org.eclipse.edc.connector.dataplane.util.sink.AsyncStreamingDataSink;\n-import org.eclipse.edc.junit.annotations.ApiTest;\n-import org.eclipse.edc.spi.result.Result;\n-import org.eclipse.edc.spi.types.domain.DataAddress;\n-import org.eclipse.edc.spi.types.domain.transfer.DataFlowStartMessage;\n-import org.eclipse.edc.web.jersey.testfixtures.RestControllerTestBase;\n-import org.junit.jupiter.api.Test;\n-import org.mockito.ArgumentCaptor;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.InputStream;\n-import java.util.UUID;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.Executors;\n-import java.util.stream.Stream;\n-\n-import static io.restassured.RestAssured.given;\n-import static io.restassured.http.ContentType.JSON;\n-import static jakarta.ws.rs.core.HttpHeaders.AUTHORIZATION;\n-import static java.util.concurrent.CompletableFuture.completedFuture;\n-import static java.util.concurrent.CompletableFuture.failedFuture;\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.eclipse.edc.connector.dataplane.spi.pipeline.StreamFailure.Reason.GENERAL_ERROR;\n-import static org.hamcrest.CoreMatchers.is;\n-import static org.hamcrest.CoreMatchers.not;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.when;\n-\n-@ApiTest\n-class DataPlanePublicApiControllerTest extends RestControllerTestBase {\n-\n-    private final PipelineService pipelineService = mock();\n-    private final DataAddressResolver dataAddressResolver = mock();\n-\n-    @Test\n-    void should_returnBadRequest_if_missingAuthorizationHeader() {\n-        baseRequest()\n-                .post(\"/any\")\n-                .then()\n-                .statusCode(Response.Status.BAD_REQUEST.getStatusCode())\n-                .body(\"errors[0]\", is(\"Missing token\"));\n-    }\n-\n-    @Test\n-    void shouldNotReturn302_whenUrlWithoutTrailingSlash() {\n-        baseRequest()\n-                .post(\"\")\n-                .then()\n-                .statusCode(not(302));\n-    }\n-\n-    @Test\n-    void should_returnForbidden_if_tokenValidationFails() {\n-        var token = UUID.randomUUID().toString();\n-        when(dataAddressResolver.resolve(any())).thenReturn(Result.failure(\"token is not value\"));\n-\n-        baseRequest()\n-                .header(AUTHORIZATION, token)\n-                .post(\"/any\")\n-                .then()\n-                .statusCode(Response.Status.FORBIDDEN.getStatusCode())\n-                .contentType(JSON)\n-                .body(\"errors.size()\", is(1));\n-\n-        verify(dataAddressResolver).resolve(token);\n-    }\n-\n-    @Test\n-    void should_returnInternalServerError_if_transferFails() {\n-        var token = UUID.randomUUID().toString();\n-        var errorMsg = UUID.randomUUID().toString();\n-        when(dataAddressResolver.resolve(any())).thenReturn(Result.success(testDestAddress()));\n-        when(pipelineService.transfer(any(), any()))\n-                .thenReturn(completedFuture(StreamResult.error(errorMsg)));\n-\n-        baseRequest()\n-                .header(AUTHORIZATION, token)\n-                .when()\n-                .post(\"/any\")\n-                .then()\n-                .statusCode(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode())\n-                .contentType(JSON)\n-                .body(\"errors[0]\", is(GENERAL_ERROR + \": \" + errorMsg));\n-    }\n-\n-    @Test\n-    void should_returnInternalServerError_if_transferThrows() {\n-        var token = UUID.randomUUID().toString();\n-        var errorMsg = UUID.randomUUID().toString();\n-        when(dataAddressResolver.resolve(any())).thenReturn(Result.success(testDestAddress()));\n-        when(pipelineService.transfer(any(DataFlowStartMessage.class), any()))\n-                .thenReturn(failedFuture(new RuntimeException(errorMsg)));\n-\n-        baseRequest()\n-                .header(AUTHORIZATION, token)\n-                .when()\n-                .post(\"/any\")\n-                .then()\n-                .statusCode(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode())\n-                .contentType(JSON)\n-                .body(\"errors[0]\", is(\"Unhandled exception occurred during data transfer: \" + errorMsg));\n-    }\n-\n-    @Test\n-    void shouldStreamSourceToResponse() {\n-        when(dataAddressResolver.resolve(any())).thenReturn(Result.success(testDestAddress()));\n-        when(pipelineService.transfer(any(), any())).thenAnswer(i -> {\n-            ((AsyncStreamingDataSink) i.getArgument(1)).transfer(new TestDataSource(\"application/something\", \"data\"));\n-            return CompletableFuture.completedFuture(StreamResult.success());\n-        });\n-\n-        var responseBody = baseRequest()\n-                .header(AUTHORIZATION, UUID.randomUUID().toString())\n-                .when()\n-                .post(\"/any?foo=bar\")\n-                .then()\n-                .log().ifError()\n-                .statusCode(Response.Status.OK.getStatusCode())\n-                .contentType(\"application/something\")\n-                .extract().body().asString();\n-\n-        assertThat(responseBody).isEqualTo(\"data\");\n-        var requestCaptor = ArgumentCaptor.forClass(DataFlowStartMessage.class);\n-        verify(pipelineService).transfer(requestCaptor.capture(), any());\n-        var request = requestCaptor.getValue();\n-        assertThat(request.getDestinationDataAddress().getType()).isEqualTo(AsyncStreamingDataSink.TYPE);\n-        assertThat(request.getSourceDataAddress().getType()).isEqualTo(\"test\");\n-        assertThat(request.getProperties()).containsEntry(\"method\", \"POST\").containsEntry(\"pathSegments\", \"any\").containsEntry(\"queryParams\", \"foo=bar\");\n-    }\n-\n-    @Override\n-    protected Object controller() {\n-        return new DataPlanePublicApiController(pipelineService, dataAddressResolver, Executors.newSingleThreadExecutor(), mock());\n-    }\n-\n-    private RequestSpecification baseRequest() {\n-        return given()\n-                .baseUri(\"http://localhost:\" + port)\n-                .when();\n-    }\n-\n-    private DataAddress testDestAddress() {\n-        return DataAddress.Builder.newInstance().type(\"test\").build();\n-    }\n-\n-    private record TestDataSource(String mediaType, String data) implements DataSource, DataSource.Part {\n-\n-        @Override\n-        public StreamResult<Stream<Part>> openPartStream() {\n-            return StreamResult.success(Stream.of(this));\n-        }\n-\n-        @Override\n-        public String name() {\n-            return \"test\";\n-        }\n-\n-        @Override\n-        public InputStream openStream() {\n-            return new ByteArrayInputStream(data.getBytes());\n-        }\n-\n-    }\n-\n-}\n```\n\nFilename: extensions/data-plane/data-plane-public-api/src/test/java/org/eclipse/edc/connector/dataplane/api/validation/ConsumerPullTransferDataAddressResolverTest.java:\n```\n@@ -1,106 +0,0 @@\n-/*\n- *  Copyright (c) 2022 Amadeus\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Amadeus - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.dataplane.api.validation;\n-\n-import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import jakarta.ws.rs.core.HttpHeaders;\n-import org.eclipse.edc.json.JacksonTypeManager;\n-import org.eclipse.edc.spi.types.domain.DataAddress;\n-import org.junit.jupiter.api.AfterAll;\n-import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-import org.mockserver.integration.ClientAndServer;\n-import org.mockserver.model.HttpRequest;\n-import org.mockserver.model.HttpResponse;\n-import org.mockserver.model.MediaType;\n-\n-import java.util.UUID;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.eclipse.edc.http.client.testfixtures.HttpTestUtils.testHttpClient;\n-import static org.eclipse.edc.util.io.Ports.getFreePort;\n-import static org.mockserver.integration.ClientAndServer.startClientAndServer;\n-import static org.mockserver.matchers.Times.once;\n-import static org.mockserver.stop.Stop.stopQuietly;\n-\n-class ConsumerPullTransferDataAddressResolverTest {\n-\n-    private static final ObjectMapper MAPPER = new JacksonTypeManager().getMapper();\n-    private static final int PORT = getFreePort();\n-    private static final String TOKEN_VALIDATION_SERVER_URL = \"http://localhost:\" + PORT;\n-    private static ClientAndServer validationClientAndServer;\n-\n-    private ConsumerPullTransferDataAddressResolver resolver;\n-\n-    @BeforeAll\n-    public static void startServer() {\n-        validationClientAndServer = startClientAndServer(PORT);\n-    }\n-\n-    @AfterAll\n-    public static void stopServer() {\n-        stopQuietly(validationClientAndServer);\n-    }\n-\n-    @BeforeEach\n-    public void setUp() {\n-        resolver = new ConsumerPullTransferDataAddressResolver(testHttpClient(), TOKEN_VALIDATION_SERVER_URL, MAPPER);\n-    }\n-\n-    @AfterEach\n-    public void tearDown() {\n-        validationClientAndServer.reset();\n-    }\n-\n-    @Test\n-    void verifySuccessTokenValidation() throws JsonProcessingException {\n-        var token = UUID.randomUUID().toString();\n-        var address = DataAddress.Builder.newInstance()\n-                .type(\"test-type\")\n-                .build();\n-\n-        validationClientAndServer.when(new HttpRequest().withHeader(HttpHeaders.AUTHORIZATION, token), once())\n-                .respond(HttpResponse.response()\n-                        .withStatusCode(200)\n-                        .withBody(MAPPER.writeValueAsString(address))\n-                        .withContentType(MediaType.APPLICATION_JSON));\n-\n-        var result = resolver.resolve(token);\n-\n-        assertThat(result.succeeded()).isTrue();\n-        assertThat(result.getContent().getType()).isEqualTo(address.getType());\n-    }\n-\n-    @Test\n-    void verifyFailedResultReturnedIfServerResponseIsUnsuccessful() throws JsonProcessingException {\n-        var token = UUID.randomUUID().toString();\n-        var address = DataAddress.Builder.newInstance()\n-                .type(\"test-type\")\n-                .build();\n-\n-        validationClientAndServer.when(new HttpRequest().withHeader(HttpHeaders.AUTHORIZATION, token), once())\n-                .respond(HttpResponse.response()\n-                        .withStatusCode(400)\n-                        .withBody(MAPPER.writeValueAsString(address))\n-                        .withContentType(MediaType.APPLICATION_JSON));\n-\n-        var result = resolver.resolve(token);\n-\n-        assertThat(result.failed()).isTrue();\n-    }\n-}\n```\n\nFilename: extensions/data-plane/data-plane-signaling/data-plane-signaling-api-configuration/build.gradle.kts:\n```\n@@ -1,38 +0,0 @@\n-/*\n- *  Copyright (c) 2024 Bayerische Motoren Werke Aktiengesellschaft (BMW AG)\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Bayerische Motoren Werke Aktiengesellschaft (BMW AG) - initial API and implementation\n- *\n- */\n-\n-\n-plugins {\n-    `java-library`\n-}\n-\n-dependencies {\n-    api(project(\":spi:common:json-ld-spi\"))\n-    api(project(\":spi:common:web-spi\"))\n-    api(project(\":spi:data-plane:data-plane-spi\"))\n-\n-    implementation(project(\":core:common:lib:transform-lib\"))\n-    implementation(project(\":extensions:common:http:lib:jersey-providers-lib\"))\n-    implementation(project(\":extensions:data-plane:data-plane-signaling:data-plane-signaling-transform\"))\n-    implementation(libs.jakarta.rsApi)\n-\n-    testImplementation(project(\":core:common:junit\"))\n-}\n-edcBuild {\n-    swagger {\n-        apiGroup.set(\"control-api\")\n-    }\n-}\n-\n-\n```\n\nFilename: extensions/data-plane/data-plane-signaling/data-plane-signaling-api-configuration/src/main/java/org/eclipse/edc/connector/api/signaling/configuration/SignalingApiConfigurationExtension.java:\n```\n@@ -1,121 +0,0 @@\n-/*\n- *  Copyright (c) 2024 Bayerische Motoren Werke Aktiengesellschaft (BMW AG)\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Bayerische Motoren Werke Aktiengesellschaft (BMW AG) - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.api.signaling.configuration;\n-\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import jakarta.json.Json;\n-import org.eclipse.edc.connector.api.signaling.transform.from.JsonObjectFromDataFlowResponseMessageTransformer;\n-import org.eclipse.edc.connector.api.signaling.transform.to.JsonObjectToDataFlowStartMessageTransformer;\n-import org.eclipse.edc.connector.api.signaling.transform.to.JsonObjectToDataFlowSuspendMessageTransformer;\n-import org.eclipse.edc.connector.api.signaling.transform.to.JsonObjectToDataFlowTerminateMessageTransformer;\n-import org.eclipse.edc.jsonld.spi.JsonLd;\n-import org.eclipse.edc.runtime.metamodel.annotation.Extension;\n-import org.eclipse.edc.runtime.metamodel.annotation.Inject;\n-import org.eclipse.edc.runtime.metamodel.annotation.SettingContext;\n-import org.eclipse.edc.spi.system.ServiceExtension;\n-import org.eclipse.edc.spi.system.ServiceExtensionContext;\n-import org.eclipse.edc.spi.types.TypeManager;\n-import org.eclipse.edc.transform.spi.TypeTransformerRegistry;\n-import org.eclipse.edc.transform.transformer.dspace.from.JsonObjectFromDataAddressDspaceTransformer;\n-import org.eclipse.edc.transform.transformer.dspace.to.JsonObjectToDataAddressDspaceTransformer;\n-import org.eclipse.edc.web.jersey.providers.jsonld.JerseyJsonLdInterceptor;\n-import org.eclipse.edc.web.jersey.providers.jsonld.ObjectMapperProvider;\n-import org.eclipse.edc.web.spi.WebServer;\n-import org.eclipse.edc.web.spi.WebService;\n-import org.eclipse.edc.web.spi.configuration.ApiContext;\n-import org.eclipse.edc.web.spi.configuration.WebServiceConfigurer;\n-import org.eclipse.edc.web.spi.configuration.WebServiceSettings;\n-import org.jetbrains.annotations.NotNull;\n-\n-import java.util.Map;\n-\n-import static org.eclipse.edc.connector.api.signaling.configuration.SignalingApiConfigurationExtension.NAME;\n-import static org.eclipse.edc.jsonld.spi.Namespaces.DSPACE_PREFIX;\n-import static org.eclipse.edc.jsonld.spi.Namespaces.DSPACE_SCHEMA;\n-import static org.eclipse.edc.policy.model.OdrlNamespace.ODRL_PREFIX;\n-import static org.eclipse.edc.policy.model.OdrlNamespace.ODRL_SCHEMA;\n-import static org.eclipse.edc.spi.constants.CoreConstants.JSON_LD;\n-\n-@Deprecated(since = \"0.6.4\")\n-@Extension(value = NAME)\n-public class SignalingApiConfigurationExtension implements ServiceExtension {\n-\n-    public static final String NAME = \"DataPlane Signaling API Configuration Extension\";\n-\n-    @SettingContext(\"Signaling API context setting key\")\n-    private static final String SIGNALING_CONFIG_KEY = \"web.http.\" + ApiContext.SIGNALING;\n-\n-    public static final WebServiceSettings SETTINGS = WebServiceSettings.Builder.newInstance()\n-            .apiConfigKey(SIGNALING_CONFIG_KEY)\n-            .contextAlias(ApiContext.SIGNALING)\n-            .defaultPath(\"/api/signaling\")\n-            .defaultPort(10080)\n-            .useDefaultContext(false)\n-            .name(\"DataPlane Signaling API\")\n-            .build();\n-\n-    private static final String SIGNALING_SCOPE = \"SIGNALING_API\";\n-\n-    @Inject\n-    private WebService webService;\n-    @Inject\n-    private WebServiceConfigurer configurer;\n-    @Inject\n-    private WebServer webServer;\n-    @Inject\n-    private JsonLd jsonLd;\n-    @Inject\n-    private TypeManager typeManager;\n-    @Inject\n-    private TypeTransformerRegistry transformerRegistry;\n-\n-    @Override\n-    public String name() {\n-        return NAME;\n-    }\n-\n-    @Override\n-    public void initialize(ServiceExtensionContext context) {\n-        var warningMessage = \"\"\"\n-                The data-plane-signaling-api-configuration extension is deprecated as the related 'web.http.signaling'\n-                settings, please exclude from your build and configure your endpoints to the control-api context\n-                \"\"\";\n-        context.getMonitor().warning(warningMessage);\n-        var config = context.getConfig(SIGNALING_CONFIG_KEY);\n-        configurer.configure(config, webServer, SETTINGS);\n-\n-        jsonLd.registerNamespace(ODRL_PREFIX, ODRL_SCHEMA, SIGNALING_SCOPE);\n-        jsonLd.registerNamespace(DSPACE_PREFIX, DSPACE_SCHEMA, SIGNALING_SCOPE);\n-\n-        var jsonLdMapper = getJsonLdMapper();\n-        webService.registerResource(ApiContext.SIGNALING, new ObjectMapperProvider(jsonLdMapper));\n-        webService.registerResource(ApiContext.SIGNALING, new JerseyJsonLdInterceptor(jsonLd, jsonLdMapper, SIGNALING_SCOPE));\n-\n-        var factory = Json.createBuilderFactory(Map.of());\n-\n-        var signalingApiTypeTransformerRegistry = transformerRegistry.forContext(\"signaling-api\");\n-        signalingApiTypeTransformerRegistry.register(new JsonObjectToDataFlowStartMessageTransformer());\n-        signalingApiTypeTransformerRegistry.register(new JsonObjectToDataFlowSuspendMessageTransformer());\n-        signalingApiTypeTransformerRegistry.register(new JsonObjectToDataFlowTerminateMessageTransformer());\n-        signalingApiTypeTransformerRegistry.register(new JsonObjectToDataAddressDspaceTransformer());\n-        signalingApiTypeTransformerRegistry.register(new JsonObjectFromDataFlowResponseMessageTransformer(factory));\n-        signalingApiTypeTransformerRegistry.register(new JsonObjectFromDataAddressDspaceTransformer(factory, jsonLdMapper));\n-    }\n-\n-    @NotNull\n-    private ObjectMapper getJsonLdMapper() {\n-        return typeManager.getMapper(JSON_LD);\n-    }\n-}\n```\n\nFilename: extensions/data-plane/data-plane-signaling/data-plane-signaling-api-configuration/src/main/resources/META-INF/services/org.eclipse.edc.spi.system.ServiceExtension:\n```\n@@ -1,15 +0,0 @@\n-#\n-#  Copyright (c) 2024 Bayerische Motoren Werke Aktiengesellschaft (BMW AG)\n-#\n-#  This program and the accompanying materials are made available under the\n-#  terms of the Apache License, Version 2.0 which is available at\n-#  https://www.apache.org/licenses/LICENSE-2.0\n-#\n-#  SPDX-License-Identifier: Apache-2.0\n-#\n-#  Contributors:\n-#       Bayerische Motoren Werke Aktiengesellschaft (BMW AG) - initial API and implementation\n-#\n-#\n-\n-org.eclipse.edc.connector.api.signaling.configuration.SignalingApiConfigurationExtension\n```\n\nFilename: extensions/data-plane/data-plane-signaling/data-plane-signaling-api-configuration/src/test/java/org/eclipse/edc/connector/api/signaling/configuration/SignalingApiConfigurationExtensionTest.java:\n```\n@@ -1,78 +0,0 @@\n-/*\n- *  Copyright (c) 2024 Bayerische Motoren Werke Aktiengesellschaft (BMW AG)\n- *\n- *  This program and the accompanying materials are made available under the\n- *  terms of the Apache License, Version 2.0 which is available at\n- *  https://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  SPDX-License-Identifier: Apache-2.0\n- *\n- *  Contributors:\n- *       Bayerische Motoren Werke Aktiengesellschaft (BMW AG) - initial API and implementation\n- *\n- */\n-\n-package org.eclipse.edc.connector.api.signaling.configuration;\n-\n-import org.eclipse.edc.boot.system.DefaultServiceExtensionContext;\n-import org.eclipse.edc.junit.extensions.DependencyInjectionExtension;\n-import org.eclipse.edc.spi.monitor.Monitor;\n-import org.eclipse.edc.spi.system.ServiceExtensionContext;\n-import org.eclipse.edc.spi.system.configuration.Config;\n-import org.eclipse.edc.spi.system.configuration.ConfigFactory;\n-import org.eclipse.edc.transform.spi.TypeTransformerRegistry;\n-import org.eclipse.edc.web.jersey.providers.jsonld.JerseyJsonLdInterceptor;\n-import org.eclipse.edc.web.jersey.providers.jsonld.ObjectMapperProvider;\n-import org.eclipse.edc.web.spi.WebService;\n-import org.eclipse.edc.web.spi.configuration.ApiContext;\n-import org.eclipse.edc.web.spi.configuration.WebServiceConfiguration;\n-import org.eclipse.edc.web.spi.configuration.WebServiceConfigurer;\n-import org.jetbrains.annotations.NotNull;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.ExtendWith;\n-\n-import static org.eclipse.edc.connector.api.signaling.configuration.SignalingApiConfigurationExtension.SETTINGS;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.eq;\n-import static org.mockito.ArgumentMatchers.isA;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.when;\n-\n-@ExtendWith(DependencyInjectionExtension.class)\n-class SignalingApiConfigurationExtensionTest {\n-\n-    private final WebServiceConfigurer configurer = mock();\n-    private final Monitor monitor = mock();\n-    private final WebService webService = mock();\n-\n-    @BeforeEach\n-    void setUp(ServiceExtensionContext context) {\n-        TypeTransformerRegistry typeTransformerRegistry = mock();\n-        when(typeTransformerRegistry.forContext(any())).thenReturn(mock());\n-        context.registerService(TypeTransformerRegistry.class, typeTransformerRegistry);\n-        context.registerService(WebService.class, webService);\n-        context.registerService(WebServiceConfigurer.class, configurer);\n-    }\n-\n-    @Test\n-    void initialize_shouldConfigureAndRegisterResource(SignalingApiConfigurationExtension extension) {\n-        var context = contextWithConfig(ConfigFactory.empty());\n-        var configuration = WebServiceConfiguration.Builder.newInstance().path(\"/path\").port(1234).build();\n-        when(configurer.configure(any(), any(), any())).thenReturn(configuration);\n-\n-        extension.initialize(context);\n-\n-        verify(configurer).configure(any(), any(), eq(SETTINGS));\n-        verify(webService).registerResource(eq(ApiContext.SIGNALING), isA(ObjectMapperProvider.class));\n-        verify(webService).registerResource(eq(ApiContext.SIGNALING), isA(JerseyJsonLdInterceptor.class));\n-    }\n-\n-    @NotNull\n-    private DefaultServiceExtensionContext contextWithConfig(Config config) {\n-        var context = new DefaultServiceExtensionContext(monitor, config);\n-        context.initialize();\n-        return context;\n-    }\n-}\n```\n\nFilename: extensions/data-plane/data-plane-signaling/data-plane-signaling-client/build.gradle.kts:\n```\n@@ -25,7 +25,6 @@\ndependencies {\n     implementation(project(\":core:common:lib:util-lib\"))\n     implementation(project(\":core:common:lib:transform-lib\"))\n     implementation(project(\":extensions:data-plane:data-plane-signaling:data-plane-signaling-transform\"))\n-    implementation(project(\":extensions:data-plane:data-plane-client-embedded\"))\n \n     implementation(libs.opentelemetry.instrumentation.annotations)\n```\n\nFilename: extensions/data-plane/data-plane-signaling/data-plane-signaling-client/src/main/java/org/eclipse/edc/connector/dataplane/client/EmbeddedDataPlaneClient.java:\n```\n\n```\n\nFilename: extensions/data-plane/data-plane-signaling/data-plane-signaling-client/src/test/java/org/eclipse/edc/connector/dataplane/client/EmbeddedDataPlaneClientTest.java:\n```\n\n```\n\nFilename: settings.gradle.kts:\n```\n@@ -174,7 +174,6 @@\ninclude(\":extensions:control-plane:api:management-api:management-api-test-fixtur\n include(\":extensions:control-plane:api:management-api:policy-definition-api\")\n include(\":extensions:control-plane:api:management-api:transfer-process-api\")\n include(\":extensions:control-plane:api:management-api:edr-cache-api\")\n-include(\":extensions:control-plane:transfer:transfer-data-plane\")\n include(\":extensions:control-plane:transfer:transfer-data-plane-signaling\")\n include(\":extensions:control-plane:transfer:transfer-pull-http-receiver\")\n include(\":extensions:control-plane:transfer:transfer-pull-http-dynamic-receiver\")\n\n@@ -192,15 +191,10 @@\ninclude(\":extensions:control-plane:callback:callback-static-endpoint\")\n include(\":extensions:control-plane:edr:edr-store-receiver\")\n \n \n-include(\":extensions:data-plane:data-plane-client\")\n-include(\":extensions:data-plane:data-plane-client-embedded\")\n-include(\":extensions:data-plane:data-plane-control-api\")\n include(\":extensions:data-plane:data-plane-self-registration\")\n include(\":extensions:data-plane:data-plane-signaling:data-plane-signaling-api\")\n-include(\":extensions:data-plane:data-plane-signaling:data-plane-signaling-api-configuration\")\n include(\":extensions:data-plane:data-plane-signaling:data-plane-signaling-client\")\n include(\":extensions:data-plane:data-plane-signaling:data-plane-signaling-transform\")\n-include(\":extensions:data-plane:data-plane-public-api\")\n include(\":extensions:data-plane:data-plane-public-api-v2\")\n \n include(\":extensions:data-plane:data-plane-http\")\n```\n\nFilename: spi/common/core-spi/src/main/java/org/eclipse/edc/spi/query/Criterion.java:\n```\n@@ -18,7 +18,6 @@\nimport com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n \n import java.util.Objects;\n-import java.util.function.Function;\n \n import static java.lang.String.format;\n import static org.eclipse.edc.spi.constants.CoreConstants.EDC_NAMESPACE;\n\n@@ -74,11 +73,6 @@\npublic Criterion withLeftOperand(String operandLeft) {\n         return new Criterion(operandLeft, operator, getOperandRight());\n     }\n \n-    @Deprecated(since = \"0.5.0\")\n-    public Criterion withLeftOperand(Function<Object, Object> function) {\n-        return new Criterion(function.apply(operandLeft), operator, getOperandRight());\n-    }\n-\n     @Override\n     public int hashCode() {\n         return Objects.hash(operandLeft, operator, operandRight);\n```\n\nFilename: spi/common/json-ld-spi/src/main/java/org/eclipse/edc/jsonld/spi/PropertyAndTypeNames.java:\n```\n@@ -40,13 +40,7 @@\npublic interface PropertyAndTypeNames {\n     String EDC_CREATED_AT = EDC_NAMESPACE + \"createdAt\";\n \n     //DCT\n-    @Deprecated(since = \"0.5.1\")\n-    String DEPRECATED_DCT_FORMAT_ATTRIBUTE = \"https://purl.org/dc/terms/format\";\n     String DCT_FORMAT_ATTRIBUTE = DCT_SCHEMA + \"format\";\n-    @Deprecated(since = \"0.6.2\")\n-    String DCT_TERMS_ATTRIBUTE = DCT_SCHEMA + \"terms\";\n-    @Deprecated(since = \"0.6.2\")\n-    String DCT_ENDPOINT_URL_ATTRIBUTE = DCT_SCHEMA + \"endpointUrl\";\n \n     String ODRL_POLICY_ATTRIBUTE = ODRL_SCHEMA + \"hasPolicy\";\n     String ODRL_POLICY_TYPE_SET = ODRL_SCHEMA + \"Set\";\n```\n\nFilename: spi/control-plane/contract-spi/src/main/java/org/eclipse/edc/connector/controlplane/contract/spi/types/negotiation/ContractRequest.java:\n```\n@@ -31,8 +31,6 @@\npublic class ContractRequest {\n     public static final String CONTRACT_REQUEST_TYPE = EDC_NAMESPACE + \"ContractRequest\";\n     public static final String CONTRACT_REQUEST_COUNTER_PARTY_ADDRESS = EDC_NAMESPACE + \"counterPartyAddress\";\n     public static final String PROTOCOL = EDC_NAMESPACE + \"protocol\";\n-    @Deprecated(since = \"0.5.1\")\n-    public static final String PROVIDER_ID = EDC_NAMESPACE + \"providerId\";\n     public static final String POLICY = EDC_NAMESPACE + \"policy\";\n     public static final String CALLBACK_ADDRESSES = EDC_NAMESPACE + \"callbackAddresses\";\n```\n\nFilename: system-tests/e2e-dataplane-tests/runtimes/data-plane/build.gradle.kts:\n```\n@@ -23,10 +23,8 @@\ndependencies {\n     implementation(project(\":extensions:control-plane:api:control-plane-api-client\"))\n     implementation(project(\":extensions:data-plane:data-plane-http\"))\n     implementation(project(\":extensions:data-plane:data-plane-iam\"))\n-    implementation(project(\":extensions:data-plane:data-plane-control-api\"))\n     implementation(project(\":extensions:data-plane:data-plane-public-api-v2\"))\n     implementation(project(\":extensions:data-plane:data-plane-signaling:data-plane-signaling-api\"))\n-    implementation(project(\":extensions:data-plane:data-plane-signaling:data-plane-signaling-api-configuration\"))\n }\n \n edcBuild {\n```\n\nFilename: system-tests/e2e-transfer-test/data-plane/build.gradle.kts:\n```\n@@ -26,7 +26,6 @@\ndependencies {\n     implementation(project(\":extensions:data-plane:data-plane-http\"))\n     implementation(project(\":extensions:data-plane:data-plane-kafka\"))\n     implementation(project(\":extensions:data-plane:data-plane-http-oauth2\"))\n-    implementation(project(\":extensions:data-plane:data-plane-control-api\"))\n     implementation(project(\":extensions:data-plane:data-plane-public-api-v2\"))\n     implementation(project(\":extensions:data-plane:data-plane-signaling:data-plane-signaling-api\"))\n }\n```\n\nFilename: system-tests/management-api/management-api-test-runtime/build.gradle.kts:\n```\n@@ -26,7 +26,7 @@\ndependencies {\n     implementation(project(\":extensions:common:api:control-api-configuration\"))\n     implementation(project(\":extensions:control-plane:api:management-api\"))\n     implementation(project(\":extensions:control-plane:api:management-api:secrets-api\"))\n-    implementation(project(\":extensions:data-plane:data-plane-client\"))\n+    implementation(project(\":extensions:data-plane:data-plane-signaling:data-plane-signaling-client\"))\n \n     implementation(project(\":core:data-plane-selector:data-plane-selector-core\"))\n }\n```\n\nFilename: system-tests/telemetry/telemetry-test-runtime/build.gradle.kts:\n```\n@@ -27,7 +27,7 @@\ndependencies {\n     implementation(project(\":extensions:common:json-ld\"))\n     implementation(project(\":extensions:common:api:control-api-configuration\"))\n     implementation(project(\":extensions:control-plane:api:management-api\"))\n-    implementation(project(\":extensions:data-plane:data-plane-client\"))\n+    implementation(project(\":extensions:data-plane:data-plane-signaling:data-plane-signaling-client\"))\n \n     implementation(project(\":core:data-plane-selector:data-plane-selector-core\"))\n```\n\nFilename: system-tests/version-api/version-api-test-runner/src/test/java/org/eclipse/edc/test/e2e/versionapi/Runtimes.java:\n```\n@@ -14,13 +14,13 @@\npackage org.eclipse.edc.test.e2e.versionapi;\n \n+import org.eclipse.edc.connector.dataplane.selector.spi.client.DataPlaneClientFactory;\n import org.eclipse.edc.connector.dataplane.spi.manager.DataPlaneManager;\n import org.eclipse.edc.iam.identitytrust.sts.spi.service.StsClientService;\n import org.eclipse.edc.iam.identitytrust.sts.spi.service.StsClientTokenGeneratorService;\n import org.eclipse.edc.junit.extensions.EmbeddedRuntime;\n import org.eclipse.edc.junit.extensions.RuntimeExtension;\n import org.eclipse.edc.junit.extensions.RuntimePerClassExtension;\n-import org.eclipse.edc.sql.testfixtures.PostgresqlEndToEndInstance;\n import org.jetbrains.annotations.NotNull;\n \n import java.util.HashMap;\n\n@@ -33,6 +33,7 @@\npublic interface Runtimes {\n     static RuntimeExtension inMemoryRuntime() {\n         var rt = new RuntimePerClassExtension(new EmbeddedRuntime(\"control-plane\", inMemoryConfiguration(), \":system-tests:version-api:version-api-test-runtime\"));\n         rt.registerServiceMock(DataPlaneManager.class, mock());\n+        rt.registerServiceMock(DataPlaneClientFactory.class, mock());\n         rt.registerServiceMock(StsClientService.class, mock());\n         rt.registerServiceMock(StsClientTokenGeneratorService.class, mock());\n         return rt;\n\n@@ -56,17 +57,4 @@\nstatic HashMap<String, String> inMemoryConfiguration() {\n         };\n     }\n \n-    @NotNull\n-    static HashMap<String, String> postgresqlConfiguration() {\n-        var config = new HashMap<String, String>() {\n-            {\n-                put(\"edc.datasource.default.url\", PostgresqlEndToEndInstance.JDBC_URL_PREFIX + \"runtime\");\n-                put(\"edc.datasource.default.user\", PostgresqlEndToEndInstance.USER);\n-                put(\"edc.datasource.default.password\", PostgresqlEndToEndInstance.PASSWORD);\n-            }\n-        };\n-\n-        config.putAll(inMemoryConfiguration());\n-        return config;\n-    }\n }\n```\n\nFilename: system-tests/version-api/version-api-test-runtime/build.gradle.kts:\n```\n@@ -26,9 +26,7 @@\ndependencies {\n     implementation(project(\":extensions:control-plane:api:management-api\"))\n     implementation(project(\":extensions:control-plane:api:management-api:secrets-api\"))\n     implementation(project(\":extensions:common:api:version-api\"))\n-    implementation(project(\":extensions:data-plane:data-plane-control-api\"))\n     implementation(project(\":extensions:common:api:api-observability\"))\n-    implementation(project(\":extensions:data-plane:data-plane-client\"))\n     implementation(project(\":extensions:common:iam:identity-trust:identity-trust-sts:identity-trust-sts-api\"))\n     implementation(project(\":core:data-plane-selector:data-plane-selector-core\"))\n     implementation(project(\":extensions:common:api:control-api-configuration\"))\n```"
            }
        ],
        "sw_version": "v0.8.1",
        "sw_version_wget": "https://github.com/eclipse-edc/Connector/archive/refs/tags/v0.8.1.zip",
        "description": "In Eclipse Dataspace Components, from version 0.5.0 and before version 0.9.0, the ConsumerPullTransferTokenValidationApiController does not check for token validity (expiry, not-before, issuance date), which can allow an attacker to bypass the check for token expiration. The issue requires to have a dataplane configured to support http proxy consumer pull AND include the module \"transfer-data-plane\". The affected code was marked deprecated from the version 0.6.0 in favour of Dataplane Signaling. In 0.9.0 the vulnerable code has been removed.",
        "sec_adv": [
            {
                "url": "https://gitlab.eclipse.org/security/vulnerability-reports/-/issues/234",
                "content": "Skip to content\nGitLab\nExplore\nSign in\nPrimary navigation\nSearch or go to\nProject\nV\nvulnerability-reports\nManage\nPlan\nIssues\nIssue boards\nMilestones\nIterations\nDeploy\nHelp\nEclipse Projects Security\nvulnerability-reports\nIssues\n#234\nEclipse EDC: Consumer pull transfer token validation does not apply any rules (e. g., expiration check)\nIssue actions\nClosed\nIssue\ncreated\n9 months ago\nby\nThomas Neidhart\nBasic information\nProject name: Eclipse EDC\nProject id: technology.edc\nMaven artifact: org.eclipse.edc:transfer-data-plane\nWhat are the affected versions?\n[0.5.0 - current]\nWho is affected: Anyone using EDC version 0.5.0 or newer if they (a) have a dataplane configured to support http proxy consumer pull AND (b) include the modules \"transfer-data-plane\" and \"data-plane-public-api\".\nDetails of the issue\nThe issue is located in the ConsumerPullTransferTokenValidationApiController at this position in the code (\"issue location\"):\nhttps://github.com/eclipse-edc/Connector/blob/980f10f2ad21368a2dc07cf3654e640aa01e3216/extensions/control-plane/transfer/transfer-data-plane/src/main/java/org/eclipse/edc/connector/controlplane/transfer/dataplane/api/ConsumerPullTransferTokenValidationApiController.java#L60\nThe TokenValidationService's validate method takes 3 arguments:\nvalidate(@NotNull String token, PublicKeyResolver publicKeyResolver, TokenValidationRule... rules).\nBut only two arguments are provided in the \"issue location\".\nThe third argument determines which rules should be checked during validation.\nTherefore, we will have an empty array at runtime, resulting in an empty list.\nThe ExpirationDateValidationRule\nshould be checked for context TRANSFER_DATAPLANE_TOKEN_CONTEXT = \"dataplane-transfer\".\nSee registration to tokenValidationRulesRegistry.\nBut the tokenValidationRulesRegistry is never queried for that context.\nIn the \"issue location\" mentioned above, there should be something like tokenValidationRulesRegistry.getRules(TRANSFER_DATAPLANE_TOKEN_CONTEXT) as the third argument.\nLacking this third argument causes that the token is only checked regarding valid signature.\nThe expiration is not checked, i.e., expired tokens will indefinitely be considered as valid.\nThe logic of the \"issue location\" / ConsumerPullTransferTokenValidationApiController is used for example in consumer pull scenarios.\nIn a Consumer Pull scenario the consumer / consumer-side systems can \"pull data\" from the provider using the token beyond its expiration.\nBut data cannot only be pulled from the provider by the consumer. With EDC, \"data transfers\" can be used to modify resources at the provider side. Therefore, the impact of this vulnerability can be twofold:\nData can be pulled / data sources can be queried longer than actors are allowed to do so. This threatens confidentiality of the resources as consumers (that are no longer allowed to access the data) can still access the data.\nThere is a feature in EDC to proxy / forward the http request method, path, parameters, payload of the pull towards the data source (i.e., one can effectively expose a Web API to the consumer that can have POST endpoints and accepts payloads etc.). One can use consumer pull to issue an API call (with payload) to the provider's data source and receive the response (proxyMethod/Path/Payload/... feature enables some kind of bi-directional data transfer). Therefore, the threat is not limited to confidentiality / accessing resources longer than allowed but also to modify resources beyond the time allowed => threatens integrity.\nResult: Defective expiration / revocation of permissions granted to an entity to access / modify protected (possibly sensitive) resources.\nIn case the token leaks, entities that were never allowed to access the resources can access them indefinitely.\nThe only way to prevent access to the resources beyond expiration might be to block all accesses to the public (consumer pull) endpoint until a fix is available and the connector has been updated.\nAs far as I was able to track, the issue / vulnerability has been introduced with version v0.5.0 via commit https://github.com/eclipse-edc/Connector/commit/19ebb19495dc78c5b27b925baaf378b7e85885c7 and is still present in main branch (i.e., most recent versions).\nThe issue is located in the maven artifact \"org.eclipse.edc:transfer-data-plane\" ([0.5.0 - current]).\nI'm unsure which CWEs suit best here.\nAll in all, the issue is a missing check regarding the expiration of a JWT.\nSo the JWT can be used to access the data source (i.e., a HTTP Endpoint; possibly with the http request method, path, parameter, payload of ones choice) way beyond its expiration.\nI would grade the vulnerability as a\nCVSS:4.0/AV:N/AC:L/AT:P/PR:L/UI:N/VC:N/VI:N/VA:L/SC:H/SI:H/SA:L\n5.6 Medium\nAV Network, because the (consumer pull) public endpoint at the provider side is exposed to the internet.\nAC Low, as consumers can just keep using their system to access the resources beyond token expiration time.\nAT Present, as the consumer needs to have negotiated a contract agreement with the provider and requested a data transfer using http proxy consumer pull method to get the EDR with the token. To threat integrity of subsequent systems, proxyMethod/Path/Payload/... configuration needs to be enabled for the asset.\nPR Low, one needs access to the consumer's system to request the data from the provider's public (consumer pull) endpoint\nUI none, no additional user interaction required\nVC none, as no information is leaked from the connector / control plane\nVI none, no state change in the connector\nVA low, small load on the connector to check the token and to proxy/forward the request to the subsequent system (data source / API).\nSC high, (at least potentially) as the data / API access is provided based on strict policies to other data space participants that must meet certain criteria. => potentially access to sensitive data\nSI high, (at least potentially) as the data / API access is provided based on strict policies to other data space participants that must meet certain criteria. => potentially access to business critical systems / APIs?\nSA low, load on the subsequent system / API\nPlease let me know if the above description is sufficient to understand and assess the vulnerability and what are the next steps in the process.\nSteps to reproduce\nRun the sample: https://github.com/eclipse-edc/Samples/tree/3a08baeb959b4bc177a3b80814abddd2f37fb254/transfer/transfer-02-consumer-pull\nMake sure to use a version before commit https://github.com/eclipse-edc/Samples/commit/e2387fc2e5560c1b84c5a3fd33a776d6792aa0e7 (in that commit they switched from \"transfer-data-plane\"/\"data-plane-public-api\" to \"transfer-data-plane-signaling\"/\"data-plane-public-api-v2\").\nI tested it with revision 3a08baeb959b4bc177a3b80814abddd2f37fb254.\nMake sure to use Linux to run the samples (because of this bug)\nUse the token to retrieve the data (see 4. step of the guide).\nYou can inspect the token using jwt.io (by default, the token expires 10 minutes after being issued). Wait 10 minutes, token should be expired then. Repeat step 4. => Token is still accepted.\nYou can observe that the token / authCode can be used beyond its expiration.\nDo you know any mitigations of the issue?\nBlock access to the public (consumer pull) endpoint.\nOnce version with fix is available:\nUpdate to version with fix\nUnblock access to the public (consumer pull) endpoint.\nOr take the chance to get rid of deprecated \"data-plane-public-api\" and switch to \"data-plane-public-api-v2\" (which is not using the ConsumerPullTransferTokenValidationApiController with the missing checks).\n\n0\n\n0\nTo upload designs, you'll need to enable LFS and have an admin enable hashed storage. More information\nChild items\n0\nMore actions\nNo child items are currently assigned. Use child items to break down this issue into smaller parts.\nLinked items\n0\nLink issues together to show that they're related or that one is blocking others. Learn more.\nActivity\nSort or filter\nThomas Neidhart assigned to @neuschwa 9 months ago\nThomas Neidhart added\nFrom_ML\nlabel 9 months ago\nThomas Neidhart made the issue visible to everyone 9 months ago\nThomas Neidhart assigned to @mspiekermann 9 months ago\nThomas Neidhart made the issue confidential 9 months ago\nThomas Neidhart\n@netomi\n 9 months ago\nAuthor\n@mspiekermann I assigned this ticket to you as PL for the EDC project. Please let me know if I should add other project members for analysis.\nPhilipp Neuschwander\n@neuschwa\n 9 months ago\nHello, is there any update on this? Were you able to reproduce / confirm the reported vulnerability?\nCollapse replies\nThomas Neidhart\n@netomi\n 9 months ago\nAuthor\nsorry for the delay, I pinged the project lead of the edc project.\n\n1\nPlease register or sign in to reply\nThomas Neidhart made the issue visible to everyone 9 months ago\nThomas Neidhart assigned to @platzel 9 months ago\nThomas Neidhart made the issue confidential 9 months ago\nThomas Neidhart\n@netomi\n 9 months ago\nAuthor\n@platzel could you also please take a look for an assessment of the report? ty\nPaul Latzelsperger\n@platzel\n 9 months ago\nThis assessment references code that has been deprecated for ~ 6 months and that will be removed in the next major release (0.9.0) slated for sometime toward the end of August.\nSince this code is on the chopping block, I would consider this vulnerability inconsequential.\nMarkus Spiekermann\n@mspiekermann\n 9 months ago\nFully agree to Paul's comment and also already aligned with other committers. What would be the steps to take, if vulnerability is inconsequential? Do we still need to file an answer via a specific process?\nMarta Rybczynska\n@mrybczyn\n 9 months ago\nMaintainer\n@mspiekermann @platzel the issue has been already fixed as I can understand and it will be fixed in 0.9.0 if I understand correctly. However, it has been there in a a publicly released version.\nIs the statement from the report valid \"Result: Defective expiration / revocation of permissions granted to an entity to access / modify protected (possibly sensitive) resources.\" ?\nIf it is, there is a vulnerability, albeit one of lower severity.\nWhat we can do here is to assign a CVE and release it at the moment you will release 0.9.0 (and you add an appropriate note in the release notes to make it clear to users to remove all usages of that old API).\nWhat do you think?\n\n1\nCollapse replies\nPaul Latzelsperger\n@platzel\n 9 months ago\nThe assessment is accurate, and I'm fine with creating a CVE for it. However, I want to make it clear that the vuln occurs in deprecated code, that should not be used anymore (as per the definition of deprecated code), and the CVE should point that out. Once we release 0.9.0, the affected code will be gone and users can't use it anymore anyways.\nEdited 9 months ago by Paul Latzelsperger\nMarta Rybczynska\n@mrybczyn\n 9 months ago\nMaintainer\nYes, absolutely we can write that in the CVE entry. I've created cve-assignement#28 (closed) to discuss the formulation. You are all three added to it, please have a look if the wording looks good (will add CVSS et al when we have agreed of the wording of the summary).\nPhilipp Neuschwander\n@neuschwa\n 9 months ago\nHowever, I want to make it clear that the vuln occurs in deprecated code, that should not be used anymore (as per the definition of deprecated code), and the CVE should point that out. (#234 (comment 2617447))\nThat code from artifact org.eclipse.edc:data-plane-public-api has been deprecated in a later release (I think release 0.7.0, see commit https://github.com/eclipse-edc/Connector/commit/b39e5326b7e31fdf83bfc2f680a3a250f02a2a93). Back then in version 0.5.0 that part was not (yet) deprecated.\nHowever, just marking something in the code as deprecated does not mark the released maven artifact as deprecated. How do your users (the developers that use EDC to create something) get to know that org.eclipse.edc:data-plane-public-api is deprecated? Are they expected to check the source code to find the deprecation annotation? Was there a hint in the release notes?\nBy the way, the ConsumerPullTransferTokenValidationApiController that contains the issue/vulnerability has not been marked as deprecated yet.\nI'd recommend to make sure to get rid of the ConsumerPullTransferTokenValidationApiController and maybe other stuff from transfer-data-plane that is no longer needed in the 0.9.0 release as well (i.e., not only the data-plane-public-api stuff).\nPaul Latzelsperger\n@platzel\n 9 months ago\nlike i said, the entire transfer-data-plane module will be removed. that solves the problem once and for all.\nHow do your users (the developers that use EDC to create something) get to know that org.eclipse.edc:data-plane-public-api is deprecated? Are they expected to check the source code to find the deprecation annotation?\nThe ConsumerPullTransferTokenValidationApiController cannot be used standalone (At least it won't do anything useful), it has to be used in conjunction with the data-plane-public-api which was indeed marked deprecated in the OpenAPI spec. Users are expected to read documentation.\nBack then in version 0.5.0 that part was not (yet) deprecated.\nThat is irrelevant, what is relevant is the since attribute of the deprecation annotation.\nHowever, just marking something in the code as deprecated does not mark the released maven artifact as deprecated\nI know of no way to mark a Maven artefact deprecated.\nI stated my proposal in the linked CVE assignment and will recommend the exact same wording to the other EDC committers, who - as you know - decide how a CVE is handled.\nEdited 9 months ago by Paul Latzelsperger\nPhilipp Neuschwander\n@neuschwa\n 8 months ago\nToday, version 0.9.0 has been released and I can confirm that the modules transfer-data-plane and data-plane-public-api have been removed from the codebase via PR 4451 (\"refactor: cleanup deprecated stuff\").\nWhat we can do here is to assign a CVE and release it at the moment you will release 0.9.0 (and you add an appropriate note in the release notes to make it clear to users to remove all usages of that old API).\nIt seems like there is no CVE assigned yet (see cve-assignement#28 (closed)) and the release notes do not contain a hint about a vulnerability. The release notes only state \"refactor: cleanup deprecated stuff\" for the merged PR.\nDo you plan to do anything else?\nWhat are the next steps regarding this report and cve-assignement#28 (closed)?\nPaul Latzelsperger\n@platzel\n 8 months ago\nthe CVE can be released with the approved wording. Once the CVE is published, we will likely announce this in the usual EDC channels (Discord) and we can close this issue here.\nFrom my perspective, that wraps it up.\nPlease register or sign in to reply\nMarta Rybczynska mentioned in issue cve-assignement#28 (closed) 9 months ago\nPhilipp Neuschwander mentioned in issue #235 (closed) 9 months ago\nThomas Neidhart added\ncve\nrequested\nvulnerability\nconfirmed\nlabels 8 months ago\nThomas Neidhart added\ncve\nreserved\nlabel and removed\ncve\nrequested\nlabel 8 months ago\nThomas Neidhart added\ncve\npublished\nlabel and removed\ncve\nreserved\nlabel 8 months ago\nThomas Neidhart added\nresolution\nfixed\nlabel 8 months ago\nThomas Neidhart\n@netomi\n 8 months ago\nAuthor\nClosing this as the problem has been resolved and the CVE entry has been published. Thank you for your contributions.\nEdited 8 months ago by Thomas Neidhart\nThomas Neidhart closed 8 months ago\nThomas Neidhart made the issue visible to everyone 8 months ago\nPlease register or sign in to reply\n3 Assignees\nPhilipp Neuschwander\nPaul Latzelsperger\nMarkus Spiekermann\nEpic\nNone\nLabels\ncve\npublished\nresolution\nfixed\nvulnerability\nconfirmed\nFrom_ML\nMilestone\nNone\nIteration\nNone\nWeight\nNone\nDue date\nNone\nTime tracking\nNo estimate or time spent\nHealth status\nNone\nConfidentiality\nConfidentiality controls have moved to the issue actions menu () at the top of the page.\n5 Participants\nCopyright  Eclipse Foundation, Inc. All Rights Reserved.     Privacy Policy | Terms of Use | Copyright Agent",
                "effective": true,
                "effective_reason": "The advisory includes steps to reproduce the vulnerability and confirms it through an example."
            },
            {
                "url": "https://gitlab.eclipse.org/security/cve-assignement/-/issues/28",
                "content": "Skip to content\nGitLab\nExplore\nSign in\nPrimary navigation\nSearch or go to\nProject\nC\ncve-assignement\nManage\nPlan\nIssues\nIssue boards\nMilestones\nIterations\nHelp\nEclipse Projects Security\ncve-assignement\nIssues\n#28\nEclipse EDC: Consumer pull transfer token validation does not apply any rules (e. g., expiration check)\nIssue actions\nClosed\nIssue\ncreated\n9 months ago\nby\nMarta Rybczynska\nThe Eclipse Foundation is a Common Vulnerabilities and Exposures (CVE) Numbering Authority. This issue it used to request and track the progress of the assignment of a CVE for a vulnerability in the project code for an Eclipse open source project.\nBasic information\nProject name: Eclipse EDC\nProject id: {id}\nRequest type: reservation\nVersions affected: before 0.9.0\nCommon Weakness Enumeration:\n{CWE-303}\n{CWE-305}\n...\nCommon Vulnerability Scoring System: {cvss}\nSummary:\nIn Eclipse ECD after 0.5.0 and before version 0.9.0, TokenValidationService validation incorrectly checks validation rules, what can allow the attacker to bypass the check for token expiration. The issue requires to have a dataplane configured to support http proxy consumer pull AND include the modules \"transfer-data-plane\" and \"data-plane-public-api\". In 0.9.0 the vulnerable code has been removed.\nLinks:\nvulnerability-reports#234 (closed)\nTracking\nThis section will completed by the project team.\nReserve an entry only\nWe're ready for this issue to be reported to the central authority (i.e., make this public now)\n(when applicable) The GitHub Security Advisory is ready to be published now\nNote that for those projects that host their repositories on GitHub, the use of GitHub Security Advisories is recommended but is not required.\nThis section will be completed by the EMO.\nCVE: {cve}\nAll required information is provided\nCVE Assigned\nPushed to Mitre\nAccepted by Mitre\n0 of 7 checklist items completed  Edited 9 months ago by Marta Rybczynska\n\n0\n\n0\nTo upload designs, you'll need to enable LFS and have an admin enable hashed storage. More information\nChild items\n0\nMore actions\nNo child items are currently assigned. Use child items to break down this issue into smaller parts.\nLinked items\n0\nLink issues together to show that they're related or that one is blocking others. Learn more.\nActivity\nSort or filter\nMarta Rybczynska assigned to @neuschwa, @mspiekermann, @platzel, @mbarbero, and @mrybczyn 9 months ago\nMarta Rybczynska mentioned in issue vulnerability-reports#234 (closed) 9 months ago\nPaul Latzelsperger\n@platzel\n 9 months ago\nMy suggestion:\nIn Eclipse Dataspace Components, after 0.5.0 and before version 0.9.0, the ConsumerPullTransferTokenValidationApiController does not check for token validity (expiry, not-before, issuance date), which can allow the attacker to bypass the check for token expiration. The issue requires to have a dataplane configured to support http proxy consumer pull AND include the modules \"transfer-data-plane\". The affected code was marked deprecated in version 0.5.1 in favour of Dataplane Signaling. In 0.9.0 the vulnerable code has been removed.\nEdited 9 months ago by Paul Latzelsperger\nCollapse replies\nPhilipp Neuschwander\n@neuschwa\n 9 months ago\nThe affected code was marked deprecated in version 0.5.1 in favour of Dataplane Signaling. (#28 (comment 2617484))\nThis statement might be incorrect. As far as I can see, the parts of org.eclipse.edc:data-plane-public-api were not marked as deprecated in version 0.5.1. They were marked as \"deprecated since 0.6.0\" and this deprecation annotation was added with the release of version 0.7.0. See this commit.\nBtw. the ConsumerPullTransferTokenValidationApiController from org.eclipse.edc:transfer-data-plane seems to not have been marked as deprecated yet.\nCan you please check and adjust the suggested text accordingly?\nEdited 9 months ago by Philipp Neuschwander\nPaul Latzelsperger\n@platzel\n 9 months ago\nthank you for your input, we'll take it under advisement.\nMarta Rybczynska\n@mrybczyn\n 9 months ago\nAuthor\nMaintainer\nWhat about:\nIn Eclipse Dataspace Components, after 0.5.0 and before version 0.9.0, the ConsumerPullTransferTokenValidationApiController does not check for token validity (expiry, not-before, issuance date), which can allow the attacker to bypass the check for token expiration. The issue requires to have a dataplane configured to support http proxy consumer pull AND include the modules \"transfer-data-plane\". The affected code was marked deprecated from the version 0.6.0 in favour of Dataplane Signaling. In 0.9.0 the vulnerable code has been removed.\nPaul Latzelsperger\n@platzel\n 9 months ago\nfine by me.\nPaul Latzelsperger\n@platzel\n 9 months ago\n@mrybczyn this wording has been approved by the EDC Committers, so we're good to go.\nPhilipp Neuschwander\n@neuschwa\n 9 months ago\nfine for me as well \nPlease register or sign in to reply\nMarta Rybczynska changed the description 9 months ago\nCompare with previous version\nMarta Rybczynska\n@mrybczyn\n 9 months ago\nAuthor\nMaintainer\nMy proposal for CVSS is CVSS:4.0/AV:N/AC:L/AT:P/PR:L/UI:N/VC:N/VI:N/VA:N/SC:H/SI:H/SA:N/RE:L/U:Green (https://www.first.org/cvss/calculator/4.0#CVSS:4.0/AV:N/AC:L/AT:P/PR:L/UI:N/VC:N/VI:N/VA:N/SC:H/SI:H/SA:N/RE:L/U:Green) which gives CVSS Score of 5.3 (Medium)\nThe little load impact is not causing any security problem, so there is only impact on the \"subsequent\" system (ones that can be accessed with the missing authentication)\nEdited 9 months ago by Marta Rybczynska\nCollapse replies\nPaul Latzelsperger\n@platzel\n 9 months ago\nOK for me, but I would put Privleges Required (PR) to High, because an attacker must have gone through a contract negotiation, transfer process, and successful data transmission setup beforehand. This also requires them to be a recognized member of a dataspace.\nhttps://www.first.org/cvss/calculator/4.0#CVSS:4.0/AV:N/AC:L/AT:P/PR:H/UI:N/VC:N/VI:N/VA:N/SC:H/SI:H/SA:N/RE:L/U:Green\nEdited 9 months ago by Paul Latzelsperger\nPaul Latzelsperger\n@platzel\n 9 months ago\n@mrybczyn The CVE score https://www.first.org/cvss/calculator/4.0#CVSS:4.0/AV:N/AC:L/AT:P/PR:H/UI:N/VC:N/VI:N/VA:N/SC:H/SI:H/SA:N/RE:L/U:Green has been approved by the EDC Committers, so we're good to go.\nEdited 9 months ago by Paul Latzelsperger\nPhilipp Neuschwander\n@neuschwa\n 9 months ago\nI would agree on the \"VA:N\" if only considering the ConsumerPullTransferTokenValidationApiController as part of the vulnerable system. Then the additional load on the connector might be considered as negligible as it is just checking (and falsely confirming) the token once per (unauthorized) request. However, there is additional the \"data-plane-public-api\" (the endpoint exposed for consumers to pull the data) that I consider to be part of the vulnerable system as well. Internally, that endpoint queries the data source (subsequent system) and forwards the response to the consumer in a synchronous way. It is possible that the data is a large file / dataset and that it takes some time to retrieve the data and send it as a response to the requester. I think this might occupy a non-negligible amount of resources of the vulnerable system / connector / dataplane (network connections, bandwith, IO, processor cycles).\nRegarding the \"SA:N\", I disagree. I recommend to consider keeping a higher rating (low or high) for \"SA\". It depends on the data source or data in use. The data could be a very large file that is retrieved; occupying network bandwith, IO, and processor cycles of the data source / subsequent system on each access that will not be availble to serve the requests of authorized entities. Effectivly occupying/consuming ressources and reducing the performance of the subsequent system. In case of using an API as data source and proxying/passing through the request method and request body to the subsequent system, it depends on the logic that is behind the API. One might expose access to a service that involves heavy calcualtions or memory usage, occupying these resources without permission and degrading the availability of the service for legitimate users. From my point of view, there might be an non-negligible impact to the availability to the subsequent system.\nPlease consider more than \"N\" for \"VA\" and \"SA\".\nOK for me, but I would put Privleges Required (PR) to High, because an attacker must have gone through a contract negotiation, transfer process, and successful data transmission setup beforehand. This also requires them to be a recognized member of a dataspace. (#28 (comment 2617841))\nI disagree on this. \"PR\" is described as\nThis metric describes the level of privileges an attacker must possess prior to successfully exploiting the vulnerability. The method by which the attacker obtains privileged credentials prior to the attack (e.g., free trial accounts), is outside the scope of this metric. Generally, self-service provisioned accounts do not constitute a privilege requirement if the attacker can grant themselves privileges as part of the attack.\n\"High\" rating is described as\nThe attacker requires privileges that provide significant (e.g., administrative) control over the vulnerable system allowing full access to the vulnerable systems settings and files.\nThe vulnerable system is the connector or dataplane at the provider side. To exploit the vulnerability, one does not need such a high level of privileges to the vulnerable system.\nOnce an eligible data space participant negotiated a contract and started a transfer process, a Token is created and pushed to the consumer-side subsequent system (everything is fully automated) and can be used there beyond its expiration for \"pulling the asset\". From my point of view, an attacker can do the attack with a rather \"normal\" level of privileges (i.e., just a normal data space participant that has no \"high\" privileges to the vulnerable system). An attacker could be a normal employee at the consumer-side company that has normal access level to subsequent systems at the consumer side (e.g., user keeps clicking on a \"refresh data\" or \"query\" button beyond the expiration time) or anyone else that got in possession of the token.\nBut to do so, one does not need some kind of \"high\" privileges to the vulnerable system.\nPlease consider less than \"H\" for \"PR\".\nPaul Latzelsperger\n@platzel\n 9 months ago\nthank you for your input, it has been taken into consideration. The decision of the EDC committers has been made.\nad \"VA:N\" and \"SA:N\": this is an incorrect assessment. A Denial-of-service attack as you describe it can be performed even if this vulnerability didn't exist, i.e. with a valid token. The fact that it is possible with an expired/revoked token does change that. It is the responsibility of the provider organization to put appropriate infrastructure, such as API gateways, rate-limiters, etc. in place.\nad \"PR:H\": This assessment is incorrect as well. The highest level of access anyone (including an attacker) could ever obtain through the systems described here is read access on the provider's data. The definition of \"PR:L\" states\nan attacker with low privileges has the ability to access only non-sensitive data\nTaking these definitions too literally is not productive. But again, access to the provider's data is absolutely sensitive, and it is also the highest privilege obtainable.\n[edit]: on a personal note I would kindly ask you to make your statements more concise. Writing walls-of-text is not productive.\nEdited 9 months ago by Paul Latzelsperger\nPhilipp Neuschwander\n@neuschwa\n 9 months ago\nregarding \"VA:N\" and \"SA:N\"\nThe difference is that valid tokens can be used to legitimately occupy/use/consume the resources. While being able to occupy/use/consume resources using expired tokens is an illegitimate resource occupation that can have an impact the availability of the system for legitimate users. Therefore I do not fully agree on the \"N\" rating.\nregarding \"PR:H\"\nThe highest level of access anyone (including an attacker) could ever obtain through the systems described here is read access on the provider's data\nFrom my point of view, this is incorrect. Consumer pull cannot only be used to read provider's data from their subsequent systems. It can be used (and is used by some) to expose an API of the provider's subsequent system that accepts POST requests to modify data in the subsequent system at the provider side. Therefore we have the \"SI:H\".\nNevertheless, PR is about the privileges required to exploit the vuln, not about what one can do or access once they successfully exploited the vuln. I could understand to pick \"PR:H\" if an attacker would require privileged access to the vulnerable system (e.g., see config files, access management api, ssh to the machine, read vault content, or logs or so). But this is not the case here. An attacker does not need any privileged access to the vulnerable system prior to being able to exploit the vuln. An attacker only needs a Token; and to get one does not require any sort of high privileged access to the vulnerable system at the provider side. Therefore I do not agree on the \"H\" rating as less privileges are sufficient to successfully exploit the vuln.\nI can only draw your attention to my point of view. Ultimately, however, it is your responsibility to make an appropriate assessment.\nMaybe @mrybczyn can double check the CVSS and provide guidance if necessary.\nPaul Latzelsperger\n@platzel\n 9 months ago\nWhat operations are available on the provider's backend is completely irrelevant, as it does not pertain to this vulnerability. In addition, a POST request does by no means imply that data is written.\nBut like I said, you've made your point, the EDC committers just happen to disagree.\nPhilipp Neuschwander\n@neuschwa\n 9 months ago\nWhat operations are available on the provider's backend is completely irrelevant, as it does not pertain to this vulnerability.\nI disagree with that. It is relevant for the Subsequent System Impact Metrics that is part of CVSS 4.0.\nIn addition, a POST request does by no means imply that data is written.\nI disagree with that. POST is by definition a non-idempotent and non-safe operation. \"A POST request is typically sent via an HTML form and results in a change on the server\". Therefore, it can (and in RESTful-APIs most commonly does) store/write data at the target system. => There are POST requests that do not write any data but there can be POST requests that do write data / modify the state of the target system. From my experience, the latter case is the more common one.\nNevertheless, discussing this detail does not add anything relevant to the discussion as no one questioned \"SI:H\" so far.\nThe discussion should be about \"VA\", \"SA\" and \"PR\" as our assessments diverge in these aspects.\nI don't think we're getting anywhere here. Both sides have presented their point of view.\nI would like to ask the Eclipse Foundation Security Team (@mrybczyn / @netomi) to review the CVSS and mediate.\nPaul Latzelsperger\n@platzel\n 9 months ago\nThe decision is up to the committers, and we've made that decision, thanks anyway.\nMarta Rybczynska\n@mrybczyn\n 9 months ago\nAuthor\nMaintainer\nLet me give my opinion. For me there is no Availability score (VA/SA) because the issue does not amplify the traffic (eg. generate two message from one) nor add additional load. The load is the same as if it were in case of a correctly authorized message.\nAs for PR, I tend to \"PR:L\" because the attacker doesn't have to be an administrator, not have access to all the configuration files. However, I'm OK for \"PR:H\" if the Project team prefers this setting. There is no important change in CVSS (5.0 vs 5.3).\nPlease note, from the process side, that other parties might add their own CVSS scoring after ours (for example NVD often does re-scoring) and slight differences in assignments are pretty common.\n@platzel is it acceptable for you?\n\n1\nPaul Latzelsperger\n@platzel\n 9 months ago\n@mrybczyn The description on the CVSS site is not really transferrable, and the attacker is already at the highest attainable authorization. Thus, the team would like to go with \"PR:H\"\nSo yes, this is OK for me (us, really).\nEdited 9 months ago by Paul Latzelsperger\nPlease register or sign in to reply\nThomas Neidhart assigned to @netomi 8 months ago\nThomas Neidhart changed due date to September 10, 2024 8 months ago\nThomas Neidhart added\ncve\nrequested\nlabel 8 months ago\nThomas Neidhart\n@netomi\n 8 months ago\nReserved the CVE ID: CVE-2024-8642\n\n1\nThomas Neidhart added\ncve\nreserved\nlabel and removed\ncve\nrequested\nlabel 8 months ago\nThomas Neidhart\n@netomi\n 8 months ago\nI prepared the following CVE, please take a look if everything is as expected. Information about the CVE was a bit spread out so I had to collect the information and I hope I did not miss anything:\nCollapse replies\nPhilipp Neuschwander\n@neuschwa\n 8 months ago\nHi @netomi thank you for taking care of this.\nI noticed that you slightly changed the wording about the affected versions in the beginning of the description text to clarify that version 0.5.0 is affected as well (\"after and including\") \nBesides of that, the description text is the one that has been approved by the EDC Committers.\nThere is a typo in the text: \"AND include the modules\" (should either be singular or one should name the \"data-plane-public-api\" module as well).\nThe affected versions are: 0.5.0 (including) - 0.9.0 (excluding).\nAs long as there will be no new 0.8.Z release, through 0.8.1 for the end of the version range is correct. But a 0.8.2 release (in case such a release might ever be released) might be affected as well.\nHow about using \"affected from 0.5.0 before 0.9.0\" for the product status following this guide? (but I'm fine with the current wording as well)\nMaybe a similar terminology could be used for the description text as well (i.e., \"from version 0.5.0 and before version 0.9.0\" or so instead of \"after and including ... and before ...\") to make it more clear. (but I'm fine with the current wording as well)\nThe CVSS vector and score might be missing (at least they are not depicted). A discussion about the CVSS can be found in this thread and its comments: #28 (comment 2617839)\nShould we add a reference to the 0.9.0 release in the CVE entry as well?\nDo you need anything else? From me or from the EDC team?\nThomas Neidhart\n@netomi\n 8 months ago\nso the only difference from the approved text I made was about the formulation about the inclusion of v0.5.0. It did not make sense to me to state \"after 0.5.0\" which makes it unclear what the first affected version is, could be 0.5.1 or 0.6.0 so I assumed that to be a mistake. I should have raised that point before populating the CVE entry.\nYou are right about the affected versions, I changed that to < 0.9.0.\nThe CVSS score is missing in the preview of the tool to populate CVE entries, but it has been added as agreed on.\nI will add a reference to the 0.9.0 release as well, I missed that.\nEdited 8 months ago by Thomas Neidhart\nPhilipp Neuschwander\n@neuschwa\n 8 months ago\nso the only difference from the approved text I made was about the formulation about the inclusion of v0.5.0. It did not make sense to me to state \"after 0.5.0\" which makes it unclear what the first affected version is, could be 0.5.1 or 0.6.0 so I assumed that to be a mistake. I should have raised that point before populating the CVE entry.\nI'm glad you noticed our unfortunate wording and took action to make it more clear for people to capture that version 0.5.0 is affected as well.\nYou are right about the affected versions, I changed that to < 0.9.0.\nAfter thinking about it again, I'm not sure how to express the product status / affected versions correctly. With EDC release 0.9.0 the whole transfer-data-plane module was removed, i.e., there is no version 0.9.0 of transfer-data-plane that is no longer vulnerable (as there is no 0.9.0 version of that module at all). Can we state < 0.9.0 if there is no version 0.9.0? Or are we referring to the EDC in general here? \nPaul Latzelsperger\n@platzel\n 8 months ago\nthe sentence starts with \"In Eclipse Dataspace Components...\" and EDC does not release individual modules with individual versions. Therefor one particular version denomination always refers to the entire set of components. I think that - again - you are splitting hairs, which is not productive.\nThomas Neidhart\n@netomi\n 8 months ago\nupdated preview\nPhilipp Neuschwander\n@neuschwa\n 8 months ago\nThank you for considering my comments.\nPlease feel free to submit / publish the CVE as it is.\nPlease register or sign in to reply\nThomas Neidhart\n@netomi\n 8 months ago\nPublished at https://www.cve.org/CVERecord?id=CVE-2024-8642.\nThomas Neidhart made the issue visible to everyone 8 months ago\nThomas Neidhart closed 8 months ago\nThomas Neidhart added\ncve\npublished\nlabel and removed\ncve\nreserved\nlabel 8 months ago\nPlease register or sign in to reply\n6 Assignees\nPhilipp Neuschwander\nThomas Neidhart\nPaul Latzelsperger\nMarta Rybczynska\nMarkus Spiekermann\n+ 1 more\nEpic\nNone\nLabels\ncve\npublished\nMilestone\nNone\nIteration\nNone\nWeight\nNone\nDue date\nSep 10, 2024\nTime tracking\nNo estimate or time spent\nHealth status\nNone\nConfidentiality\nConfidentiality controls have moved to the issue actions menu () at the top of the page.\n6 Participants\nCopyright  Eclipse Foundation, Inc. All Rights Reserved.     Privacy Policy | Terms of Use | Copyright Agent",
                "effective": false,
                "effective_reason": "Analyzing the provided advisory, while it contains detailed technical discussions about the issue and the affected components, it does not include a proof of concept or exact steps to reproduce the vulnerability."
            }
        ],
        "cwe": [
            {
                "id": "CWE-303",
                "value": "CWE-303"
            },
            {
                "id": "CWE-305",
                "value": "CWE-305"
            }
        ]
    }
}