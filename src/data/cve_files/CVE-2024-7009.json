{
    "CVE-2024-7009": {
        "published_date": "2024-08-06T03:40:33.075Z",
        "patch_commits": [
            {
                "url": "https://github.com/kovidgoyal/calibre/commit/d56574285e8859d3d715eb7829784ee74337b7d7",
                "content": "Fix #2075131 [Private bug](https://bugs.launchpad.net/calibre/+bug/2075131)\n\nFilename: src/calibre/db/backend.py:\n```\n@@ -2365,18 +2365,20 @@\ndef search_annotations(self,\n         fts_engine_query = unicode_normalize(fts_engine_query)\n         fts_table = 'annotations_fts_stemmed' if use_stemming else 'annotations_fts'\n         text = 'annotations.searchable_text'\n+        data = []\n         if highlight_start is not None and highlight_end is not None:\n             if snippet_size is not None:\n-                text = \"snippet({fts_table}, 0, '{highlight_start}', '{highlight_end}', '…', {snippet_size})\".format(\n-                        fts_table=fts_table, highlight_start=highlight_start, highlight_end=highlight_end,\n-                        snippet_size=max(1, min(snippet_size, 64)))\n+                text = \"snippet({fts_table}, 0, ?, ?, '…', {snippet_size})\".format(\n+                        fts_table=fts_table, snippet_size=max(1, min(snippet_size, 64)))\n             else:\n-                text = f\"highlight({fts_table}, 0, '{highlight_start}', '{highlight_end}')\"\n+                text = f\"highlight({fts_table}, 0, ?, ?)\"\n+            data.append(highlight_start)\n+            data.append(highlight_end)\n         query = 'SELECT {0}.id, {0}.book, {0}.format, {0}.user_type, {0}.user, {0}.annot_data, {1} FROM {0} '\n         query = query.format('annotations', text)\n         query += ' JOIN {fts_table} ON annotations.id = {fts_table}.rowid'.format(fts_table=fts_table)\n         query += f' WHERE {fts_table} MATCH ?'\n-        data = [fts_engine_query]\n+        data.append(fts_engine_query)\n         if restrict_to_user:\n             query += ' AND annotations.user_type = ? AND annotations.user = ?'\n             data += list(restrict_to_user)\n```\n\nFilename: src/calibre/db/fts/connect.py:\n```\n@@ -156,20 +156,22 @@\ndef search(self,\n             return\n         fts_engine_query = unicode_normalize(fts_engine_query)\n         fts_table = 'books_fts' + ('_stemmed' if use_stemming else '')\n+        data = []\n         if return_text:\n             text = 'books_text.searchable_text'\n             if highlight_start is not None and highlight_end is not None:\n                 if snippet_size is not None:\n-                    text = f'''snippet(\"{fts_table}\", 0, '{highlight_start}', '{highlight_end}', '…', {max(1, min(snippet_size, 64))})'''\n+                    text = f'''snippet(\"{fts_table}\", 0, ?, ?, '…', {max(1, min(snippet_size, 64))})'''\n                 else:\n-                    text = f'''highlight(\"{fts_table}\", 0, '{highlight_start}', '{highlight_end}')'''\n+                    text = f'''highlight(\"{fts_table}\", 0, ?, ?)'''\n+                data.append(highlight_start)\n+                data.append(highlight_end)\n             text = ', ' + text\n         else:\n             text = ''\n         query = 'SELECT {0}.id, {0}.book, {0}.format {1} FROM {0} '.format('books_text', text)\n         query += f' JOIN {fts_table} ON fts_db.books_text.id = {fts_table}.rowid'\n         query += ' WHERE '\n-        data = []\n         conn = self.get_connection()\n         temp_table_name = ''\n         if restrict_to_book_ids:\n```\n\nFilename: src/calibre/db/notes/connect.py:\n```\n@@ -413,13 +413,15 @@\ndef search(self,\n             return\n         fts_engine_query = unicode_normalize(fts_engine_query)\n         fts_table = 'notes_fts' + ('_stemmed' if use_stemming else '')\n+        hl_data = ()\n         if return_text:\n             text = 'notes.searchable_text'\n             if highlight_start is not None and highlight_end is not None:\n                 if snippet_size is not None:\n-                    text = f'''snippet(\"{fts_table}\", 0, '{highlight_start}', '{highlight_end}', '…', {max(1, min(snippet_size, 64))})'''\n+                    text = f'''snippet(\"{fts_table}\", 0, ?, ?, '…', {max(1, min(snippet_size, 64))})'''\n                 else:\n-                    text = f'''highlight(\"{fts_table}\", 0, '{highlight_start}', '{highlight_end}')'''\n+                    text = f'''highlight(\"{fts_table}\", 0, ?, ?)'''\n+                hl_data = (highlight_start, highlight_end)\n             text = ', ' + text\n         else:\n             text = ''\n\n@@ -433,7 +435,7 @@\ndef search(self,\n         if limit is not None:\n             query += f' LIMIT {limit}'\n         try:\n-            for record in conn.execute(query, restrict_to_fields+(fts_engine_query,)):\n+            for record in conn.execute(query, hl_data + restrict_to_fields + (fts_engine_query,)):\n                 result = {\n                     'id': record[0],\n                     'field': record[1],\n```"
            }
        ],
        "sw_version": "v7.15.0",
        "sw_version_wget": "https://github.com/kovidgoyal/calibre/archive/refs/tags/v7.15.0.zip",
        "description": "Unsanitized user-input in Calibre <= 7.15.0 allow users with permissions to perform full-text searches to achieve SQL injection on the SQLite database.",
        "sec_adv": [
            {
                "url": "https://starlabs.sg/advisories/24/24-7009/",
                "content": "Home\nAbout\nAdvisories\nBlog\nAchievements\nPublications\nSearch\nHome\n » \nAdvisories\n(CVE-2024-7009) Calibre SQLite Injection\nJuly 31, 2024\n · 5 min · Devesh Logendran\nTable of Contents\nSummary\nProduct Calibre\nVendor Calibre\nSeverity Medium\nAffected Versions <= 7.15.0 (latest version as of writing)\nTested Versions 7.15.0\nCVE Identifier CVE-2024-7009\nCWE Classification(s) CWE-89 Improper Neutralization of Special Elements used in an SQL Command (‘SQL Injection’)\nCAPEC Classification(s) CAPEC-66 SQL Injection\nCVSS3.1 Scoring System\nBase Score: 4.2 (Medium) Vector String: CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:N\nMetric Value\nAttack Vector (AV) Network\nAttack Complexity (AC) High\nPrivileges Required (PR) Low\nUser Interaction (UI) None\nScope (S) Unchanged\nConfidentiality (C) Low\nIntegrity (I) Low\nAvailability (A) None\nProduct Overview\nCalibre is a cross-platform free and open-source suite of e-book software. Calibre supports organizing existing e-books into virtual libraries, displaying, editing, creating and converting e-books, as well as syncing e-books with a variety of e-readers. Editing books is supported for EPUB and AZW3 formats. Books in other formats like MOBI must first be converted to those formats, if they are to be edited. Calibre also has a large collection of community contributed plugins.\nCalibre also offers a powerful content server feature. This allows users to share their Calibre libraries over the internet, making it easy to access your e-book collection from anywhere, at any time.\nVulnerability Summary\nA user with privileges to perform full-text searches on any Calibre library on the content server can inject arbitrary SQL code into the search query. This can be used to extract sensitive information from any SQLite databases on the server’s filesystem, as well as the ability to perform limited file writes to the filesystem.\nVulnerability Details\nIn src/calibre/srv/fts.py, the /fts/snippets/{book_ids} endpoint is defined.\n@endpoint('/fts/snippets/{book_ids}', postprocess=json)\ndef fts_snippets(ctx, rd, book_ids):\n    '''\n    Perform the specified full text query and return the results with snippets restricted to the specified book ids.\n\n    Optional: ?query=<search query>&library_id=<default library>&use_stemming=<y or n>\n    &query_id=arbitrary&snippet_size=32&highlight_start=\\x1c&highlight_end=\\x1e\n    '''\n    db = get_library_data(ctx, rd)[0]\n    if not db.is_fts_enabled():\n        raise HTTPPreconditionRequired('Full text searching is not enabled on this library')\n    # ...\n    from calibre.db import FTSQueryError\n    sanitize_pat = re.compile(r'\\s+')\n    try:\n        for x in db.fts_search(\n            query, use_stemming=use_stemming, return_text=True,\n            highlight_start=rd.query.get('highlight_start', '\\x1c'), highlight_end=rd.query.get('highlight_end', '\\x1e'),\n            restrict_to_book_ids=bids, snippet_size=ssz,\n        ):\n            r = snippets[x['book_id']]\n            q = sanitize_pat.sub('', x['text'])\n            r.setdefault(q, {'formats': [], 'text': x['text'],})['formats'].append(x['format'])\n    except FTSQueryError as e:\n        raise HTTPUnprocessableEntity(str(e))\n    ans['snippets'] = {bid: tuple(v.values()) for bid, v in snippets.items()}\n    return ans\nTracing the call to db.fts_search, we eventually land in src/calibre/db/fts/connect.py:\ndef search(self,\n    fts_engine_query, use_stemming, highlight_start, highlight_end, snippet_size, restrict_to_book_ids,\n    return_text=True, process_each_result=None\n):\n    if restrict_to_book_ids is not None and not restrict_to_book_ids:\n        return\n    fts_engine_query = unicode_normalize(fts_engine_query)\n    fts_table = 'books_fts' + ('_stemmed' if use_stemming else '')\n    if return_text:\n        text = 'books_text.searchable_text'\n        if highlight_start is not None and highlight_end is not None:\n            if snippet_size is not None:\n                text = f'''snippet(\"{fts_table}\", 0, '{highlight_start}', '{highlight_end}', '…', {max(1, min(snippet_size, 64))})''' # [1]\n            else:\n                text = f'''highlight(\"{fts_table}\", 0, '{highlight_start}', '{highlight_end}')'''\n        text = ', ' + text\n    else:\n        text = ''\n    query = 'SELECT {0}.id, {0}.book, {0}.format {1} FROM {0} '.format('books_text', text)\n    query += f' JOIN {fts_table} ON fts_db.books_text.id = {fts_table}.rowid'\n    query += ' WHERE '\n    data = []\n    conn = self.get_connection()\n    temp_table_name = ''\n    if restrict_to_book_ids:\n        temp_table_name = f'fts_restrict_search_{next(self.temp_table_counter)}'\n        conn.execute(f'CREATE TABLE temp.{temp_table_name}(x INTEGER)')\n        conn.executemany(f'INSERT INTO temp.{temp_table_name} VALUES (?)', tuple((x,) for x in restrict_to_book_ids))\n        query += f' fts_db.books_text.book IN temp.{temp_table_name} AND '\n    query += f' \"{fts_table}\" MATCH ?'\n    data.append(fts_engine_query)\n    query += f' ORDER BY {fts_table}.rank '\n    if temp_table_name:\n        query += f'; DROP TABLE temp.{temp_table_name}'\n    try:\n        for record in conn.execute(query, tuple(data)):\n            result = {\n                'id': record[0],\n                'book_id': record[1],\n                'format': record[2],\n                'text': record[3] if return_text else '',\n            }\n            if process_each_result is not None:\n                result = process_each_result(result)\n            ret = yield result\n            if ret is True:\n                break\n    except apsw.SQLError as e:\n        raise FTSQueryError(fts_engine_query, query, e) from e\nAt no point are the highlight_start and highlight_end parameters sanitized. This allows an attacker to inject arbitrary SQL code into the highlight_start and highlight_end parameters at [1], which are then used in the query string. This can be seen by attempting to use a single quote in the highlight_end parameter:\nInjecting into this database is of little worth to an attacker, as the database is not used for anything other than full-text search. However, the SQLite3 engine allows for data to be read from other databases on the filesystem, such as the server-users.sqlite file which contains the username and password information used for authentication to the content server. This can be done by using the ATTACH command to attach the database to the current connection, and then querying the table. For instance, consider a server setup where there is a privileged user testacc with write access and a non-privileged user nonprivacc with read-only access, including full-text search access to the “Calibre Library” library. If the non-privileged user knows the location of the server-users.sqlite file (on Windows, this is typically in %AppData%, requiring the attacker to know the user profile name), they can access the username and password data through the following URL:\nhttp://CALIBRE_SERVER/fts/snippets/1?library_id=Calibre_Library&query=C&query_id=1&highlight_end=','',32) FROM books_text JOIN books_fts_stemmed ON fts_db.books_text.id = books_fts_stemmed.rowid WHERE \"books_fts_stemmed\" MATCH ?; attach 'C:\\Users\\Devesh\\AppData\\Roaming\\calibre\\server-users.sqlite' as suwu; select 1,1,name,pw from suwu.users;-- -\nIt is similarly possible to use the ATTACH DATABASE command on a non-existing filename to write data to the filesystem, albeit in a limited fashion. This could be used to, for instance, write a batch file to the user’s startup folder that will be executed on the next operating system login.\nSuggested Mitigations\nThe highlight_start and highlight_end parameters should be sanitized before being used in the query string. This can be done by escaping any single quotes in the parameters. Parameterised queries, if possible, should be used for these values.\nCredits\nDevesh Logendran of STAR Labs SG Pte. Ltd. (@starlabs_sg)\n« PREV\n(CVE-2024-7008) Calibre Reflected Cross-Site Scripting (XSS)\nNEXT »\n(CVE-2024-1837) Singtel RT5703W Unauthenticated Command Injection RCE via Login Vulnerability\n© 2025 STAR Labs Powered by Hugo & PaperMod",
                "effective": true,
                "effective_reason": "The advisory includes a detailed demonstration using example URLs and technical descriptions of the SQL injection vector, showing how the vulnerability can be exploited."
            }
        ],
        "cwe": [
            {
                "id": "CWE-89",
                "value": "CWE-89 Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
            }
        ]
    }
}