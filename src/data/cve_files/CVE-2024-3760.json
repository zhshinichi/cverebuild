{
    "CVE-2024-3760": {
        "published_date": "2024-11-14T18:26:21.685Z",
        "patch_commits": [
            {
                "url": "https://github.com/lunary-ai/lunary/commit/29374bb10020712009c1ec238affe098112a51d6",
                "content": "fix: reate limit on reset password endpoint (#203)\n\nFilename: packages/backend/src/api/v1/auth/index.ts:\n```\n@@ -1,18 +1,20 @@\n+import { Db } from \"@/src/types\"\n import sql from \"@/src/utils/db\"\n import { sendVerifyEmail } from \"@/src/utils/emails\"\n import Context from \"@/src/utils/koa\"\n import { sendTelegramMessage } from \"@/src/utils/notifications\"\n import Router from \"koa-router\"\n import { z } from \"zod\"\n+import saml, { getLoginUrl } from \"./saml\"\n import {\n   hashPassword,\n+  isJWTExpired,\n   requestPasswordReset,\n   sanitizeEmail,\n-  signJwt,\n-  verifyJwt,\n+  signJWT,\n+  verifyJWT,\n   verifyPassword,\n } from \"./utils\"\n-import saml, { getLoginUrl } from \"./saml\"\n \n const auth = new Router({\n   prefix: \"/auth\",\n\n@@ -42,6 +44,7 @@\nauth.post(\"/method\", async (ctx: Context) => {\n   }\n })\n \n+// TODO: split signup and join\n auth.post(\"/signup\", async (ctx: Context) => {\n   const bodySchema = z.object({\n     email: z.string().email().transform(sanitizeEmail),\n\n@@ -141,7 +144,7 @@\nauth.post(\"/signup\", async (ctx: Context) => {\n       return { user, org }\n     })\n \n-    const token = await signJwt({\n+    const token = await signJWT({\n       userId: user.id,\n       email: user.email,\n       orgId: org.id,\n\n@@ -161,7 +164,7 @@\nauth.post(\"/signup\", async (ctx: Context) => {\n     ctx.body = { token }\n     return\n   } else if (signupMethod === \"join\") {\n-    const { payload } = await verifyJwt(token!)\n+    const { payload } = await verifyJWT(token!)\n \n     if (payload.email !== email) {\n       ctx.throw(403, \"Invalid token\")\n\n@@ -193,7 +196,7 @@\nauth.get(\"/join-data\", async (ctx: Context) => {\n \n   const {\n     payload: { orgId },\n-  } = await verifyJwt(token)\n+  } = await verifyJWT(token)\n \n   const [org] = await sql`\n     select name, plan from org where id = ${orgId}\n\n@@ -238,6 +241,8 @@\nauth.post(\"/login\", async (ctx: Context) => {\n   }\n \n   if (!user.passwordHash) {\n+    // If SAML was the only auth method allowed since the account creation,\n+    // and that SAML is disabled by admin, accounts don't have a password yet\n     await requestPasswordReset(email)\n \n     ctx.body = { message: \"We sent you an email to reset your password\" }\n\n@@ -255,7 +260,7 @@\nauth.post(\"/login\", async (ctx: Context) => {\n   // update last login\n   await sql`update account set last_login_at = now() where id = ${user.id}`\n \n-  const token = await signJwt({\n+  const token = await signJWT({\n     userId: user.id,\n     email: user.email,\n     orgId: user.orgId,\n\n@@ -276,11 +281,28 @@\nauth.post(\"/request-password-reset\", async (ctx: Context) => {\n       ctx.body = { error: \"Invalid email format\" }\n       return\n     }\n-\n     const { email } = body.data\n \n-    await requestPasswordReset(email)\n+    const [{ recoveryToken }] = await sql<\n+      Db.Account[]\n+    >`select * from account where email = ${email}`\n+\n+    if (recoveryToken) {\n+      if (await isJWTExpired(recoveryToken)) {\n+        // Edge case 1: User has made a password reset request more than one hour ago, but has not completed the flow\n+        await requestPasswordReset(email)\n+        ctx.body = { ok: true }\n+        return\n+      } else {\n+        // Edge case 2: User has already made a password request less than one hour ago\n+        throw new Error(\n+          \"Password reset request already initiated less than one hour ago\",\n+        )\n+      }\n+    }\n \n+    // Base case: User is making his first password reset request since the last one has been successfully reset\n+    await requestPasswordReset(email)\n     ctx.body = { ok: true }\n   } catch (error) {\n     console.error(error)\n\n@@ -298,15 +320,15 @@\nauth.post(\"/reset-password\", async (ctx: Context) => {\n \n   const {\n     payload: { email },\n-  } = await verifyJwt<{ email: string }>(token)\n+  } = await verifyJWT<{ email: string }>(token)\n \n   const passwordHash = await hashPassword(password)\n \n   const [user] = await sql`\n     update account set password_hash = ${passwordHash}, last_login_at = NOW() where email = ${email} returning *\n   `\n \n-  const authToken = await signJwt({\n+  const authToken = await signJWT({\n     userId: user.id,\n     email: user.email,\n     orgId: user.orgId,\n\n@@ -319,7 +341,7 @@\nauth.post(\"/reset-password\", async (ctx: Context) => {\n auth.post(\"/exchange-token\", async (ctx: Context) => {\n   const { onetimeToken } = ctx.request.body as { onetimeToken: string }\n \n-  await verifyJwt(onetimeToken)\n+  await verifyJWT(onetimeToken)\n \n   // get account with onetime_token = token\n   const [account] = await sql`\n\n@@ -332,7 +354,7 @@\nauth.post(\"/exchange-token\", async (ctx: Context) => {\n \n   const oneDay = 60 * 60 * 24\n \n-  const authToken = await signJwt(\n+  const authToken = await signJWT(\n     {\n       userId: account.id,\n       email: account.email,\n```\n\nFilename: packages/backend/src/api/v1/auth/utils.ts:\n```\n@@ -37,7 +37,7 @@\nexport async function hashPassword(password: string): Promise<string> {\n \n const ONE_MONTH = 60 * 60 * 24 * 30\n \n-export function signJwt(\n+export function signJWT(\n   payload: any,\n   expiresIn: number = ONE_MONTH,\n ): Promise<string> {\n\n@@ -52,13 +52,22 @@\nexport function signJwt(\n     .sign(new TextEncoder().encode(process.env.JWT_SECRET))\n }\n \n-export function verifyJwt<Payload>(token: string) {\n-  return jose.jwtVerify<Payload>(\n+export function verifyJWT<Payload>(token: string) {\n+  return jose.jwtVerify<Payload & { iat: number; exp: number; nbf: number }>(\n     token,\n     new TextEncoder().encode(process.env.JWT_SECRET),\n   )\n }\n \n+export async function isJWTExpired(token: string) {\n+  try {\n+    await verifyJWT(token)\n+    return false\n+  } catch (error) {\n+    return true\n+  }\n+}\n+\n // TODO: shared\n interface SessionData {\n   userId: string\n\n@@ -144,7 +153,7 @@\nexport async function authMiddleware(ctx: Context, next: Next) {\n       if (!bearer) {\n         throw new Error(\"No bearer token provided.\")\n       }\n-      const { payload } = await verifyJwt<SessionData>(key)\n+      const { payload } = await verifyJWT<SessionData>(key)\n \n       ctx.state.userId = payload.userId\n       ctx.state.orgId = payload.orgId\n\n@@ -179,7 +188,7 @@\nexport async function requestPasswordReset(email: string) {\n   const [user] = await sql`select id from account where email = ${email}`\n \n   const ONE_HOUR = 60 * 60\n-  const token = await signJwt({ email }, ONE_HOUR)\n+  const token = await signJWT({ email }, ONE_HOUR)\n \n   await sql`update account set recovery_token = ${token} where id = ${user.id}`\n```\n\nFilename: packages/backend/src/api/v1/users.ts:\n```\n@@ -9,7 +9,7 @@\nimport {\n import { jwtVerify } from \"jose\"\n import { z } from \"zod\"\n import { sendEmail } from \"@/src/utils/sendEmail\"\n-import { signJwt } from \"./auth/utils\"\n+import { signJWT } from \"./auth/utils\"\n import { roles } from \"shared\"\n import { checkAccess } from \"@/src/utils/authorization\"\n\n@@ -182,7 +182,7 @@\nusers.post(\"/\", checkAccess(\"teamMembers\", \"create\"), async (ctx: Context) => {\n   `\n   const orgUserCount = orgUserCountResult.count\n \n-  const token = await signJwt({ email, orgId }, FIFTEEN_DAYS)\n+  const token = await signJWT({ email, orgId }, FIFTEEN_DAYS)\n   const userToInsert = {\n     email,\n     orgId,\n```\n\nFilename: packages/backend/src/types/database.ts:\n```\n@@ -0,0 +1,14 @@\n+export interface Account {\n+  id: string\n+  createdAt: Date\n+  email: string | null\n+  passwordHash: string | null\n+  recoveryToken: string | null\n+  name: string | null\n+  orgId: string | null\n+  role: \"owner\" | \"admin\" | \"member\" | \"viewer\" | \"prompt_editor\" | \"billing\"\n+  verified: boolean\n+  avatarUrl: string | null\n+  lastLoginAt: Date | null\n+  singleUseToken: string | null\n+}\n```\n\nFilename: packages/backend/src/types/index.ts:\n```\n@@ -0,0 +1 @@\n+export * as Db from \"./database\"\n```\n\nFilename: packages/backend/src/utils/emails.ts:\n```\n@@ -1,4 +1,4 @@\n-import { signJwt } from \"@/src/api/v1/auth/utils\"\n+import { signJWT } from \"@/src/api/v1/auth/utils\"\n import { sendEmail } from \"./sendEmail\"\n \n function extractFirstName(name: string) {\n\n@@ -7,7 +7,7 @@\nfunction extractFirstName(name: string) {\n }\n \n export async function sendVerifyEmail(email: string, name: string) {\n-  const token = await signJwt({ email })\n+  const token = await signJWT({ email })\n \n   const confirmLink = `${process.env.API_URL}/v1/users/verify-email?token=${token}`\n```\n\nFilename: packages/db/0010.sql:\n```\n@@ -0,0 +1 @@\n+alter table account alter column role set not null;\n\\ No newline at end of file\n```"
            }
        ],
        "sw_version": "v1.2.7",
        "sw_version_wget": "https://github.com/lunary-ai/lunary/archive/refs/tags/v1.2.7.zip",
        "description": "In lunary-ai/lunary version 1.2.7, there is a lack of rate limiting on the forgot password page, leading to an email bombing vulnerability. Attackers can exploit this by automating forgot password requests to flood targeted user accounts with a high volume of password reset emails. This not only overwhelms the victim's mailbox, making it difficult to manage and locate legitimate emails, but also significantly impacts mail servers by consuming their resources. The increased load can cause performance degradation and, in severe cases, make the mail servers unresponsive or unavailable, disrupting email services for the entire organization.",
        "sec_adv": [
            {
                "url": "https://huntr.com/bounties/c29e9f36-8261-463d-8862-7f4fdcc8eddc",
                "content": "Bounties\nPartners\nCommunity\nInfo\nSUBMIT REPORT\nMail bombing: rate-limit absent on forgot-password page in lunary-ai/lunary\nValid\nReported on Apr 13th 2024\nDescription\nThe absence of rate limiting on the forgot password page allows attackers to exploit an email bombing vulnerability. By automating forgot password requests in a loop, an attacker can flood targeted user accounts with a high volume of password reset emails, overwhelming the victim's mailbox. Additionally, this vulnerability can significantly impact mail servers by consuming their resources, leading to performance degradation and potential unavailability for other users. Implementing proper rate limiting controls is crucial to prevent email bombing attacks and ensure the stability of the system's email services.\nProof of Concept\nGo to reset password page, enter email and intercept the request in burp.\nNow send that request to Intruder and select payloads for user-agent.\nStart the attack\nNow check the email address is been flooded with mail\nImpact\nThe impact of this vulnerability is twofold:\nUser Account Disruption:\nTargeted user accounts can be flooded with a high volume of password reset emails. The victim's mailbox becomes overwhelmed, making it difficult to manage and locate legitimate emails. The excessive number of password reset emails can cause confusion and frustration for the affected users.\nMail Server Performance and Availability:\nThe mail servers processing the large volume of password reset emails can experience significant resource consumption. The increased load on the mail servers can lead to performance degradation, slowing down email delivery for all users. In severe cases, the mail servers may become unresponsive or unavailable, disrupting email services for the entire organization.\nWe are processing your report and will contact thelunary-ai/lunary team within 24 hours.a year ago\nHugues Chocart validated this vulnerabilitya year ago\nantonin36330has been awarded the disclosure bounty\nThe fix bounty is now up for grabs\nThe researcher's credibility has increased: +7\nCVE-2024-3760assigned to this report.a year ago\nHugues Chocart gave praisea year ago\nThanks!\nThe researcher's credibility has slightly increased as a result of the maintainer's thanks: +1\nHugues Chocartmarked this as fixedin 1.2.8with commit29374ba year ago\nHugues Chocarthas been awarded the fix bounty\nWe have notified the lunary-ai/lunary maintainers about this report in their weekly follow-up6 months ago\nThis vulnerability has now been published6 months ago\nCVE-2024-3760has now been published6 months ago\nSign in to join this conversation\nCVE\nCVE-2024-3760\n(Published)\nVulnerability Type\nCWE-770: Allocation of Resources Without Limits or Throttling\nSeverity\nHigh (7.5)\nAttack vector\nNetwork\nAttack complexity\nLow\nPrivileges required\nNone\nUser interaction\nNone\nScope\nUnchanged\nConfidentiality\nNone\nIntegrity\nNone\nAvailability\nHigh\nOpen in visual CVSS calculator\nRegistry\nNpm\nAffected Version\n1.2.7\nVisibility\nPublic\nStatus\nFixed\nDisclosure Bounty\n$450\nFix Bounty\n$112.5\nFound by\nFixed by\nSupported by Protect AI and leading the way to MLSecOps and greater AI security.\nÂ© 2024\nPrivacy Policy\nTerms of Service\nCode of Conduct\nCookie Preferences\nContact Us",
                "effective": true,
                "effective_reason": "The advisory provides a proof of concept which includes steps to exploit the described vulnerability."
            }
        ],
        "cwe": [
            {
                "id": "CWE-770",
                "value": "CWE-770 Allocation of Resources Without Limits or Throttling"
            }
        ]
    }
}