{
    "CVE-2024-25638": {
        "published_date": "2024-07-22T14:05:29.278Z",
        "patch_commits": [
            {
                "url": "https://github.com/dnsjava/dnsjava/commit/2073a0cdea2c560465f7ac0cc56f202e6fc39705",
                "content": "CVE-2024-25638: Message normalization\n\nFilename: README.adoc:\n```\n@@ -108,6 +108,13 @@\nDo NOT use it.\n |1000\n |700\n \n+.2+|dnsjava.harden_unknown_additional\n+3+|Harden against unknown records in the authority section and additional section.\n+If disabled, such records are copied from the upstream and presented to the client together with the answer.\n+|Boolean\n+|True\n+|False\n+\n 4+h|dnssec options\n .2+|dnsjava.dnssec.keycache.max_ttl\n 3+|Maximum time-to-live (TTL) of entries in the key cache in seconds.\n```\n\nFilename: pom.xml:\n```\n@@ -75,7 +75,7 @@\n<plugin>\n                 <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-gpg-plugin</artifactId>\n-                <version>3.2.2</version>\n+                <version>3.2.4</version>\n                 <executions>\n                     <execution>\n                         <id>sign-artifacts</id>\n\n@@ -265,7 +265,7 @@\n<plugin>\n                 <groupId>com.github.siom79.japicmp</groupId>\n                 <artifactId>japicmp-maven-plugin</artifactId>\n-                <version> 0.20.0</version>\n+                <version>0.20.0</version>\n                 <configuration>\n                     <newVersion>\n                         <file>\n\n@@ -528,6 +528,18 @@\n<version>${org.junit.version}</version>\n             <scope>test</scope>\n         </dependency>\n+        <dependency>\n+            <groupId>org.assertj</groupId>\n+            <artifactId>assertj-core</artifactId>\n+            <version>3.25.3</version>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.junit-pioneer</groupId>\n+            <artifactId>junit-pioneer</artifactId>\n+            <version>2.2.0</version>\n+            <scope>test</scope>\n+        </dependency>\n         <dependency>\n             <groupId>org.mockito</groupId>\n             <artifactId>mockito-core</artifactId>\n\n@@ -540,6 +552,12 @@\n<version>${mockito.version}</version>\n             <scope>test</scope>\n         </dependency>\n+        <dependency>\n+            <groupId>net.bytebuddy</groupId>\n+            <artifactId>byte-buddy-agent</artifactId>\n+            <version>1.14.14</version>\n+            <scope>test</scope>\n+        </dependency>\n         <dependency>\n             <groupId>org.slf4j</groupId>\n             <artifactId>slf4j-simple</artifactId>\n\n@@ -676,7 +694,9 @@\n<artifactId>maven-surefire-plugin</artifactId>\n                         <configuration>\n                             <argLine>\n-                                ${argLine} --add-opens java.base/sun.net.dns=ALL-UNNAMED\n+                                @{argLine}\n+                                --add-opens java.base/sun.net.dns=ALL-UNNAMED\n+                                --add-opens java.base/sun.net.dns=org.dnsjava\n                             </argLine>\n                             <additionalClasspathElements>\n                                 <additionalClasspathElement>${project.build.outputDirectory}/META-INF/versions/11</additionalClasspathElement>\n\n@@ -784,12 +804,29 @@\n</executions>\n                     </plugin>\n \n+                    <plugin>\n+                        <groupId>org.apache.maven.plugins</groupId>\n+                        <artifactId>maven-dependency-plugin</artifactId>\n+                        <version>3.6.1</version>\n+                        <executions>\n+                            <execution>\n+                                <phase>initialize</phase>\n+                                <goals>\n+                                    <goal>properties</goal>\n+                                </goals>\n+                            </execution>\n+                        </executions>\n+                    </plugin>\n+\n                     <plugin>\n                         <groupId>org.apache.maven.plugins</groupId>\n                         <artifactId>maven-surefire-plugin</artifactId>\n                         <configuration>\n                             <argLine>\n-                                ${argLine} --add-opens java.base/sun.net.dns=ALL-UNNAMED\n+                                @{argLine}\n+                                --add-opens java.base/sun.net.dns=ALL-UNNAMED\n+                                --add-opens java.base/sun.net.dns=org.dnsjava\n+                                -javaagent:${net.bytebuddy:byte-buddy-agent:jar}\n                             </argLine>\n                             <additionalClasspathElements>\n                                 <additionalClasspathElement>${project.build.outputDirectory}/META-INF/versions/11</additionalClasspathElement>\n```\n\nFilename: src/main/java/org/xbill/DNS/Cache.java:\n```\n@@ -31,6 +31,8 @@\nprivate interface Element {\n     int compareCredibility(int cred);\n \n     int getType();\n+\n+    boolean isAuthenticated();\n   }\n \n   private static int limitExpire(long ttl, long maxttl) {\n\n@@ -44,23 +46,23 @@\nprivate static int limitExpire(long ttl, long maxttl) {\n     return (int) expire;\n   }\n \n-  private static class CacheRRset extends RRset implements Element {\n-    private static final long serialVersionUID = 5971755205903597024L;\n-\n+  static class CacheRRset extends RRset implements Element {\n     int credibility;\n     int expire;\n+    boolean isAuthenticated;\n \n-    public CacheRRset(Record rec, int cred, long maxttl) {\n-      super();\n+    public CacheRRset(Record rec, int cred, long maxttl, boolean isAuthenticated) {\n       this.credibility = cred;\n       this.expire = limitExpire(rec.getTTL(), maxttl);\n+      this.isAuthenticated = isAuthenticated;\n       addRR(rec);\n     }\n \n-    public CacheRRset(RRset rrset, int cred, long maxttl) {\n+    public CacheRRset(RRset rrset, int cred, long maxttl, boolean isAuthenticated) {\n       super(rrset);\n       this.credibility = cred;\n       this.expire = limitExpire(rrset.getTTL(), maxttl);\n+      this.isAuthenticated = isAuthenticated;\n     }\n \n     @Override\n\n@@ -78,15 +80,22 @@\npublic final int compareCredibility(int cred) {\n     public String toString() {\n       return super.toString() + \" cl = \" + credibility;\n     }\n+\n+    @Override\n+    public boolean isAuthenticated() {\n+      return isAuthenticated;\n+    }\n   }\n \n   private static class NegativeElement implements Element {\n     int type;\n     Name name;\n     int credibility;\n     int expire;\n+    boolean isAuthenticated;\n \n-    public NegativeElement(Name name, int type, SOARecord soa, int cred, long maxttl) {\n+    public NegativeElement(\n+        Name name, int type, SOARecord soa, int cred, long maxttl, boolean isAuthenticated) {\n       this.name = name;\n       this.type = type;\n       long cttl = 0;\n\n@@ -95,6 +104,7 @@\npublic NegativeElement(Name name, int type, SOARecord soa, int cred, long maxttl\n       }\n       this.credibility = cred;\n       this.expire = limitExpire(cttl, maxttl);\n+      this.isAuthenticated = isAuthenticated;\n     }\n \n     @Override\n\n@@ -113,6 +123,11 @@\npublic final int compareCredibility(int cred) {\n       return credibility - cred;\n     }\n \n+    @Override\n+    public boolean isAuthenticated() {\n+      return isAuthenticated;\n+    }\n+\n     @Override\n     public String toString() {\n       StringBuilder sb = new StringBuilder();\n\n@@ -327,7 +342,7 @@\npublic synchronized void clearCache() {\n    */\n   @Deprecated\n   public synchronized void addRecord(Record r, int cred, Object o) {\n-    addRecord(r, cred);\n+    addRecord(r, cred, false);\n   }\n \n   /**\n\n@@ -338,15 +353,19 @@\npublic synchronized void addRecord(Record r, int cred, Object o) {\n    * @see Record\n    */\n   public synchronized void addRecord(Record r, int cred) {\n+    addRecord(r, cred, false);\n+  }\n+\n+  private synchronized void addRecord(Record r, int cred, boolean isAuthenticated) {\n     Name name = r.getName();\n     int type = r.getRRsetType();\n     if (!Type.isRR(type)) {\n       return;\n     }\n     Element element = findElement(name, type, cred);\n     if (element == null) {\n-      CacheRRset crrset = new CacheRRset(r, cred, maxcache);\n-      addRRset(crrset, cred);\n+      CacheRRset crrset = new CacheRRset(r, cred, maxcache, isAuthenticated);\n+      addRRset(crrset, cred, isAuthenticated);\n     } else if (element.compareCredibility(cred) == 0) {\n       if (element instanceof CacheRRset) {\n         CacheRRset crrset = (CacheRRset) element;\n\n@@ -363,6 +382,11 @@\npublic synchronized void addRecord(Record r, int cred) {\n    * @see RRset\n    */\n   public synchronized <T extends Record> void addRRset(RRset rrset, int cred) {\n+    addRRset(rrset, cred, false);\n+  }\n+\n+  private synchronized <T extends Record> void addRRset(\n+      RRset rrset, int cred, boolean isAuthenticated) {\n     long ttl = rrset.getTTL();\n     Name name = rrset.getName();\n     int type = rrset.getType();\n\n@@ -380,7 +404,7 @@\npublic synchronized <T extends Record> void addRRset(RRset rrset, int cred) {\n         if (rrset instanceof CacheRRset) {\n           crrset = (CacheRRset) rrset;\n         } else {\n-          crrset = new CacheRRset(rrset, cred, maxcache);\n+          crrset = new CacheRRset(rrset, cred, maxcache, isAuthenticated);\n         }\n         addElement(name, crrset);\n       }\n\n@@ -397,6 +421,11 @@\npublic synchronized <T extends Record> void addRRset(RRset rrset, int cred) {\n    * @param cred The credibility of the negative entry\n    */\n   public synchronized void addNegative(Name name, int type, SOARecord soa, int cred) {\n+    addNegative(name, type, soa, cred, false);\n+  }\n+\n+  private synchronized void addNegative(\n+      Name name, int type, SOARecord soa, int cred, boolean isAuthenticated) {\n     long ttl = 0;\n     if (soa != null) {\n       ttl = Math.min(soa.getMinimum(), soa.getTTL());\n\n@@ -411,7 +440,7 @@\npublic synchronized void addNegative(Name name, int type, SOARecord soa, int cre\n         element = null;\n       }\n       if (element == null) {\n-        addElement(name, new NegativeElement(name, type, soa, cred, maxncache));\n+        addElement(name, new NegativeElement(name, type, soa, cred, maxncache, isAuthenticated));\n       }\n     }\n   }\n\n@@ -536,7 +565,7 @@\nprivate List<RRset> findRecords(Name name, int type, int minCred) {\n    *\n    * @param name The name to look up\n    * @param type The type to look up\n-   * @return An array of RRsets, or null\n+   * @return A list of matching RRsets, or {@code null}.\n    * @see Credibility\n    */\n   public List<RRset> findRecords(Name name, int type) {\n\n@@ -549,7 +578,7 @@\npublic List<RRset> findRecords(Name name, int type) {\n    *\n    * @param name The name to look up\n    * @param type The type to look up\n-   * @return An array of RRsets, or null\n+   * @return A list of matching RRsets, or {@code null}.\n    * @see Credibility\n    */\n   public List<RRset> findAnyRecords(Name name, int type) {\n\n@@ -600,7 +629,8 @@\nprivate static void markAdditional(RRset rrset, Set<Name> names) {\n    * @see Message\n    */\n   public SetResponse addMessage(Message in) {\n-    boolean isAuth = in.getHeader().getFlag(Flags.AA);\n+    boolean isAuthoritative = in.getHeader().getFlag(Flags.AA);\n+    boolean isAuthenticated = in.getHeader().getFlag(Flags.AD);\n     Record question = in.getQuestion();\n     Name qname;\n     Name curname;\n\n@@ -626,15 +656,16 @@\npublic SetResponse addMessage(Message in) {\n     additionalNames = new HashSet<>();\n \n     answers = in.getSectionRRsets(Section.ANSWER);\n-    for (RRset answer : answers) {\n+    for (int i = 0; i < answers.size(); i++) {\n+      RRset answer = answers.get(i);\n       if (answer.getDClass() != qclass) {\n         continue;\n       }\n       int type = answer.getType();\n       Name name = answer.getName();\n-      cred = getCred(Section.ANSWER, isAuth);\n+      cred = getCred(Section.ANSWER, isAuthoritative);\n       if ((type == qtype || qtype == Type.ANY) && name.equals(curname)) {\n-        addRRset(answer, cred);\n+        addRRset(answer, cred, isAuthenticated);\n         completed = true;\n         if (curname == qname) {\n           if (response == null) {\n\n@@ -643,26 +674,36 @@\npublic SetResponse addMessage(Message in) {\n           response.addRRset(answer);\n         }\n         markAdditional(answer, additionalNames);\n-      } else if (type == Type.CNAME && name.equals(curname)) {\n-        CNAMERecord cname;\n-        addRRset(answer, cred);\n-        if (curname == qname) {\n-          response = SetResponse.ofType(SetResponseType.CNAME, answer);\n-        }\n-        cname = (CNAMERecord) answer.first();\n-        curname = cname.getTarget();\n       } else if (type == Type.DNAME && curname.subdomain(name)) {\n         DNAMERecord dname;\n-        addRRset(answer, cred);\n+        addRRset(answer, cred, isAuthenticated);\n         if (curname == qname) {\n-          response = SetResponse.ofType(SetResponseType.DNAME, answer);\n+          response = SetResponse.ofType(SetResponseType.DNAME, answer, isAuthenticated);\n+        }\n+\n+        if (i + 1 < answers.size()) {\n+          RRset next = answers.get(i + 1);\n+          if (next.getType() == Type.CNAME && next.getName().equals(curname)) {\n+            // Skip generating the next name from the current DNAME, the synthesized CNAME did that\n+            // for us\n+            continue;\n+          }\n         }\n+\n         dname = (DNAMERecord) answer.first();\n         try {\n           curname = curname.fromDNAME(dname);\n         } catch (NameTooLongException e) {\n           break;\n         }\n+      } else if (type == Type.CNAME && name.equals(curname)) {\n+        CNAMERecord cname;\n+        addRRset(answer, cred, isAuthenticated);\n+        if (curname == qname) {\n+          response = SetResponse.ofType(SetResponseType.CNAME, answer, isAuthenticated);\n+        }\n+        cname = (CNAMERecord) answer.first();\n+        curname = cname.getTarget();\n       }\n     }\n\n@@ -681,12 +722,12 @@\npublic SetResponse addMessage(Message in) {\n       int cachetype = (rcode == Rcode.NXDOMAIN) ? 0 : qtype;\n       if (rcode == Rcode.NXDOMAIN || soa != null || ns == null) {\n         /* Negative response */\n-        cred = getCred(Section.AUTHORITY, isAuth);\n+        cred = getCred(Section.AUTHORITY, isAuthoritative);\n         SOARecord soarec = null;\n         if (soa != null) {\n           soarec = (SOARecord) soa.first();\n         }\n-        addNegative(curname, cachetype, soarec, cred);\n+        addNegative(curname, cachetype, soarec, cred, isAuthenticated);\n         if (response == null) {\n           SetResponseType responseType;\n           if (rcode == Rcode.NXDOMAIN) {\n\n@@ -699,17 +740,17 @@\npublic SetResponse addMessage(Message in) {\n         /* DNSSEC records are not cached. */\n       } else {\n         /* Referral response */\n-        cred = getCred(Section.AUTHORITY, isAuth);\n-        addRRset(ns, cred);\n+        cred = getCred(Section.AUTHORITY, isAuthoritative);\n+        addRRset(ns, cred, isAuthenticated);\n         markAdditional(ns, additionalNames);\n         if (response == null) {\n-          response = SetResponse.ofType(SetResponseType.DELEGATION, ns);\n+          response = SetResponse.ofType(SetResponseType.DELEGATION, ns, isAuthenticated);\n         }\n       }\n     } else if (rcode == Rcode.NOERROR && ns != null) {\n       /* Cache the NS set from a positive response. */\n-      cred = getCred(Section.AUTHORITY, isAuth);\n-      addRRset(ns, cred);\n+      cred = getCred(Section.AUTHORITY, isAuthoritative);\n+      addRRset(ns, cred, isAuthenticated);\n       markAdditional(ns, additionalNames);\n     }\n\n@@ -723,8 +764,8 @@\npublic SetResponse addMessage(Message in) {\n       if (!additionalNames.contains(name)) {\n         continue;\n       }\n-      cred = getCred(Section.ADDITIONAL, isAuth);\n-      addRRset(rRset, cred);\n+      cred = getCred(Section.ADDITIONAL, isAuthoritative);\n+      addRRset(rRset, cred, isAuthenticated);\n     }\n \n     log.debug(\n```\n\nFilename: src/main/java/org/xbill/DNS/Lookup.java:\n```\n@@ -433,12 +433,18 @@\npublic void setSearchPath(String... domains) throws TextParseException {\n    * results of this lookup should not be permanently cached, null can be provided here.\n    *\n    * @param cache The cache to use.\n+   * @throws IllegalArgumentException If the DClass of the cache doesn't match this Lookup's DClass.\n    */\n   public void setCache(Cache cache) {\n     if (cache == null) {\n       this.cache = new Cache(dclass);\n       this.temporary_cache = true;\n     } else {\n+      if (cache.getDClass() != dclass) {\n+        throw new IllegalArgumentException(\n+            \"DClass of cache doesn't match DClass of this Lookup instance\");\n+      }\n+\n       this.cache = cache;\n       this.temporary_cache = false;\n     }\n\n@@ -571,7 +577,7 @@\nprivate void lookup(Name current) {\n     Message query = Message.newQuery(question);\n     Message response;\n     try {\n-      response = resolver.send(query);\n+      response = resolver.send(query).normalize(query);\n     } catch (IOException e) {\n       log.debug(\n           \"Lookup for {}/{}, id={} failed using resolver {}\",\n```\n\nFilename: src/main/java/org/xbill/DNS/Message.java:\n```\n@@ -1,18 +1,18 @@\n// SPDX-License-Identifier: BSD-3-Clause\n // Copyright (c) 1999-2004 Brian Wellington (bwelling@xbill.org)\n+// Copyright (c) 2007-2023 NLnet Labs\n \n package org.xbill.DNS;\n \n import java.io.IOException;\n import java.nio.ByteBuffer;\n import java.util.ArrayList;\n import java.util.Collections;\n-import java.util.HashSet;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Optional;\n-import java.util.Set;\n import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n \n /**\n  * A DNS Message. A message is the basic unit of communication between the client and server of a\n\n@@ -23,6 +23,7 @@\n* @see Section\n  * @author Brian Wellington\n  */\n+@Slf4j\n public class Message implements Cloneable {\n \n   /** The maximum length of a message in wire format. */\n\n@@ -192,6 +193,7 @@\npublic void addRecord(Record r, int section) {\n    * @see Section\n    */\n   public boolean removeRecord(Record r, int section) {\n+    Section.check(section);\n     if (sections[section] != null && sections[section].remove(r)) {\n       header.decCount(section);\n       return true;\n\n@@ -207,6 +209,7 @@\npublic boolean removeRecord(Record r, int section) {\n    * @see Section\n    */\n   public void removeAllRecords(int section) {\n+    Section.check(section);\n     sections[section] = null;\n     header.setCount(section, 0);\n   }\n\n@@ -218,6 +221,7 @@\npublic void removeAllRecords(int section) {\n    * @see Section\n    */\n   public boolean findRecord(Record r, int section) {\n+    Section.check(section);\n     return sections[section] != null && sections[section].contains(r);\n   }\n\n@@ -243,6 +247,8 @@\npublic boolean findRecord(Record r) {\n    * @see Section\n    */\n   public boolean findRRset(Name name, int type, int section) {\n+    Type.check(type);\n+    Section.check(section);\n     if (sections[section] == null) {\n       return false;\n     }\n\n@@ -364,6 +370,7 @@\npublic int getRcode() {\n    */\n   @Deprecated\n   public Record[] getSectionArray(int section) {\n+    Section.check(section);\n     if (sections[section] == null) {\n       return emptyRecordArray;\n     }\n\n@@ -378,51 +385,43 @@\npublic Record[] getSectionArray(int section) {\n    * @see Section\n    */\n   public List<Record> getSection(int section) {\n+    Section.check(section);\n     if (sections[section] == null) {\n       return Collections.emptyList();\n     }\n     return Collections.unmodifiableList(sections[section]);\n   }\n \n-  private static boolean sameSet(Record r1, Record r2) {\n-    return r1.getRRsetType() == r2.getRRsetType()\n-        && r1.getDClass() == r2.getDClass()\n-        && r1.getName().equals(r2.getName());\n-  }\n-\n   /**\n    * Returns an array containing all records in the given section grouped into RRsets.\n    *\n    * @see RRset\n    * @see Section\n    */\n+  @SuppressWarnings(\"java:S1119\") // label\n   public List<RRset> getSectionRRsets(int section) {\n+    Section.check(section);\n     if (sections[section] == null) {\n       return Collections.emptyList();\n     }\n+\n     List<RRset> sets = new LinkedList<>();\n-    Set<Name> hash = new HashSet<>();\n-    for (Record rec : getSection(section)) {\n-      Name name = rec.getName();\n-      boolean newset = true;\n-      if (hash.contains(name)) {\n-        for (int j = sets.size() - 1; j >= 0; j--) {\n-          RRset set = sets.get(j);\n-          if (set.getType() == rec.getRRsetType()\n-              && set.getDClass() == rec.getDClass()\n-              && set.getName().equals(name)) {\n-            set.addRR(rec);\n-            newset = false;\n-            break;\n-          }\n+    record_iteration:\n+    for (Record rec : sections[section]) {\n+      for (int j = sets.size() - 1; j >= 0; j--) {\n+        RRset set = sets.get(j);\n+        if (rec.sameRRset(set)) {\n+          set.addRR(rec);\n+\n+          // Existing set found, continue with the next record\n+          continue record_iteration;\n         }\n       }\n-      if (newset) {\n-        RRset set = new RRset(rec);\n-        sets.add(set);\n-        hash.add(name);\n-      }\n+\n+      // No existing set found, create a new one\n+      sets.add(new RRset(rec));\n     }\n+\n     return sets;\n   }\n\n@@ -453,7 +452,7 @@\nprivate int sectionToWire(DNSOutput out, int section, Compression c, int maxLeng\n         continue;\n       }\n \n-      if (lastrec != null && !sameSet(rec, lastrec)) {\n+      if (lastrec != null && !rec.sameRRset(lastrec)) {\n         pos = out.current();\n         rendered = count;\n       }\n\n@@ -604,13 +603,10 @@\npublic int numBytes() {\n    *\n    * @see Section\n    */\n-  public String sectionToString(int i) {\n-    if (i > 3) {\n-      return null;\n-    }\n-\n+  public String sectionToString(int section) {\n+    Section.check(section);\n     StringBuilder sb = new StringBuilder();\n-    sectionToString(sb, i);\n+    sectionToString(sb, section);\n     return sb.toString();\n   }\n\n@@ -677,10 +673,10 @@\npublic String toString() {\n    */\n   @Override\n   @SneakyThrows(CloneNotSupportedException.class)\n-  @SuppressWarnings(\"unchecked\")\n+  @SuppressWarnings({\"unchecked\", \"java:S2975\"})\n   public Message clone() {\n     Message m = (Message) super.clone();\n-    m.sections = (List<Record>[]) new List[sections.length];\n+    m.sections = new List[sections.length];\n     for (int i = 0; i < sections.length; i++) {\n       if (sections[i] != null) {\n         m.sections[i] = new LinkedList<>(sections[i]);\n\n@@ -705,4 +701,401 @@\npublic void setResolver(Resolver resolver) {\n   public Optional<Resolver> getResolver() {\n     return Optional.ofNullable(resolver);\n   }\n+\n+  /**\n+   * Checks if a record {@link Type} is allowed within a {@link Section}.\n+   *\n+   * @return {@code true} if the type is allowed, {@code false} otherwise.\n+   */\n+  boolean isTypeAllowedInSection(int type, int section) {\n+    Type.check(type);\n+    Section.check(section);\n+    switch (section) {\n+      case Section.AUTHORITY:\n+        if (type == Type.SOA\n+            || type == Type.NS\n+            || type == Type.DS\n+            || type == Type.NSEC\n+            || type == Type.NSEC3) {\n+          return true;\n+        }\n+        break;\n+      case Section.ADDITIONAL:\n+        if (type == Type.A || type == Type.AAAA) {\n+          return true;\n+        }\n+        break;\n+    }\n+\n+    return !Boolean.parseBoolean(System.getProperty(\"dnsjava.harden_unknown_additional\", \"true\"));\n+  }\n+\n+  /**\n+   * Creates a normalized copy of this message by following xNAME chains, synthesizing CNAMEs from\n+   * DNAMEs if necessary, and removing illegal RRsets from {@link Section#AUTHORITY} and {@link\n+   * Section#ADDITIONAL}.\n+   *\n+   * <p>Normalization is only applied to {@link Rcode#NOERROR} and {@link Rcode#NXDOMAIN} responses.\n+   *\n+   * <p>This method is equivalent to calling {@link #normalize(Message, boolean)} with {@code\n+   * false}.\n+   *\n+   * @param query The query that produced this message.\n+   * @return {@code null} if the message could not be normalized or is otherwise invalid.\n+   * @since 3.6\n+   */\n+  public Message normalize(Message query) {\n+    try {\n+      return normalize(query, false);\n+    } catch (WireParseException e) {\n+      // Cannot happen with 'false'\n+    }\n+\n+    return null;\n+  }\n+\n+  /**\n+   * Creates a normalized copy of this message by following xNAME chains, synthesizing CNAMEs from\n+   * DNAMEs if necessary, and removing illegal RRsets from {@link Section#AUTHORITY} and {@link\n+   * Section#ADDITIONAL}.\n+   *\n+   * <p>Normalization is only applied to {@link Rcode#NOERROR} and {@link Rcode#NXDOMAIN} responses.\n+   *\n+   * @param query The query that produced this message.\n+   * @param throwOnIrrelevantRecord If {@code true}, throw an exception instead of silently ignoring\n+   *     irrelevant records.\n+   * @return {@code null} if the message could not be normalized or is otherwise invalid.\n+   * @throws WireParseException when {@code throwOnIrrelevantRecord} is {@code true} and an invalid\n+   *     or irrelevant record was found.\n+   * @since 3.6\n+   */\n+  public Message normalize(Message query, boolean throwOnIrrelevantRecord)\n+      throws WireParseException {\n+    if (getRcode() != Rcode.NOERROR && getRcode() != Rcode.NXDOMAIN) {\n+      return this;\n+    }\n+\n+    Name sname = query.getQuestion().getName();\n+    List<RRset> answerSectionSets = getSectionRRsets(Section.ANSWER);\n+    List<RRset> additionalSectionSets = getSectionRRsets(Section.ADDITIONAL);\n+    List<RRset> authoritySectionSets = getSectionRRsets(Section.AUTHORITY);\n+\n+    List<RRset> cleanedAnswerSection = new ArrayList<>();\n+    List<RRset> cleanedAuthoritySection = new ArrayList<>();\n+    List<RRset> cleanedAdditionalSection = new ArrayList<>();\n+    boolean hadNsInAuthority = false;\n+\n+    // For the ANSWER section, remove all \"irrelevant\" records and add synthesized CNAMEs from\n+    // DNAMEs. This will strip out-of-order CNAMEs as well.\n+    for (int i = 0; i < answerSectionSets.size(); i++) {\n+      RRset rrset = answerSectionSets.get(i);\n+      Name oldSname = sname;\n+\n+      if (rrset.getType() == Type.DNAME && sname.subdomain(rrset.getName())) {\n+        if (rrset.size() > 1) {\n+          String template =\n+              \"Normalization failed in response to <{}/{}/{}> (id {}), found {} entries (instead of just one) in DNAME RRSet <{}/{}>\";\n+          if (throwOnIrrelevantRecord) {\n+            throw new WireParseException(template.replace(\"{}\", \"%s\"));\n+          }\n+          log.warn(\n+              template,\n+              sname,\n+              Type.string(query.getQuestion().getType()),\n+              DClass.string(query.getQuestion().getDClass()),\n+              getHeader().getID(),\n+              rrset.size(),\n+              rrset.getName(),\n+              DClass.string(rrset.getDClass()));\n+          return null;\n+        }\n+\n+        // If DNAME was queried, don't attempt to synthesize CNAME\n+        if (query.getQuestion().getType() != Type.DNAME) {\n+          // The DNAME is valid, accept it\n+          cleanedAnswerSection.add(rrset);\n+\n+          // Check if the next rrset is correct CNAME, otherwise synthesize a CNAME\n+          RRset nextRRSet = answerSectionSets.size() >= i + 2 ? answerSectionSets.get(i + 1) : null;\n+          DNAMERecord dname = ((DNAMERecord) rrset.first());\n+          try {\n+            // Validate that an existing CNAME matches what we would synthesize\n+            if (nextRRSet != null\n+                && nextRRSet.getType() == Type.CNAME\n+                && nextRRSet.getName().equals(sname)) {\n+              Name expected =\n+                  Name.concatenate(\n+                      nextRRSet.getName().relativize(dname.getName()), dname.getTarget());\n+              if (expected.equals(((CNAMERecord) nextRRSet.first()).getTarget())) {\n+                continue;\n+              }\n+            }\n+\n+            // Add a synthesized CNAME; TTL=0 to avoid caching\n+            Name dnameTarget = sname.fromDNAME(dname);\n+            cleanedAnswerSection.add(\n+                new RRset(new CNAMERecord(sname, dname.getDClass(), 0, dnameTarget)));\n+            sname = dnameTarget;\n+\n+            // In DNAME ANY response, can have data after DNAME\n+            if (query.getQuestion().getType() == Type.ANY) {\n+              for (i++; i < answerSectionSets.size(); i++) {\n+                rrset = answerSectionSets.get(i);\n+                if (rrset.getName().equals(oldSname)) {\n+                  cleanedAnswerSection.add(rrset);\n+                } else {\n+                  break;\n+                }\n+              }\n+            }\n+\n+            continue;\n+          } catch (NameTooLongException e) {\n+            String template =\n+                \"Normalization failed in response to <{}/{}/{}> (id {}), could not synthesize CNAME for DNAME <{}/{}>\";\n+            if (throwOnIrrelevantRecord) {\n+              throw new WireParseException(template.replace(\"{}\", \"%s\"), e);\n+            }\n+            log.warn(\n+                template,\n+                sname,\n+                Type.string(query.getQuestion().getType()),\n+                DClass.string(query.getQuestion().getDClass()),\n+                getHeader().getID(),\n+                rrset.getName(),\n+                DClass.string(rrset.getDClass()));\n+            return null;\n+          }\n+        }\n+      }\n+\n+      // Ignore irrelevant records\n+      if (!sname.equals(rrset.getName())) {\n+        logOrThrow(\n+            throwOnIrrelevantRecord,\n+            \"Ignoring irrelevant RRset <{}/{}/{}> in response to <{}/{}/{}> (id {})\",\n+            rrset,\n+            sname,\n+            query);\n+        continue;\n+      }\n+\n+      // Follow CNAMEs\n+      if (rrset.getType() == Type.CNAME && query.getQuestion().getType() != Type.CNAME) {\n+        if (rrset.size() > 1) {\n+          String template =\n+              \"Found {} CNAMEs in <{}/{}> response to <{}/{}/{}> (id {}), removing all but the first\";\n+          if (throwOnIrrelevantRecord) {\n+            throw new WireParseException(\n+                String.format(\n+                    template.replace(\"{}\", \"%s\"),\n+                    rrset.rrs(false).size(),\n+                    rrset.getName(),\n+                    DClass.string(rrset.getDClass()),\n+                    sname,\n+                    Type.string(query.getQuestion().getType()),\n+                    DClass.string(query.getQuestion().getDClass()),\n+                    getHeader().getID()));\n+          }\n+          log.warn(\n+              template,\n+              rrset.rrs(false).size(),\n+              rrset.getName(),\n+              DClass.string(rrset.getDClass()),\n+              sname,\n+              Type.string(query.getQuestion().getType()),\n+              DClass.string(query.getQuestion().getDClass()),\n+              getHeader().getID());\n+          List<Record> cnameRRset = rrset.rrs(false);\n+          for (int cnameIndex = 1; cnameIndex < cnameRRset.size(); cnameIndex++) {\n+            rrset.deleteRR(cnameRRset.get(i));\n+          }\n+        }\n+\n+        sname = ((CNAMERecord) rrset.first()).getTarget();\n+        cleanedAnswerSection.add(rrset);\n+\n+        // In CNAME ANY response, can have data after CNAME\n+        if (query.getQuestion().getType() == Type.ANY) {\n+          for (i++; i < answerSectionSets.size(); i++) {\n+            rrset = answerSectionSets.get(i);\n+            if (rrset.getName().equals(oldSname)) {\n+              cleanedAnswerSection.add(rrset);\n+            } else {\n+              break;\n+            }\n+          }\n+        }\n+\n+        continue;\n+      }\n+\n+      // Remove records that don't match the queried type\n+      int qtype = getQuestion().getType();\n+      if (qtype != Type.ANY && rrset.getActualType() != qtype) {\n+        logOrThrow(\n+            throwOnIrrelevantRecord,\n+            \"Ignoring irrelevant RRset <{}/{}/{}> in ANSWER section response to <{}/{}/{}> (id {})\",\n+            rrset,\n+            sname,\n+            query);\n+        continue;\n+      }\n+\n+      // Mark the additional names from relevant RRset as OK\n+      cleanedAnswerSection.add(rrset);\n+      if (sname.equals(rrset.getName())) {\n+        addAdditionalRRset(rrset, additionalSectionSets, cleanedAdditionalSection);\n+      }\n+    }\n+\n+    for (RRset rrset : authoritySectionSets) {\n+      switch (rrset.getType()) {\n+        case Type.DNAME:\n+        case Type.CNAME:\n+        case Type.A:\n+        case Type.AAAA:\n+          logOrThrow(\n+              throwOnIrrelevantRecord,\n+              \"Ignoring forbidden RRset <{}/{}/{}> in AUTHORITY section response to <{}/{}/{}> (id {})\",\n+              rrset,\n+              sname,\n+              query);\n+          continue;\n+      }\n+\n+      if (!isTypeAllowedInSection(rrset.getType(), Section.AUTHORITY)) {\n+        logOrThrow(\n+            throwOnIrrelevantRecord,\n+            \"Ignoring disallowed RRset <{}/{}/{}> in AUTHORITY section response to <{}/{}/{}> (id {})\",\n+            rrset,\n+            sname,\n+            query);\n+        continue;\n+      }\n+\n+      if (rrset.getType() == Type.NS) {\n+        // NS set must be pertinent to the query\n+        if (!sname.subdomain(rrset.getName())) {\n+          logOrThrow(\n+              throwOnIrrelevantRecord,\n+              \"Ignoring disallowed RRset <{}/{}/{}> in AUTHORITY section response to <{}/{}/{}> (id {}), not a subdomain of the query\",\n+              rrset,\n+              sname,\n+              query);\n+          continue;\n+        }\n+\n+        // We don't want NS sets for NODATA or NXDOMAIN answers, because they could contain\n+        // poisonous contents, from e.g. fragmentation attacks, inserted after long RRSIGs in the\n+        // packet get to the packet border and such\n+        if (getRcode() == Rcode.NXDOMAIN\n+            || (getRcode() == Rcode.NOERROR\n+                && authoritySectionSets.stream().anyMatch(set -> set.getType() == Type.SOA)\n+                && sections[Section.ANSWER] == null)) {\n+          logOrThrow(\n+              throwOnIrrelevantRecord,\n+              \"Ignoring disallowed RRset <{}/{}/{}> in AUTHORITY section response to <{}/{}/{}> (id {}), NXDOMAIN or NODATA\",\n+              rrset,\n+              sname,\n+              query);\n+          continue;\n+        }\n+\n+        if (!hadNsInAuthority) {\n+          hadNsInAuthority = true;\n+        } else {\n+          logOrThrow(\n+              throwOnIrrelevantRecord,\n+              \"Ignoring disallowed RRset <{}/{}/{}> in AUTHORITY section response to <{}/{}/{}> (id {}), already seen another NS\",\n+              rrset,\n+              sname,\n+              query);\n+          continue;\n+        }\n+      }\n+\n+      cleanedAuthoritySection.add(rrset);\n+      addAdditionalRRset(rrset, additionalSectionSets, cleanedAdditionalSection);\n+    }\n+\n+    Message cleanedMessage = new Message(this.getHeader());\n+    cleanedMessage.sections[Section.QUESTION] = this.sections[Section.QUESTION];\n+    cleanedMessage.sections[Section.ANSWER] = rrsetListToRecords(cleanedAnswerSection);\n+    cleanedMessage.sections[Section.AUTHORITY] = rrsetListToRecords(cleanedAuthoritySection);\n+    cleanedMessage.sections[Section.ADDITIONAL] = rrsetListToRecords(cleanedAdditionalSection);\n+    return cleanedMessage;\n+  }\n+\n+  private void logOrThrow(\n+      boolean throwOnIrrelevantRecord, String format, RRset rrset, Name sname, Message query)\n+      throws WireParseException {\n+    if (throwOnIrrelevantRecord) {\n+      throw new WireParseException(\n+          String.format(\n+              format.replace(\"{}\", \"%s\") + this,\n+              rrset.getName(),\n+              DClass.string(rrset.getDClass()),\n+              Type.string(rrset.getType()),\n+              sname,\n+              Type.string(query.getQuestion().getType()),\n+              DClass.string(query.getQuestion().getDClass()),\n+              getHeader().getID()));\n+    }\n+    log.debug(\n+        format,\n+        rrset.getName(),\n+        DClass.string(rrset.getDClass()),\n+        Type.string(rrset.getType()),\n+        sname,\n+        Type.string(query.getQuestion().getType()),\n+        DClass.string(query.getQuestion().getDClass()),\n+        getHeader().getID());\n+  }\n+\n+  private List<Record> rrsetListToRecords(List<RRset> rrsets) {\n+    if (rrsets.isEmpty()) {\n+      return null;\n+    }\n+\n+    List<Record> result = new ArrayList<>(rrsets.size());\n+    for (RRset set : rrsets) {\n+      result.addAll(set.rrs(false));\n+      result.addAll(set.sigs());\n+    }\n+\n+    return result;\n+  }\n+\n+  private void addAdditionalRRset(\n+      RRset rrset, List<RRset> additionalSectionSets, List<RRset> cleanedAdditionalSection) {\n+    if (!doesTypeHaveAdditionalRecords(rrset.getType())) {\n+      return;\n+    }\n+\n+    for (Record r : rrset.rrs(false)) {\n+      for (RRset set : additionalSectionSets) {\n+        if (set.getName().equals(r.getAdditionalName())\n+            && isTypeAllowedInSection(set.getType(), Section.ADDITIONAL)) {\n+          cleanedAdditionalSection.add(set);\n+        }\n+      }\n+    }\n+  }\n+\n+  private boolean doesTypeHaveAdditionalRecords(int type) {\n+    switch (type) {\n+      case Type.MB:\n+      case Type.MD:\n+      case Type.MF:\n+      case Type.NS:\n+      case Type.MX:\n+      case Type.KX:\n+      case Type.SRV:\n+      case Type.NAPTR:\n+        return true;\n+    }\n+\n+    return false;\n+  }\n }\n```\n\nFilename: src/main/java/org/xbill/DNS/RRset.java:\n```\n@@ -206,14 +206,25 @@\npublic Name getName() {\n   }\n \n   /**\n-   * Returns the type of the records\n+   * Returns the type of the records. If this set contains only signatures, it returns the covered\n+   * type.\n    *\n    * @see Type\n    */\n   public int getType() {\n     return first().getRRsetType();\n   }\n \n+  /**\n+   * Returns the actual type of the records, i.e. for signatures not the type covered but {@link\n+   * Type#RRSIG}.\n+   *\n+   * @see Type\n+   */\n+  int getActualType() {\n+    return first().getType();\n+  }\n+\n   /**\n    * Returns the class of the records\n    *\n```\n\nFilename: src/main/java/org/xbill/DNS/Record.java:\n```\n@@ -566,6 +566,18 @@\npublic boolean sameRRset(Record rec) {\n     return getRRsetType() == rec.getRRsetType() && dclass == rec.dclass && name.equals(rec.name);\n   }\n \n+  /**\n+   * Determines if this Record could be part of the passed RRset. This compares the name, type, and\n+   * class of the Record and the set.\n+   *\n+   * @since 3.6\n+   */\n+  public boolean sameRRset(RRset set) {\n+    return getRRsetType() == set.getType()\n+        && dclass == set.getDClass()\n+        && name.equals(set.getName());\n+  }\n+\n   /**\n    * Determines if two Records are identical. This compares the name, type, class, and rdata (with\n    * names canonicalized). The TTLs are not compared.\n```\n\nFilename: src/main/java/org/xbill/DNS/Section.java:\n```\n@@ -79,4 +79,13 @@\npublic static String updString(int i) {\n   public static int value(String s) {\n     return sections.getValue(s);\n   }\n+\n+  /**\n+   * Checks that a numeric section value is valid.\n+   *\n+   * @since 3.6\n+   */\n+  public static void check(int section) {\n+    sections.check(section);\n+  }\n }\n```\n\nFilename: src/main/java/org/xbill/DNS/SetResponse.java:\n```\n@@ -13,6 +13,7 @@\nimport java.util.ArrayList;\n import java.util.List;\n+import lombok.AccessLevel;\n import lombok.Getter;\n \n /**\n\n@@ -33,10 +34,8 @@\npublic class SetResponse {\n \n   private final SetResponseType type;\n \n-  /**\n-   * @since 3.6\n-   */\n-  @Getter private boolean isAuthenticated;\n+  @Getter(AccessLevel.PACKAGE)\n+  private boolean isAuthenticated;\n \n   private List<RRset> data;\n\n@@ -56,6 +55,10 @@\nstatic SetResponse ofType(SetResponseType type, RRset rrset) {\n     return ofType(type, rrset, false);\n   }\n \n+  static SetResponse ofType(SetResponseType type, Cache.CacheRRset rrset) {\n+    return ofType(type, rrset, rrset.isAuthenticated());\n+  }\n+\n   static SetResponse ofType(SetResponseType type, RRset rrset, boolean isAuthenticated) {\n     switch (type) {\n       case UNKNOWN:\n\n@@ -81,6 +84,13 @@\nvoid addRRset(RRset rrset) {\n \n     if (data == null) {\n       data = new ArrayList<>();\n+      if (rrset instanceof Cache.CacheRRset) {\n+        isAuthenticated = ((Cache.CacheRRset) rrset).isAuthenticated();\n+      }\n+    } else {\n+      if (rrset instanceof Cache.CacheRRset && isAuthenticated) {\n+        isAuthenticated = ((Cache.CacheRRset) rrset).isAuthenticated();\n+      }\n     }\n \n     data.add(rrset);\n```\n\nFilename: src/main/java/org/xbill/DNS/SetResponseType.java:\n```\n@@ -1,3 +1,4 @@\n+// SPDX-License-Identifier: BSD-3-Clause\n package org.xbill.DNS;\n \n import lombok.Getter;\n```\n\nFilename: src/main/java/org/xbill/DNS/dnssec/ValidatingResolver.java:\n```\n@@ -221,7 +221,6 @@\npublic void loadTrustAnchors(InputStream data) throws IOException {\n    * Gets the store with the loaded trust anchors.\n    *\n    * @return The store with the loaded trust anchors.\n-   * @since 3.6\n    */\n   public TrustAnchorStore getTrustAnchors() {\n     return this.trustAnchors;\n```\n\nFilename: src/main/java/org/xbill/DNS/lookup/IrrelevantRecordMode.java:\n```\n@@ -0,0 +1,10 @@\n+// SPDX-License-Identifier: BSD-3-Clause\n+package org.xbill.DNS.lookup;\n+\n+/** Defines the handling of irrelevant records during messages normalization. */\n+enum IrrelevantRecordMode {\n+  /** Irrelevant records are removed from the message, but otherwise ignored. */\n+  REMOVE,\n+  /** Throws an error when an irrelevant record is found. */\n+  THROW,\n+}\n```\n\nFilename: src/main/java/org/xbill/DNS/lookup/LookupResult.java:\n```\n@@ -3,8 +3,15 @@\nimport java.util.ArrayList;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import lombok.AccessLevel;\n import lombok.Data;\n+import lombok.Getter;\n+import org.xbill.DNS.Flags;\n+import org.xbill.DNS.Message;\n import org.xbill.DNS.Name;\n import org.xbill.DNS.Record;\n\n@@ -26,18 +33,77 @@\npublic final class LookupResult {\n    */\n   private final List<Name> aliases;\n \n+  /** The queries and responses that made up the result. */\n+  @Getter(AccessLevel.PACKAGE)\n+  private final Map<Record, Message> queryResponsePairs;\n+\n+  /**\n+   * Gets an indication if the message(s) that provided this result were authenticated, e.g. by\n+   * using {@link org.xbill.DNS.dnssec.ValidatingResolver} or when the upstream resolver has set the\n+   * {@link org.xbill.DNS.Flags#AD} flag.\n+   *\n+   * <p><b>IMPORTANT</b>: Note that in the latter case, the flag cannot be trusted unless the {@link\n+   * org.xbill.DNS.Resolver} used by the {@link LookupSession} that created this result:\n+   *\n+   * <ul>\n+   *   <li>has TSIG enabled\n+   *   <li>uses an externally secured transport, e.g. with IPSec or DNS over TLS.\n+   * </ul>\n+   */\n+  @Getter(AccessLevel.PACKAGE)\n+  private final boolean isAuthenticated;\n+\n   /**\n    * Construct an instance with the provided records and, in the case of a CNAME or DNAME\n    * indirection a List of aliases.\n    *\n    * @param records a list of records to return.\n    * @param aliases a list of aliases discovered during lookup, or null if there was no indirection.\n+   * @deprecated This class is not intended for public instantiation.\n    */\n+  @Deprecated\n   public LookupResult(List<Record> records, List<Name> aliases) {\n     this.records = Collections.unmodifiableList(new ArrayList<>(records));\n     this.aliases =\n         aliases == null\n             ? Collections.emptyList()\n             : Collections.unmodifiableList(new ArrayList<>(aliases));\n+    queryResponsePairs = Collections.emptyMap();\n+    isAuthenticated = false;\n+  }\n+\n+  LookupResult(boolean isAuthenticated) {\n+    queryResponsePairs = Collections.emptyMap();\n+    this.isAuthenticated = isAuthenticated;\n+    records = Collections.emptyList();\n+    aliases = Collections.emptyList();\n+  }\n+\n+  LookupResult(Record query, boolean isAuthenticated, Record record) {\n+    this.queryResponsePairs = Collections.singletonMap(query, null);\n+    this.isAuthenticated = isAuthenticated;\n+    this.records = Collections.singletonList(record);\n+    this.aliases = Collections.emptyList();\n+  }\n+\n+  LookupResult(\n+      LookupResult previous,\n+      Record query,\n+      Message answer,\n+      boolean isAuthenticated,\n+      List<Record> records,\n+      List<Name> aliases) {\n+    Map<Record, Message> map = new HashMap<>(previous.queryResponsePairs.size() + 1);\n+    map.putAll(previous.queryResponsePairs);\n+    map.put(query, answer);\n+    this.queryResponsePairs = Collections.unmodifiableMap(map);\n+    this.isAuthenticated =\n+        previous.isAuthenticated\n+            && isAuthenticated\n+            && this.queryResponsePairs.values().stream()\n+                .filter(Objects::nonNull)\n+                .allMatch(a -> a.getHeader().getFlag(Flags.AD));\n+    this.records = Collections.unmodifiableList(new ArrayList<>(records));\n+    this.aliases = Collections.unmodifiableList(new ArrayList<>(aliases));\n   }\n }\n```\n\nFilename: src/main/java/org/xbill/DNS/lookup/LookupSession.java:\n```\n@@ -43,6 +43,7 @@\nimport org.xbill.DNS.SetResponse;\n import org.xbill.DNS.SimpleResolver;\n import org.xbill.DNS.Type;\n+import org.xbill.DNS.WireParseException;\n import org.xbill.DNS.hosts.HostsFileParser;\n \n /**\n\n@@ -65,6 +66,7 @@\npublic class LookupSession {\n   private final Map<Integer, Cache> caches;\n   private final HostsFileParser hostsFileParser;\n   private final Executor executor;\n+  private IrrelevantRecordMode irrelevantRecordMode;\n \n   private LookupSession(\n       @NonNull Resolver resolver,\n\n@@ -74,7 +76,8 @@\nprivate LookupSession(\n       boolean cycleResults,\n       List<Cache> caches,\n       HostsFileParser hostsFileParser,\n-      Executor executor) {\n+      Executor executor,\n+      IrrelevantRecordMode irrelevantRecordMode) {\n     this.resolver = resolver;\n     this.maxRedirects = maxRedirects;\n     this.ndots = ndots;\n\n@@ -86,6 +89,7 @@\nprivate LookupSession(\n             : caches.stream().collect(Collectors.toMap(Cache::getDClass, e -> e));\n     this.hostsFileParser = hostsFileParser;\n     this.executor = executor == null ? ForkJoinPool.commonPool() : executor;\n+    this.irrelevantRecordMode = irrelevantRecordMode;\n   }\n \n   /**\n\n@@ -104,6 +108,7 @@\npublic static class LookupSessionBuilder {\n     private List<Cache> caches;\n     private HostsFileParser hostsFileParser;\n     private Executor executor;\n+    private IrrelevantRecordMode irrelevantRecordMode = IrrelevantRecordMode.REMOVE;\n \n     private LookupSessionBuilder() {}\n\n@@ -210,6 +215,17 @@\npublic LookupSessionBuilder executor(Executor executor) {\n       return this;\n     }\n \n+    /**\n+     * Sets how irrelevant records in a {@link Message} returned from the {@link\n+     * #resolver(Resolver)} is handled. The default is {@link IrrelevantRecordMode#REMOVE}.\n+     *\n+     * @return {@code this}.\n+     */\n+    LookupSessionBuilder irrelevantRecordMode(IrrelevantRecordMode irrelevantRecordMode) {\n+      this.irrelevantRecordMode = irrelevantRecordMode;\n+      return this;\n+    }\n+\n     /**\n      * Enable querying the local hosts database using the system defaults.\n      *\n\n@@ -322,7 +338,8 @@\npublic LookupSession build() {\n           cycleResults,\n           caches,\n           hostsFileParser,\n-          executor);\n+          executor,\n+          irrelevantRecordMode);\n     }\n   }\n\n@@ -360,6 +377,22 @@\npublic static LookupSessionBuilder defaultBuilder() {\n         .defaultHostsFileParser();\n   }\n \n+  // Visible for testing only\n+  Cache getCache(int dclass) {\n+    return caches.get(dclass);\n+  }\n+\n+  /**\n+   * Make an asynchronous lookup with the provided {@link Record}.\n+   *\n+   * @param question the name, type and DClass to look up.\n+   * @return A {@link CompletionStage} what will yield the eventual lookup result.\n+   * @since 3.6\n+   */\n+  public CompletionStage<LookupResult> lookupAsync(Record question) {\n+    return lookupAsync(question.getName(), question.getType(), question.getDClass());\n+  }\n+\n   /**\n    * Make an asynchronous lookup of the provided name using the default {@link DClass#IN}.\n    *\n\n@@ -434,7 +467,8 @@\nprivate LookupResult lookupWithHosts(List<Name> names, int type) {\n             } else {\n               r = new AAAARecord(name, DClass.IN, 0, result.get());\n             }\n-            return new LookupResult(Collections.singletonList(r), Collections.emptyList());\n+\n+            return new LookupResult(Record.newRecord(name, type, DClass.IN), true, r);\n           }\n         }\n       } catch (IOException e) {\n\n@@ -458,10 +492,10 @@\nprivate CompletionStage<LookupResult> lookupUntilSuccess(\n                 if (names.hasNext()) {\n                   return lookupUntilSuccess(names, type, dclass);\n                 } else {\n-                  return completeExceptionally(cause);\n+                  return this.<Throwable, LookupResult>completeExceptionally(cause);\n                 }\n               } else if (cause != null) {\n-                return completeExceptionally(cause);\n+                return this.<Throwable, LookupResult>completeExceptionally(cause);\n               } else {\n                 return CompletableFuture.completedFuture(result);\n               }\n\n@@ -471,14 +505,54 @@\nprivate CompletionStage<LookupResult> lookupUntilSuccess(\n \n   private CompletionStage<LookupResult> lookupWithCache(Record queryRecord, List<Name> aliases) {\n     return Optional.ofNullable(caches.get(queryRecord.getDClass()))\n-        .map(c -> c.lookupRecords(queryRecord.getName(), queryRecord.getType(), Credibility.NORMAL))\n+        .map(\n+            c -> {\n+              log.debug(\n+                  \"Looking for <{}/{}/{}> in cache\",\n+                  queryRecord.getName(),\n+                  Type.string(queryRecord.getType()),\n+                  DClass.string(queryRecord.getDClass()));\n+              return c.lookupRecords(\n+                  queryRecord.getName(), queryRecord.getType(), Credibility.NORMAL);\n+            })\n         .map(setResponse -> setResponseToMessageFuture(setResponse, queryRecord, aliases))\n         .orElseGet(() -> lookupWithResolver(queryRecord, aliases));\n   }\n \n   private CompletionStage<LookupResult> lookupWithResolver(Record queryRecord, List<Name> aliases) {\n+    Message query = Message.newQuery(queryRecord);\n+    log.debug(\n+        \"Asking {} for <{}/{}/{}>\",\n+        resolver,\n+        queryRecord.getName(),\n+        Type.string(queryRecord.getType()),\n+        DClass.string(queryRecord.getDClass()));\n     return resolver\n-        .sendAsync(Message.newQuery(queryRecord), executor)\n+        .sendAsync(query, executor)\n+        .thenCompose(\n+            m -> {\n+              try {\n+                Message normalized =\n+                    m.normalize(query, irrelevantRecordMode == IrrelevantRecordMode.THROW);\n+\n+                log.trace(\n+                    \"Normalized response for <{}/{}/{}> from \\n{}\\ninto\\n{}\",\n+                    queryRecord.getName(),\n+                    Type.string(queryRecord.getType()),\n+                    DClass.string(queryRecord.getDClass()),\n+                    m,\n+                    normalized);\n+                if (normalized == null) {\n+                  return completeExceptionally(\n+                      new InvalidZoneDataException(\"Failed to normalize message\"));\n+                }\n+                return CompletableFuture.completedFuture(normalized);\n+              } catch (WireParseException e) {\n+                return completeExceptionally(\n+                    new LookupFailedException(\n+                        \"Message normalization failed, refusing to return it\", e));\n+              }\n+            })\n         .thenApply(this::maybeAddToCache)\n         .thenApply(answer -> buildResult(answer, aliases, queryRecord));\n   }\n\n@@ -494,34 +568,38 @@\nprivate Message maybeAddToCache(Message message) {\n     return message;\n   }\n \n+  @SuppressWarnings(\"deprecated\")\n   private CompletionStage<LookupResult> setResponseToMessageFuture(\n       SetResponse setResponse, Record queryRecord, List<Name> aliases) {\n     if (setResponse.isNXDOMAIN()) {\n       return completeExceptionally(\n           new NoSuchDomainException(queryRecord.getName(), queryRecord.getType()));\n     }\n+\n     if (setResponse.isNXRRSET()) {\n       return completeExceptionally(\n           new NoSuchRRSetException(queryRecord.getName(), queryRecord.getType()));\n     }\n+\n     if (setResponse.isSuccessful()) {\n       List<Record> records =\n           setResponse.answers().stream()\n               .flatMap(rrset -> rrset.rrs(cycleResults).stream())\n               .collect(Collectors.toList());\n       return CompletableFuture.completedFuture(new LookupResult(records, aliases));\n     }\n+\n     return null;\n   }\n \n-  private <T extends Throwable> CompletionStage<LookupResult> completeExceptionally(T failure) {\n-    CompletableFuture<LookupResult> future = new CompletableFuture<>();\n+  private <T extends Throwable, R> CompletionStage<R> completeExceptionally(T failure) {\n+    CompletableFuture<R> future = new CompletableFuture<>();\n     future.completeExceptionally(failure);\n     return future;\n   }\n \n   private CompletionStage<LookupResult> resolveRedirects(LookupResult response, Record query) {\n-    return maybeFollowRedirect(response, query, 1);\n+    return maybeFollowRedirect(response, query, 0);\n   }\n \n   private CompletionStage<LookupResult> maybeFollowRedirect(\n\n@@ -540,13 +618,20 @@\nprivate CompletionStage<LookupResult> maybeFollowRedirect(\n     }\n   }\n \n+  @SuppressWarnings(\"deprecated\")\n   private CompletionStage<LookupResult> maybeFollowRedirectsInAnswer(\n       LookupResult response, Record query, int redirectCount) {\n     List<Name> aliases = new ArrayList<>(response.getAliases());\n     List<Record> results = new ArrayList<>();\n     Name current = query.getName();\n     for (Record r : response.getRecords()) {\n-      if (redirectCount > maxRedirects) {\n+      // Abort with a dedicated exception for loops instead of simply trying until reaching the max\n+      // redirects\n+      if (aliases.contains(current)) {\n+        return completeExceptionally(new RedirectLoopException(maxRedirects));\n+      }\n+\n+      if (redirectCount >= maxRedirects) {\n         throw new RedirectOverflowException(maxRedirects);\n       }\n\n@@ -576,11 +661,17 @@\nprivate CompletionStage<LookupResult> maybeFollowRedirectsInAnswer(\n       return CompletableFuture.completedFuture(new LookupResult(results, aliases));\n     }\n \n-    if (redirectCount > maxRedirects) {\n+    // Abort with a dedicated exception for loops instead of simply trying until reaching the max\n+    // redirects\n+    if (aliases.contains(current)) {\n+      return completeExceptionally(new RedirectLoopException(maxRedirects));\n+    }\n+\n+    if (redirectCount >= maxRedirects) {\n       throw new RedirectOverflowException(maxRedirects);\n     }\n \n-    int finalRedirectCount = redirectCount + 1;\n+    int finalRedirectCount = redirectCount;\n     Record redirectQuery = Record.newRecord(current, query.getType(), query.getDClass());\n     return lookupWithCache(redirectQuery, aliases)\n         .thenCompose(\n```\n\nFilename: src/main/java/org/xbill/DNS/lookup/NoSuchDomainException.java:\n```\n@@ -14,9 +14,6 @@\npublic NoSuchDomainException(Name name, int type) {\n     this(name, type, false);\n   }\n \n-  /**\n-   * @since 3.6\n-   */\n   NoSuchDomainException(Name name, int type, boolean isAuthenticated) {\n     super(null, null, name, type, isAuthenticated);\n   }\n```\n\nFilename: src/main/java/org/xbill/DNS/lookup/NoSuchRRSetException.java:\n```\n@@ -14,9 +14,6 @@\npublic NoSuchRRSetException(Name name, int type) {\n     this(name, type, false);\n   }\n \n-  /**\n-   * @since 3.6\n-   */\n   NoSuchRRSetException(Name name, int type, boolean isAuthenticated) {\n     super(null, null, name, type, isAuthenticated);\n   }\n```\n\nFilename: src/main/java/org/xbill/DNS/lookup/RedirectOverflowException.java:\n```\n@@ -24,9 +24,9 @@\npublic RedirectOverflowException(String message) {\n   }\n \n   /**\n-   * @since 3.4.2\n    * @param maxRedirects Informational, indicates the after how many redirects following was\n    *     aborted.\n+   * @since 3.4.2\n    */\n   public RedirectOverflowException(int maxRedirects) {\n     super(\"Refusing to follow more than \" + maxRedirects + \" redirects\");\n```\n\nFilename: src/test/java/org/xbill/DNS/LookupTest.java:\n```\n@@ -445,8 +445,28 @@\npublic static Message answer(Message query, Function<Name, Record> recordMaker)\n       if (DUMMY_NAME.equals(response.getName())) {\n         response = response.withName(query.getQuestion().getName());\n       }\n+      response.setTTL(120);\n       answer.addRecord(response, Section.ANSWER);\n     }\n     return answer;\n   }\n+\n+  public static Message multiAnswer(Message query, Function<Name, Record[]> recordMaker) {\n+    Message answer = new Message(query.getHeader().getID());\n+    answer.addRecord(query.getQuestion(), Section.QUESTION);\n+    Name questionName = query.getQuestion().getName();\n+    Record[] response = recordMaker.apply(questionName);\n+    if (response == null) {\n+      answer.getHeader().setRcode(Rcode.NXDOMAIN);\n+    } else {\n+      for (Record r : response) {\n+        if (DUMMY_NAME.equals(r.getName())) {\n+          r = r.withName(query.getQuestion().getName());\n+        }\n+        r.setTTL(120);\n+        answer.addRecord(r, Section.ANSWER);\n+      }\n+    }\n+    return answer;\n+  }\n }\n```\n\nFilename: src/test/java/org/xbill/DNS/MessageTest.java:\n```\n@@ -53,9 +53,9 @@\nvoid ctor_0arg() {\n     Message m = new Message();\n     assertTrue(m.getSection(0).isEmpty());\n     assertTrue(m.getSection(1).isEmpty());\n-    assertTrue(m.getSection(3).isEmpty());\n     assertTrue(m.getSection(2).isEmpty());\n-    assertThrows(IndexOutOfBoundsException.class, () -> m.getSection(4));\n+    assertTrue(m.getSection(3).isEmpty());\n+    assertThrows(IllegalArgumentException.class, () -> m.getSection(4));\n     Header h = m.getHeader();\n     assertEquals(0, h.getCount(0));\n     assertEquals(0, h.getCount(1));\n\n@@ -71,7 +71,7 @@\nvoid ctor_1arg() {\n     assertTrue(m.getSection(1).isEmpty());\n     assertTrue(m.getSection(2).isEmpty());\n     assertTrue(m.getSection(3).isEmpty());\n-    assertThrows(IndexOutOfBoundsException.class, () -> m.getSection(4));\n+    assertThrows(IllegalArgumentException.class, () -> m.getSection(4));\n     Header h = m.getHeader();\n     assertEquals(0, h.getCount(0));\n     assertEquals(0, h.getCount(1));\n\n@@ -167,4 +167,17 @@\nvoid testResponseClone() throws UnknownHostException {\n     assertEquals(clone.getQuestion(), response.getQuestion());\n     assertEquals(clone.getSection(Section.ANSWER), response.getSection(Section.ANSWER));\n   }\n+\n+  @Test\n+  void normalize() throws WireParseException {\n+    Record queryRecord =\n+        Record.newRecord(Name.fromConstantString(\"example.com.\"), Type.MX, DClass.IN);\n+    Message query = Message.newQuery(queryRecord);\n+    Message response = new Message();\n+    response.addRecord(queryRecord, Section.QUESTION);\n+    response.addRecord(queryRecord, Section.ADDITIONAL);\n+    response = response.normalize(query, true);\n+    assertTrue(response.getSection(Section.ANSWER).isEmpty());\n+    assertTrue(response.getSection(Section.ADDITIONAL).isEmpty());\n+  }\n }\n```\n\nFilename: src/test/java/org/xbill/DNS/SetResponseTest.java:\n```\n@@ -46,7 +46,9 @@\nimport java.net.UnknownHostException;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n \n class SetResponseTest {\n   private static final ARecord A_RECORD_1 =\n\n@@ -129,6 +131,47 @@\nvoid addRRset() {\n     assertArrayEquals(exp, sr.answers().toArray());\n   }\n \n+  @ParameterizedTest\n+  @ValueSource(booleans = {false, true})\n+  void ofTypeWithCachedRRset(boolean isAuthenticated) {\n+    SetResponse sr =\n+        SetResponse.ofType(\n+            SetResponseType.SUCCESSFUL,\n+            new Cache.CacheRRset(new RRset(A_RECORD_1), 0, 0, isAuthenticated));\n+    assertEquals(isAuthenticated, sr.isAuthenticated());\n+  }\n+\n+  @ParameterizedTest\n+  @CsvSource({\n+    \"false,true,true,true,true\",\n+    \"false,false,true,false,false\",\n+    \"true,true,false,true,false\",\n+    \"true,false,false,false,false\",\n+  })\n+  void addRRsetAuthenticated(\n+      boolean addInitial,\n+      boolean first,\n+      boolean second,\n+      boolean firstResult,\n+      boolean secondResult) {\n+    RRset rrs = new RRset(A_RECORD_1);\n+    SetResponse sr;\n+    if (addInitial) {\n+      sr = SetResponse.ofType(SetResponseType.SUCCESSFUL, rrs, first);\n+    } else {\n+      sr = SetResponse.ofType(SetResponseType.SUCCESSFUL);\n+      sr.addRRset(new Cache.CacheRRset(rrs, 0, 0, first));\n+    }\n+\n+    RRset[] exp = new RRset[] {rrs};\n+    assertArrayEquals(exp, sr.answers().toArray());\n+    assertEquals(firstResult, sr.isAuthenticated());\n+\n+    sr.addRRset(new Cache.CacheRRset(new RRset(A_RECORD_1), 0, 0, second));\n+    assertEquals(secondResult, sr.isAuthenticated());\n+    assertEquals(2, sr.answers().size());\n+  }\n+\n   @Test\n   void addRRset_multiple() throws TextParseException, UnknownHostException {\n     RRset rrs = new RRset();\n```\n\nFilename: src/test/java/org/xbill/DNS/dnssec/Rpl.java:\n```\n@@ -17,6 +17,7 @@\nclass Rpl {\n   TreeMap<Integer, Integer> nsec3iterations;\n   String digestPreference;\n   boolean hardenAlgoDowngrade;\n+  boolean hardenUnknownAdditional = true;\n   boolean enableSha1;\n   boolean enableDsa;\n   boolean loadBouncyCastle;\n```\n\nFilename: src/test/java/org/xbill/DNS/dnssec/RplParser.java:\n```\n@@ -73,7 +73,7 @@\nRpl parse() throws ParseException, IOException {\n           if (line.startsWith(\"server:\")) {\n             state = ParseState.Server;\n           } else if (line.startsWith(\"SCENARIO_BEGIN\")) {\n-            rpl.scenario = line.substring(line.indexOf(\" \"));\n+            rpl.scenario = line.substring(line.indexOf(\" \")).trim();\n             rpl.replays = new LinkedList<>();\n             rpl.checks = new TreeMap<>();\n           } else if (line.startsWith(\"ENTRY_BEGIN\")) {\n\n@@ -128,6 +128,8 @@\nRpl parse() throws ParseException, IOException {\n             rpl.enableSha1 = \"yes\".equalsIgnoreCase(line.split(\":\")[1].trim());\n           } else if (line.matches(\"\\\\s*fake-dsa:.*\")) {\n             rpl.enableDsa = \"yes\".equalsIgnoreCase(line.split(\":\")[1].trim());\n+          } else if (line.matches(\"\\\\s*harden-unknown-additional:.*\")) {\n+            rpl.hardenUnknownAdditional = \"yes\".equalsIgnoreCase(line.split(\":\")[1].trim());\n           } else if (line.matches(\"\\\\s*bouncycastle:.*\")) {\n             rpl.loadBouncyCastle = \"yes\".equalsIgnoreCase(line.split(\":\")[1].trim());\n           } else if (line.startsWith(\"CONFIG_END\")) {\n```\n\nFilename: src/test/java/org/xbill/DNS/dnssec/TestBase.java:\n```\n@@ -28,12 +28,11 @@\nimport java.util.concurrent.CompletionStage;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.Executor;\n+import lombok.extern.slf4j.Slf4j;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.TestInfo;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.xbill.DNS.ARecord;\n import org.xbill.DNS.DClass;\n import org.xbill.DNS.DNSSEC.DNSSECException;\n\n@@ -49,9 +48,8 @@\nimport org.xbill.DNS.TXTRecord;\n import org.xbill.DNS.Type;\n \n+@Slf4j\n public abstract class TestBase {\n-  private static final Logger logger = LoggerFactory.getLogger(TestBase.class);\n-\n   private static final boolean offline = !Boolean.getBoolean(\"dnsjava.dnssec.online\");\n   private static final boolean partialOffline =\n       \"partial\".equals(System.getProperty(\"dnsjava.dnssec.offline\"));\n\n@@ -126,6 +124,7 @@\nprivate void starting(TestInfo description) {\n \n           Message m;\n           while ((m = messageReader.readMessage(r)) != null) {\n+            m = m.normalize(Message.newQuery(m.getQuestion()), true);\n             queryResponsePairs.put(key(m), m);\n           }\n\n@@ -163,9 +162,13 @@\nprivate void setup() throws NumberFormatException, IOException, DNSSECException\n             new SimpleResolver(\"8.8.4.4\") {\n               @Override\n               public CompletionStage<Message> sendAsync(Message query, Executor executor) {\n-                logger.info(\"---{}\", key(query));\n                 Message response = queryResponsePairs.get(key(query));\n                 if (response != null) {\n+                  if (!log.isTraceEnabled()) {\n+                    log.debug(\"---{}\", key(query));\n+                  }\n+\n+                  log.trace(\"---{}\\n{}\", key(query), response);\n                   return CompletableFuture.completedFuture(response);\n                 } else if ((offline && !partialOffline) || unboundTest || alwaysOffline) {\n                   fail(\"Response for \" + key(query) + \" not found.\");\n```\n\nFilename: src/test/java/org/xbill/DNS/dnssec/UnboundTests.java:\n```\n@@ -5,6 +5,7 @@\nimport static org.mockito.Mockito.when;\n \n import java.io.File;\n+import java.io.FileInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.security.Security;\n\n@@ -15,10 +16,13 @@\nimport java.util.Map;\n import java.util.Map.Entry;\n import java.util.Properties;\n+import lombok.extern.slf4j.Slf4j;\n import org.bouncycastle.jce.provider.BouncyCastleProvider;\n import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n import org.junit.jupiter.api.Test;\n import org.xbill.DNS.CNAMERecord;\n+import org.xbill.DNS.DClass;\n import org.xbill.DNS.DNAMERecord;\n import org.xbill.DNS.DNSSEC;\n import org.xbill.DNS.Flags;\n\n@@ -31,133 +35,150 @@\nimport org.xbill.DNS.Section;\n import org.xbill.DNS.Type;\n \n+@Slf4j\n class UnboundTests extends TestBase {\n   void runUnboundTest() throws ParseException, IOException {\n-    InputStream data = getClass().getResourceAsStream(\"/unbound/\" + testName + \".rpl\");\n-    RplParser p = new RplParser(data);\n-    Rpl rpl = p.parse();\n-    Properties config = new Properties();\n-    if (rpl.nsec3iterations != null) {\n-      for (Entry<Integer, Integer> e : rpl.nsec3iterations.entrySet()) {\n-        config.put(\"dnsjava.dnssec.nsec3.iterations.\" + e.getKey(), e.getValue());\n+    try {\n+      InputStream data = getClass().getResourceAsStream(\"/unbound/\" + testName + \".rpl\");\n+      RplParser p = new RplParser(data);\n+      Rpl rpl = p.parse();\n+      Properties config = new Properties();\n+      if (rpl.nsec3iterations != null) {\n+        for (Entry<Integer, Integer> e : rpl.nsec3iterations.entrySet()) {\n+          config.put(\"dnsjava.dnssec.nsec3.iterations.\" + e.getKey(), e.getValue());\n+        }\n       }\n-    }\n \n-    if (rpl.digestPreference != null) {\n-      config.put(ValUtils.DIGEST_PREFERENCE, rpl.digestPreference);\n-    }\n+      if (rpl.digestPreference != null) {\n+        config.put(ValUtils.DIGEST_PREFERENCE, rpl.digestPreference);\n+      }\n \n-    config.put(ValUtils.DIGEST_HARDEN_DOWNGRADE, Boolean.toString(rpl.hardenAlgoDowngrade));\n+      config.put(ValUtils.DIGEST_HARDEN_DOWNGRADE, Boolean.toString(rpl.hardenAlgoDowngrade));\n \n-    if (rpl.enableSha1) {\n-      config.put(ValUtils.DIGEST_ENABLED + \".\" + DNSSEC.Digest.SHA1, Boolean.TRUE.toString());\n-    }\n+      if (rpl.enableSha1) {\n+        config.put(ValUtils.DIGEST_ENABLED + \".\" + DNSSEC.Digest.SHA1, Boolean.TRUE.toString());\n+      }\n \n-    if (rpl.enableDsa || rpl.enableSha1) {\n-      config.put(ValUtils.ALGORITHM_ENABLED + \".\" + DNSSEC.Algorithm.DSA, Boolean.TRUE.toString());\n-      config.put(\n-          ValUtils.ALGORITHM_ENABLED + \".\" + DNSSEC.Algorithm.DSA_NSEC3_SHA1,\n-          Boolean.TRUE.toString());\n-    }\n+      if (rpl.enableDsa || rpl.enableSha1) {\n+        config.put(\n+            ValUtils.ALGORITHM_ENABLED + \".\" + DNSSEC.Algorithm.DSA, Boolean.TRUE.toString());\n+        config.put(\n+            ValUtils.ALGORITHM_ENABLED + \".\" + DNSSEC.Algorithm.DSA_NSEC3_SHA1,\n+            Boolean.TRUE.toString());\n+      }\n \n-    if (rpl.loadBouncyCastle) {\n-      Security.addProvider(new BouncyCastleProvider());\n-    }\n+      if (!rpl.hardenUnknownAdditional) {\n+        System.setProperty(\"dnsjava.harden_unknown_additional\", Boolean.TRUE.toString());\n+      }\n \n-    for (Message m : rpl.replays) {\n-      add(m);\n-    }\n+      if (rpl.loadBouncyCastle) {\n+        Security.addProvider(new BouncyCastleProvider());\n+      }\n \n-    // merge xNAME queries into one\n-    List<Message> copy = new ArrayList<>(rpl.replays.size());\n-    copy.addAll(rpl.replays);\n-    List<Name> copiedTargets = new ArrayList<>(5);\n-    for (Message m : copy) {\n-      Name target = null;\n-      for (RRset s : m.getSectionRRsets(Section.ANSWER)) {\n-        if (s.getType() == Type.CNAME) {\n-          target = ((CNAMERecord) s.first()).getTarget();\n-        } else if (s.getType() == Type.DNAME) {\n-          target = ((DNAMERecord) s.first()).getTarget();\n-        }\n+      for (Message m : rpl.replays) {\n+        add(m);\n+      }\n \n-        while (target != null) {\n-          Message a = get(target, m.getQuestion().getType());\n-          if (a == null) {\n-            a = get(target, Type.CNAME);\n+      // merge xNAME queries into one\n+      List<Message> copy = new ArrayList<>(rpl.replays.size());\n+      copy.addAll(rpl.replays);\n+      List<Name> copiedTargets = new ArrayList<>(5);\n+      for (Message m : copy) {\n+        Name target = null;\n+        for (RRset s : m.getSectionRRsets(Section.ANSWER)) {\n+          if (s.getType() == Type.CNAME) {\n+            target = ((CNAMERecord) s.first()).getTarget();\n+          } else if (s.getType() == Type.DNAME) {\n+            target = ((DNAMERecord) s.first()).getTarget();\n           }\n \n-          if (a == null) {\n-            a = get(target, Type.DNAME);\n-          }\n+          while (target != null) {\n+            Message a = get(target, m.getQuestion().getType());\n+            if (a == null) {\n+              a = get(target, Type.CNAME);\n+            }\n \n-          if (a != null) {\n-            target = add(m, a);\n-            if (copiedTargets.contains(target)) {\n-              break;\n+            if (a == null) {\n+              a = get(target, Type.DNAME);\n             }\n \n-            copiedTargets.add(target);\n-            rpl.replays.remove(a);\n-          } else {\n-            target = null;\n+            if (a != null) {\n+              target = add(m, a);\n+              if (copiedTargets.contains(target)) {\n+                break;\n+              }\n+\n+              copiedTargets.add(target);\n+              rpl.replays.remove(a);\n+            } else {\n+              target = null;\n+            }\n           }\n         }\n       }\n-    }\n \n-    // promote any DS records in auth. sections to real queries\n-    copy = new ArrayList<>(rpl.replays.size());\n-    copy.addAll(rpl.replays);\n-    for (Message m : copy) {\n-      for (RRset s : m.getSectionRRsets(Section.AUTHORITY)) {\n-        if (s.getType() == Type.DS) {\n-          Message ds = new Message();\n-          ds.addRecord(Record.newRecord(s.getName(), s.getType(), s.getDClass()), Section.QUESTION);\n-          for (Record rr : s.rrs()) {\n-            ds.addRecord(rr, Section.ANSWER);\n-          }\n+      // promote any DS records in auth. sections to real queries\n+      copy = new ArrayList<>(rpl.replays.size());\n+      copy.addAll(rpl.replays);\n+      for (Message m : copy) {\n+        for (RRset s : m.getSectionRRsets(Section.AUTHORITY)) {\n+          if (s.getType() == Type.DS) {\n+            Message ds = new Message();\n+            ds.addRecord(\n+                Record.newRecord(s.getName(), s.getType(), s.getDClass()), Section.QUESTION);\n+            for (Record rr : s.rrs()) {\n+              ds.addRecord(rr, Section.ANSWER);\n+            }\n \n-          for (RRSIGRecord sig : s.sigs()) {\n-            ds.addRecord(sig, Section.ANSWER);\n-          }\n+            for (RRSIGRecord sig : s.sigs()) {\n+              ds.addRecord(sig, Section.ANSWER);\n+            }\n \n-          rpl.replays.add(ds);\n+            rpl.replays.add(ds);\n+          }\n         }\n       }\n-    }\n-\n-    clear();\n-    for (Message m : rpl.replays) {\n-      add(m);\n-    }\n \n-    if (rpl.date != null) {\n-      try {\n-        when(resolverClock.instant()).thenReturn(rpl.date);\n-      } catch (Exception e) {\n-        throw new RuntimeException(e);\n+      clear();\n+      for (Message m : rpl.replays) {\n+        add(m);\n       }\n-    }\n \n-    if (rpl.trustAnchors != null) {\n-      resolver.getTrustAnchors().clear();\n-      for (SRRset rrset : rpl.trustAnchors) {\n-        resolver.getTrustAnchors().store(rrset);\n+      if (rpl.date != null) {\n+        try {\n+          when(resolverClock.instant()).thenReturn(rpl.date);\n+        } catch (Exception e) {\n+          throw new RuntimeException(e);\n+        }\n       }\n-    }\n \n-    resolver.init(config);\n+      if (rpl.trustAnchors != null) {\n+        resolver.getTrustAnchors().clear();\n+        for (SRRset rrset : rpl.trustAnchors) {\n+          resolver.getTrustAnchors().store(rrset);\n+        }\n+      }\n \n-    for (Check c : rpl.checks.values()) {\n-      Message s = resolver.send(c.query);\n+      resolver.init(config);\n+\n+      for (Check c : rpl.checks.values()) {\n+        Message s = resolver.send(c.query).normalize(c.query, true);\n+        log.trace(\n+            \"{}/{}/{} ---> \\n{}\",\n+            c.query.getQuestion().getName(),\n+            Type.string(c.query.getQuestion().getType()),\n+            DClass.string(c.query.getQuestion().getDClass()),\n+            s);\n+        assertEquals(\n+            c.response.getHeader().getFlag(Flags.AD),\n+            s.getHeader().getFlag(Flags.AD),\n+            \"AD Flag must match\");\n+        assertEquals(\n+            Rcode.string(c.response.getRcode()), Rcode.string(s.getRcode()), \"RCode must match\");\n+      }\n+    } finally {\n       Security.removeProvider(BouncyCastleProvider.PROVIDER_NAME);\n-      assertEquals(\n-          c.response.getHeader().getFlag(Flags.AD),\n-          s.getHeader().getFlag(Flags.AD),\n-          \"AD Flag must match\");\n-      assertEquals(\n-          Rcode.string(c.response.getRcode()), Rcode.string(s.getRcode()), \"RCode must match\");\n+      System.clearProperty(\"dnsjava.harden_unknown_additional\");\n     }\n   }\n\n@@ -182,7 +203,7 @@\nprivate Name add(Message target, Message source) {\n     return next;\n   }\n \n-  static void xmain(String[] xargs) {\n+  static void main(String[] xargs) throws IOException, ParseException {\n     Map<String, String> ignored =\n         new HashMap<String, String>() {\n           {\n\n@@ -207,8 +228,12 @@\nstatic void xmain(String[] xargs) {\n             put(\"val_cnametoinsecure.rpl\", \"incomplete CNAME answer\");\n             put(\"val_nsec3_optout_cache.rpl\", \"more cache stuff\");\n             put(\"val_unsecds_qtypeds.rpl\", \"tests the iterative resolver\");\n-            put(\"val_anchor_nx.rpl\", \"tests caching of NX from a parent resolver\");\n-            put(\"val_anchor_nx_nosig.rpl\", \"tests caching of NX from a parent resolver\");\n+            put(\n+                \"val_anchor_nx.rpl\",\n+                \"tests resolving conflicting responses in a recursive resolver\");\n+            put(\n+                \"val_anchor_nx_nosig.rpl\",\n+                \"tests resolving conflicting responses in a recursive resolver\");\n             put(\"val_negcache_nta.rpl\", \"tests unbound option domain-insecure, not available here\");\n           }\n         };\n\n@@ -219,7 +244,9 @@\nstatic void xmain(String[] xargs) {\n         System.out.println(\"    @Disabled(\\\"\" + comment + \"\\\")\");\n       }\n \n+      Rpl rpl = new RplParser(new FileInputStream(\"./src/test/resources/unbound/\" + f)).parse();\n       System.out.println(\"    @Test\");\n+      System.out.println(\"    @DisplayName(\\\"\" + f + \": \" + rpl.scenario + \"\\\")\");\n       System.out.println(\n           \"    void \" + f.split(\"\\\\.\")[0] + \"() throws ParseException, IOException {\");\n       System.out.println(\"        runUnboundTest();\");\n\n@@ -229,798 +256,1010 @@\nstatic void xmain(String[] xargs) {\n   }\n \n   @Test\n+  @DisplayName(\"val_adbit.rpl: Test validator AD bit signaling\")\n   void val_adbit() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_adcopy.rpl: Test validator AD bit sent by untrusted upstream\")\n   void val_adcopy() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n-  @Disabled(\"tests caching of NX from a parent resolver\")\n+  @Disabled(\"tests resolving conflicting responses in a recursive resolver\")\n   @Test\n+  @DisplayName(\"val_anchor_nx.rpl: Test validator with secure proof of trust anchor nxdomain\")\n   void val_anchor_nx() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n-  @Disabled(\"tests caching of NX from a parent resolver\")\n+  @Disabled(\"tests resolving conflicting responses in a recursive resolver\")\n   @Test\n+  @DisplayName(\"val_anchor_nx_nosig.rpl: Test validator with unsigned denial of trust anchor\")\n   void val_anchor_nx_nosig() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_ans_dsent.rpl: Test validator with empty nonterminals on the trust chain.\")\n   void val_ans_dsent() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_ans_nx.rpl: Test validator with DS nodata as nxdomain on trust chain\")\n   void val_ans_nx() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_any.rpl: Test validator with response to qtype ANY\")\n   void val_any() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_any_cname.rpl: Test validator with response to qtype ANY that includes CNAME\")\n   void val_any_cname() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_any_dname.rpl: Test validator with response to qtype ANY that includes DNAME\")\n   void val_any_dname() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_cnameinsectopos.rpl: Test validator with an insecure cname to positive cached\")\n   void val_cnameinsectopos() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_cnamenx_dblnsec.rpl: Test validator with cname-nxdomain for duplicate NSEC detection\")\n   void val_cnamenx_dblnsec() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_cnamenx_rcodenx.rpl: Test validator with cname-nxdomain with rcode nxdomain\")\n   void val_cnamenx_rcodenx() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_cnameqtype.rpl: Test validator with a query for type cname\")\n   void val_cnameqtype() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_cnametocloser.rpl: Test validator with CNAME to closer anchor under optout.\")\n   void val_cnametocloser() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_cnametocloser_nosig.rpl: Test validator with CNAME to closer anchor optout missing sigs.\")\n   void val_cnametocloser_nosig() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_cnametocnamewctoposwc.rpl: Test validator with a regular cname to wildcard cname to wildcard response\")\n   void val_cnametocnamewctoposwc() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_cnametodname.rpl: Test validator with a cname to a dname\")\n   void val_cnametodname() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_cnametodnametocnametopos.rpl: Test validator with cname, dname, cname, positive answer\")\n   void val_cnametodnametocnametopos() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Disabled(\"incomplete CNAME answer\")\n   @Test\n+  @DisplayName(\"val_cnametoinsecure.rpl: Test validator with CNAME to insecure NSEC or NSEC3.\")\n   void val_cnametoinsecure() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_cnametonodata.rpl: Test validator with cname to nodata\")\n   void val_cnametonodata() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_cnametonodata_nonsec.rpl: Test validator with cname to nodata\")\n   void val_cnametonodata_nonsec() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Disabled(\"incomplete CNAME answer\")\n   @Test\n+  @DisplayName(\"val_cnametonsec.rpl: Test validator with CNAME to insecure NSEC delegation\")\n   void val_cnametonsec() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_cnametonx.rpl: Test validator with cname to nxdomain\")\n   void val_cnametonx() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Disabled(\"incomplete CNAME answer\")\n   @Test\n+  @DisplayName(\"val_cnametooptin.rpl: Test validator with CNAME to insecure optin NSEC3\")\n   void val_cnametooptin() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_cnametooptout.rpl: Test validator with CNAME to optout NSEC3 span NODATA\")\n   void val_cnametooptout() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_cnametopos.rpl: Test validator with a cname to positive\")\n   void val_cnametopos() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_cnametoposnowc.rpl: Test validator with a cname to positive wildcard without proof\")\n   void val_cnametoposnowc() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_cnametoposwc.rpl: Test validator with a cname to positive wildcard\")\n   void val_cnametoposwc() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_cnamewctonodata.rpl: Test validator with wildcard cname to nodata\")\n   void val_cnamewctonodata() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_cnamewctonx.rpl: Test validator with wildcard cname to nxdomain\")\n   void val_cnamewctonx() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_cnamewctoposwc.rpl: Test validator with wildcard cname to positive wildcard\")\n   void val_cnamewctoposwc() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_cname_loop1.rpl: Test validator with cname loop\")\n   void val_cname_loop1() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_cname_loop2.rpl: Test validator with cname 2 step loop\")\n   void val_cname_loop2() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_cname_loop3.rpl: Test validator with cname 3 step loop\")\n   void val_cname_loop3() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_deleg_nons.rpl: Test validator with unsigned delegation with no NS bit in NSEC\")\n+  void val_deleg_nons() throws ParseException, IOException {\n+    runUnboundTest();\n+  }\n+\n+  @Test\n+  @DisplayName(\"val_dnametoolong.rpl: Test validator with a dname too long response\")\n   void val_dnametoolong() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_dnametopos.rpl: Test validator with a dname to positive\")\n   void val_dnametopos() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_dnametoposwc.rpl: Test validator with a dname to positive wildcard\")\n   void val_dnametoposwc() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_dnamewc.rpl: Test validator with a wildcarded dname\")\n   void val_dnamewc() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Disabled(\"we don't do negative caching\")\n   @Test\n+  @DisplayName(\"val_dsnsec.rpl: Test pickup of DS NSEC from the cache.\")\n   void val_dsnsec() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_ds_afterprime.rpl: Test DS lookup after key prime is done.\")\n   void val_ds_afterprime() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_ds_cname.rpl: Test validator with CNAME response to DS\")\n   void val_ds_cname() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_ds_cnamesub.rpl: Test validator with CNAME response to DS in chain of trust\")\n   void val_ds_cnamesub() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_ds_cnamesubbogus.rpl: Test validator with bogus CNAME response to DS in chain of trust\")\n   void val_ds_cnamesubbogus() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_ds_gost.rpl: Test validator with GOST DS digest\")\n   void val_ds_gost() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_ds_gost_downgrade.rpl: Test validator with GOST DS digest downgrade attack\")\n   void val_ds_gost_downgrade() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_ds_sha2.rpl: Test validator with SHA256 DS digest\")\n   void val_ds_sha2() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_ds_sha2_downgrade.rpl: Test validator with SHA256 DS downgrade to SHA1\")\n   void val_ds_sha2_downgrade() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_ds_sha2_downgrade_override.rpl: Test validator with SHA256 DS downgrade to SHA1\")\n   void val_ds_sha2_downgrade_override() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_ds_sha2_lenient.rpl: Test validator with SHA256 DS downgrade to SHA1 lenience\")\n   void val_ds_sha2_lenient() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_entds.rpl: Test validator with lots of ENTs in the chain of trust\")\n   void val_entds() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_faildnskey.rpl: Test validator with failed DNSKEY request\")\n   void val_faildnskey() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Disabled(\"tests an unbound specific config option\")\n   @Test\n+  @DisplayName(\n+      \"val_faildnskey_ok.rpl: Test validator with failed DNSKEY request, but not hardened.\")\n   void val_faildnskey_ok() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Disabled(\"irrelevant, we're not a recursive resolver\")\n   @Test\n+  @DisplayName(\"val_fwdds.rpl: Test forward-zone with DS query\")\n   void val_fwdds() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_keyprefetch.rpl: Test validator with key prefetch\")\n   void val_keyprefetch() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_keyprefetch_verify.rpl: Test validator with key prefetch and verify with the anchor\")\n   void val_keyprefetch_verify() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_mal_wc.rpl: Test validator with nodata, wildcards and ENT\")\n   void val_mal_wc() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_negcache_ds.rpl: Test validator with negative cache DS response\")\n   void val_negcache_ds() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Disabled(\"we don't do negative caching\")\n   @Test\n+  @DisplayName(\n+      \"val_negcache_dssoa.rpl: Test validator with negative cache DS response with cached SOA\")\n   void val_negcache_dssoa() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Disabled(\"aggressive NSEC is not supported\")\n   @Test\n+  @DisplayName(\n+      \"val_negcache_nodata.rpl: Test validator with negative cache NXDOMAIN response (aggressive NSEC)\")\n   void val_negcache_nodata() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Disabled(\"tests unbound option domain-insecure, not available here\")\n   @Test\n+  @DisplayName(\"val_negcache_nta.rpl: Test to not do aggressive NSEC for domains under NTA\")\n   void val_negcache_nta() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Disabled(\"aggressive NSEC is not supported\")\n   @Test\n+  @DisplayName(\n+      \"val_negcache_nxdomain.rpl: Test validator with negative cache NXDOMAIN response (aggressive NSEC)\")\n   void val_negcache_nxdomain() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Disabled(\"irrelevant - if we wouldn't want AD, we wouldn't be using this stuff\")\n   @Test\n+  @DisplayName(\"val_noadwhennodo.rpl: Test if AD bit is returned on non-DO query.\")\n   void val_noadwhennodo() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nodata.rpl: Test validator with nodata response\")\n   void val_nodata() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nodatawc.rpl: Test validator with wildcard nodata response\")\n   void val_nodatawc() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nodatawc_badce.rpl: Test validator with wildcard nodata, bad closest encloser\")\n   void val_nodatawc_badce() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nodatawc_nodeny.rpl: Test validator with wildcard nodata response without qdenial\")\n   void val_nodatawc_nodeny() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nodatawc_one.rpl: Test validator with wildcard nodata response with one NSEC\")\n   void val_nodatawc_one() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nodatawc_wcns.rpl: Test validator with wildcard nodata response from parent zone with SOA\")\n   void val_nodatawc_wcns() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nodatawc_wrongdeleg.rpl: Test validator with wildcard nodata response from parent zone\")\n   void val_nodatawc_wrongdeleg() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nodata_ent.rpl: Test validator with nodata on empty nonterminal response\")\n   void val_nodata_ent() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nodata_entnx.rpl: Test validator with nodata on empty nonterminal response with rcode NXDOMAIN\")\n   void val_nodata_entnx() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nodata_entwc.rpl: Test validator with wildcard nodata on empty nonterminal response\")\n   void val_nodata_entwc() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nodata_failsig.rpl: Test validator with nodata response with bogus RRSIG\")\n   void val_nodata_failsig() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nodata_failwc.rpl: Test validator with nodata response with wildcard expanded NSEC record, original NSEC owner does not provide proof for QNAME. CVE-2017-15105 test.\")\n   void val_nodata_failwc() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nodata_hasdata.rpl: Test validator with nodata response, that proves the data.\")\n   void val_nodata_hasdata() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nodata_zonecut.rpl: Test validator with nodata response from wrong side of zonecut\")\n   void val_nodata_zonecut() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nokeyprime.rpl: Test validator with failed key prime, no keys.\")\n   void val_nokeyprime() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nsec3_b1_nameerror.rpl: Test validator NSEC3 B.1 name error.\")\n   void val_nsec3_b1_nameerror() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nsec3_b1_nameerror_noce.rpl: Test validator NSEC3 B.1 name error without ce NSEC3.\")\n   void val_nsec3_b1_nameerror_noce() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nsec3_b1_nameerror_nonc.rpl: Test validator NSEC3 B.1 name error without nc NSEC3.\")\n   void val_nsec3_b1_nameerror_nonc() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nsec3_b1_nameerror_nowc.rpl: Test validator NSEC3 B.1 name error without wc NSEC3.\")\n   void val_nsec3_b1_nameerror_nowc() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nsec3_b21_nodataent.rpl: Test validator NSEC3 B.2.1 no data empty nonterminal.\")\n   void val_nsec3_b21_nodataent() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nsec3_b21_nodataent_wr.rpl: Test validator NSEC3 B.2.1 no data empty nonterminal, wrong rr.\")\n   void val_nsec3_b21_nodataent_wr() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nsec3_b2_nodata.rpl: Test validator NSEC3 B.2 no data.\")\n   void val_nsec3_b2_nodata() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nsec3_b2_nodata_nons.rpl: Test validator NSEC3 B.2 no data, without NSEC3.\")\n   void val_nsec3_b2_nodata_nons() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nsec3_b3_optout.rpl: Test validator NSEC3 B.3 referral to optout unsigned zone.\")\n   void val_nsec3_b3_optout() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Disabled(\"we don't do negative caching\")\n   @Test\n+  @DisplayName(\n+      \"val_nsec3_b3_optout_negcache.rpl: Test validator NSEC3 B.3 referral optout with negative cache.\")\n   void val_nsec3_b3_optout_negcache() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nsec3_b3_optout_noce.rpl: Test validator NSEC3 B.3 optout unsigned, without ce.\")\n   void val_nsec3_b3_optout_noce() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nsec3_b3_optout_nonc.rpl: Test validator NSEC3 B.3 optout unsigned, without nc.\")\n   void val_nsec3_b3_optout_nonc() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nsec3_b4_wild.rpl: Test validator NSEC3 B.4 wildcard expansion.\")\n   void val_nsec3_b4_wild() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nsec3_b4_wild_wr.rpl: Test validator NSEC3 B.4 wildcard expansion, wrong NSEC3.\")\n   void val_nsec3_b4_wild_wr() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nsec3_b5_wcnodata.rpl: Test validator NSEC3 B.5 wildcard nodata.\")\n   void val_nsec3_b5_wcnodata() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nsec3_b5_wcnodata_noce.rpl: Test validator NSEC3 B.5 wildcard nodata, without ce.\")\n   void val_nsec3_b5_wcnodata_noce() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nsec3_b5_wcnodata_nonc.rpl: Test validator NSEC3 B.5 wildcard nodata, without nc.\")\n   void val_nsec3_b5_wcnodata_nonc() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nsec3_b5_wcnodata_nowc.rpl: Test validator NSEC3 B.5 wildcard nodata, without wc.\")\n   void val_nsec3_b5_wcnodata_nowc() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nsec3_cnametocnamewctoposwc.rpl: Test validator with a regular cname to wildcard cname to wildcard response\")\n   void val_nsec3_cnametocnamewctoposwc() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nsec3_cname_ds.rpl: Test validator with NSEC3 CNAME for qtype DS.\")\n   void val_nsec3_cname_ds() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nsec3_cname_par.rpl: Test validator with NSEC3 wildcard CNAME to parent.\")\n   void val_nsec3_cname_par() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nsec3_cname_sub.rpl: Test validator with NSEC3 wildcard CNAME to subzone.\")\n   void val_nsec3_cname_sub() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nsec3_entnodata_optout.rpl: Test validator with NSEC3 response for NODATA ENT with optout.\")\n   void val_nsec3_entnodata_optout() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nsec3_entnodata_optout_badopt.rpl: Test validator with NSEC3 response for NODATA ENT with optout.\")\n   void val_nsec3_entnodata_optout_badopt() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nsec3_entnodata_optout_match.rpl: Test validator NODATA ENT with nsec3 optout matches the ent.\")\n   void val_nsec3_entnodata_optout_match() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nsec3_iter_high.rpl: Test validator with nxdomain NSEC3 with too high iterations\")\n   void val_nsec3_iter_high() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nsec3_nodatawccname.rpl: Test validator with nodata NSEC3 abused wildcarded CNAME.\")\n   void val_nsec3_nodatawccname() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nsec3_nods.rpl: Test validator with NSEC3 with no DS referral.\")\n   void val_nsec3_nods() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nsec3_nods_badopt.rpl: Test validator with NSEC3 with no DS with wrong optout bit.\")\n   void val_nsec3_nods_badopt() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nsec3_nods_badsig.rpl: Test validator with NSEC3 with no DS referral with bad signature.\")\n   void val_nsec3_nods_badsig() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Disabled(\"we don't do negative caching\")\n   @Test\n+  @DisplayName(\n+      \"val_nsec3_nods_negcache.rpl: Test validator with NSEC3 with no DS referral from neg cache.\")\n   void val_nsec3_nods_negcache() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nsec3_nods_soa.rpl: Test validator with NSEC3 with no DS referral abuse of apex.\")\n   void val_nsec3_nods_soa() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nsec3_optout_ad.rpl: Test validator with optout NSEC3 response that gets no AD.\")\n   void val_nsec3_optout_ad() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Disabled(\"more cache stuff\")\n   @Test\n+  @DisplayName(\n+      \"val_nsec3_optout_cache.rpl: Test validator with NSEC3 span change and cache effects.\")\n   void val_nsec3_optout_cache() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nsec3_wcany.rpl: Test validator with NSEC3 wildcard qtype ANY response.\")\n   void val_nsec3_wcany() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nsec3_wcany_nodeny.rpl: Test validator with NSEC3 wildcard qtype ANY without denial.\")\n   void val_nsec3_wcany_nodeny() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nx.rpl: Test validator with nxdomain response\")\n   void val_nx() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nx_failwc.rpl: Test validator with nxdomain response with wildcard expanded NSEC record, original NSEC owner does not provide proof for QNAME. CVE-2017-15105 test.\")\n   void val_nx_failwc() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nx_nodeny.rpl: Test validator with nxdomain response missing qname denial\")\n   void val_nx_nodeny() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nx_nowc.rpl: Test validator with nxdomain response missing wildcard denial\")\n   void val_nx_nowc() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nx_nsec3_collision.rpl: Test validator with nxdomain NSEC3 with a collision.\")\n   void val_nx_nsec3_collision() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nx_nsec3_collision2.rpl: Test validator with nxdomain NSEC3 with a salt mismatch.\")\n   void val_nx_nsec3_collision2() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nx_nsec3_collision3.rpl: Test validator with nxdomain NSEC3 with a collision.\")\n   void val_nx_nsec3_collision3() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nx_nsec3_collision4.rpl: Test validator with nxdomain NSEC3 with a collision.\")\n   void val_nx_nsec3_collision4() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nx_nsec3_hashalg.rpl: Test validator with unknown NSEC3 hash algorithm.\")\n   void val_nx_nsec3_hashalg() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_nx_nsec3_nsecmix.rpl: Test validator with NSEC3 responses that has an NSEC mixed in.\")\n   void val_nx_nsec3_nsecmix() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nx_nsec3_params.rpl: Test validator with nxdomain NSEC3 several parameters.\")\n   void val_nx_nsec3_params() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_nx_overreach.rpl: Test validator with overreaching NSEC record\")\n   void val_nx_overreach() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_positive.rpl: Test validator with positive response\")\n   void val_positive() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_positive_nosigs.rpl: Test validator with positive response, signatures removed.\")\n   void val_positive_nosigs() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_positive_wc.rpl: Test validator with positive wildcard response\")\n   void val_positive_wc() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_positive_wc_nodeny.rpl: Test validator with positive wildcard without qname denial\")\n   void val_positive_wc_nodeny() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_pos_truncns.rpl: Test validator with badly truncated positive response\")\n   void val_pos_truncns() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_qds_badanc.rpl: Test validator with DS query and a bad anchor\")\n   void val_qds_badanc() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_qds_oneanc.rpl: Test validator with DS query and one anchor\")\n   void val_qds_oneanc() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_qds_twoanc.rpl: Test validator with DS query and two anchors\")\n   void val_qds_twoanc() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Disabled(\"NSEC records missing for validation, tests caching stuff\")\n   @Test\n+  @DisplayName(\"val_referd.rpl: Test validator with cache referral\")\n   void val_referd() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Disabled(\"we don't do negative caching\")\n   @Test\n+  @DisplayName(\"val_referglue.rpl: Test validator with cache referral with unsigned glue\")\n   void val_referglue() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Disabled(\"we don't do negative caching\")\n   @Test\n+  @DisplayName(\"val_refer_unsignadd.rpl: Test validator with a referral with unsigned additional\")\n   void val_refer_unsignadd() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_rrsig.rpl: Test validator with qtype RRSIG response\")\n   void val_rrsig() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_secds.rpl: Test validator with secure delegation\")\n   void val_secds() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_secds_nosig.rpl: Test validator with no signatures after secure delegation\")\n   void val_secds_nosig() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n-  @Disabled(\"tests unbound specific config (stub zones)\")\n   @Test\n-  void val_stubds() throws ParseException, IOException {\n+  @DisplayName(\"val_spurious_ns.rpl: Test validator with spurious unsigned NS in auth section\")\n+  void val_spurious_ns() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n+  @Disabled(\"tests unbound specific config (stub zones)\")\n   @Test\n-  void val_spurious_ns() throws ParseException, IOException {\n+  @DisplayName(\"val_stubds.rpl: Test stub with DS query\")\n+  void val_stubds() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_stub_noroot.rpl: Test validation of stub zone without root prime.\")\n   void val_stub_noroot() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_ta_algo_dnskey.rpl: Test validator with multiple algorithm trust anchor\")\n   void val_ta_algo_dnskey() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\n+      \"val_ta_algo_dnskey_dp.rpl: Test validator with multiple algorithm trust anchor without harden\")\n   void val_ta_algo_dnskey_dp() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_ta_algo_missing.rpl: Test validator with multiple algorithm missing one\")\n   void val_ta_algo_missing() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_ta_algo_missing_dp.rpl: Test validator with multiple algorithm missing one\")\n   void val_ta_algo_missing_dp() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_twocname.rpl: Test validator with unsigned CNAME to signed CNAME to data\")\n   void val_twocname() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_unalgo_anchor.rpl: Test validator with unsupported algorithm trust anchor\")\n   void val_unalgo_anchor() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_unalgo_dlv.rpl: Test validator with unknown algorithm DLV anchor\")\n   void val_unalgo_dlv() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_unalgo_ds.rpl: Test validator with unknown algorithm delegation\")\n   void val_unalgo_ds() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_unsecds.rpl: Test validator with insecure delegation\")\n   void val_unsecds() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Disabled(\"we don't do negative caching\")\n   @Test\n+  @DisplayName(\n+      \"val_unsecds_negcache.rpl: Test validator with insecure delegation and DS negative cache\")\n   void val_unsecds_negcache() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Disabled(\"tests the iterative resolver\")\n   @Test\n+  @DisplayName(\"val_unsecds_qtypeds.rpl: Test validator with insecure delegation and qtype DS.\")\n   void val_unsecds_qtypeds() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_unsec_cname.rpl: Test validator with DS, unsec, cname sequence.\")\n   void val_unsec_cname() throws ParseException, IOException {\n     runUnboundTest();\n   }\n \n   @Test\n+  @DisplayName(\"val_wild_pos.rpl: Test validator with direct wildcard positive response\")\n   void val_wild_pos() throws ParseException, IOException {\n     runUnboundTest();\n   }\n```\n\nFilename: src/test/java/org/xbill/DNS/lookup/LookupResultTest.java:\n```\n@@ -3,34 +3,101 @@\nimport static java.util.Collections.singletonList;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n \n import java.net.InetAddress;\n+import java.util.Collections;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n import org.xbill.DNS.ARecord;\n+import org.xbill.DNS.CNAMERecord;\n import org.xbill.DNS.DClass;\n import org.xbill.DNS.Name;\n import org.xbill.DNS.Record;\n \n class LookupResultTest {\n+  private static final LookupResult PREVIOUS = new LookupResult(false);\n+  private static final ARecord A_RECORD =\n+      new ARecord(Name.fromConstantString(\"a.\"), DClass.IN, 0, InetAddress.getLoopbackAddress());\n+\n   @Test\n   void ctor_nullRecords() {\n-    assertThrows(NullPointerException.class, () -> new LookupResult(null, null));\n+    assertThrows(\n+        NullPointerException.class,\n+        () -> new LookupResult(PREVIOUS, null, null, false, null, Collections.emptyList()));\n+  }\n+\n+  @Test\n+  void ctor_nullAliases() {\n+    assertThrows(\n+        NullPointerException.class,\n+        () -> new LookupResult(PREVIOUS, null, null, false, Collections.emptyList(), null));\n+  }\n+\n+  @ParameterizedTest\n+  @ValueSource(booleans = {false, true})\n+  void ctor_authOnly(boolean isAuthenticated) {\n+    LookupResult lookupResult = new LookupResult(isAuthenticated);\n+    assertEquals(isAuthenticated, lookupResult.isAuthenticated());\n+    assertEquals(0, lookupResult.getAliases().size());\n+    assertEquals(0, lookupResult.getRecords().size());\n+    assertEquals(0, lookupResult.getQueryResponsePairs().size());\n+  }\n+\n+  @ParameterizedTest\n+  @ValueSource(booleans = {false, true})\n+  void ctor_singleRecord(boolean isAuthenticated) {\n+    LookupResult lookupResult = new LookupResult(A_RECORD, isAuthenticated, A_RECORD);\n+    assertEquals(isAuthenticated, lookupResult.isAuthenticated());\n+    assertEquals(0, lookupResult.getAliases().size());\n+    assertEquals(1, lookupResult.getRecords().size());\n+    assertEquals(1, lookupResult.getQueryResponsePairs().size());\n+    assertNull(lookupResult.getQueryResponsePairs().get(A_RECORD));\n   }\n \n   @Test\n   void getResult() {\n-    Record record =\n-        new ARecord(Name.fromConstantString(\"a.\"), DClass.IN, 0, InetAddress.getLoopbackAddress());\n-    LookupResult lookupResult = new LookupResult(singletonList(record), null);\n-    assertEquals(singletonList(record), lookupResult.getRecords());\n+    LookupResult lookupResult =\n+        new LookupResult(\n+            PREVIOUS, null, null, false, singletonList(A_RECORD), Collections.emptyList());\n+    assertEquals(singletonList(A_RECORD), lookupResult.getRecords());\n   }\n \n   @Test\n   void getAliases() {\n     Name name = Name.fromConstantString(\"b.\");\n     Record record = new ARecord(name, DClass.IN, 0, InetAddress.getLoopbackAddress());\n-    LookupResult lookupResult = new LookupResult(singletonList(record), singletonList(name));\n+    LookupResult lookupResult =\n+        new LookupResult(PREVIOUS, null, null, false, singletonList(record), singletonList(name));\n     assertEquals(singletonList(name), lookupResult.getAliases());\n   }\n+\n+  @ParameterizedTest\n+  @ValueSource(booleans = {false, true})\n+  void isAuthenticated(boolean isAuthenticated) {\n+    LookupResult lookupResult =\n+        new LookupResult(\n+            new LookupResult(isAuthenticated),\n+            null,\n+            null,\n+            isAuthenticated,\n+            singletonList(A_RECORD),\n+            Collections.emptyList());\n+    assertEquals(isAuthenticated, lookupResult.isAuthenticated());\n+  }\n+\n+  @ParameterizedTest\n+  @ValueSource(booleans = {false, true})\n+  void isAuthenticatedRequiresAllForTrue(boolean isAuthenticated) {\n+    Name nameA = Name.fromConstantString(\"a.\");\n+    Name nameB = Name.fromConstantString(\"b.\");\n+    Record cname = new CNAMERecord(nameA, DClass.IN, 0, nameB);\n+    Record a = new ARecord(nameB, DClass.IN, 0, InetAddress.getLoopbackAddress());\n+    LookupResult lookupResult1 = new LookupResult(isAuthenticated);\n+    LookupResult lookupResult2 =\n+        new LookupResult(lookupResult1, cname, null, true, singletonList(a), singletonList(nameA));\n+    assertEquals(isAuthenticated, lookupResult2.isAuthenticated());\n+  }\n }\n```\n\nFilename: src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java:\n```\n@@ -5,12 +5,19 @@\nimport static java.util.Arrays.asList;\n import static java.util.Collections.emptyList;\n import static java.util.Collections.singletonList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junitpioneer.jupiter.cartesian.CartesianTest.Enum;\n+import static org.junitpioneer.jupiter.cartesian.CartesianTest.Values;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.Mockito.inOrder;\n+import static org.mockito.Mockito.lenient;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.verifyNoMoreInteractions;\n\n@@ -20,9 +27,11 @@\nimport static org.xbill.DNS.LookupTest.LONG_LABEL;\n import static org.xbill.DNS.LookupTest.answer;\n import static org.xbill.DNS.LookupTest.fail;\n+import static org.xbill.DNS.LookupTest.multiAnswer;\n import static org.xbill.DNS.Type.A;\n import static org.xbill.DNS.Type.AAAA;\n import static org.xbill.DNS.Type.CNAME;\n+import static org.xbill.DNS.Type.DNAME;\n import static org.xbill.DNS.Type.MX;\n \n import java.io.IOException;\n\n@@ -44,11 +53,12 @@\nimport org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.extension.ExtendWith;\n-import org.junit.jupiter.api.function.Executable;\n import org.junit.jupiter.api.io.TempDir;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.CsvSource;\n+import org.junit.jupiter.params.provider.EnumSource;\n import org.junit.jupiter.params.provider.ValueSource;\n+import org.junitpioneer.jupiter.cartesian.CartesianTest;\n import org.mockito.ArgumentCaptor;\n import org.mockito.InOrder;\n import org.mockito.Mock;\n\n@@ -70,6 +80,7 @@\nimport org.xbill.DNS.Section;\n import org.xbill.DNS.SetResponse;\n import org.xbill.DNS.Type;\n+import org.xbill.DNS.WireParseException;\n import org.xbill.DNS.hosts.HostsFileParser;\n \n @ExtendWith(MockitoExtension.class)\n\n@@ -80,7 +91,9 @@\nclass LookupSessionTest {\n \n   private static final ARecord LOOPBACK_A =\n       new ARecord(DUMMY_NAME, IN, 3600, InetAddress.getLoopbackAddress());\n+  private static final ARecord EXAMPLE_A = (ARecord) LOOPBACK_A.withName(name(\"example.com.\"));\n   private static final AAAARecord LOOPBACK_AAAA;\n+  private static final String INVALID_SERVER_RESPONSE_MESSAGE = \"refusing to return it\";\n   private HostsFileParser lookupSessionTestHostsFileParser;\n \n   static {\n\n@@ -124,6 +137,31 @@\nvoid lookupAsync_absoluteQuery() throws InterruptedException, ExecutionException\n     verify(mockResolver).sendAsync(any(), any(Executor.class));\n   }\n \n+  @CartesianTest(name = \"useCache={0}, irrelevantRecordMode={1}\")\n+  void lookupAsync_absoluteQueryNoExtra(\n+      @Values(booleans = {true, false}) boolean useCache, @Enum IrrelevantRecordMode mode)\n+      throws ExecutionException, InterruptedException {\n+    wireUpMockResolver(\n+        mockResolver, query -> multiAnswer(query, name -> new Record[] {LOOPBACK_A, EXAMPLE_A}));\n+\n+    LookupSession lookupSession = lookupSession(useCache).irrelevantRecordMode(mode).build();\n+    CompletableFuture<LookupResult> future =\n+        lookupSession.lookupAsync(name(\"a.b.\"), A, IN).toCompletableFuture();\n+    if (mode == IrrelevantRecordMode.THROW) {\n+      assertThatThrownBy(future::get)\n+          .cause()\n+          .isInstanceOf(LookupFailedException.class)\n+          .hasMessageContaining(INVALID_SERVER_RESPONSE_MESSAGE);\n+    } else {\n+      LookupResult result = future.get();\n+      assertThat(result.getAliases()).isEmpty();\n+      assertThat(result.getRecords()).containsExactly(LOOPBACK_A.withName(name(\"a.b.\")));\n+    }\n+\n+    assertCacheUnused(useCache, mode, lookupSession);\n+    verify(mockResolver).sendAsync(any(), any(Executor.class));\n+  }\n+\n   @Test\n   void lookupAsync_absoluteQuery_defaultClass() throws InterruptedException, ExecutionException {\n     wireUpMockResolver(mockResolver, query -> answer(query, name -> LOOPBACK_A));\n\n@@ -160,10 +198,14 @@\nvoid lookupAsync_absoluteQueryWithFailedHosts() throws IOException {\n     when(mockHosts.getAddressForHost(any(), anyInt())).thenThrow(IOException.class);\n     LookupSession lookupSession =\n         LookupSession.builder().resolver(mockResolver).hostsFileParser(mockHosts).build();\n-    CompletionStage<LookupResult> resultFuture =\n-        lookupSession.lookupAsync(name(\"kubernetes.docker.internal.\"), A, IN);\n \n-    assertThrowsCause(NoSuchDomainException.class, () -> resultFuture.toCompletableFuture().get());\n+    assertThatThrownBy(\n+            lookupSession\n+                    .lookupAsync(name(\"kubernetes.docker.internal.\"), A, IN)\n+                    .toCompletableFuture()\n+                ::get)\n+        .cause()\n+        .isInstanceOf(NoSuchDomainException.class);\n   }\n \n   @Test\n\n@@ -174,10 +216,14 @@\nvoid lookupAsync_absoluteQueryWithHostsInvalidType() {\n             .resolver(mockResolver)\n             .hostsFileParser(lookupSessionTestHostsFileParser)\n             .build();\n-    CompletionStage<LookupResult> resultFuture =\n-        lookupSession.lookupAsync(name(\"kubernetes.docker.internal.\"), MX, IN);\n \n-    assertThrowsCause(NoSuchDomainException.class, () -> resultFuture.toCompletableFuture().get());\n+    assertThatThrownBy(\n+            lookupSession\n+                    .lookupAsync(name(\"kubernetes.docker.internal.\"), MX, IN)\n+                    .toCompletableFuture()\n+                ::get)\n+        .cause()\n+        .isInstanceOf(NoSuchDomainException.class);\n     verify(mockResolver).sendAsync(any(), any(Executor.class));\n   }\n\n@@ -355,11 +401,12 @@\nvoid lookupAsync_searchPathWithCacheMissAndHit() throws InterruptedException, Ex\n     when(mockCache.lookupRecords(name(\"host.tld.\"), A, Credibility.NORMAL))\n         .thenReturn(mock(SetResponse.class));\n \n-    SetResponse second = mock(SetResponse.class);\n-    when(second.isSuccessful()).thenReturn(true);\n-    when(second.answers())\n+    SetResponse anotherTldResponse = mock(SetResponse.class);\n+    when(anotherTldResponse.isSuccessful()).thenReturn(true);\n+    when(anotherTldResponse.answers())\n         .thenReturn(singletonList(new RRset(LOOPBACK_A.withName(name(\"another.tld.\")))));\n-    when(mockCache.lookupRecords(name(\"another.tld.\"), A, Credibility.NORMAL)).thenReturn(second);\n+    when(mockCache.lookupRecords(name(\"another.tld.\"), A, Credibility.NORMAL))\n+        .thenReturn(anotherTldResponse);\n \n     LookupSession lookupSession =\n         LookupSession.builder()\n\n@@ -432,29 +479,25 @@\nvoid lookupAsync_twoCnameRedirectMultipleQueries(boolean useCache) throws Except\n         };\n     wireUpMockResolver(mockResolver, q -> answer(q, nameToRecord));\n \n-    LookupSession lookupSession =\n-        useCache\n-            ? LookupSession.builder().cache(new Cache()).resolver(mockResolver).build()\n-            : LookupSession.builder().resolver(mockResolver).build();\n-\n+    LookupSession lookupSession = lookupSession(useCache).build();\n     CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(name(\"cname.a.\"), A, IN);\n \n     LookupResult result = resultFuture.toCompletableFuture().get();\n     assertEquals(singletonList(LOOPBACK_A.withName(name(\"a.b.\"))), result.getRecords());\n     assertEquals(\n         Stream.of(name(\"cname.a.\"), name(\"cname.b.\")).collect(Collectors.toList()),\n         result.getAliases());\n+    if (useCache) {\n+      assertEquals(3, lookupSession.getCache(IN).getSize());\n+    }\n     verify(mockResolver, times(3)).sendAsync(any(), any(Executor.class));\n   }\n \n-  @ParameterizedTest\n-  @CsvSource({\n-    \"false,false\",\n-    \"true,false\",\n-    \"false,true\",\n-    \"true,true\",\n-  })\n-  void lookupAsync_twoDnameRedirectOneQuery(boolean useCache, boolean includeSyntheticCnames)\n+  @CartesianTest(name = \"useCache={0}, includeSyntheticCnames={1}, irrelevantRecordMode={2}\")\n+  void lookupAsync_twoDnameRedirectOneQuery(\n+      @Values(booleans = {true, false}) boolean useCache,\n+      @Values(booleans = {true, false}) boolean includeSyntheticCnames,\n+      @Enum IrrelevantRecordMode mode)\n       throws Exception {\n     wireUpMockResolver(\n         mockResolver,\n\n@@ -474,11 +517,7 @@\nvoid lookupAsync_twoDnameRedirectOneQuery(boolean useCache, boolean includeSynth\n           return answer;\n         });\n \n-    LookupSession lookupSession =\n-        useCache\n-            ? LookupSession.builder().cache(new Cache()).resolver(mockResolver).build()\n-            : LookupSession.builder().resolver(mockResolver).build();\n-\n+    LookupSession lookupSession = lookupSession(useCache).irrelevantRecordMode(mode).build();\n     CompletionStage<LookupResult> resultFuture =\n         lookupSession.lookupAsync(name(\"www.example.org.\"), A, IN);\n\n@@ -488,6 +527,9 @@\nvoid lookupAsync_twoDnameRedirectOneQuery(boolean useCache, boolean includeSynth\n         Stream.of(name(\"www.example.org.\"), name(\"www.example.net.\"), name(\"www.example.com.\"))\n             .collect(Collectors.toList()),\n         result.getAliases());\n+    if (useCache) {\n+      assertEquals(4 + (includeSyntheticCnames ? 2 : 0), lookupSession.getCache(IN).getSize());\n+    }\n     verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));\n   }\n\n@@ -505,11 +547,7 @@\nvoid lookupAsync_twoCnameRedirectOneQuery(boolean useCache) throws Exception {\n           return answer;\n         });\n \n-    LookupSession lookupSession =\n-        useCache\n-            ? LookupSession.builder().cache(new Cache()).resolver(mockResolver).build()\n-            : LookupSession.builder().resolver(mockResolver).build();\n-\n+    LookupSession lookupSession = lookupSession(useCache).build();\n     CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(name(\"cname.a.\"), A, IN);\n \n     LookupResult result = resultFuture.toCompletableFuture().get();\n\n@@ -545,18 +583,17 @@\nvoid lookupAsync_twoCnameRedirectIncompleteResponse(boolean useCache, int firstR\n           return answer;\n         });\n \n-    LookupSession lookupSession =\n-        useCache\n-            ? LookupSession.builder().cache(new Cache()).resolver(mockResolver).build()\n-            : LookupSession.builder().resolver(mockResolver).build();\n-\n+    LookupSession lookupSession = lookupSession(useCache).build();\n     CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(name(\"cname.a.\"), A, IN);\n \n     LookupResult result = resultFuture.toCompletableFuture().get();\n     assertEquals(singletonList(LOOPBACK_A.withName(name(\"a.b.\"))), result.getRecords());\n     assertEquals(\n         Stream.of(name(\"cname.a.\"), name(\"cname.b.\")).collect(Collectors.toList()),\n         result.getAliases());\n+    if (useCache) {\n+      assertEquals(3, lookupSession.getCache(IN).getSize());\n+    }\n     verify(mockResolver, times(2)).sendAsync(any(), any(Executor.class));\n   }\n\n@@ -601,37 +638,69 @@\nvoid lookupAsync_simpleCnameRedirect(boolean useCache, String rcode, String type\n           }\n         });\n \n-    LookupSession lookupSession =\n-        useCache\n-            ? LookupSession.builder().cache(new Cache()).resolver(mockResolver).build()\n-            : LookupSession.builder().resolver(mockResolver).build();\n-\n-    CompletionStage<LookupResult> resultFuture =\n-        lookupSession.lookupAsync(name(\"cname.r.\"), Type.value(type), IN);\n+    LookupSession lookupSession = lookupSession(useCache).build();\n+    CompletableFuture<LookupResult> future =\n+        lookupSession.lookupAsync(name(\"cname.r.\"), Type.value(type), IN).toCompletableFuture();\n \n-    CompletableFuture<LookupResult> future = resultFuture.toCompletableFuture();\n     if (rcode.equals(\"NXDOMAIN\")) {\n-      assertThrowsCause(NoSuchDomainException.class, future::get);\n+      assertThatThrownBy(future::get).cause().isInstanceOf(NoSuchDomainException.class);\n     } else {\n       LookupResult result = future.get();\n-      assertEquals(0, result.getRecords().size());\n+      assertThat(result.getRecords()).isEmpty();\n     }\n     verify(mockResolver, times(2)).sendAsync(any(), any(Executor.class));\n   }\n \n   @Test\n   void lookupAsync_simpleCnameRedirect() throws Exception {\n+    Name cname = name(\"cname.r.\");\n+    Name target = name(\"a.b.\");\n     Function<Name, Record> nameToRecord =\n-        name -> name(\"cname.r.\").equals(name) ? cname(\"cname.r.\", \"a.b.\") : LOOPBACK_A;\n+        name -> cname.equals(name) ? cname(cname, target) : LOOPBACK_A;\n     wireUpMockResolver(mockResolver, q -> answer(q, nameToRecord));\n \n     LookupSession lookupSession = LookupSession.builder().resolver(mockResolver).build();\n \n-    CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(name(\"cname.r.\"), A, IN);\n+    CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(cname, A, IN);\n \n     LookupResult result = resultFuture.toCompletableFuture().get();\n     assertEquals(singletonList(LOOPBACK_A.withName(name(\"a.b.\"))), result.getRecords());\n-    assertEquals(singletonList(name(\"cname.r.\")), result.getAliases());\n+    assertEquals(singletonList(cname), result.getAliases());\n+    verify(mockResolver, times(2)).sendAsync(any(), any(Executor.class));\n+  }\n+\n+  @ParameterizedTest\n+  @EnumSource(value = IrrelevantRecordMode.class)\n+  void lookupAsync_simpleCnameRedirectNoExtra(IrrelevantRecordMode mode)\n+      throws ExecutionException, InterruptedException {\n+    Name query = name(\"cname.r.\");\n+    Name target = name(\"a.b.\");\n+    Function<Name, Record[]> nameToRecord =\n+        name ->\n+            query.equals(name)\n+                ? new Record[] {cname(query, target)}\n+                : new Record[] {\n+                  LOOPBACK_A, EXAMPLE_A,\n+                };\n+    wireUpMockResolver(mockResolver, q -> multiAnswer(q, nameToRecord));\n+\n+    LookupSession lookupSession =\n+        LookupSession.builder().resolver(mockResolver).irrelevantRecordMode(mode).build();\n+\n+    CompletableFuture<LookupResult> f =\n+        lookupSession.lookupAsync(query, A, IN).toCompletableFuture();\n+    if (mode == IrrelevantRecordMode.REMOVE) {\n+      LookupResult result = f.get();\n+      assertThat(result.getRecords()).hasSize(1).containsExactly(LOOPBACK_A.withName(target));\n+    } else {\n+      assertThatThrownBy(f::get)\n+          .cause()\n+          .isInstanceOf(LookupFailedException.class)\n+          .hasMessageContaining(INVALID_SERVER_RESPONSE_MESSAGE)\n+          .rootCause()\n+          .isInstanceOf(WireParseException.class);\n+    }\n+\n     verify(mockResolver, times(2)).sendAsync(any(), any(Executor.class));\n   }\n\n@@ -652,40 +721,324 @@\nvoid lookupAsync_cnameQuery() throws Exception {\n     verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));\n   }\n \n+  @Test\n+  void lookupAsync_dnameQuery() throws Exception {\n+    Name query = name(\"dname.r.\");\n+    DNAMERecord response = dname(query, \"a.b.\");\n+    Function<Name, Record> nameToRecord = name -> name.equals(query) ? response : LOOPBACK_A;\n+    wireUpMockResolver(mockResolver, q -> answer(q, nameToRecord));\n+\n+    LookupSession lookupSession = LookupSession.builder().resolver(mockResolver).build();\n+\n+    CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(query, DNAME, IN);\n+\n+    LookupResult result = resultFuture.toCompletableFuture().get();\n+    assertEquals(singletonList(response), result.getRecords());\n+    assertEquals(emptyList(), result.getAliases());\n+    verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));\n+  }\n+\n+  @CartesianTest(name = \"useCache={0}, irrelevantRecordMode={1}\")\n+  void lookupAsync_cnameQueryExtra(\n+      @Values(booleans = {true, false}) boolean useCache, @Enum IrrelevantRecordMode mode)\n+      throws ExecutionException, InterruptedException {\n+    Name query = name(\"cname.r.\");\n+    Name target = name(\"a.b.\");\n+    CNAMERecord response1 = cname(query, target);\n+    CNAMERecord response2 = cname(name(\"additional.r.\"), target);\n+    Function<Name, Record[]> nameToRecord =\n+        name ->\n+            query.equals(name) ? new Record[] {response1, response2} : new Record[] {LOOPBACK_A};\n+    wireUpMockResolver(mockResolver, q -> multiAnswer(q, nameToRecord));\n+\n+    LookupSession lookupSession = lookupSession(useCache, mode).build();\n+    CompletableFuture<LookupResult> future =\n+        lookupSession.lookupAsync(query, CNAME, IN).toCompletableFuture();\n+    if (mode == IrrelevantRecordMode.THROW) {\n+      assertThatThrownBy(future::get)\n+          .cause()\n+          .isInstanceOf(LookupFailedException.class)\n+          .hasMessageContaining(INVALID_SERVER_RESPONSE_MESSAGE);\n+    } else {\n+      LookupResult result = future.get();\n+      assertThat(result.getAliases()).isEmpty();\n+      assertThat(result.getRecords()).containsExactly(cname(query, target));\n+    }\n+\n+    assertCacheUnused(useCache, mode, lookupSession);\n+    verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));\n+  }\n+\n+  @CartesianTest(name = \"useCache={0}, irrelevantRecordMode={1}\")\n+  void lookupAsync_dnameQueryExtra(\n+      @Values(booleans = {true, false}) boolean useCache, @Enum IrrelevantRecordMode mode)\n+      throws ExecutionException, InterruptedException {\n+    Name query = name(\"cname.r.\");\n+    Name target = name(\"a.b.\");\n+    DNAMERecord response1 = dname(query, target);\n+    DNAMERecord response2 = dname(name(\"additional.r.\"), target);\n+    Function<Name, Record[]> nameToRecord =\n+        name ->\n+            query.equals(name) ? new Record[] {response1, response2} : new Record[] {LOOPBACK_A};\n+    wireUpMockResolver(mockResolver, q -> multiAnswer(q, nameToRecord));\n+\n+    LookupSession lookupSession = lookupSession(useCache, mode).build();\n+    CompletableFuture<LookupResult> future =\n+        lookupSession.lookupAsync(query, DNAME, IN).toCompletableFuture();\n+    if (mode == IrrelevantRecordMode.THROW) {\n+      assertThatThrownBy(future::get)\n+          .cause()\n+          .isInstanceOf(LookupFailedException.class)\n+          .hasMessageContaining(INVALID_SERVER_RESPONSE_MESSAGE);\n+    } else {\n+      LookupResult result = future.get();\n+      assertThat(result.getAliases()).isEmpty();\n+      assertThat(result.getRecords()).containsExactly(response1);\n+    }\n+\n+    assertCacheUnused(useCache, mode, lookupSession);\n+    verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));\n+  }\n+\n   @Test\n   void lookupAsync_simpleDnameRedirect() throws Exception {\n+    Name query = name(\"x.y.to.dname.\");\n     Function<Name, Record> nameToRecord =\n-        n -> name(\"x.y.to.dname.\").equals(n) ? dname(\"to.dname.\", \"to.a.\") : LOOPBACK_A;\n+        name -> name.equals(query) ? dname(\"to.dname.\", \"to.a.\") : LOOPBACK_A;\n     wireUpMockResolver(mockResolver, q -> answer(q, nameToRecord));\n \n     LookupSession lookupSession = LookupSession.builder().resolver(mockResolver).build();\n \n-    CompletionStage<LookupResult> resultFuture =\n-        lookupSession.lookupAsync(name(\"x.y.to.dname.\"), A, IN);\n+    CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(query, A, IN);\n \n     LookupResult result = resultFuture.toCompletableFuture().get();\n     assertEquals(singletonList(LOOPBACK_A.withName(name(\"x.y.to.a.\"))), result.getRecords());\n     verify(mockResolver, times(2)).sendAsync(any(), any(Executor.class));\n   }\n \n   @Test\n-  void lookupAsync_redirectLoop() {\n-    Function<Name, Record> nameToRecord =\n-        name -> name(\"a.b.\").equals(name) ? cname(\"a.\", \"b.\") : cname(\"b.\", \"a.\");\n-    wireUpMockResolver(mockResolver, q -> answer(q, nameToRecord));\n+  void lookupAsync_simpleDnameRedirectSynthesizedCname() throws Exception {\n+    Name query = name(\"x.y.example.org.\");\n+    wireUpMockResolver(\n+        mockResolver,\n+        q ->\n+            multiAnswer(\n+                q,\n+                name ->\n+                    new Record[] {\n+                      dname(\"example.org.\", \"example.net.\"),\n+                      cname(\"x.y.example.org.\", \"x.y.example.net.\"),\n+                      LOOPBACK_A.withName(name(\"x.y.example.net.\")),\n+                    }));\n \n-    LookupSession lookupSession =\n-        LookupSession.builder().resolver(mockResolver).maxRedirects(2).build();\n+    LookupSession lookupSession = LookupSession.builder().resolver(mockResolver).build();\n \n-    CompletionStage<LookupResult> resultFuture =\n-        lookupSession.lookupAsync(name(\"first.example.com.\"), A, IN);\n+    CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(query, A, IN);\n \n-    assertThrowsCause(\n-        RedirectOverflowException.class, () -> resultFuture.toCompletableFuture().get());\n-    verify(mockResolver, times(3)).sendAsync(any(), any(Executor.class));\n+    LookupResult result = resultFuture.toCompletableFuture().get();\n+    assertEquals(singletonList(LOOPBACK_A.withName(name(\"x.y.example.net.\"))), result.getRecords());\n+    assertEquals(singletonList(name(\"x.y.example.org.\")), result.getAliases());\n+    verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));\n   }\n \n   @ParameterizedTest\n+  @CsvSource(\n+      value = {\n+        \"x.y.example.com.,x.y.example.org.,REMOVE\",\n+        \"x.y.example.com.,x.y.example.org.,THROW\",\n+        \"x.y.example.org.,x.y.example.com.,REMOVE\",\n+        \"x.y.example.org.,x.y.example.com.,THROW\",\n+      })\n+  void lookupAsync_simpleDnameRedirectWrongSynthesizedCname(\n+      String from, String to, IrrelevantRecordMode mode)\n+      throws ExecutionException, InterruptedException {\n+    Name query = name(\"x.y.example.org.\");\n+    wireUpMockResolver(\n+        mockResolver,\n+        q ->\n+            multiAnswer(\n+                q,\n+                name ->\n+                    new Record[] {\n+                      // Correct\n+                      dname(\"example.org.\", \"example.net.\"),\n+                      // Extra and wrong\n+                      cname(from, to),\n+                      // Correct\n+                      LOOPBACK_A.withName(name(\"x.y.example.net.\")),\n+                      // Extra and wrong\n+                      LOOPBACK_A.withName(name(to)),\n+                    }));\n+\n+    LookupSession lookupSession =\n+        LookupSession.builder().resolver(mockResolver).irrelevantRecordMode(mode).build();\n+\n+    CompletableFuture<LookupResult> future =\n+        lookupSession.lookupAsync(query, A, IN).toCompletableFuture();\n+    if (mode == IrrelevantRecordMode.THROW) {\n+      assertThatThrownBy(future::get)\n+          .cause()\n+          .isInstanceOf(LookupFailedException.class)\n+          .hasMessageContaining(INVALID_SERVER_RESPONSE_MESSAGE);\n+    } else {\n+      LookupResult result = future.get();\n+      assertThat(result.getAliases()).containsExactly(name(\"x.y.example.org.\"));\n+      assertThat(result.getRecords())\n+          .containsExactly(LOOPBACK_A.withName(name(\"x.y.example.net.\")));\n+    }\n+    verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));\n+  }\n+\n+  @CartesianTest(name = \"useCache={0}, irrelevantRecordMode={1}\")\n+  void lookupAsync_simpleDnameRedirectNoExtra(\n+      @Values(booleans = {true, false}) boolean useCache, @Enum IrrelevantRecordMode mode)\n+      throws ExecutionException, InterruptedException {\n+    Name queryName = name(\"x.y.to.dname.\");\n+    wireUpMockResolver(\n+        mockResolver,\n+        question ->\n+            multiAnswer(\n+                question,\n+                name ->\n+                    name.equals(queryName)\n+                        ? new Record[] {dname(\"to.dname.\", \"to.a.\")}\n+                        : new Record[] {\n+                          // LOOPBACK_A will be transformed to 'x.y.to.a.'\n+                          LOOPBACK_A, EXAMPLE_A,\n+                        }));\n+\n+    LookupSession lookupSession = lookupSession(useCache, mode).build();\n+    CompletableFuture<LookupResult> future =\n+        lookupSession.lookupAsync(queryName, A, IN).toCompletableFuture();\n+    if (mode == IrrelevantRecordMode.THROW) {\n+      assertThatThrownBy(future::get)\n+          .cause()\n+          .isInstanceOf(LookupFailedException.class)\n+          .hasMessageContaining(INVALID_SERVER_RESPONSE_MESSAGE);\n+    } else {\n+      LookupResult result = future.get();\n+      assertAll(\n+          () -> {\n+            assertThat(result.getAliases()).containsExactly(name(\"x.y.to.dname.\"));\n+            assertThat(result.getRecords()).containsExactly(LOOPBACK_A.withName(name(\"x.y.to.a.\")));\n+          });\n+    }\n+\n+    if (useCache && mode == IrrelevantRecordMode.THROW) {\n+      // Verify that the invalid response didn't end up in the cache\n+      Cache cache = lookupSession.getCache(IN);\n+      verify(cache, times(1)).addMessage(any(Message.class));\n+      assertEquals(1, cache.getSize());\n+      assertTrue(cache.lookupRecords(name(\"example.com.\"), A, Credibility.NORMAL).isUnknown());\n+    }\n+\n+    verify(mockResolver, times(2)).sendAsync(any(), any(Executor.class));\n+  }\n+\n+  @CartesianTest(name = \"useCache={0}, irrelevantRecordMode={1}\")\n+  void lookupAsync_simpleCnameWrongInitial(\n+      @Values(booleans = {true, false}) boolean useCache, @Enum IrrelevantRecordMode mode)\n+      throws ExecutionException, InterruptedException {\n+    Name query = name(\"first.example.com.\");\n+    wireUpMockResolver(mockResolver, q -> answer(q, name -> cname(\"a.\", \"b.\")));\n+\n+    LookupSession lookupSession = lookupSession(useCache).irrelevantRecordMode(mode).build();\n+    CompletableFuture<LookupResult> future =\n+        lookupSession.lookupAsync(query, A, IN).toCompletableFuture();\n+    if (mode == IrrelevantRecordMode.THROW) {\n+      assertThatThrownBy(future::get)\n+          .cause()\n+          .isInstanceOf(LookupFailedException.class)\n+          .hasMessageContaining(INVALID_SERVER_RESPONSE_MESSAGE);\n+    } else {\n+      LookupResult result = future.get();\n+      assertThat(result.getAliases()).isEmpty();\n+      assertThat(result.getRecords()).isEmpty();\n+    }\n+\n+    assertCacheUnused(useCache, mode, lookupSession);\n+\n+    verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));\n+  }\n+\n+  @CartesianTest(name = \"useCache={0}, irrelevantRecordMode={1}\")\n+  void lookupAsync_simpleDnameWrongInitial(\n+      @Values(booleans = {true, false}) boolean useCache, @Enum IrrelevantRecordMode mode)\n+      throws ExecutionException, InterruptedException {\n+    Name query = name(\"first.example.com.\");\n+    wireUpMockResolver(mockResolver, q -> answer(q, name -> dname(\"a.\", \"b.\")));\n+\n+    LookupSession lookupSession =\n+        lookupSession(useCache, mode == IrrelevantRecordMode.THROW)\n+            .irrelevantRecordMode(mode)\n+            .build();\n+\n+    CompletableFuture<LookupResult> future =\n+        lookupSession.lookupAsync(query, A, IN).toCompletableFuture();\n+    if (mode == IrrelevantRecordMode.THROW) {\n+      assertThatThrownBy(future::get)\n+          .cause()\n+          .isInstanceOf(LookupFailedException.class)\n+          .hasMessageContaining(INVALID_SERVER_RESPONSE_MESSAGE);\n+    } else {\n+      LookupResult result = future.get();\n+      assertThat(result.getAliases()).isEmpty();\n+      assertThat(result.getRecords()).isEmpty();\n+    }\n+\n+    assertCacheUnused(useCache, mode, lookupSession);\n+    verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));\n+  }\n+\n+  private static void assertCacheUnused(\n+      boolean useCache, IrrelevantRecordMode mode, LookupSession lookupSession) {\n+    if (useCache && mode == IrrelevantRecordMode.THROW) {\n+      // Verify that the invalid response didn't end up in the cache\n+      Cache cache = lookupSession.getCache(IN);\n+      verify(cache, times(0)).addMessage(any(Message.class));\n+      assertEquals(0, cache.getSize());\n+    }\n+  }\n+\n+  @CartesianTest(name = \"maxRedirects={0}, irrelevantRecordMode={1}\")\n+  void lookupAsync_redirectLoop(\n+      @Values(ints = {3, 4}) int maxRedirects, @Enum IrrelevantRecordMode mode) {\n+    CNAMERecord cnameA = cname(\"a.\", \"b.\");\n+    CNAMERecord cnameB = cname(\"b.\", \"c.\");\n+    CNAMERecord cnameC = cname(\"c.\", \"d.\");\n+    CNAMERecord cnameD = cname(\"d.\", \"a.\");\n+    Function<Name, Record> nameToRecord =\n+        name -> {\n+          if (name.equals(cnameA.getName())) {\n+            return cnameA;\n+          } else if (name.equals(cnameB.getName())) {\n+            return cnameB;\n+          } else if (name.equals(cnameC.getName())) {\n+            return cnameC;\n+          } else if (name.equals(cnameD.getName())) {\n+            return cnameD;\n+          } else {\n+            throw new RuntimeException(\"Unexpected query\");\n+          }\n+        };\n+    wireUpMockResolver(mockResolver, q -> answer(q, nameToRecord));\n+    LookupSession lookupSession =\n+        LookupSession.builder()\n+            .maxRedirects(maxRedirects)\n+            .resolver(mockResolver)\n+            .irrelevantRecordMode(mode)\n+            .build();\n+\n+    Class<? extends Throwable> expected =\n+        maxRedirects == 3 ? RedirectOverflowException.class : RedirectLoopException.class;\n+    assertThatThrownBy(\n+            lookupSession.lookupAsync(cnameA.getName(), A, IN).toCompletableFuture()::get)\n+        .cause()\n+        .isInstanceOf(expected);\n+    verify(mockResolver, times(maxRedirects)).sendAsync(any(), any(Executor.class));\n+  }\n+\n+  @ParameterizedTest(name = \"maxRedirects={0}\")\n   @ValueSource(ints = {3, 4})\n   void lookupAsync_redirectLoopOneAnswer(int maxRedirects) {\n     wireUpMockResolver(\n\n@@ -703,10 +1056,11 @@\nvoid lookupAsync_redirectLoopOneAnswer(int maxRedirects) {\n     LookupSession lookupSession =\n         LookupSession.builder().resolver(mockResolver).maxRedirects(maxRedirects).build();\n \n-    CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(name(\"a.\"), A, IN);\n-\n-    assertThrowsCause(\n-        RedirectOverflowException.class, () -> resultFuture.toCompletableFuture().get());\n+    Class<? extends Throwable> expected =\n+        maxRedirects == 3 ? RedirectOverflowException.class : RedirectLoopException.class;\n+    assertThatThrownBy(lookupSession.lookupAsync(name(\"a.\"), A, IN).toCompletableFuture()::get)\n+        .cause()\n+        .isInstanceOf(expected);\n     verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));\n   }\n\n@@ -718,7 +1072,7 @@\nvoid lookupAsync_NODATA() throws ExecutionException, InterruptedException {\n     CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(name(\"a.b.\"), A, IN);\n \n     LookupResult result = resultFuture.toCompletableFuture().get();\n-    assertEquals(0, result.getRecords().size());\n+    assertThat(result.getRecords()).isEmpty();\n     verify(mockResolver).sendAsync(any(), any(Executor.class));\n   }\n\n@@ -727,9 +1081,9 @@\nvoid lookupAsync_NXDOMAIN() {\n     wireUpMockResolver(mockResolver, q -> fail(q, Rcode.NXDOMAIN));\n \n     LookupSession lookupSession = LookupSession.builder().resolver(mockResolver).build();\n-    CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(name(\"a.b.\"), A, IN);\n-\n-    assertThrowsCause(NoSuchDomainException.class, () -> resultFuture.toCompletableFuture().get());\n+    assertThatThrownBy(lookupSession.lookupAsync(name(\"a.b.\"), A, IN).toCompletableFuture()::get)\n+        .cause()\n+        .isInstanceOf(NoSuchDomainException.class);\n     verify(mockResolver).sendAsync(any(), any(Executor.class));\n   }\n\n@@ -738,9 +1092,9 @@\nvoid lookupAsync_SERVFAIL() {\n     wireUpMockResolver(mockResolver, q -> fail(q, Rcode.SERVFAIL));\n \n     LookupSession lookupSession = LookupSession.builder().resolver(mockResolver).build();\n-    CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(name(\"a.b.\"), A, IN);\n-\n-    assertThrowsCause(ServerFailedException.class, () -> resultFuture.toCompletableFuture().get());\n+    assertThatThrownBy(lookupSession.lookupAsync(name(\"a.b.\"), A, IN).toCompletableFuture()::get)\n+        .cause()\n+        .isInstanceOf(ServerFailedException.class);\n     verify(mockResolver).sendAsync(any(), any(Executor.class));\n   }\n\n@@ -749,9 +1103,9 @@\nvoid lookupAsync_unknownFailure() {\n     wireUpMockResolver(mockResolver, q -> fail(q, Rcode.NOTIMP));\n \n     LookupSession lookupSession = LookupSession.builder().resolver(mockResolver).build();\n-    CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(name(\"a.b.\"), A, IN);\n-\n-    assertThrowsCause(LookupFailedException.class, () -> resultFuture.toCompletableFuture().get());\n+    assertThatThrownBy(lookupSession.lookupAsync(name(\"a.b.\"), A, IN).toCompletableFuture()::get)\n+        .cause()\n+        .isInstanceOf(LookupFailedException.class);\n     verify(mockResolver).sendAsync(any(), any(Executor.class));\n   }\n\n@@ -760,9 +1114,9 @@\nvoid lookupAsync_NXRRSET() {\n     wireUpMockResolver(mockResolver, q -> fail(q, Rcode.NXRRSET));\n \n     LookupSession lookupSession = LookupSession.builder().resolver(mockResolver).build();\n-    CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(name(\"a.b.\"), A, IN);\n-\n-    assertThrowsCause(NoSuchRRSetException.class, () -> resultFuture.toCompletableFuture().get());\n+    assertThatThrownBy(lookupSession.lookupAsync(name(\"a.b.\"), A, IN).toCompletableFuture()::get)\n+        .cause()\n+        .isInstanceOf(NoSuchRRSetException.class);\n     verify(mockResolver).sendAsync(any(), any(Executor.class));\n   }\n\n@@ -773,36 +1127,35 @@\nvoid lookupAsync_TooLongNameDNAME() {\n \n     LookupSession lookupSession = LookupSession.builder().resolver(mockResolver).build();\n     Name toLookup = name(format(\"%s.%s.%s.to.dname.\", LONG_LABEL, LONG_LABEL, LONG_LABEL));\n-    CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(toLookup, A, IN);\n-\n-    assertThrowsCause(\n-        InvalidZoneDataException.class, () -> resultFuture.toCompletableFuture().get());\n+    assertThatThrownBy(lookupSession.lookupAsync(toLookup, A, IN).toCompletableFuture()::get)\n+        .cause()\n+        .isInstanceOf(InvalidZoneDataException.class);\n     verify(mockResolver).sendAsync(any(), any(Executor.class));\n   }\n \n   @Test\n-  void lookupAsync_MultipleCNAMEs() {\n+  void lookupAsync_MultipleCNAMEs() throws ExecutionException, InterruptedException {\n+    Record testQuestion = Record.newRecord(name(\"a.b.\"), A, IN);\n     // According to https://docstore.mik.ua/orelly/networking_2ndEd/dns/ch10_07.htm this is\n-    // apparently something that BIND 4 did.\n-    wireUpMockResolver(mockResolver, LookupSessionTest::multipleCNAMEs);\n+    // apparently something that BIND 4 / BIND 9 before 9.1 could do.\n+    wireUpMockResolver(\n+        mockResolver,\n+        query -> {\n+          Message answer = new Message(query.getHeader().getID());\n+          answer.addRecord(testQuestion, Section.QUESTION);\n+          answer.addRecord(cname(testQuestion.getName(), \"target1.\"), Section.ANSWER);\n+          answer.addRecord(cname(testQuestion.getName(), \"target2.\"), Section.ANSWER);\n+          return answer;\n+        });\n \n     LookupSession lookupSession = LookupSession.builder().resolver(mockResolver).build();\n-    CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(name(\"a.b.\"), A, IN);\n+    LookupResult result = lookupSession.lookupAsync(testQuestion).toCompletableFuture().get();\n \n-    assertThrowsCause(\n-        InvalidZoneDataException.class, () -> resultFuture.toCompletableFuture().get());\n-    verify(mockResolver).sendAsync(any(), any(Executor.class));\n-  }\n+    assertTrue(result.getRecords().isEmpty());\n+    assertThat(result.getAliases()).containsExactly(testQuestion.getName());\n \n-  private static Message multipleCNAMEs(Message query) {\n-    Message answer = new Message(query.getHeader().getID());\n-    Record question = query.getQuestion();\n-    answer.addRecord(question, Section.QUESTION);\n-    answer.addRecord(\n-        new CNAMERecord(question.getName(), CNAME, IN, name(\"target1.\")), Section.ANSWER);\n-    answer.addRecord(\n-        new CNAMERecord(question.getName(), CNAME, IN, name(\"target2.\")), Section.ANSWER);\n-    return answer;\n+    // Two invocations as the result doesn't include an actual answer\n+    verify(mockResolver, times(2)).sendAsync(any(), any(Executor.class));\n   }\n \n   @Test\n\n@@ -821,12 +1174,11 @@\nvoid lookupAsync_searchAppended() throws Exception {\n     ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);\n     verify(mockResolver).sendAsync(messageCaptor.capture(), any(Executor.class));\n \n-    assertEquals(\n-        Record.newRecord(name(\"host.example.com.\"), Type.A, DClass.IN, 0L),\n-        messageCaptor.getValue().getSection(Section.QUESTION).get(0));\n+    assertThat(messageCaptor.getValue().getSection(Section.QUESTION))\n+        .containsExactly(Record.newRecord(name(\"host.example.com.\"), Type.A, DClass.IN, 0L));\n \n-    assertEquals(\n-        singletonList(LOOPBACK_A.withName(name(\"host.example.com.\"))), lookupResult.getRecords());\n+    assertThat(lookupResult.getRecords())\n+        .containsExactly(LOOPBACK_A.withName(name(\"host.example.com.\")));\n   }\n \n   @Test\n\n@@ -999,26 +1351,68 @@\nvoid expandName_ndotsMoreThanOne() {\n   }\n \n   private static CNAMERecord cname(String name, String target) {\n-    return cname(name(name), target);\n+    return cname(name(name), name(target));\n   }\n \n+  @SuppressWarnings(\"SameParameterValue\")\n   private static CNAMERecord cname(Name name, String target) {\n-    return new CNAMERecord(name, IN, 0, name(target));\n+    return cname(name, name(target));\n+  }\n+\n+  private static CNAMERecord cname(Name name, Name target) {\n+    return new CNAMERecord(name, IN, 120, target);\n   }\n \n-  @SuppressWarnings(\"SameParameterValue\")\n   private static DNAMERecord dname(String name, String target) {\n-    return new DNAMERecord(name(name), IN, 0, name(target));\n+    return dname(name(name), name(target));\n+  }\n+\n+  @SuppressWarnings(\"SameParameterValue\")\n+  private static DNAMERecord dname(Name name, String target) {\n+    return dname(name, name(target));\n+  }\n+\n+  private static DNAMERecord dname(Name name, Name target) {\n+    return new DNAMERecord(name, IN, 120, target);\n   }\n \n   private static Name name(String name) {\n     return Name.fromConstantString(name);\n   }\n \n-  @SuppressWarnings(\"SameParameterValue\")\n-  private <T extends Throwable> void assertThrowsCause(Class<T> ex, Executable executable) {\n-    Throwable outerException = assertThrows(Throwable.class, executable);\n-    assertEquals(ex, outerException.getCause().getClass());\n+  private LookupSession.LookupSessionBuilder lookupSession(boolean useCache) {\n+    return lookupSession(useCache, false);\n+  }\n+\n+  private LookupSession.LookupSessionBuilder lookupSession(\n+      boolean useCache, IrrelevantRecordMode mode) {\n+    return lookupSession(useCache, mode, false);\n+  }\n+\n+  private LookupSession.LookupSessionBuilder lookupSession(boolean useCache, boolean throwOnUse) {\n+    return lookupSession(useCache, IrrelevantRecordMode.REMOVE, throwOnUse);\n+  }\n+\n+  private LookupSession.LookupSessionBuilder lookupSession(\n+      boolean useCache, IrrelevantRecordMode mode, boolean throwOnUse) {\n+    LookupSession.LookupSessionBuilder builder =\n+        LookupSession.builder().resolver(mockResolver).irrelevantRecordMode(mode);\n+    if (useCache) {\n+      Cache cache = spy(new Cache());\n+      builder.cache(cache);\n+      if (throwOnUse) {\n+        lenient()\n+            .doThrow(new RuntimeException(\"Unexpected addMessage\"))\n+            .when(cache)\n+            .addMessage(any(Message.class));\n+        lenient()\n+            .doThrow(new RuntimeException(\"Unexpected addRecord\"))\n+            .when(cache)\n+            .addRecord(any(Record.class), anyInt());\n+      }\n+    }\n+\n+    return builder;\n   }\n \n   private void wireUpMockResolver(Resolver mockResolver, Function<Message, Message> handler) {\n```\n\nFilename: src/test/resources/unbound/val_adcopy.rpl:\n```\n@@ -17,7 +17,7 @@\nSCENARIO_BEGIN Test validator AD bit sent by untrusted upstream\n \n ; K.ROOT-SERVERS.NET.\n RANGE_BEGIN 0 100\n-\tADDRESS 193.0.14.129 \n+\tADDRESS 193.0.14.129\n ENTRY_BEGIN\n MATCH opcode qtype qname\n ADJUST copy_id\n\n@@ -115,13 +115,13 @@\nSECTION QUESTION\n www.example.com. IN A\n SECTION ANSWER\n www.example.com. IN A\t10.20.30.40\n-ns.example.com. 3600    IN      RRSIG   A 3 3 3600 20070926134150 20070829134150 2854 example.com. MC0CFQCQMyTjn7WWwpwAR1LlVeLpRgZGuQIUCcJDEkwAuzytTDRlYK7nIMwH1CM= ;{id = 2854}\n+www.example.com.        3600    IN      RRSIG   A 3 3 3600 20070926134150 20070829134150 2854 example.com. MC0CFC99iE9K5y2WNgI0gFvBWaTi9wm6AhUAoUqOpDtG5Zct+Qr9F3mSdnbc6V4= ;{id = 2854}\n SECTION AUTHORITY\n example.com.\tIN NS\tns.example.com.\n example.com.    3600    IN      RRSIG   NS 3 2 3600 20070926134150 20070829134150 2854 example.com. MC0CFQCN+qHdJxoI/2tNKwsb08pra/G7aAIUAWA5sDdJTbrXA1/3OaesGBAO3sI= ;{id = 2854}\n SECTION ADDITIONAL\n ns.example.com.\t\tIN \tA\t1.2.3.4\n-www.example.com.        3600    IN      RRSIG   A 3 3 3600 20070926134150 20070829134150 2854 example.com. MC0CFC99iE9K5y2WNgI0gFvBWaTi9wm6AhUAoUqOpDtG5Zct+Qr9F3mSdnbc6V4= ;{id = 2854}\n+ns.example.com. 3600    IN      RRSIG   A 3 3 3600 20070926134150 20070829134150 2854 example.com. MC0CFQCQMyTjn7WWwpwAR1LlVeLpRgZGuQIUCcJDEkwAuzytTDRlYK7nIMwH1CM= ;{id = 2854}\n ENTRY_END\n RANGE_END\n```\n\nFilename: src/test/resources/unbound/val_unalgo_anchor.rpl:\n```\n@@ -13,11 +13,11 @@\nstub-zone:\n \tstub-addr: 193.0.14.129 \t# K.ROOT-SERVERS.NET.\n CONFIG_END\n \n-SCENARIO_BEGIN Test validator with unsupported algorithm trust anchor \n+SCENARIO_BEGIN Test validator with unsupported algorithm trust anchor\n \n ; K.ROOT-SERVERS.NET.\n RANGE_BEGIN 0 100\n-\tADDRESS 193.0.14.129 \n+\tADDRESS 193.0.14.129\n ENTRY_BEGIN\n MATCH opcode qtype qname\n ADJUST copy_id\n\n@@ -115,13 +115,13 @@\nSECTION QUESTION\n www.example.com. IN A\n SECTION ANSWER\n www.example.com. IN A\t10.20.30.40\n-ns.example.com. 3600    IN      RRSIG   A 3 3 3600 20070926134150 20070829134150 2854 example.com. MC0CFQCQMyTjn7WWwpwAR1LlVeLpRgZGuQIUCcJDEkwAuzytTDRlYK7nIMwH1CM= ;{id = 2854}\n+www.example.com.        3600    IN      RRSIG   A 3 3 3600 20070926134150 20070829134150 2854 example.com. MC0CFC99iE9K5y2WNgI0gFvBWaTi9wm6AhUAoUqOpDtG5Zct+Qr9F3mSdnbc6V4= ;{id = 2854}\n SECTION AUTHORITY\n example.com.\tIN NS\tns.example.com.\n example.com.    3600    IN      RRSIG   NS 3 2 3600 20070926134150 20070829134150 2854 example.com. MC0CFQCN+qHdJxoI/2tNKwsb08pra/G7aAIUAWA5sDdJTbrXA1/3OaesGBAO3sI= ;{id = 2854}\n SECTION ADDITIONAL\n ns.example.com.\t\tIN \tA\t1.2.3.4\n-www.example.com.        3600    IN      RRSIG   A 3 3 3600 20070926134150 20070829134150 2854 example.com. MC0CFC99iE9K5y2WNgI0gFvBWaTi9wm6AhUAoUqOpDtG5Zct+Qr9F3mSdnbc6V4= ;{id = 2854}\n+ns.example.com. 3600    IN      RRSIG   A 3 3 3600 20070926134150 20070829134150 2854 example.com. MC0CFQCQMyTjn7WWwpwAR1LlVeLpRgZGuQIUCcJDEkwAuzytTDRlYK7nIMwH1CM= ;{id = 2854}\n ENTRY_END\n RANGE_END\n```"
            }
        ],
        "sw_version": "v3.5.3",
        "sw_version_wget": "https://github.com/dnsjava/dnsjava/archive/refs/tags/v3.5.3.zip",
        "description": "dnsjava is an implementation of DNS in Java. Records in DNS replies are not checked for their relevance to the query, allowing an attacker to respond with RRs from different zones. This vulnerability is fixed in 3.6.0.",
        "sec_adv": [
            {
                "url": "https://github.com/dnsjava/dnsjava/security/advisories/GHSA-cfxw-4h78-h7fw",
                "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\ndnsjava\n/\ndnsjava\nPublic\nNotifications You must be signed in to change notification settings\nFork 247\nStar 993\nCode\nIssues\n16\nPull requests\n3\nActions\nProjects\nSecurity\n3\nInsights\nAdditional navigation options\nImproper response validation allowing DNSSEC Bypass\nHigh ibauersachs published GHSA-cfxw-4h78-h7fw on Jul 21, 2024Jul 21, 2024\nPackage\nmaven dnsjava:dnsjava\n(\nMaven\n)\nAffected versions\n3.5.0\nPatched versions\n3.6.0\nDescription\nSummary\nRecords in DNS replies are not checked for their relevance to the query, allowing an attacker to respond with RRs from different zones.\nDetails\nDNS Messages are not authenticated. They do not guarantee that\nreceived RRs are authentic\nnot received RRs do not exist\nall or any received records in a response relate to the request\nApplications utilizing DNSSEC generally expect these guarantees to be met, however DNSSEC by itself only guarantees the first two.\nTo meet the third guarantee, resolvers generally follow an (undocumented, as far as RFCs go1) algorithm such as: (simplified, e.g. lacks DNSSEC validation!)\ndenote by QNAME the name you are querying (e.g. fraunhofer.de.), and initialize a list of aliases\nif the ANSWER section contains a valid PTR RRSet for QNAME, return it (and optionally return the list of aliases as well)\nif the ANSWER section contains a valid CNAME RRSet for QNAME, add it to the list of aliases. Set QNAME to the CNAME's target and go to 2.\nVerify that QNAME does not have any PTR, CNAME and DNAME records using valid NSEC or NSEC3 records. Return null.\nNote that this algorithm relies on NSEC records and thus requires a considerable portion of the DNSSEC specifications to be implemented. For this reason, it cannot be performed by a DNS client (aka application) and is typically performed as part of the resolver logic.\nAs far as we can tell, dnsjava does not implement a comparable algorithm, and the provided APIs instead return either\nthe received DNS message itself (e.g. when using a ValidatingResolver such as in this example), or\nessentially just the contents of its ANSWER section (e.g. when using a LookupSession such as in this example)\nIf applications blindly filter the received results for RRs of the desired record type (as seems to be typical usage for dnsjava), a rogue recursive resolver or (on UDP/TCP connections) a network attacker can\nIn addition to the actual DNS response, add RRs irrelevant to the query but of the right datatype, e.g. from another zone, as long as that zone is correctly using DNSSEC, or\ncompletely exchange the relevant response records\nImpact\nDNS(SEC) libraries are usually used as part of a larger security framework.\nTherefore, the main misuses of this vulnerability concern application code, which might take the returned records as authentic answers to the request.\nWe give three concrete examples of where this might be detrimental:\nRFC 6186 specifies that to connect to an IMAP server for a user, a mail user agent should retrieve certain SRV records and send the user's credentials to the specified servers. Exchanging the SRV records can be a tool to redirect the credentials.\nWhen delivering mail via SMTP, MX records determine where to deliver the mails to. Exchanging the MX records might lead to information disclosure. Additionally, an exchange of TLSA records might allow attackers to intercept TLS traffic.\nSome research projects like LIGHTest are trying to manage CA trust stores via URI and SMIMEA records in the DNS. Exchanging these allows manipulating the root of trust for dependent applications.\nMitigations\nAt this point, we recommend the following mitigations:\nWhen using a ValidatingResolver, ignore any Server indications of whether or not data was available (e.g. NXDOMAIN, NODATA, ...).\nFor APIs returning RRs from DNS responses, filter the RRs using an algorithm such as the one above. This includes e.g. LookupSession.lookupAsync.\nRemove APIs dealing with raw DNS messages from the examples section or place a noticable warning above.\nIf you have any questions about the report, please do not hesitate to contact us.\nBest regards,\nThomas Bellebaum, Fraunhofer AISEC\nFootnotes\nWe have contacted the DNSOP WG at the IETF to ask for guidance, but so far this has yet to reveal anything helpful other than a connection to DNS cache poisoning attacks. \nSeverity\nHigh\n8.9\n/ 10\nCVSS v3 base metrics\nAttack vector\nNetwork\nAttack complexity\nHigh\nPrivileges required\nNone\nUser interaction\nNone\nScope\nChanged\nConfidentiality\nHigh\nIntegrity\nHigh\nAvailability\nLow\nLearn more about base metrics\nCVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:L\nCVE ID\nCVE-2024-25638\nWeaknesses\nCWE-345 CWE-349\nCredits\nbellebaum\nFinder\nschanzen\nCoordinator\nmilux\nTool\nFooter\n 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
                "effective": false,
                "effective_reason": "The advisory does not provide proof of concept code or exact reproduction steps but discusses the conditions and implications."
            }
        ],
        "cwe": [
            {
                "id": "CWE-345",
                "value": "CWE-345: Insufficient Verification of Data Authenticity"
            },
            {
                "id": "CWE-349",
                "value": "CWE-349: Acceptance of Extraneous Untrusted Data With Trusted Data"
            }
        ]
    }
}