{
    "CVE-2024-6923": {
        "published_date": "2024-08-01T13:40:11.069Z",
        "patch_commits": [
            {
                "url": "https://github.com/python/cpython/commit/4766d1200fdf8b6728137aa2927a297e224d5fa7",
                "content": "[3.12] gh-121650: Encode newlines in headers, and verify headers are sound (GH-122233) (#122599)\n\n* gh-121650: Encode newlines in headers, and verify headers are sound (GH-122233)\r\n\r\n- Encode header parts that contain newlines\r\n\r\nPer RFC 2047:\r\n\r\n> [...] these encoding schemes allow the\r\n> encoding of arbitrary octet values, mail readers that implement this\r\n> decoding should also ensure that display of the decoded data on the\r\n> recipient's terminal will not cause unwanted side-effects\r\n\r\nIt seems that the \"quoted-word\" scheme is a valid way to include\r\na newline character in a header value, just like we already allow\r\nundecodable bytes or control characters.\r\nThey do need to be properly quoted when serialized to text, though.\r\n\r\n- Verify that email headers are well-formed\r\n\r\nThis should fail for custom fold() implementations that aren't careful\r\nabout newlines.\r\n\r\nCo-authored-by: Bas Bloemsaat <bas@bloemsaat.org>\r\nCo-authored-by: Serhiy Storchaka <storchaka@gmail.com>\r\n(cherry picked from commit 097633981879b3c9de9a1dd120d3aa585ecc2384)\r\n\r\n* Document changes as made in 3.12.5\n\nFilename: Doc/library/email.errors.rst:\n```\n@@ -58,6 +58,13 @@\nThe following exception classes are defined in the :mod:`email.errors` module:\n    :class:`~email.mime.nonmultipart.MIMENonMultipart` (e.g.\n    :class:`~email.mime.image.MIMEImage`).\n \n+\n+.. exception:: HeaderWriteError()\n+\n+   Raised when an error occurs when the :mod:`~email.generator` outputs\n+   headers.\n+\n+\n .. exception:: MessageDefect()\n \n    This is the base class for all defects found when parsing email messages.\n```\n\nFilename: Doc/library/email.policy.rst:\n```\n@@ -229,6 +229,24 @@\nadded matters.  To illustrate::\n \n       .. versionadded:: 3.6\n \n+\n+   .. attribute:: verify_generated_headers\n+\n+      If ``True`` (the default), the generator will raise\n+      :exc:`~email.errors.HeaderWriteError` instead of writing a header\n+      that is improperly folded or delimited, such that it would\n+      be parsed as multiple headers or joined with adjacent data.\n+      Such headers can be generated by custom header classes or bugs\n+      in the ``email`` module.\n+\n+      As it's a security feature, this defaults to ``True`` even in the\n+      :class:`~email.policy.Compat32` policy.\n+      For backwards compatible, but unsafe, behavior, it must be set to\n+      ``False`` explicitly.\n+\n+      .. versionadded:: 3.12.5\n+\n+\n    The following :class:`Policy` method is intended to be called by code using\n    the email library to create policy instances with custom settings:\n```\n\nFilename: Doc/whatsnew/3.12.rst:\n```\n@@ -2260,3 +2260,20 @@\nipaddress\n \n * Fixed ``is_global`` and ``is_private`` behavior in ``IPv4Address``,\n   ``IPv6Address``, ``IPv4Network`` and ``IPv6Network``.\n+\n+\n+Notable changes in 3.12.5\n+=========================\n+\n+email\n+-----\n+\n+\n+* Headers with embedded newlines are now quoted on output.\n+\n+  The :mod:`~email.generator` will now refuse to serialize (write) headers\n+  that are improperly folded or delimited, such that they would be parsed as\n+  multiple headers or joined with adjacent data.\n+  If you need to turn this safety feature off,\n+  set :attr:`~email.policy.Policy.verify_generated_headers`.\n+  (Contributed by Bas Bloemsaat and Petr Viktorin in :gh:`121650`.)\n```\n\nFilename: Lib/email/_header_value_parser.py:\n```\n@@ -92,6 +92,8 @@\nASPECIALS = TSPECIALS | set(\"*'%\")\n ATTRIBUTE_ENDS = ASPECIALS | WSP\n EXTENDED_ATTRIBUTE_ENDS = ATTRIBUTE_ENDS - set('%')\n+NLSET = {'\\n', '\\r'}\n+SPECIALSNL = SPECIALS | NLSET\n \n def quote_string(value):\n     return '\"'+str(value).replace('\\\\', '\\\\\\\\').replace('\"', r'\\\"')+'\"'\n\n@@ -2802,9 +2804,13 @@\ndef _refold_parse_tree(parse_tree, *, policy):\n             wrap_as_ew_blocked -= 1\n             continue\n         tstr = str(part)\n-        if part.token_type == 'ptext' and set(tstr) & SPECIALS:\n-            # Encode if tstr contains special characters.\n-            want_encoding = True\n+        if not want_encoding:\n+            if part.token_type == 'ptext':\n+                # Encode if tstr contains special characters.\n+                want_encoding = not SPECIALSNL.isdisjoint(tstr)\n+            else:\n+                # Encode if tstr contains newlines.\n+                want_encoding = not NLSET.isdisjoint(tstr)\n         try:\n             tstr.encode(encoding)\n             charset = encoding\n```\n\nFilename: Lib/email/_policybase.py:\n```\n@@ -157,6 +157,13 @@\nclass Policy(_PolicyBase, metaclass=abc.ABCMeta):\n     message_factory     -- the class to use to create new message objects.\n                            If the value is None, the default is Message.\n \n+    verify_generated_headers\n+                        -- if true, the generator verifies that each header\n+                           they are properly folded, so that a parser won't\n+                           treat it as multiple headers, start-of-body, or\n+                           part of another header.\n+                           This is a check against custom Header & fold()\n+                           implementations.\n     \"\"\"\n \n     raise_on_defect = False\n\n@@ -165,6 +172,7 @@\nclass Policy(_PolicyBase, metaclass=abc.ABCMeta):\n     max_line_length = 78\n     mangle_from_ = False\n     message_factory = None\n+    verify_generated_headers = True\n \n     def handle_defect(self, obj, defect):\n         \"\"\"Based on policy, either raise defect or call register_defect.\n```\n\nFilename: Lib/email/errors.py:\n```\n@@ -29,6 +29,10 @@\nclass CharsetError(MessageError):\n     \"\"\"An illegal charset was given.\"\"\"\n \n \n+class HeaderWriteError(MessageError):\n+    \"\"\"Error while writing headers.\"\"\"\n+\n+\n # These are parsing defects which the parser was able to work around.\n class MessageDefect(ValueError):\n     \"\"\"Base class for a message defect.\"\"\"\n```\n\nFilename: Lib/email/generator.py:\n```\n@@ -14,12 +14,14 @@\nfrom copy import deepcopy\n from io import StringIO, BytesIO\n from email.utils import _has_surrogates\n+from email.errors import HeaderWriteError\n \n UNDERSCORE = '_'\n NL = '\\n'  # XXX: no longer used by the code below.\n \n NLCRE = re.compile(r'\\r\\n|\\r|\\n')\n fcre = re.compile(r'^From ', re.MULTILINE)\n+NEWLINE_WITHOUT_FWSP = re.compile(r'\\r\\n[^ \\t]|\\r[^ \\n\\t]|\\n[^ \\t]')\n \n \n class Generator:\n\n@@ -222,7 +224,16 @@\ndef _dispatch(self, msg):\n \n     def _write_headers(self, msg):\n         for h, v in msg.raw_items():\n-            self.write(self.policy.fold(h, v))\n+            folded = self.policy.fold(h, v)\n+            if self.policy.verify_generated_headers:\n+                linesep = self.policy.linesep\n+                if not folded.endswith(self.policy.linesep):\n+                    raise HeaderWriteError(\n+                        f'folded header does not end with {linesep!r}: {folded!r}')\n+                if NEWLINE_WITHOUT_FWSP.search(folded.removesuffix(linesep)):\n+                    raise HeaderWriteError(\n+                        f'folded header contains newline: {folded!r}')\n+            self.write(folded)\n         # A blank line always separates headers from body\n         self.write(self._NL)\n```\n\nFilename: Lib/test/test_email/test_generator.py:\n```\n@@ -6,6 +6,7 @@\nfrom email.generator import Generator, BytesGenerator\n from email.headerregistry import Address\n from email import policy\n+import email.errors\n from test.test_email import TestEmailBase, parameterize\n\n@@ -249,6 +250,44 @@\ndef test_rfc2231_wrapping_switches_to_default_len_if_too_narrow(self):\n         g.flatten(msg)\n         self.assertEqual(s.getvalue(), self.typ(expected))\n \n+    def test_keep_encoded_newlines(self):\n+        msg = self.msgmaker(self.typ(textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")))\n+        expected = textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")\n+        s = self.ioclass()\n+        g = self.genclass(s, policy=self.policy.clone(max_line_length=80))\n+        g.flatten(msg)\n+        self.assertEqual(s.getvalue(), self.typ(expected))\n+\n+    def test_keep_long_encoded_newlines(self):\n+        msg = self.msgmaker(self.typ(textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")))\n+        expected = textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject\n+             =?utf-8?q?=0A?=Bcc:\n+             injection@example.com\n+\n+            None\n+            \"\"\")\n+        s = self.ioclass()\n+        g = self.genclass(s, policy=self.policy.clone(max_line_length=30))\n+        g.flatten(msg)\n+        self.assertEqual(s.getvalue(), self.typ(expected))\n+\n \n class TestGenerator(TestGeneratorBase, TestEmailBase):\n\n@@ -273,6 +312,29 @@\ndef test_flatten_unicode_linesep(self):\n         g.flatten(msg)\n         self.assertEqual(s.getvalue(), self.typ(expected))\n \n+    def test_verify_generated_headers(self):\n+        \"\"\"gh-121650: by default the generator prevents header injection\"\"\"\n+        class LiteralHeader(str):\n+            name = 'Header'\n+            def fold(self, **kwargs):\n+                return self\n+\n+        for text in (\n+            'Value\\r\\nBad Injection\\r\\n',\n+            'NoNewLine'\n+        ):\n+            with self.subTest(text=text):\n+                message = message_from_string(\n+                    \"Header: Value\\r\\n\\r\\nBody\",\n+                    policy=self.policy,\n+                )\n+\n+                del message['Header']\n+                message['Header'] = LiteralHeader(text)\n+\n+                with self.assertRaises(email.errors.HeaderWriteError):\n+                    message.as_string()\n+\n \n class TestBytesGenerator(TestGeneratorBase, TestEmailBase):\n```\n\nFilename: Lib/test/test_email/test_policy.py:\n```\n@@ -26,6 +26,7 @@\nclass PolicyAPITests(unittest.TestCase):\n         'raise_on_defect':          False,\n         'mangle_from_':             True,\n         'message_factory':          None,\n+        'verify_generated_headers': True,\n         }\n     # These default values are the ones set on email.policy.default.\n     # If any of these defaults change, the docs must be updated.\n\n@@ -294,6 +295,31 @@\ndef test_short_maxlen_error(self):\n                 with self.assertRaises(email.errors.HeaderParseError):\n                     policy.fold(\"Subject\", subject)\n \n+    def test_verify_generated_headers(self):\n+        \"\"\"Turning protection off allows header injection\"\"\"\n+        policy = email.policy.default.clone(verify_generated_headers=False)\n+        for text in (\n+            'Header: Value\\r\\nBad: Injection\\r\\n',\n+            'Header: NoNewLine'\n+        ):\n+            with self.subTest(text=text):\n+                message = email.message_from_string(\n+                    \"Header: Value\\r\\n\\r\\nBody\",\n+                    policy=policy,\n+                )\n+                class LiteralHeader(str):\n+                    name = 'Header'\n+                    def fold(self, **kwargs):\n+                        return self\n+\n+                del message['Header']\n+                message['Header'] = LiteralHeader(text)\n+\n+                self.assertEqual(\n+                    message.as_string(),\n+                    f\"{text}\\nBody\",\n+                )\n+\n     # XXX: Need subclassing tests.\n     # For adding subclassed objects, make sure the usual rules apply (subclass\n     # wins), but that the order still works (right overrides left).\n```\n\nFilename: Misc/NEWS.d/next/Library/2024-07-27-16-10-41.gh-issue-121650.nf6oc9.rst:\n```\n@@ -0,0 +1,5 @@\n+:mod:`email` headers with embedded newlines are now quoted on output. The\n+:mod:`~email.generator` will now refuse to serialize (write) headers that\n+are unsafely folded or delimited; see\n+:attr:`~email.policy.Policy.verify_generated_headers`. (Contributed by Bas\n+Bloemsaat and Petr Viktorin in :gh:`121650`.)\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/4aaa4259b5a6e664b7316a4d60bdec7ee0f124d0",
                "content": "[3.13] gh-121650: Encode newlines in headers, and verify headers are sound (GH-122233) (#122484)\n\ngh-121650: Encode newlines in headers, and verify headers are sound (GH-122233)\r\n\r\nGH-GH- Encode header parts that contain newlines\r\n\r\nPer RFC 2047:\r\n\r\n> [...] these encoding schemes allow the\r\n> encoding of arbitrary octet values, mail readers that implement this\r\n> decoding should also ensure that display of the decoded data on the\r\n> recipient's terminal will not cause unwanted side-effects\r\n\r\nIt seems that the \"quoted-word\" scheme is a valid way to include\r\na newline character in a header value, just like we already allow\r\nundecodable bytes or control characters.\r\nThey do need to be properly quoted when serialized to text, though.\r\n\r\nGH-GH- Verify that email headers are well-formed\r\n\r\nThis should fail for custom fold() implementations that aren't careful\r\nabout newlines.\r\n\r\n(cherry picked from commit 097633981879b3c9de9a1dd120d3aa585ecc2384)\r\n\r\nCo-authored-by: Petr Viktorin <encukou@gmail.com>\r\nCo-authored-by: Bas Bloemsaat <bas@bloemsaat.org>\r\nCo-authored-by: Serhiy Storchaka <storchaka@gmail.com>\n\nFilename: Doc/library/email.errors.rst:\n```\n@@ -58,6 +58,13 @@\nThe following exception classes are defined in the :mod:`email.errors` module:\n    :class:`~email.mime.nonmultipart.MIMENonMultipart` (e.g.\n    :class:`~email.mime.image.MIMEImage`).\n \n+\n+.. exception:: HeaderWriteError()\n+\n+   Raised when an error occurs when the :mod:`~email.generator` outputs\n+   headers.\n+\n+\n .. exception:: MessageDefect()\n \n    This is the base class for all defects found when parsing email messages.\n```\n\nFilename: Doc/library/email.policy.rst:\n```\n@@ -229,6 +229,24 @@\nadded matters.  To illustrate::\n \n       .. versionadded:: 3.6\n \n+\n+   .. attribute:: verify_generated_headers\n+\n+      If ``True`` (the default), the generator will raise\n+      :exc:`~email.errors.HeaderWriteError` instead of writing a header\n+      that is improperly folded or delimited, such that it would\n+      be parsed as multiple headers or joined with adjacent data.\n+      Such headers can be generated by custom header classes or bugs\n+      in the ``email`` module.\n+\n+      As it's a security feature, this defaults to ``True`` even in the\n+      :class:`~email.policy.Compat32` policy.\n+      For backwards compatible, but unsafe, behavior, it must be set to\n+      ``False`` explicitly.\n+\n+      .. versionadded:: 3.13\n+\n+\n    The following :class:`Policy` method is intended to be called by code using\n    the email library to create policy instances with custom settings:\n```\n\nFilename: Doc/whatsnew/3.13.rst:\n```\n@@ -724,6 +724,15 @@\ndoctest\n email\n -----\n \n+* Headers with embedded newlines are now quoted on output.\n+\n+  The :mod:`~email.generator` will now refuse to serialize (write) headers\n+  that are improperly folded or delimited, such that they would be parsed as\n+  multiple headers or joined with adjacent data.\n+  If you need to turn this safety feature off,\n+  set :attr:`~email.policy.Policy.verify_generated_headers`.\n+  (Contributed by Bas Bloemsaat and Petr Viktorin in :gh:`121650`.)\n+\n * :func:`email.utils.getaddresses` and :func:`email.utils.parseaddr` now return\n   ``('', '')`` 2-tuples in more situations where invalid email addresses are\n   encountered instead of potentially inaccurate values. Add optional *strict*\n```\n\nFilename: Lib/email/_header_value_parser.py:\n```\n@@ -92,6 +92,8 @@\nASPECIALS = TSPECIALS | set(\"*'%\")\n ATTRIBUTE_ENDS = ASPECIALS | WSP\n EXTENDED_ATTRIBUTE_ENDS = ATTRIBUTE_ENDS - set('%')\n+NLSET = {'\\n', '\\r'}\n+SPECIALSNL = SPECIALS | NLSET\n \n def quote_string(value):\n     return '\"'+str(value).replace('\\\\', '\\\\\\\\').replace('\"', r'\\\"')+'\"'\n\n@@ -2802,9 +2804,13 @@\ndef _refold_parse_tree(parse_tree, *, policy):\n             wrap_as_ew_blocked -= 1\n             continue\n         tstr = str(part)\n-        if part.token_type == 'ptext' and set(tstr) & SPECIALS:\n-            # Encode if tstr contains special characters.\n-            want_encoding = True\n+        if not want_encoding:\n+            if part.token_type == 'ptext':\n+                # Encode if tstr contains special characters.\n+                want_encoding = not SPECIALSNL.isdisjoint(tstr)\n+            else:\n+                # Encode if tstr contains newlines.\n+                want_encoding = not NLSET.isdisjoint(tstr)\n         try:\n             tstr.encode(encoding)\n             charset = encoding\n```\n\nFilename: Lib/email/_policybase.py:\n```\n@@ -157,6 +157,13 @@\nclass Policy(_PolicyBase, metaclass=abc.ABCMeta):\n     message_factory     -- the class to use to create new message objects.\n                            If the value is None, the default is Message.\n \n+    verify_generated_headers\n+                        -- if true, the generator verifies that each header\n+                           they are properly folded, so that a parser won't\n+                           treat it as multiple headers, start-of-body, or\n+                           part of another header.\n+                           This is a check against custom Header & fold()\n+                           implementations.\n     \"\"\"\n \n     raise_on_defect = False\n\n@@ -165,6 +172,7 @@\nclass Policy(_PolicyBase, metaclass=abc.ABCMeta):\n     max_line_length = 78\n     mangle_from_ = False\n     message_factory = None\n+    verify_generated_headers = True\n \n     def handle_defect(self, obj, defect):\n         \"\"\"Based on policy, either raise defect or call register_defect.\n```\n\nFilename: Lib/email/errors.py:\n```\n@@ -29,6 +29,10 @@\nclass CharsetError(MessageError):\n     \"\"\"An illegal charset was given.\"\"\"\n \n \n+class HeaderWriteError(MessageError):\n+    \"\"\"Error while writing headers.\"\"\"\n+\n+\n # These are parsing defects which the parser was able to work around.\n class MessageDefect(ValueError):\n     \"\"\"Base class for a message defect.\"\"\"\n```\n\nFilename: Lib/email/generator.py:\n```\n@@ -14,12 +14,14 @@\nfrom copy import deepcopy\n from io import StringIO, BytesIO\n from email.utils import _has_surrogates\n+from email.errors import HeaderWriteError\n \n UNDERSCORE = '_'\n NL = '\\n'  # XXX: no longer used by the code below.\n \n NLCRE = re.compile(r'\\r\\n|\\r|\\n')\n fcre = re.compile(r'^From ', re.MULTILINE)\n+NEWLINE_WITHOUT_FWSP = re.compile(r'\\r\\n[^ \\t]|\\r[^ \\n\\t]|\\n[^ \\t]')\n \n \n class Generator:\n\n@@ -222,7 +224,16 @@\ndef _dispatch(self, msg):\n \n     def _write_headers(self, msg):\n         for h, v in msg.raw_items():\n-            self.write(self.policy.fold(h, v))\n+            folded = self.policy.fold(h, v)\n+            if self.policy.verify_generated_headers:\n+                linesep = self.policy.linesep\n+                if not folded.endswith(self.policy.linesep):\n+                    raise HeaderWriteError(\n+                        f'folded header does not end with {linesep!r}: {folded!r}')\n+                if NEWLINE_WITHOUT_FWSP.search(folded.removesuffix(linesep)):\n+                    raise HeaderWriteError(\n+                        f'folded header contains newline: {folded!r}')\n+            self.write(folded)\n         # A blank line always separates headers from body\n         self.write(self._NL)\n```\n\nFilename: Lib/test/test_email/test_generator.py:\n```\n@@ -6,6 +6,7 @@\nfrom email.generator import Generator, BytesGenerator\n from email.headerregistry import Address\n from email import policy\n+import email.errors\n from test.test_email import TestEmailBase, parameterize\n\n@@ -249,6 +250,44 @@\ndef test_rfc2231_wrapping_switches_to_default_len_if_too_narrow(self):\n         g.flatten(msg)\n         self.assertEqual(s.getvalue(), self.typ(expected))\n \n+    def test_keep_encoded_newlines(self):\n+        msg = self.msgmaker(self.typ(textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")))\n+        expected = textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")\n+        s = self.ioclass()\n+        g = self.genclass(s, policy=self.policy.clone(max_line_length=80))\n+        g.flatten(msg)\n+        self.assertEqual(s.getvalue(), self.typ(expected))\n+\n+    def test_keep_long_encoded_newlines(self):\n+        msg = self.msgmaker(self.typ(textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")))\n+        expected = textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject\n+             =?utf-8?q?=0A?=Bcc:\n+             injection@example.com\n+\n+            None\n+            \"\"\")\n+        s = self.ioclass()\n+        g = self.genclass(s, policy=self.policy.clone(max_line_length=30))\n+        g.flatten(msg)\n+        self.assertEqual(s.getvalue(), self.typ(expected))\n+\n \n class TestGenerator(TestGeneratorBase, TestEmailBase):\n\n@@ -273,6 +312,29 @@\ndef test_flatten_unicode_linesep(self):\n         g.flatten(msg)\n         self.assertEqual(s.getvalue(), self.typ(expected))\n \n+    def test_verify_generated_headers(self):\n+        \"\"\"gh-121650: by default the generator prevents header injection\"\"\"\n+        class LiteralHeader(str):\n+            name = 'Header'\n+            def fold(self, **kwargs):\n+                return self\n+\n+        for text in (\n+            'Value\\r\\nBad Injection\\r\\n',\n+            'NoNewLine'\n+        ):\n+            with self.subTest(text=text):\n+                message = message_from_string(\n+                    \"Header: Value\\r\\n\\r\\nBody\",\n+                    policy=self.policy,\n+                )\n+\n+                del message['Header']\n+                message['Header'] = LiteralHeader(text)\n+\n+                with self.assertRaises(email.errors.HeaderWriteError):\n+                    message.as_string()\n+\n \n class TestBytesGenerator(TestGeneratorBase, TestEmailBase):\n```\n\nFilename: Lib/test/test_email/test_policy.py:\n```\n@@ -26,6 +26,7 @@\nclass PolicyAPITests(unittest.TestCase):\n         'raise_on_defect':          False,\n         'mangle_from_':             True,\n         'message_factory':          None,\n+        'verify_generated_headers': True,\n         }\n     # These default values are the ones set on email.policy.default.\n     # If any of these defaults change, the docs must be updated.\n\n@@ -294,6 +295,31 @@\ndef test_short_maxlen_error(self):\n                 with self.assertRaises(email.errors.HeaderParseError):\n                     policy.fold(\"Subject\", subject)\n \n+    def test_verify_generated_headers(self):\n+        \"\"\"Turning protection off allows header injection\"\"\"\n+        policy = email.policy.default.clone(verify_generated_headers=False)\n+        for text in (\n+            'Header: Value\\r\\nBad: Injection\\r\\n',\n+            'Header: NoNewLine'\n+        ):\n+            with self.subTest(text=text):\n+                message = email.message_from_string(\n+                    \"Header: Value\\r\\n\\r\\nBody\",\n+                    policy=policy,\n+                )\n+                class LiteralHeader(str):\n+                    name = 'Header'\n+                    def fold(self, **kwargs):\n+                        return self\n+\n+                del message['Header']\n+                message['Header'] = LiteralHeader(text)\n+\n+                self.assertEqual(\n+                    message.as_string(),\n+                    f\"{text}\\nBody\",\n+                )\n+\n     # XXX: Need subclassing tests.\n     # For adding subclassed objects, make sure the usual rules apply (subclass\n     # wins), but that the order still works (right overrides left).\n```\n\nFilename: Misc/NEWS.d/next/Library/2024-07-27-16-10-41.gh-issue-121650.nf6oc9.rst:\n```\n@@ -0,0 +1,5 @@\n+:mod:`email` headers with embedded newlines are now quoted on output. The\n+:mod:`~email.generator` will now refuse to serialize (write) headers that\n+are unsafely folded or delimited; see\n+:attr:`~email.policy.Policy.verify_generated_headers`. (Contributed by Bas\n+Bloemsaat and Petr Viktorin in :gh:`121650`.)\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/06f28dc236708f72871c64d4bc4b4ea144c50147",
                "content": "[3.10] gh-121650: Encode newlines in headers, and verify headers are sound (GH-122233) (#122609)\n\nPer RFC 2047:\r\n\r\n> [...] these encoding schemes allow the\r\n> encoding of arbitrary octet values, mail readers that implement this\r\n> decoding should also ensure that display of the decoded data on the\r\n> recipient's terminal will not cause unwanted side-effects\r\n\r\nIt seems that the \"quoted-word\" scheme is a valid way to include\r\na newline character in a header value, just like we already allow\r\nundecodable bytes or control characters.\r\nThey do need to be properly quoted when serialized to text, though.\r\n\r\nThis should fail for custom fold() implementations that aren't careful\r\nabout newlines.\r\n\r\n(cherry picked from commit 097633981879b3c9de9a1dd120d3aa585ecc2384)\r\n\r\nCo-authored-by: Petr Viktorin <encukou@gmail.com>\r\nCo-authored-by: Bas Bloemsaat <bas@bloemsaat.org>\r\nCo-authored-by: Serhiy Storchaka <storchaka@gmail.com>\n\nFilename: Doc/library/email.errors.rst:\n```\n@@ -59,6 +59,12 @@\nThe following exception classes are defined in the :mod:`email.errors` module:\n    :class:`~email.mime.image.MIMEImage`).\n \n \n+.. exception:: HeaderWriteError()\n+\n+   Raised when an error occurs when the :mod:`~email.generator` outputs\n+   headers.\n+\n+\n Here is the list of the defects that the :class:`~email.parser.FeedParser`\n can find while parsing messages.  Note that the defects are added to the message\n where the problem was found, so for example, if a message nested inside a\n```\n\nFilename: Doc/library/email.policy.rst:\n```\n@@ -229,6 +229,24 @@\nadded matters.  To illustrate::\n \n       .. versionadded:: 3.6\n \n+\n+   .. attribute:: verify_generated_headers\n+\n+      If ``True`` (the default), the generator will raise\n+      :exc:`~email.errors.HeaderWriteError` instead of writing a header\n+      that is improperly folded or delimited, such that it would\n+      be parsed as multiple headers or joined with adjacent data.\n+      Such headers can be generated by custom header classes or bugs\n+      in the ``email`` module.\n+\n+      As it's a security feature, this defaults to ``True`` even in the\n+      :class:`~email.policy.Compat32` policy.\n+      For backwards compatible, but unsafe, behavior, it must be set to\n+      ``False`` explicitly.\n+\n+      .. versionadded:: 3.10.15\n+\n+\n    The following :class:`Policy` method is intended to be called by code using\n    the email library to create policy instances with custom settings:\n```\n\nFilename: Doc/whatsnew/3.10.rst:\n```\n@@ -2372,3 +2372,15 @@\nipaddress\n \n * Fixed ``is_global`` and ``is_private`` behavior in ``IPv4Address``,\n   ``IPv6Address``, ``IPv4Network`` and ``IPv6Network``.\n+\n+email\n+-----\n+\n+* Headers with embedded newlines are now quoted on output.\n+\n+  The :mod:`~email.generator` will now refuse to serialize (write) headers\n+  that are improperly folded or delimited, such that they would be parsed as\n+  multiple headers or joined with adjacent data.\n+  If you need to turn this safety feature off,\n+  set :attr:`~email.policy.Policy.verify_generated_headers`.\n+  (Contributed by Bas Bloemsaat and Petr Viktorin in :gh:`121650`.)\n```\n\nFilename: Lib/email/_header_value_parser.py:\n```\n@@ -92,6 +92,8 @@\nASPECIALS = TSPECIALS | set(\"*'%\")\n ATTRIBUTE_ENDS = ASPECIALS | WSP\n EXTENDED_ATTRIBUTE_ENDS = ATTRIBUTE_ENDS - set('%')\n+NLSET = {'\\n', '\\r'}\n+SPECIALSNL = SPECIALS | NLSET\n \n def quote_string(value):\n     return '\"'+str(value).replace('\\\\', '\\\\\\\\').replace('\"', r'\\\"')+'\"'\n\n@@ -2778,9 +2780,13 @@\ndef _refold_parse_tree(parse_tree, *, policy):\n             wrap_as_ew_blocked -= 1\n             continue\n         tstr = str(part)\n-        if part.token_type == 'ptext' and set(tstr) & SPECIALS:\n-            # Encode if tstr contains special characters.\n-            want_encoding = True\n+        if not want_encoding:\n+            if part.token_type == 'ptext':\n+                # Encode if tstr contains special characters.\n+                want_encoding = not SPECIALSNL.isdisjoint(tstr)\n+            else:\n+                # Encode if tstr contains newlines.\n+                want_encoding = not NLSET.isdisjoint(tstr)\n         try:\n             tstr.encode(encoding)\n             charset = encoding\n```\n\nFilename: Lib/email/_policybase.py:\n```\n@@ -157,6 +157,13 @@\nclass Policy(_PolicyBase, metaclass=abc.ABCMeta):\n     message_factory     -- the class to use to create new message objects.\n                            If the value is None, the default is Message.\n \n+    verify_generated_headers\n+                        -- if true, the generator verifies that each header\n+                           they are properly folded, so that a parser won't\n+                           treat it as multiple headers, start-of-body, or\n+                           part of another header.\n+                           This is a check against custom Header & fold()\n+                           implementations.\n     \"\"\"\n \n     raise_on_defect = False\n\n@@ -165,6 +172,7 @@\nclass Policy(_PolicyBase, metaclass=abc.ABCMeta):\n     max_line_length = 78\n     mangle_from_ = False\n     message_factory = None\n+    verify_generated_headers = True\n \n     def handle_defect(self, obj, defect):\n         \"\"\"Based on policy, either raise defect or call register_defect.\n```\n\nFilename: Lib/email/errors.py:\n```\n@@ -29,6 +29,10 @@\nclass CharsetError(MessageError):\n     \"\"\"An illegal charset was given.\"\"\"\n \n \n+class HeaderWriteError(MessageError):\n+    \"\"\"Error while writing headers.\"\"\"\n+\n+\n # These are parsing defects which the parser was able to work around.\n class MessageDefect(ValueError):\n     \"\"\"Base class for a message defect.\"\"\"\n```\n\nFilename: Lib/email/generator.py:\n```\n@@ -14,12 +14,14 @@\nfrom copy import deepcopy\n from io import StringIO, BytesIO\n from email.utils import _has_surrogates\n+from email.errors import HeaderWriteError\n \n UNDERSCORE = '_'\n NL = '\\n'  # XXX: no longer used by the code below.\n \n NLCRE = re.compile(r'\\r\\n|\\r|\\n')\n fcre = re.compile(r'^From ', re.MULTILINE)\n+NEWLINE_WITHOUT_FWSP = re.compile(r'\\r\\n[^ \\t]|\\r[^ \\n\\t]|\\n[^ \\t]')\n\n@@ -223,7 +225,16 @@\ndef _dispatch(self, msg):\n \n     def _write_headers(self, msg):\n         for h, v in msg.raw_items():\n-            self.write(self.policy.fold(h, v))\n+            folded = self.policy.fold(h, v)\n+            if self.policy.verify_generated_headers:\n+                linesep = self.policy.linesep\n+                if not folded.endswith(self.policy.linesep):\n+                    raise HeaderWriteError(\n+                        f'folded header does not end with {linesep!r}: {folded!r}')\n+                if NEWLINE_WITHOUT_FWSP.search(folded.removesuffix(linesep)):\n+                    raise HeaderWriteError(\n+                        f'folded header contains newline: {folded!r}')\n+            self.write(folded)\n         # A blank line always separates headers from body\n         self.write(self._NL)\n```\n\nFilename: Lib/test/test_email/test_generator.py:\n```\n@@ -6,6 +6,7 @@\nfrom email.generator import Generator, BytesGenerator\n from email.headerregistry import Address\n from email import policy\n+import email.errors\n from test.test_email import TestEmailBase, parameterize\n\n@@ -216,6 +217,44 @@\ndef test_rfc2231_wrapping_switches_to_default_len_if_too_narrow(self):\n         g.flatten(msg)\n         self.assertEqual(s.getvalue(), self.typ(expected))\n \n+    def test_keep_encoded_newlines(self):\n+        msg = self.msgmaker(self.typ(textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")))\n+        expected = textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")\n+        s = self.ioclass()\n+        g = self.genclass(s, policy=self.policy.clone(max_line_length=80))\n+        g.flatten(msg)\n+        self.assertEqual(s.getvalue(), self.typ(expected))\n+\n+    def test_keep_long_encoded_newlines(self):\n+        msg = self.msgmaker(self.typ(textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")))\n+        expected = textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject\n+             =?utf-8?q?=0A?=Bcc:\n+             injection@example.com\n+\n+            None\n+            \"\"\")\n+        s = self.ioclass()\n+        g = self.genclass(s, policy=self.policy.clone(max_line_length=30))\n+        g.flatten(msg)\n+        self.assertEqual(s.getvalue(), self.typ(expected))\n+\n \n class TestGenerator(TestGeneratorBase, TestEmailBase):\n\n@@ -224,6 +263,29 @@\nclass TestGenerator(TestGeneratorBase, TestEmailBase):\n     ioclass = io.StringIO\n     typ = str\n \n+    def test_verify_generated_headers(self):\n+        \"\"\"gh-121650: by default the generator prevents header injection\"\"\"\n+        class LiteralHeader(str):\n+            name = 'Header'\n+            def fold(self, **kwargs):\n+                return self\n+\n+        for text in (\n+            'Value\\r\\nBad Injection\\r\\n',\n+            'NoNewLine'\n+        ):\n+            with self.subTest(text=text):\n+                message = message_from_string(\n+                    \"Header: Value\\r\\n\\r\\nBody\",\n+                    policy=self.policy,\n+                )\n+\n+                del message['Header']\n+                message['Header'] = LiteralHeader(text)\n+\n+                with self.assertRaises(email.errors.HeaderWriteError):\n+                    message.as_string()\n+\n \n class TestBytesGenerator(TestGeneratorBase, TestEmailBase):\n```\n\nFilename: Lib/test/test_email/test_policy.py:\n```\n@@ -26,6 +26,7 @@\nclass PolicyAPITests(unittest.TestCase):\n         'raise_on_defect':          False,\n         'mangle_from_':             True,\n         'message_factory':          None,\n+        'verify_generated_headers': True,\n         }\n     # These default values are the ones set on email.policy.default.\n     # If any of these defaults change, the docs must be updated.\n\n@@ -277,6 +278,31 @@\ndef test_short_maxlen_error(self):\n                 with self.assertRaises(email.errors.HeaderParseError):\n                     policy.fold(\"Subject\", subject)\n \n+    def test_verify_generated_headers(self):\n+        \"\"\"Turning protection off allows header injection\"\"\"\n+        policy = email.policy.default.clone(verify_generated_headers=False)\n+        for text in (\n+            'Header: Value\\r\\nBad: Injection\\r\\n',\n+            'Header: NoNewLine'\n+        ):\n+            with self.subTest(text=text):\n+                message = email.message_from_string(\n+                    \"Header: Value\\r\\n\\r\\nBody\",\n+                    policy=policy,\n+                )\n+                class LiteralHeader(str):\n+                    name = 'Header'\n+                    def fold(self, **kwargs):\n+                        return self\n+\n+                del message['Header']\n+                message['Header'] = LiteralHeader(text)\n+\n+                self.assertEqual(\n+                    message.as_string(),\n+                    f\"{text}\\nBody\",\n+                )\n+\n     # XXX: Need subclassing tests.\n     # For adding subclassed objects, make sure the usual rules apply (subclass\n     # wins), but that the order still works (right overrides left).\n```\n\nFilename: Misc/NEWS.d/next/Library/2024-07-27-16-10-41.gh-issue-121650.nf6oc9.rst:\n```\n@@ -0,0 +1,5 @@\n+:mod:`email` headers with embedded newlines are now quoted on output. The\n+:mod:`~email.generator` will now refuse to serialize (write) headers that\n+are unsafely folded or delimited; see\n+:attr:`~email.policy.Policy.verify_generated_headers`. (Contributed by Bas\n+Bloemsaat and Petr Viktorin in :gh:`121650`.)\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/b158a76ce094897c870fb6b3de62887b7ccc33f1",
                "content": "[3.8] gh-121650: Encode newlines in headers, and verify headers are sound (GH-122233) (#122611)\n\nPer RFC 2047:\r\n\r\n> [...] these encoding schemes allow the\r\n> encoding of arbitrary octet values, mail readers that implement this\r\n> decoding should also ensure that display of the decoded data on the\r\n> recipient's terminal will not cause unwanted side-effects\r\n\r\nIt seems that the \"quoted-word\" scheme is a valid way to include\r\na newline character in a header value, just like we already allow\r\nundecodable bytes or control characters.\r\nThey do need to be properly quoted when serialized to text, though.\r\n\r\nThis should fail for custom fold() implementations that aren't careful\r\nabout newlines.\r\n\r\n(cherry picked from commit 097633981879b3c9de9a1dd120d3aa585ecc2384)\r\n\r\nCo-authored-by: Petr Viktorin <encukou@gmail.com>\r\nCo-authored-by: Bas Bloemsaat <bas@bloemsaat.org>\r\nCo-authored-by: Serhiy Storchaka <storchaka@gmail.com>\n\nFilename: Doc/library/email.errors.rst:\n```\n@@ -59,6 +59,12 @@\nThe following exception classes are defined in the :mod:`email.errors` module:\n    :class:`~email.mime.image.MIMEImage`).\n \n \n+.. exception:: HeaderWriteError()\n+\n+   Raised when an error occurs when the :mod:`~email.generator` outputs\n+   headers.\n+\n+\n Here is the list of the defects that the :class:`~email.parser.FeedParser`\n can find while parsing messages.  Note that the defects are added to the message\n where the problem was found, so for example, if a message nested inside a\n```\n\nFilename: Doc/library/email.policy.rst:\n```\n@@ -229,6 +229,24 @@\nadded matters.  To illustrate::\n \n       .. versionadded:: 3.6\n \n+\n+   .. attribute:: verify_generated_headers\n+\n+      If ``True`` (the default), the generator will raise\n+      :exc:`~email.errors.HeaderWriteError` instead of writing a header\n+      that is improperly folded or delimited, such that it would\n+      be parsed as multiple headers or joined with adjacent data.\n+      Such headers can be generated by custom header classes or bugs\n+      in the ``email`` module.\n+\n+      As it's a security feature, this defaults to ``True`` even in the\n+      :class:`~email.policy.Compat32` policy.\n+      For backwards compatible, but unsafe, behavior, it must be set to\n+      ``False`` explicitly.\n+\n+      .. versionadded:: 3.8.20\n+\n+\n    The following :class:`Policy` method is intended to be called by code using\n    the email library to create policy instances with custom settings:\n```\n\nFilename: Doc/whatsnew/3.8.rst:\n```\n@@ -2380,3 +2380,15 @@\nipaddress\n \n * Fixed ``is_global`` and ``is_private`` behavior in ``IPv4Address``,\n   ``IPv6Address``, ``IPv4Network`` and ``IPv6Network``.\n+\n+email\n+-----\n+\n+* Headers with embedded newlines are now quoted on output.\n+\n+  The :mod:`~email.generator` will now refuse to serialize (write) headers\n+  that are improperly folded or delimited, such that they would be parsed as\n+  multiple headers or joined with adjacent data.\n+  If you need to turn this safety feature off,\n+  set :attr:`~email.policy.Policy.verify_generated_headers`.\n+  (Contributed by Bas Bloemsaat and Petr Viktorin in :gh:`121650`.)\n```\n\nFilename: Lib/email/_header_value_parser.py:\n```\n@@ -92,6 +92,8 @@\nASPECIALS = TSPECIALS | set(\"*'%\")\n ATTRIBUTE_ENDS = ASPECIALS | WSP\n EXTENDED_ATTRIBUTE_ENDS = ATTRIBUTE_ENDS - set('%')\n+NLSET = {'\\n', '\\r'}\n+SPECIALSNL = SPECIALS | NLSET\n \n def quote_string(value):\n     return '\"'+str(value).replace('\\\\', '\\\\\\\\').replace('\"', r'\\\"')+'\"'\n\n@@ -2778,9 +2780,13 @@\ndef _refold_parse_tree(parse_tree, *, policy):\n             wrap_as_ew_blocked -= 1\n             continue\n         tstr = str(part)\n-        if part.token_type == 'ptext' and set(tstr) & SPECIALS:\n-            # Encode if tstr contains special characters.\n-            want_encoding = True\n+        if not want_encoding:\n+            if part.token_type == 'ptext':\n+                # Encode if tstr contains special characters.\n+                want_encoding = not SPECIALSNL.isdisjoint(tstr)\n+            else:\n+                # Encode if tstr contains newlines.\n+                want_encoding = not NLSET.isdisjoint(tstr)\n         try:\n             tstr.encode(encoding)\n             charset = encoding\n```\n\nFilename: Lib/email/_policybase.py:\n```\n@@ -157,6 +157,13 @@\nclass Policy(_PolicyBase, metaclass=abc.ABCMeta):\n     message_factory     -- the class to use to create new message objects.\n                            If the value is None, the default is Message.\n \n+    verify_generated_headers\n+                        -- if true, the generator verifies that each header\n+                           they are properly folded, so that a parser won't\n+                           treat it as multiple headers, start-of-body, or\n+                           part of another header.\n+                           This is a check against custom Header & fold()\n+                           implementations.\n     \"\"\"\n \n     raise_on_defect = False\n\n@@ -165,6 +172,7 @@\nclass Policy(_PolicyBase, metaclass=abc.ABCMeta):\n     max_line_length = 78\n     mangle_from_ = False\n     message_factory = None\n+    verify_generated_headers = True\n \n     def handle_defect(self, obj, defect):\n         \"\"\"Based on policy, either raise defect or call register_defect.\n```\n\nFilename: Lib/email/errors.py:\n```\n@@ -29,6 +29,10 @@\nclass CharsetError(MessageError):\n     \"\"\"An illegal charset was given.\"\"\"\n \n \n+class HeaderWriteError(MessageError):\n+    \"\"\"Error while writing headers.\"\"\"\n+\n+\n # These are parsing defects which the parser was able to work around.\n class MessageDefect(ValueError):\n     \"\"\"Base class for a message defect.\"\"\"\n```\n\nFilename: Lib/email/generator.py:\n```\n@@ -14,12 +14,14 @@\nfrom copy import deepcopy\n from io import StringIO, BytesIO\n from email.utils import _has_surrogates\n+from email.errors import HeaderWriteError\n \n UNDERSCORE = '_'\n NL = '\\n'  # XXX: no longer used by the code below.\n \n NLCRE = re.compile(r'\\r\\n|\\r|\\n')\n fcre = re.compile(r'^From ', re.MULTILINE)\n+NEWLINE_WITHOUT_FWSP = re.compile(r'\\r\\n[^ \\t]|\\r[^ \\n\\t]|\\n[^ \\t]')\n\n@@ -223,7 +225,19 @@\ndef _dispatch(self, msg):\n \n     def _write_headers(self, msg):\n         for h, v in msg.raw_items():\n-            self.write(self.policy.fold(h, v))\n+            folded = self.policy.fold(h, v)\n+            if self.policy.verify_generated_headers:\n+                linesep = self.policy.linesep\n+                if not folded.endswith(self.policy.linesep):\n+                    raise HeaderWriteError(\n+                        f'folded header does not end with {linesep!r}: {folded!r}')\n+                folded_no_linesep = folded\n+                if folded.endswith(linesep):\n+                    folded_no_linesep = folded[:-len(linesep)]\n+                if NEWLINE_WITHOUT_FWSP.search(folded_no_linesep):\n+                    raise HeaderWriteError(\n+                        f'folded header contains newline: {folded!r}')\n+            self.write(folded)\n         # A blank line always separates headers from body\n         self.write(self._NL)\n```\n\nFilename: Lib/test/test_email/test_generator.py:\n```\n@@ -6,6 +6,7 @@\nfrom email.generator import Generator, BytesGenerator\n from email.headerregistry import Address\n from email import policy\n+import email.errors\n from test.test_email import TestEmailBase, parameterize\n\n@@ -216,6 +217,44 @@\ndef test_rfc2231_wrapping_switches_to_default_len_if_too_narrow(self):\n         g.flatten(msg)\n         self.assertEqual(s.getvalue(), self.typ(expected))\n \n+    def test_keep_encoded_newlines(self):\n+        msg = self.msgmaker(self.typ(textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")))\n+        expected = textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")\n+        s = self.ioclass()\n+        g = self.genclass(s, policy=self.policy.clone(max_line_length=80))\n+        g.flatten(msg)\n+        self.assertEqual(s.getvalue(), self.typ(expected))\n+\n+    def test_keep_long_encoded_newlines(self):\n+        msg = self.msgmaker(self.typ(textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")))\n+        expected = textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject\n+             =?utf-8?q?=0A?=Bcc:\n+             injection@example.com\n+\n+            None\n+            \"\"\")\n+        s = self.ioclass()\n+        g = self.genclass(s, policy=self.policy.clone(max_line_length=30))\n+        g.flatten(msg)\n+        self.assertEqual(s.getvalue(), self.typ(expected))\n+\n \n class TestGenerator(TestGeneratorBase, TestEmailBase):\n\n@@ -224,6 +263,29 @@\nclass TestGenerator(TestGeneratorBase, TestEmailBase):\n     ioclass = io.StringIO\n     typ = str\n \n+    def test_verify_generated_headers(self):\n+        \"\"\"gh-121650: by default the generator prevents header injection\"\"\"\n+        class LiteralHeader(str):\n+            name = 'Header'\n+            def fold(self, **kwargs):\n+                return self\n+\n+        for text in (\n+            'Value\\r\\nBad Injection\\r\\n',\n+            'NoNewLine'\n+        ):\n+            with self.subTest(text=text):\n+                message = message_from_string(\n+                    \"Header: Value\\r\\n\\r\\nBody\",\n+                    policy=self.policy,\n+                )\n+\n+                del message['Header']\n+                message['Header'] = LiteralHeader(text)\n+\n+                with self.assertRaises(email.errors.HeaderWriteError):\n+                    message.as_string()\n+\n \n class TestBytesGenerator(TestGeneratorBase, TestEmailBase):\n```\n\nFilename: Lib/test/test_email/test_policy.py:\n```\n@@ -26,6 +26,7 @@\nclass PolicyAPITests(unittest.TestCase):\n         'raise_on_defect':          False,\n         'mangle_from_':             True,\n         'message_factory':          None,\n+        'verify_generated_headers': True,\n         }\n     # These default values are the ones set on email.policy.default.\n     # If any of these defaults change, the docs must be updated.\n\n@@ -277,6 +278,31 @@\ndef test_short_maxlen_error(self):\n                 with self.assertRaises(email.errors.HeaderParseError):\n                     policy.fold(\"Subject\", subject)\n \n+    def test_verify_generated_headers(self):\n+        \"\"\"Turning protection off allows header injection\"\"\"\n+        policy = email.policy.default.clone(verify_generated_headers=False)\n+        for text in (\n+            'Header: Value\\r\\nBad: Injection\\r\\n',\n+            'Header: NoNewLine'\n+        ):\n+            with self.subTest(text=text):\n+                message = email.message_from_string(\n+                    \"Header: Value\\r\\n\\r\\nBody\",\n+                    policy=policy,\n+                )\n+                class LiteralHeader(str):\n+                    name = 'Header'\n+                    def fold(self, **kwargs):\n+                        return self\n+\n+                del message['Header']\n+                message['Header'] = LiteralHeader(text)\n+\n+                self.assertEqual(\n+                    message.as_string(),\n+                    f\"{text}\\nBody\",\n+                )\n+\n     # XXX: Need subclassing tests.\n     # For adding subclassed objects, make sure the usual rules apply (subclass\n     # wins), but that the order still works (right overrides left).\n```\n\nFilename: Misc/NEWS.d/next/Library/2024-07-27-16-10-41.gh-issue-121650.nf6oc9.rst:\n```\n@@ -0,0 +1,5 @@\n+:mod:`email` headers with embedded newlines are now quoted on output. The\n+:mod:`~email.generator` will now refuse to serialize (write) headers that\n+are unsafely folded or delimited; see\n+:attr:`~email.policy.Policy.verify_generated_headers`. (Contributed by Bas\n+Bloemsaat and Petr Viktorin in :gh:`121650`.)\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/f7be505d137a22528cb0fc004422c0081d5d90e6",
                "content": "[3.9] gh-121650: Encode newlines in headers, and verify headers are sound (GH-122233) (#122610)\n\nPer RFC 2047:\r\n\r\n> [...] these encoding schemes allow the\r\n> encoding of arbitrary octet values, mail readers that implement this\r\n> decoding should also ensure that display of the decoded data on the\r\n> recipient's terminal will not cause unwanted side-effects\r\n\r\nIt seems that the \"quoted-word\" scheme is a valid way to include\r\na newline character in a header value, just like we already allow\r\nundecodable bytes or control characters.\r\nThey do need to be properly quoted when serialized to text, though.\r\n\r\nThis should fail for custom fold() implementations that aren't careful\r\nabout newlines.\r\n\r\n(cherry picked from commit 097633981879b3c9de9a1dd120d3aa585ecc2384)\r\n\r\nCo-authored-by: Petr Viktorin <encukou@gmail.com>\r\nCo-authored-by: Bas Bloemsaat <bas@bloemsaat.org>\r\nCo-authored-by: Serhiy Storchaka <storchaka@gmail.com>\n\nFilename: Doc/library/email.errors.rst:\n```\n@@ -59,6 +59,12 @@\nThe following exception classes are defined in the :mod:`email.errors` module:\n    :class:`~email.mime.image.MIMEImage`).\n \n \n+.. exception:: HeaderWriteError()\n+\n+   Raised when an error occurs when the :mod:`~email.generator` outputs\n+   headers.\n+\n+\n Here is the list of the defects that the :class:`~email.parser.FeedParser`\n can find while parsing messages.  Note that the defects are added to the message\n where the problem was found, so for example, if a message nested inside a\n```\n\nFilename: Doc/library/email.policy.rst:\n```\n@@ -229,6 +229,24 @@\nadded matters.  To illustrate::\n \n       .. versionadded:: 3.6\n \n+\n+   .. attribute:: verify_generated_headers\n+\n+      If ``True`` (the default), the generator will raise\n+      :exc:`~email.errors.HeaderWriteError` instead of writing a header\n+      that is improperly folded or delimited, such that it would\n+      be parsed as multiple headers or joined with adjacent data.\n+      Such headers can be generated by custom header classes or bugs\n+      in the ``email`` module.\n+\n+      As it's a security feature, this defaults to ``True`` even in the\n+      :class:`~email.policy.Compat32` policy.\n+      For backwards compatible, but unsafe, behavior, it must be set to\n+      ``False`` explicitly.\n+\n+      .. versionadded:: 3.9.20\n+\n+\n    The following :class:`Policy` method is intended to be called by code using\n    the email library to create policy instances with custom settings:\n```\n\nFilename: Doc/whatsnew/3.9.rst:\n```\n@@ -1640,3 +1640,15 @@\nipaddress\n \n * Fixed ``is_global`` and ``is_private`` behavior in ``IPv4Address``,\n   ``IPv6Address``, ``IPv4Network`` and ``IPv6Network``.\n+\n+email\n+-----\n+\n+* Headers with embedded newlines are now quoted on output.\n+\n+  The :mod:`~email.generator` will now refuse to serialize (write) headers\n+  that are improperly folded or delimited, such that they would be parsed as\n+  multiple headers or joined with adjacent data.\n+  If you need to turn this safety feature off,\n+  set :attr:`~email.policy.Policy.verify_generated_headers`.\n+  (Contributed by Bas Bloemsaat and Petr Viktorin in :gh:`121650`.)\n```\n\nFilename: Lib/email/_header_value_parser.py:\n```\n@@ -92,6 +92,8 @@\nASPECIALS = TSPECIALS | set(\"*'%\")\n ATTRIBUTE_ENDS = ASPECIALS | WSP\n EXTENDED_ATTRIBUTE_ENDS = ATTRIBUTE_ENDS - set('%')\n+NLSET = {'\\n', '\\r'}\n+SPECIALSNL = SPECIALS | NLSET\n \n def quote_string(value):\n     return '\"'+str(value).replace('\\\\', '\\\\\\\\').replace('\"', r'\\\"')+'\"'\n\n@@ -2778,9 +2780,13 @@\ndef _refold_parse_tree(parse_tree, *, policy):\n             wrap_as_ew_blocked -= 1\n             continue\n         tstr = str(part)\n-        if part.token_type == 'ptext' and set(tstr) & SPECIALS:\n-            # Encode if tstr contains special characters.\n-            want_encoding = True\n+        if not want_encoding:\n+            if part.token_type == 'ptext':\n+                # Encode if tstr contains special characters.\n+                want_encoding = not SPECIALSNL.isdisjoint(tstr)\n+            else:\n+                # Encode if tstr contains newlines.\n+                want_encoding = not NLSET.isdisjoint(tstr)\n         try:\n             tstr.encode(encoding)\n             charset = encoding\n```\n\nFilename: Lib/email/_policybase.py:\n```\n@@ -157,6 +157,13 @@\nclass Policy(_PolicyBase, metaclass=abc.ABCMeta):\n     message_factory     -- the class to use to create new message objects.\n                            If the value is None, the default is Message.\n \n+    verify_generated_headers\n+                        -- if true, the generator verifies that each header\n+                           they are properly folded, so that a parser won't\n+                           treat it as multiple headers, start-of-body, or\n+                           part of another header.\n+                           This is a check against custom Header & fold()\n+                           implementations.\n     \"\"\"\n \n     raise_on_defect = False\n\n@@ -165,6 +172,7 @@\nclass Policy(_PolicyBase, metaclass=abc.ABCMeta):\n     max_line_length = 78\n     mangle_from_ = False\n     message_factory = None\n+    verify_generated_headers = True\n \n     def handle_defect(self, obj, defect):\n         \"\"\"Based on policy, either raise defect or call register_defect.\n```\n\nFilename: Lib/email/errors.py:\n```\n@@ -29,6 +29,10 @@\nclass CharsetError(MessageError):\n     \"\"\"An illegal charset was given.\"\"\"\n \n \n+class HeaderWriteError(MessageError):\n+    \"\"\"Error while writing headers.\"\"\"\n+\n+\n # These are parsing defects which the parser was able to work around.\n class MessageDefect(ValueError):\n     \"\"\"Base class for a message defect.\"\"\"\n```\n\nFilename: Lib/email/generator.py:\n```\n@@ -14,12 +14,14 @@\nfrom copy import deepcopy\n from io import StringIO, BytesIO\n from email.utils import _has_surrogates\n+from email.errors import HeaderWriteError\n \n UNDERSCORE = '_'\n NL = '\\n'  # XXX: no longer used by the code below.\n \n NLCRE = re.compile(r'\\r\\n|\\r|\\n')\n fcre = re.compile(r'^From ', re.MULTILINE)\n+NEWLINE_WITHOUT_FWSP = re.compile(r'\\r\\n[^ \\t]|\\r[^ \\n\\t]|\\n[^ \\t]')\n\n@@ -223,7 +225,16 @@\ndef _dispatch(self, msg):\n \n     def _write_headers(self, msg):\n         for h, v in msg.raw_items():\n-            self.write(self.policy.fold(h, v))\n+            folded = self.policy.fold(h, v)\n+            if self.policy.verify_generated_headers:\n+                linesep = self.policy.linesep\n+                if not folded.endswith(self.policy.linesep):\n+                    raise HeaderWriteError(\n+                        f'folded header does not end with {linesep!r}: {folded!r}')\n+                if NEWLINE_WITHOUT_FWSP.search(folded.removesuffix(linesep)):\n+                    raise HeaderWriteError(\n+                        f'folded header contains newline: {folded!r}')\n+            self.write(folded)\n         # A blank line always separates headers from body\n         self.write(self._NL)\n```\n\nFilename: Lib/test/test_email/test_generator.py:\n```\n@@ -6,6 +6,7 @@\nfrom email.generator import Generator, BytesGenerator\n from email.headerregistry import Address\n from email import policy\n+import email.errors\n from test.test_email import TestEmailBase, parameterize\n\n@@ -216,6 +217,44 @@\ndef test_rfc2231_wrapping_switches_to_default_len_if_too_narrow(self):\n         g.flatten(msg)\n         self.assertEqual(s.getvalue(), self.typ(expected))\n \n+    def test_keep_encoded_newlines(self):\n+        msg = self.msgmaker(self.typ(textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")))\n+        expected = textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")\n+        s = self.ioclass()\n+        g = self.genclass(s, policy=self.policy.clone(max_line_length=80))\n+        g.flatten(msg)\n+        self.assertEqual(s.getvalue(), self.typ(expected))\n+\n+    def test_keep_long_encoded_newlines(self):\n+        msg = self.msgmaker(self.typ(textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")))\n+        expected = textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject\n+             =?utf-8?q?=0A?=Bcc:\n+             injection@example.com\n+\n+            None\n+            \"\"\")\n+        s = self.ioclass()\n+        g = self.genclass(s, policy=self.policy.clone(max_line_length=30))\n+        g.flatten(msg)\n+        self.assertEqual(s.getvalue(), self.typ(expected))\n+\n \n class TestGenerator(TestGeneratorBase, TestEmailBase):\n\n@@ -224,6 +263,29 @@\nclass TestGenerator(TestGeneratorBase, TestEmailBase):\n     ioclass = io.StringIO\n     typ = str\n \n+    def test_verify_generated_headers(self):\n+        \"\"\"gh-121650: by default the generator prevents header injection\"\"\"\n+        class LiteralHeader(str):\n+            name = 'Header'\n+            def fold(self, **kwargs):\n+                return self\n+\n+        for text in (\n+            'Value\\r\\nBad Injection\\r\\n',\n+            'NoNewLine'\n+        ):\n+            with self.subTest(text=text):\n+                message = message_from_string(\n+                    \"Header: Value\\r\\n\\r\\nBody\",\n+                    policy=self.policy,\n+                )\n+\n+                del message['Header']\n+                message['Header'] = LiteralHeader(text)\n+\n+                with self.assertRaises(email.errors.HeaderWriteError):\n+                    message.as_string()\n+\n \n class TestBytesGenerator(TestGeneratorBase, TestEmailBase):\n```\n\nFilename: Lib/test/test_email/test_policy.py:\n```\n@@ -26,6 +26,7 @@\nclass PolicyAPITests(unittest.TestCase):\n         'raise_on_defect':          False,\n         'mangle_from_':             True,\n         'message_factory':          None,\n+        'verify_generated_headers': True,\n         }\n     # These default values are the ones set on email.policy.default.\n     # If any of these defaults change, the docs must be updated.\n\n@@ -277,6 +278,31 @@\ndef test_short_maxlen_error(self):\n                 with self.assertRaises(email.errors.HeaderParseError):\n                     policy.fold(\"Subject\", subject)\n \n+    def test_verify_generated_headers(self):\n+        \"\"\"Turning protection off allows header injection\"\"\"\n+        policy = email.policy.default.clone(verify_generated_headers=False)\n+        for text in (\n+            'Header: Value\\r\\nBad: Injection\\r\\n',\n+            'Header: NoNewLine'\n+        ):\n+            with self.subTest(text=text):\n+                message = email.message_from_string(\n+                    \"Header: Value\\r\\n\\r\\nBody\",\n+                    policy=policy,\n+                )\n+                class LiteralHeader(str):\n+                    name = 'Header'\n+                    def fold(self, **kwargs):\n+                        return self\n+\n+                del message['Header']\n+                message['Header'] = LiteralHeader(text)\n+\n+                self.assertEqual(\n+                    message.as_string(),\n+                    f\"{text}\\nBody\",\n+                )\n+\n     # XXX: Need subclassing tests.\n     # For adding subclassed objects, make sure the usual rules apply (subclass\n     # wins), but that the order still works (right overrides left).\n```\n\nFilename: Misc/NEWS.d/next/Library/2024-07-27-16-10-41.gh-issue-121650.nf6oc9.rst:\n```\n@@ -0,0 +1,5 @@\n+:mod:`email` headers with embedded newlines are now quoted on output. The\n+:mod:`~email.generator` will now refuse to serialize (write) headers that\n+are unsafely folded or delimited; see\n+:attr:`~email.policy.Policy.verify_generated_headers`. (Contributed by Bas\n+Bloemsaat and Petr Viktorin in :gh:`121650`.)\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/f7c0f09e69e950cf3c5ada9dbde93898eb975533",
                "content": "[3.11] gh-121650: Encode newlines in headers, and verify headers are sound (GH-122233) (#122608)\n\nPer RFC 2047:\r\n\r\n> [...] these encoding schemes allow the\r\n> encoding of arbitrary octet values, mail readers that implement this\r\n> decoding should also ensure that display of the decoded data on the\r\n> recipient's terminal will not cause unwanted side-effects\r\n\r\nIt seems that the \"quoted-word\" scheme is a valid way to include\r\na newline character in a header value, just like we already allow\r\nundecodable bytes or control characters.\r\nThey do need to be properly quoted when serialized to text, though.\r\n\r\nVerify that email headers are well-formed.\r\n\r\nThis should fail for custom fold() implementations that aren't careful\r\nabout newlines.\r\n\r\n(cherry picked from commit 097633981879b3c9de9a1dd120d3aa585ecc2384)\r\n\r\nCo-authored-by: Petr Viktorin <encukou@gmail.com>\r\nCo-authored-by: Bas Bloemsaat <bas@bloemsaat.org>\r\nCo-authored-by: Serhiy Storchaka <storchaka@gmail.com>\n\nFilename: Doc/library/email.errors.rst:\n```\n@@ -58,6 +58,13 @@\nThe following exception classes are defined in the :mod:`email.errors` module:\n    :class:`~email.mime.nonmultipart.MIMENonMultipart` (e.g.\n    :class:`~email.mime.image.MIMEImage`).\n \n+\n+.. exception:: HeaderWriteError()\n+\n+   Raised when an error occurs when the :mod:`~email.generator` outputs\n+   headers.\n+\n+\n .. exception:: MessageDefect()\n \n    This is the base class for all defects found when parsing email messages.\n```\n\nFilename: Doc/library/email.policy.rst:\n```\n@@ -228,6 +228,24 @@\nadded matters.  To illustrate::\n \n       .. versionadded:: 3.6\n \n+\n+   .. attribute:: verify_generated_headers\n+\n+      If ``True`` (the default), the generator will raise\n+      :exc:`~email.errors.HeaderWriteError` instead of writing a header\n+      that is improperly folded or delimited, such that it would\n+      be parsed as multiple headers or joined with adjacent data.\n+      Such headers can be generated by custom header classes or bugs\n+      in the ``email`` module.\n+\n+      As it's a security feature, this defaults to ``True`` even in the\n+      :class:`~email.policy.Compat32` policy.\n+      For backwards compatible, but unsafe, behavior, it must be set to\n+      ``False`` explicitly.\n+\n+      .. versionadded:: 3.11.10\n+\n+\n    The following :class:`Policy` method is intended to be called by code using\n    the email library to create policy instances with custom settings:\n```\n\nFilename: Doc/whatsnew/3.11.rst:\n```\n@@ -2755,6 +2755,7 @@\nOpenSSL\n \n .. _libb2: https://www.blake2.net/\n \n+\n Notable changes in 3.11.10\n ==========================\n\n@@ -2763,3 +2764,15 @@\nipaddress\n \n * Fixed ``is_global`` and ``is_private`` behavior in ``IPv4Address``,\n   ``IPv6Address``, ``IPv4Network`` and ``IPv6Network``.\n+\n+email\n+-----\n+\n+* Headers with embedded newlines are now quoted on output.\n+\n+  The :mod:`~email.generator` will now refuse to serialize (write) headers\n+  that are improperly folded or delimited, such that they would be parsed as\n+  multiple headers or joined with adjacent data.\n+  If you need to turn this safety feature off,\n+  set :attr:`~email.policy.Policy.verify_generated_headers`.\n+  (Contributed by Bas Bloemsaat and Petr Viktorin in :gh:`121650`.)\n```\n\nFilename: Lib/email/_header_value_parser.py:\n```\n@@ -92,6 +92,8 @@\nASPECIALS = TSPECIALS | set(\"*'%\")\n ATTRIBUTE_ENDS = ASPECIALS | WSP\n EXTENDED_ATTRIBUTE_ENDS = ATTRIBUTE_ENDS - set('%')\n+NLSET = {'\\n', '\\r'}\n+SPECIALSNL = SPECIALS | NLSET\n \n def quote_string(value):\n     return '\"'+str(value).replace('\\\\', '\\\\\\\\').replace('\"', r'\\\"')+'\"'\n\n@@ -2781,9 +2783,13 @@\ndef _refold_parse_tree(parse_tree, *, policy):\n             wrap_as_ew_blocked -= 1\n             continue\n         tstr = str(part)\n-        if part.token_type == 'ptext' and set(tstr) & SPECIALS:\n-            # Encode if tstr contains special characters.\n-            want_encoding = True\n+        if not want_encoding:\n+            if part.token_type == 'ptext':\n+                # Encode if tstr contains special characters.\n+                want_encoding = not SPECIALSNL.isdisjoint(tstr)\n+            else:\n+                # Encode if tstr contains newlines.\n+                want_encoding = not NLSET.isdisjoint(tstr)\n         try:\n             tstr.encode(encoding)\n             charset = encoding\n```\n\nFilename: Lib/email/_policybase.py:\n```\n@@ -157,6 +157,13 @@\nclass Policy(_PolicyBase, metaclass=abc.ABCMeta):\n     message_factory     -- the class to use to create new message objects.\n                            If the value is None, the default is Message.\n \n+    verify_generated_headers\n+                        -- if true, the generator verifies that each header\n+                           they are properly folded, so that a parser won't\n+                           treat it as multiple headers, start-of-body, or\n+                           part of another header.\n+                           This is a check against custom Header & fold()\n+                           implementations.\n     \"\"\"\n \n     raise_on_defect = False\n\n@@ -165,6 +172,7 @@\nclass Policy(_PolicyBase, metaclass=abc.ABCMeta):\n     max_line_length = 78\n     mangle_from_ = False\n     message_factory = None\n+    verify_generated_headers = True\n \n     def handle_defect(self, obj, defect):\n         \"\"\"Based on policy, either raise defect or call register_defect.\n```\n\nFilename: Lib/email/errors.py:\n```\n@@ -29,6 +29,10 @@\nclass CharsetError(MessageError):\n     \"\"\"An illegal charset was given.\"\"\"\n \n \n+class HeaderWriteError(MessageError):\n+    \"\"\"Error while writing headers.\"\"\"\n+\n+\n # These are parsing defects which the parser was able to work around.\n class MessageDefect(ValueError):\n     \"\"\"Base class for a message defect.\"\"\"\n```\n\nFilename: Lib/email/generator.py:\n```\n@@ -14,12 +14,14 @@\nfrom copy import deepcopy\n from io import StringIO, BytesIO\n from email.utils import _has_surrogates\n+from email.errors import HeaderWriteError\n \n UNDERSCORE = '_'\n NL = '\\n'  # XXX: no longer used by the code below.\n \n NLCRE = re.compile(r'\\r\\n|\\r|\\n')\n fcre = re.compile(r'^From ', re.MULTILINE)\n+NEWLINE_WITHOUT_FWSP = re.compile(r'\\r\\n[^ \\t]|\\r[^ \\n\\t]|\\n[^ \\t]')\n \n \n class Generator:\n\n@@ -222,7 +224,16 @@\ndef _dispatch(self, msg):\n \n     def _write_headers(self, msg):\n         for h, v in msg.raw_items():\n-            self.write(self.policy.fold(h, v))\n+            folded = self.policy.fold(h, v)\n+            if self.policy.verify_generated_headers:\n+                linesep = self.policy.linesep\n+                if not folded.endswith(self.policy.linesep):\n+                    raise HeaderWriteError(\n+                        f'folded header does not end with {linesep!r}: {folded!r}')\n+                if NEWLINE_WITHOUT_FWSP.search(folded.removesuffix(linesep)):\n+                    raise HeaderWriteError(\n+                        f'folded header contains newline: {folded!r}')\n+            self.write(folded)\n         # A blank line always separates headers from body\n         self.write(self._NL)\n```\n\nFilename: Lib/test/test_email/test_generator.py:\n```\n@@ -6,6 +6,7 @@\nfrom email.generator import Generator, BytesGenerator\n from email.headerregistry import Address\n from email import policy\n+import email.errors\n from test.test_email import TestEmailBase, parameterize\n\n@@ -216,6 +217,44 @@\ndef test_rfc2231_wrapping_switches_to_default_len_if_too_narrow(self):\n         g.flatten(msg)\n         self.assertEqual(s.getvalue(), self.typ(expected))\n \n+    def test_keep_encoded_newlines(self):\n+        msg = self.msgmaker(self.typ(textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")))\n+        expected = textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")\n+        s = self.ioclass()\n+        g = self.genclass(s, policy=self.policy.clone(max_line_length=80))\n+        g.flatten(msg)\n+        self.assertEqual(s.getvalue(), self.typ(expected))\n+\n+    def test_keep_long_encoded_newlines(self):\n+        msg = self.msgmaker(self.typ(textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")))\n+        expected = textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject\n+             =?utf-8?q?=0A?=Bcc:\n+             injection@example.com\n+\n+            None\n+            \"\"\")\n+        s = self.ioclass()\n+        g = self.genclass(s, policy=self.policy.clone(max_line_length=30))\n+        g.flatten(msg)\n+        self.assertEqual(s.getvalue(), self.typ(expected))\n+\n \n class TestGenerator(TestGeneratorBase, TestEmailBase):\n\n@@ -224,6 +263,29 @@\nclass TestGenerator(TestGeneratorBase, TestEmailBase):\n     ioclass = io.StringIO\n     typ = str\n \n+    def test_verify_generated_headers(self):\n+        \"\"\"gh-121650: by default the generator prevents header injection\"\"\"\n+        class LiteralHeader(str):\n+            name = 'Header'\n+            def fold(self, **kwargs):\n+                return self\n+\n+        for text in (\n+            'Value\\r\\nBad Injection\\r\\n',\n+            'NoNewLine'\n+        ):\n+            with self.subTest(text=text):\n+                message = message_from_string(\n+                    \"Header: Value\\r\\n\\r\\nBody\",\n+                    policy=self.policy,\n+                )\n+\n+                del message['Header']\n+                message['Header'] = LiteralHeader(text)\n+\n+                with self.assertRaises(email.errors.HeaderWriteError):\n+                    message.as_string()\n+\n \n class TestBytesGenerator(TestGeneratorBase, TestEmailBase):\n```\n\nFilename: Lib/test/test_email/test_policy.py:\n```\n@@ -26,6 +26,7 @@\nclass PolicyAPITests(unittest.TestCase):\n         'raise_on_defect':          False,\n         'mangle_from_':             True,\n         'message_factory':          None,\n+        'verify_generated_headers': True,\n         }\n     # These default values are the ones set on email.policy.default.\n     # If any of these defaults change, the docs must be updated.\n\n@@ -294,6 +295,31 @@\ndef test_short_maxlen_error(self):\n                 with self.assertRaises(email.errors.HeaderParseError):\n                     policy.fold(\"Subject\", subject)\n \n+    def test_verify_generated_headers(self):\n+        \"\"\"Turning protection off allows header injection\"\"\"\n+        policy = email.policy.default.clone(verify_generated_headers=False)\n+        for text in (\n+            'Header: Value\\r\\nBad: Injection\\r\\n',\n+            'Header: NoNewLine'\n+        ):\n+            with self.subTest(text=text):\n+                message = email.message_from_string(\n+                    \"Header: Value\\r\\n\\r\\nBody\",\n+                    policy=policy,\n+                )\n+                class LiteralHeader(str):\n+                    name = 'Header'\n+                    def fold(self, **kwargs):\n+                        return self\n+\n+                del message['Header']\n+                message['Header'] = LiteralHeader(text)\n+\n+                self.assertEqual(\n+                    message.as_string(),\n+                    f\"{text}\\nBody\",\n+                )\n+\n     # XXX: Need subclassing tests.\n     # For adding subclassed objects, make sure the usual rules apply (subclass\n     # wins), but that the order still works (right overrides left).\n```\n\nFilename: Misc/NEWS.d/next/Library/2024-07-27-16-10-41.gh-issue-121650.nf6oc9.rst:\n```\n@@ -0,0 +1,5 @@\n+:mod:`email` headers with embedded newlines are now quoted on output. The\n+:mod:`~email.generator` will now refuse to serialize (write) headers that\n+are unsafely folded or delimited; see\n+:attr:`~email.policy.Policy.verify_generated_headers`. (Contributed by Bas\n+Bloemsaat and Petr Viktorin in :gh:`121650`.)\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/097633981879b3c9de9a1dd120d3aa585ecc2384",
                "content": "gh-121650: Encode newlines in headers, and verify headers are sound (GH-122233)\n\n## Encode header parts that contain newlines\r\n\r\nPer RFC 2047:\r\n\r\n> [...] these encoding schemes allow the\r\n> encoding of arbitrary octet values, mail readers that implement this\r\n> decoding should also ensure that display of the decoded data on the\r\n> recipient's terminal will not cause unwanted side-effects\r\n\r\nIt seems that the \"quoted-word\" scheme is a valid way to include\r\na newline character in a header value, just like we already allow\r\nundecodable bytes or control characters.\r\nThey do need to be properly quoted when serialized to text, though.\r\n\r\n\r\n## Verify that email headers are well-formed\r\n\r\nThis should fail for custom fold() implementations that aren't careful\r\nabout newlines.\r\n\r\n\r\nCo-authored-by: Bas Bloemsaat <bas@bloemsaat.org>\r\nCo-authored-by: Serhiy Storchaka <storchaka@gmail.com>\n\nFilename: Doc/library/email.errors.rst:\n```\n@@ -58,6 +58,13 @@\nThe following exception classes are defined in the :mod:`email.errors` module:\n    :class:`~email.mime.nonmultipart.MIMENonMultipart` (e.g.\n    :class:`~email.mime.image.MIMEImage`).\n \n+\n+.. exception:: HeaderWriteError()\n+\n+   Raised when an error occurs when the :mod:`~email.generator` outputs\n+   headers.\n+\n+\n .. exception:: MessageDefect()\n \n    This is the base class for all defects found when parsing email messages.\n```\n\nFilename: Doc/library/email.policy.rst:\n```\n@@ -229,6 +229,24 @@\nadded matters.  To illustrate::\n \n       .. versionadded:: 3.6\n \n+\n+   .. attribute:: verify_generated_headers\n+\n+      If ``True`` (the default), the generator will raise\n+      :exc:`~email.errors.HeaderWriteError` instead of writing a header\n+      that is improperly folded or delimited, such that it would\n+      be parsed as multiple headers or joined with adjacent data.\n+      Such headers can be generated by custom header classes or bugs\n+      in the ``email`` module.\n+\n+      As it's a security feature, this defaults to ``True`` even in the\n+      :class:`~email.policy.Compat32` policy.\n+      For backwards compatible, but unsafe, behavior, it must be set to\n+      ``False`` explicitly.\n+\n+      .. versionadded:: 3.13\n+\n+\n    The following :class:`Policy` method is intended to be called by code using\n    the email library to create policy instances with custom settings:\n```\n\nFilename: Doc/whatsnew/3.13.rst:\n```\n@@ -736,6 +736,15 @@\ndoctest\n email\n -----\n \n+* Headers with embedded newlines are now quoted on output.\n+\n+  The :mod:`~email.generator` will now refuse to serialize (write) headers\n+  that are improperly folded or delimited, such that they would be parsed as\n+  multiple headers or joined with adjacent data.\n+  If you need to turn this safety feature off,\n+  set :attr:`~email.policy.Policy.verify_generated_headers`.\n+  (Contributed by Bas Bloemsaat and Petr Viktorin in :gh:`121650`.)\n+\n * :func:`email.utils.getaddresses` and :func:`email.utils.parseaddr` now return\n   ``('', '')`` 2-tuples in more situations where invalid email addresses are\n   encountered instead of potentially inaccurate values. Add optional *strict*\n```\n\nFilename: Lib/email/_header_value_parser.py:\n```\n@@ -92,6 +92,8 @@\nASPECIALS = TSPECIALS | set(\"*'%\")\n ATTRIBUTE_ENDS = ASPECIALS | WSP\n EXTENDED_ATTRIBUTE_ENDS = ATTRIBUTE_ENDS - set('%')\n+NLSET = {'\\n', '\\r'}\n+SPECIALSNL = SPECIALS | NLSET\n \n def quote_string(value):\n     return '\"'+str(value).replace('\\\\', '\\\\\\\\').replace('\"', r'\\\"')+'\"'\n\n@@ -2802,9 +2804,13 @@\ndef _refold_parse_tree(parse_tree, *, policy):\n             wrap_as_ew_blocked -= 1\n             continue\n         tstr = str(part)\n-        if part.token_type == 'ptext' and set(tstr) & SPECIALS:\n-            # Encode if tstr contains special characters.\n-            want_encoding = True\n+        if not want_encoding:\n+            if part.token_type == 'ptext':\n+                # Encode if tstr contains special characters.\n+                want_encoding = not SPECIALSNL.isdisjoint(tstr)\n+            else:\n+                # Encode if tstr contains newlines.\n+                want_encoding = not NLSET.isdisjoint(tstr)\n         try:\n             tstr.encode(encoding)\n             charset = encoding\n```\n\nFilename: Lib/email/_policybase.py:\n```\n@@ -157,6 +157,13 @@\nclass Policy(_PolicyBase, metaclass=abc.ABCMeta):\n     message_factory     -- the class to use to create new message objects.\n                            If the value is None, the default is Message.\n \n+    verify_generated_headers\n+                        -- if true, the generator verifies that each header\n+                           they are properly folded, so that a parser won't\n+                           treat it as multiple headers, start-of-body, or\n+                           part of another header.\n+                           This is a check against custom Header & fold()\n+                           implementations.\n     \"\"\"\n \n     raise_on_defect = False\n\n@@ -165,6 +172,7 @@\nclass Policy(_PolicyBase, metaclass=abc.ABCMeta):\n     max_line_length = 78\n     mangle_from_ = False\n     message_factory = None\n+    verify_generated_headers = True\n \n     def handle_defect(self, obj, defect):\n         \"\"\"Based on policy, either raise defect or call register_defect.\n```\n\nFilename: Lib/email/errors.py:\n```\n@@ -29,6 +29,10 @@\nclass CharsetError(MessageError):\n     \"\"\"An illegal charset was given.\"\"\"\n \n \n+class HeaderWriteError(MessageError):\n+    \"\"\"Error while writing headers.\"\"\"\n+\n+\n # These are parsing defects which the parser was able to work around.\n class MessageDefect(ValueError):\n     \"\"\"Base class for a message defect.\"\"\"\n```\n\nFilename: Lib/email/generator.py:\n```\n@@ -14,12 +14,14 @@\nfrom copy import deepcopy\n from io import StringIO, BytesIO\n from email.utils import _has_surrogates\n+from email.errors import HeaderWriteError\n \n UNDERSCORE = '_'\n NL = '\\n'  # XXX: no longer used by the code below.\n \n NLCRE = re.compile(r'\\r\\n|\\r|\\n')\n fcre = re.compile(r'^From ', re.MULTILINE)\n+NEWLINE_WITHOUT_FWSP = re.compile(r'\\r\\n[^ \\t]|\\r[^ \\n\\t]|\\n[^ \\t]')\n \n \n class Generator:\n\n@@ -222,7 +224,16 @@\ndef _dispatch(self, msg):\n \n     def _write_headers(self, msg):\n         for h, v in msg.raw_items():\n-            self.write(self.policy.fold(h, v))\n+            folded = self.policy.fold(h, v)\n+            if self.policy.verify_generated_headers:\n+                linesep = self.policy.linesep\n+                if not folded.endswith(self.policy.linesep):\n+                    raise HeaderWriteError(\n+                        f'folded header does not end with {linesep!r}: {folded!r}')\n+                if NEWLINE_WITHOUT_FWSP.search(folded.removesuffix(linesep)):\n+                    raise HeaderWriteError(\n+                        f'folded header contains newline: {folded!r}')\n+            self.write(folded)\n         # A blank line always separates headers from body\n         self.write(self._NL)\n```\n\nFilename: Lib/test/test_email/test_generator.py:\n```\n@@ -6,6 +6,7 @@\nfrom email.generator import Generator, BytesGenerator\n from email.headerregistry import Address\n from email import policy\n+import email.errors\n from test.test_email import TestEmailBase, parameterize\n\n@@ -249,6 +250,44 @@\ndef test_rfc2231_wrapping_switches_to_default_len_if_too_narrow(self):\n         g.flatten(msg)\n         self.assertEqual(s.getvalue(), self.typ(expected))\n \n+    def test_keep_encoded_newlines(self):\n+        msg = self.msgmaker(self.typ(textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")))\n+        expected = textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")\n+        s = self.ioclass()\n+        g = self.genclass(s, policy=self.policy.clone(max_line_length=80))\n+        g.flatten(msg)\n+        self.assertEqual(s.getvalue(), self.typ(expected))\n+\n+    def test_keep_long_encoded_newlines(self):\n+        msg = self.msgmaker(self.typ(textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")))\n+        expected = textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject\n+             =?utf-8?q?=0A?=Bcc:\n+             injection@example.com\n+\n+            None\n+            \"\"\")\n+        s = self.ioclass()\n+        g = self.genclass(s, policy=self.policy.clone(max_line_length=30))\n+        g.flatten(msg)\n+        self.assertEqual(s.getvalue(), self.typ(expected))\n+\n \n class TestGenerator(TestGeneratorBase, TestEmailBase):\n\n@@ -273,6 +312,29 @@\ndef test_flatten_unicode_linesep(self):\n         g.flatten(msg)\n         self.assertEqual(s.getvalue(), self.typ(expected))\n \n+    def test_verify_generated_headers(self):\n+        \"\"\"gh-121650: by default the generator prevents header injection\"\"\"\n+        class LiteralHeader(str):\n+            name = 'Header'\n+            def fold(self, **kwargs):\n+                return self\n+\n+        for text in (\n+            'Value\\r\\nBad Injection\\r\\n',\n+            'NoNewLine'\n+        ):\n+            with self.subTest(text=text):\n+                message = message_from_string(\n+                    \"Header: Value\\r\\n\\r\\nBody\",\n+                    policy=self.policy,\n+                )\n+\n+                del message['Header']\n+                message['Header'] = LiteralHeader(text)\n+\n+                with self.assertRaises(email.errors.HeaderWriteError):\n+                    message.as_string()\n+\n \n class TestBytesGenerator(TestGeneratorBase, TestEmailBase):\n```\n\nFilename: Lib/test/test_email/test_policy.py:\n```\n@@ -26,6 +26,7 @@\nclass PolicyAPITests(unittest.TestCase):\n         'raise_on_defect':          False,\n         'mangle_from_':             True,\n         'message_factory':          None,\n+        'verify_generated_headers': True,\n         }\n     # These default values are the ones set on email.policy.default.\n     # If any of these defaults change, the docs must be updated.\n\n@@ -294,6 +295,31 @@\ndef test_short_maxlen_error(self):\n                 with self.assertRaises(email.errors.HeaderParseError):\n                     policy.fold(\"Subject\", subject)\n \n+    def test_verify_generated_headers(self):\n+        \"\"\"Turning protection off allows header injection\"\"\"\n+        policy = email.policy.default.clone(verify_generated_headers=False)\n+        for text in (\n+            'Header: Value\\r\\nBad: Injection\\r\\n',\n+            'Header: NoNewLine'\n+        ):\n+            with self.subTest(text=text):\n+                message = email.message_from_string(\n+                    \"Header: Value\\r\\n\\r\\nBody\",\n+                    policy=policy,\n+                )\n+                class LiteralHeader(str):\n+                    name = 'Header'\n+                    def fold(self, **kwargs):\n+                        return self\n+\n+                del message['Header']\n+                message['Header'] = LiteralHeader(text)\n+\n+                self.assertEqual(\n+                    message.as_string(),\n+                    f\"{text}\\nBody\",\n+                )\n+\n     # XXX: Need subclassing tests.\n     # For adding subclassed objects, make sure the usual rules apply (subclass\n     # wins), but that the order still works (right overrides left).\n```\n\nFilename: Misc/NEWS.d/next/Library/2024-07-27-16-10-41.gh-issue-121650.nf6oc9.rst:\n```\n@@ -0,0 +1,5 @@\n+:mod:`email` headers with embedded newlines are now quoted on output. The\n+:mod:`~email.generator` will now refuse to serialize (write) headers that\n+are unsafely folded or delimited; see\n+:attr:`~email.policy.Policy.verify_generated_headers`. (Contributed by Bas\n+Bloemsaat and Petr Viktorin in :gh:`121650`.)\n```"
            }
        ],
        "sw_version": "v3.8.19",
        "sw_version_wget": "https://github.com/python/cpython/archive/refs/tags/v3.8.19.zip",
        "description": "There is a MEDIUM severity vulnerability affecting CPython.\n\nThe \nemail module didnt properly quote newlines for email headers when \nserializing an email message allowing for header injection when an email\n is serialized.",
        "sec_adv": [],
        "cwe": [
            {
                "id": "n/a",
                "value": "n/a"
            }
        ]
    }
}