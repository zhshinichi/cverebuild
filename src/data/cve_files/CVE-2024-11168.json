{
    "CVE-2024-11168": {
        "published_date": "2024-11-12T21:22:23.438Z",
        "patch_commits": [
            {
                "url": "https://github.com/python/cpython/commit/29f348e232e82938ba2165843c448c2b291504c5",
                "content": "gh-103848: Adds checks to ensure that bracketed hosts found by urlsplit are of IPv6 or IPvFuture format (#103849)\n\n* Adds checks to ensure that bracketed hosts found by urlsplit are of IPv6 or IPvFuture format\r\n\r\n---------\r\n\r\nCo-authored-by: Gregory P. Smith <greg@krypto.org>\n\nFilename: Lib/test/test_urlparse.py:\n```\n@@ -1042,6 +1042,32 @@\ndef test_issue14072(self):\n         self.assertEqual(p2.scheme, 'tel')\n         self.assertEqual(p2.path, '+31641044153')\n \n+    def test_invalid_bracketed_hosts(self):\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[192.0.2.146]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[important.com:8000]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[v123r.IP]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[v12ae]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[v.IP]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[v123.]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[v]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[0439:23af::2309::fae7:1234]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[0439:23af:2309::fae7:1234:2342:438e:192.0.2.146]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@]v6a.ip[/Path')\n+\n+    def test_splitting_bracketed_hosts(self):\n+        p1 = urllib.parse.urlsplit('scheme://user@[v6a.ip]/path?query')\n+        self.assertEqual(p1.hostname, 'v6a.ip')\n+        self.assertEqual(p1.username, 'user')\n+        self.assertEqual(p1.path, '/path')\n+        p2 = urllib.parse.urlsplit('scheme://user@[0439:23af:2309::fae7%test]/path?query')\n+        self.assertEqual(p2.hostname, '0439:23af:2309::fae7%test')\n+        self.assertEqual(p2.username, 'user')\n+        self.assertEqual(p2.path, '/path')\n+        p3 = urllib.parse.urlsplit('scheme://user@[0439:23af:2309::fae7:1234:192.0.2.146%test]/path?query')\n+        self.assertEqual(p3.hostname, '0439:23af:2309::fae7:1234:192.0.2.146%test')\n+        self.assertEqual(p3.username, 'user')\n+        self.assertEqual(p3.path, '/path')\n+\n     def test_port_casting_failure_message(self):\n         message = \"Port could not be cast to integer value as 'oracle'\"\n         p1 = urllib.parse.urlparse('http://Server=sde; Service=sde:oracle')\n```\n\nFilename: Lib/urllib/parse.py:\n```\n@@ -33,6 +33,7 @@\nimport re\n import types\n import warnings\n+import ipaddress\n \n __all__ = [\"urlparse\", \"urlunparse\", \"urljoin\", \"urldefrag\",\n            \"urlsplit\", \"urlunsplit\", \"urlencode\", \"parse_qs\",\n\n@@ -427,6 +428,17 @@\ndef _checknetloc(netloc):\n             raise ValueError(\"netloc '\" + netloc + \"' contains invalid \" +\n                              \"characters under NFKC normalization\")\n \n+# Valid bracketed hosts are defined in\n+# https://www.rfc-editor.org/rfc/rfc3986#page-49 and https://url.spec.whatwg.org/\n+def _check_bracketed_host(hostname):\n+    if hostname.startswith('v'):\n+        if not re.match(r\"\\Av[a-fA-F0-9]+\\..+\\Z\", hostname):\n+            raise ValueError(f\"IPvFuture address is invalid\")\n+    else:\n+        ip = ipaddress.ip_address(hostname) # Throws Value Error if not IPv6 or IPv4\n+        if isinstance(ip, ipaddress.IPv4Address):\n+            raise ValueError(f\"An IPv4 address cannot be in brackets\")\n+\n # typed=True avoids BytesWarnings being emitted during cache key\n # comparison since this API supports both bytes and str input.\n @functools.lru_cache(typed=True)\n\n@@ -466,12 +478,14 @@\ndef urlsplit(url, scheme='', allow_fragments=True):\n                 break\n         else:\n             scheme, url = url[:i].lower(), url[i+1:]\n-\n     if url[:2] == '//':\n         netloc, url = _splitnetloc(url, 2)\n         if (('[' in netloc and ']' not in netloc) or\n                 (']' in netloc and '[' not in netloc)):\n             raise ValueError(\"Invalid IPv6 URL\")\n+        if '[' in netloc and ']' in netloc:\n+            bracketed_host = netloc.partition('[')[2].partition(']')[0]\n+            _check_bracketed_host(bracketed_host)\n     if allow_fragments and '#' in url:\n         url, fragment = url.split('#', 1)\n     if '?' in url:\n```\n\nFilename: Misc/NEWS.d/next/Library/2023-04-26-09-54-25.gh-issue-103848.aDSnpR.rst:\n```\n@@ -0,0 +1,2 @@\n+Add checks to ensure that ``[`` bracketed ``]`` hosts found by\n+:func:`urllib.parse.urlsplit` are of IPv6 or IPvFuture format.\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/b2171a2fd41416cf68afd67460578631d755a550",
                "content": "[3.11] gh-103848: Adds checks to ensure that bracketed hosts found by urlsplit are of IPv6 or IPvFuture format (GH-103849) (#104349)\n\ngh-103848: Adds checks to ensure that bracketed hosts found by urlsplit are of IPv6 or IPvFuture format (GH-103849)\r\n\r\n* Adds checks to ensure that bracketed hosts found by urlsplit are of IPv6 or IPvFuture format\r\n\r\n---------\r\n\r\n(cherry picked from commit 29f348e232e82938ba2165843c448c2b291504c5)\r\n\r\nCo-authored-by: JohnJamesUtley <81572567+JohnJamesUtley@users.noreply.github.com>\r\nCo-authored-by: Gregory P. Smith <greg@krypto.org>\n\nFilename: Lib/test/test_urlparse.py:\n```\n@@ -1033,6 +1033,32 @@\ndef test_issue14072(self):\n         self.assertEqual(p2.scheme, 'tel')\n         self.assertEqual(p2.path, '+31641044153')\n \n+    def test_invalid_bracketed_hosts(self):\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[192.0.2.146]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[important.com:8000]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[v123r.IP]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[v12ae]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[v.IP]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[v123.]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[v]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[0439:23af::2309::fae7:1234]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[0439:23af:2309::fae7:1234:2342:438e:192.0.2.146]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@]v6a.ip[/Path')\n+\n+    def test_splitting_bracketed_hosts(self):\n+        p1 = urllib.parse.urlsplit('scheme://user@[v6a.ip]/path?query')\n+        self.assertEqual(p1.hostname, 'v6a.ip')\n+        self.assertEqual(p1.username, 'user')\n+        self.assertEqual(p1.path, '/path')\n+        p2 = urllib.parse.urlsplit('scheme://user@[0439:23af:2309::fae7%test]/path?query')\n+        self.assertEqual(p2.hostname, '0439:23af:2309::fae7%test')\n+        self.assertEqual(p2.username, 'user')\n+        self.assertEqual(p2.path, '/path')\n+        p3 = urllib.parse.urlsplit('scheme://user@[0439:23af:2309::fae7:1234:192.0.2.146%test]/path?query')\n+        self.assertEqual(p3.hostname, '0439:23af:2309::fae7:1234:192.0.2.146%test')\n+        self.assertEqual(p3.username, 'user')\n+        self.assertEqual(p3.path, '/path')\n+\n     def test_port_casting_failure_message(self):\n         message = \"Port could not be cast to integer value as 'oracle'\"\n         p1 = urllib.parse.urlparse('http://Server=sde; Service=sde:oracle')\n```\n\nFilename: Lib/urllib/parse.py:\n```\n@@ -33,6 +33,7 @@\nimport sys\n import types\n import warnings\n+import ipaddress\n \n __all__ = [\"urlparse\", \"urlunparse\", \"urljoin\", \"urldefrag\",\n            \"urlsplit\", \"urlunsplit\", \"urlencode\", \"parse_qs\",\n\n@@ -427,6 +428,17 @@\ndef _checknetloc(netloc):\n             raise ValueError(\"netloc '\" + netloc + \"' contains invalid \" +\n                              \"characters under NFKC normalization\")\n \n+# Valid bracketed hosts are defined in\n+# https://www.rfc-editor.org/rfc/rfc3986#page-49 and https://url.spec.whatwg.org/\n+def _check_bracketed_host(hostname):\n+    if hostname.startswith('v'):\n+        if not re.match(r\"\\Av[a-fA-F0-9]+\\..+\\Z\", hostname):\n+            raise ValueError(f\"IPvFuture address is invalid\")\n+    else:\n+        ip = ipaddress.ip_address(hostname) # Throws Value Error if not IPv6 or IPv4\n+        if isinstance(ip, ipaddress.IPv4Address):\n+            raise ValueError(f\"An IPv4 address cannot be in brackets\")\n+\n # typed=True avoids BytesWarnings being emitted during cache key\n # comparison since this API supports both bytes and str input.\n @functools.lru_cache(typed=True)\n\n@@ -466,12 +478,14 @@\ndef urlsplit(url, scheme='', allow_fragments=True):\n                 break\n         else:\n             scheme, url = url[:i].lower(), url[i+1:]\n-\n     if url[:2] == '//':\n         netloc, url = _splitnetloc(url, 2)\n         if (('[' in netloc and ']' not in netloc) or\n                 (']' in netloc and '[' not in netloc)):\n             raise ValueError(\"Invalid IPv6 URL\")\n+        if '[' in netloc and ']' in netloc:\n+            bracketed_host = netloc.partition('[')[2].partition(']')[0]\n+            _check_bracketed_host(bracketed_host)\n     if allow_fragments and '#' in url:\n         url, fragment = url.split('#', 1)\n     if '?' in url:\n```\n\nFilename: Misc/NEWS.d/next/Library/2023-04-26-09-54-25.gh-issue-103848.aDSnpR.rst:\n```\n@@ -0,0 +1,2 @@\n+Add checks to ensure that ``[`` bracketed ``]`` hosts found by\n+:func:`urllib.parse.urlsplit` are of IPv6 or IPvFuture format.\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/634ded45545ce8cbd6fd5d49785613dd7fa9b89e",
                "content": "[3.10] gh-103848: Adds checks to ensure that bracketed hosts found by urlsplit are of IPv6 or IPvFuture format (#103849) (#126975)\n\nCo-authored-by: Gregory P. Smith <greg@krypto.org>\r\n(cherry picked from commit 29f348e232e82938ba2165843c448c2b291504c5)\r\n\r\nCo-authored-by: JohnJamesUtley <81572567+JohnJamesUtley@users.noreply.github.com>\n\nFilename: Lib/test/test_urlparse.py:\n```\n@@ -1138,6 +1138,32 @@\ndef test_issue14072(self):\n         self.assertEqual(p2.scheme, 'tel')\n         self.assertEqual(p2.path, '+31641044153')\n \n+    def test_invalid_bracketed_hosts(self):\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[192.0.2.146]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[important.com:8000]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[v123r.IP]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[v12ae]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[v.IP]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[v123.]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[v]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[0439:23af::2309::fae7:1234]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[0439:23af:2309::fae7:1234:2342:438e:192.0.2.146]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@]v6a.ip[/Path')\n+\n+    def test_splitting_bracketed_hosts(self):\n+        p1 = urllib.parse.urlsplit('scheme://user@[v6a.ip]/path?query')\n+        self.assertEqual(p1.hostname, 'v6a.ip')\n+        self.assertEqual(p1.username, 'user')\n+        self.assertEqual(p1.path, '/path')\n+        p2 = urllib.parse.urlsplit('scheme://user@[0439:23af:2309::fae7%test]/path?query')\n+        self.assertEqual(p2.hostname, '0439:23af:2309::fae7%test')\n+        self.assertEqual(p2.username, 'user')\n+        self.assertEqual(p2.path, '/path')\n+        p3 = urllib.parse.urlsplit('scheme://user@[0439:23af:2309::fae7:1234:192.0.2.146%test]/path?query')\n+        self.assertEqual(p3.hostname, '0439:23af:2309::fae7:1234:192.0.2.146%test')\n+        self.assertEqual(p3.username, 'user')\n+        self.assertEqual(p3.path, '/path')\n+\n     def test_port_casting_failure_message(self):\n         message = \"Port could not be cast to integer value as 'oracle'\"\n         p1 = urllib.parse.urlparse('http://Server=sde; Service=sde:oracle')\n```\n\nFilename: Lib/urllib/parse.py:\n```\n@@ -36,6 +36,7 @@\nimport types\n import collections\n import warnings\n+import ipaddress\n \n __all__ = [\"urlparse\", \"urlunparse\", \"urljoin\", \"urldefrag\",\n            \"urlsplit\", \"urlunsplit\", \"urlencode\", \"parse_qs\",\n\n@@ -441,6 +442,17 @@\ndef _checknetloc(netloc):\n             raise ValueError(\"netloc '\" + netloc + \"' contains invalid \" +\n                              \"characters under NFKC normalization\")\n \n+# Valid bracketed hosts are defined in\n+# https://www.rfc-editor.org/rfc/rfc3986#page-49 and https://url.spec.whatwg.org/\n+def _check_bracketed_host(hostname):\n+    if hostname.startswith('v'):\n+        if not re.match(r\"\\Av[a-fA-F0-9]+\\..+\\Z\", hostname):\n+            raise ValueError(f\"IPvFuture address is invalid\")\n+    else:\n+        ip = ipaddress.ip_address(hostname) # Throws Value Error if not IPv6 or IPv4\n+        if isinstance(ip, ipaddress.IPv4Address):\n+            raise ValueError(f\"An IPv4 address cannot be in brackets\")\n+\n def urlsplit(url, scheme='', allow_fragments=True):\n     \"\"\"Parse a URL into 5 components:\n     <scheme>://<netloc>/<path>?<query>#<fragment>\n\n@@ -487,12 +499,14 @@\ndef urlsplit(url, scheme='', allow_fragments=True):\n                 break\n         else:\n             scheme, url = url[:i].lower(), url[i+1:]\n-\n     if url[:2] == '//':\n         netloc, url = _splitnetloc(url, 2)\n         if (('[' in netloc and ']' not in netloc) or\n                 (']' in netloc and '[' not in netloc)):\n             raise ValueError(\"Invalid IPv6 URL\")\n+        if '[' in netloc and ']' in netloc:\n+            bracketed_host = netloc.partition('[')[2].partition(']')[0]\n+            _check_bracketed_host(bracketed_host)\n     if allow_fragments and '#' in url:\n         url, fragment = url.split('#', 1)\n     if '?' in url:\n```\n\nFilename: Misc/NEWS.d/next/Library/2023-04-26-09-54-25.gh-issue-103848.aDSnpR.rst:\n```\n@@ -0,0 +1,2 @@\n+Add checks to ensure that ``[`` bracketed ``]`` hosts found by\n+:func:`urllib.parse.urlsplit` are of IPv6 or IPvFuture format.\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/ddca2953191c67a12b1f19d6bca41016c6ae7132",
                "content": "[3.9] gh-103848: Adds checks to ensure that bracketed hosts found by urlsplit are of IPv6 or IPvFuture format (#103849) (#126976)\n\nCo-authored-by: Gregory P. Smith <greg@krypto.org>\r\n(cherry picked from commit 29f348e232e82938ba2165843c448c2b291504c5)\r\n\r\nCo-authored-by: JohnJamesUtley <81572567+JohnJamesUtley@users.noreply.github.com>\n\nFilename: Lib/test/test_urlparse.py:\n```\n@@ -1135,6 +1135,32 @@\ndef test_issue14072(self):\n         self.assertEqual(p2.scheme, 'tel')\n         self.assertEqual(p2.path, '+31641044153')\n \n+    def test_invalid_bracketed_hosts(self):\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[192.0.2.146]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[important.com:8000]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[v123r.IP]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[v12ae]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[v.IP]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[v123.]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[v]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[0439:23af::2309::fae7:1234]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@[0439:23af:2309::fae7:1234:2342:438e:192.0.2.146]/Path?Query')\n+        self.assertRaises(ValueError, urllib.parse.urlsplit, 'Scheme://user@]v6a.ip[/Path')\n+\n+    def test_splitting_bracketed_hosts(self):\n+        p1 = urllib.parse.urlsplit('scheme://user@[v6a.ip]/path?query')\n+        self.assertEqual(p1.hostname, 'v6a.ip')\n+        self.assertEqual(p1.username, 'user')\n+        self.assertEqual(p1.path, '/path')\n+        p2 = urllib.parse.urlsplit('scheme://user@[0439:23af:2309::fae7%test]/path?query')\n+        self.assertEqual(p2.hostname, '0439:23af:2309::fae7%test')\n+        self.assertEqual(p2.username, 'user')\n+        self.assertEqual(p2.path, '/path')\n+        p3 = urllib.parse.urlsplit('scheme://user@[0439:23af:2309::fae7:1234:192.0.2.146%test]/path?query')\n+        self.assertEqual(p3.hostname, '0439:23af:2309::fae7:1234:192.0.2.146%test')\n+        self.assertEqual(p3.username, 'user')\n+        self.assertEqual(p3.path, '/path')\n+\n     def test_port_casting_failure_message(self):\n         message = \"Port could not be cast to integer value as 'oracle'\"\n         p1 = urllib.parse.urlparse('http://Server=sde; Service=sde:oracle')\n```\n\nFilename: Lib/urllib/parse.py:\n```\n@@ -36,6 +36,7 @@\nimport types\n import collections\n import warnings\n+import ipaddress\n \n __all__ = [\"urlparse\", \"urlunparse\", \"urljoin\", \"urldefrag\",\n            \"urlsplit\", \"urlunsplit\", \"urlencode\", \"parse_qs\",\n\n@@ -442,6 +443,17 @@\ndef _checknetloc(netloc):\n             raise ValueError(\"netloc '\" + netloc + \"' contains invalid \" +\n                              \"characters under NFKC normalization\")\n \n+# Valid bracketed hosts are defined in\n+# https://www.rfc-editor.org/rfc/rfc3986#page-49 and https://url.spec.whatwg.org/\n+def _check_bracketed_host(hostname):\n+    if hostname.startswith('v'):\n+        if not re.match(r\"\\Av[a-fA-F0-9]+\\..+\\Z\", hostname):\n+            raise ValueError(f\"IPvFuture address is invalid\")\n+    else:\n+        ip = ipaddress.ip_address(hostname) # Throws Value Error if not IPv6 or IPv4\n+        if isinstance(ip, ipaddress.IPv4Address):\n+            raise ValueError(f\"An IPv4 address cannot be in brackets\")\n+\n def urlsplit(url, scheme='', allow_fragments=True):\n     \"\"\"Parse a URL into 5 components:\n     <scheme>://<netloc>/<path>?<query>#<fragment>\n\n@@ -488,12 +500,14 @@\ndef urlsplit(url, scheme='', allow_fragments=True):\n                 break\n         else:\n             scheme, url = url[:i].lower(), url[i+1:]\n-\n     if url[:2] == '//':\n         netloc, url = _splitnetloc(url, 2)\n         if (('[' in netloc and ']' not in netloc) or\n                 (']' in netloc and '[' not in netloc)):\n             raise ValueError(\"Invalid IPv6 URL\")\n+        if '[' in netloc and ']' in netloc:\n+            bracketed_host = netloc.partition('[')[2].partition(']')[0]\n+            _check_bracketed_host(bracketed_host)\n     if allow_fragments and '#' in url:\n         url, fragment = url.split('#', 1)\n     if '?' in url:\n```\n\nFilename: Misc/NEWS.d/next/Library/2023-04-26-09-54-25.gh-issue-103848.aDSnpR.rst:\n```\n@@ -0,0 +1,2 @@\n+Add checks to ensure that ``[`` bracketed ``]`` hosts found by\n+:func:`urllib.parse.urlsplit` are of IPv6 or IPvFuture format.\n```"
            }
        ],
        "sw_version": "v3.9.20",
        "sw_version_wget": "https://github.com/python/cpython/archive/refs/tags/v3.9.20.zip",
        "description": "The urllib.parse.urlsplit() and urlparse() functions improperly validated bracketed hosts (`[]`), allowing hosts that weren't IPv6 or IPvFuture. This behavior was not conformant to RFC 3986 and potentially enabled SSRF if a URL is processed by more than one URL parser.",
        "sec_adv": [],
        "cwe": [
            {
                "id": "n/a",
                "value": "n/a"
            }
        ]
    }
}