{
    "CVE-2024-40635": {
        "published_date": "2025-03-17T21:32:37.894Z",
        "patch_commits": [
            {
                "url": "https://github.com/containerd/containerd/commit/05044ec0a9a75232cad458027ca83437aae3f4da",
                "content": "Merge commit from fork\n\n[release 1.7] validate uid/gid\n\nFilename: oci/spec_opts.go:\n```\n@@ -22,6 +22,7 @@\nimport (\n \t\"encoding/json\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"math\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"runtime\"\n\n@@ -594,6 +595,20 @@\nfunc WithUser(userstr string) SpecOpts {\n \t\tdefer ensureAdditionalGids(s)\n \t\tsetProcess(s)\n \t\ts.Process.User.AdditionalGids = nil\n+\t\t// While the Linux kernel allows the max UID to be MaxUint32 - 2,\n+                // and the OCI Runtime Spec has no definition about the max UID,\n+                // the runc implementation is known to require the UID to be <= MaxInt32.\n+                //\n+                // containerd follows runc's limitation here.\n+                //\n+                // In future we may relax this limitation to allow MaxUint32 - 2,\n+                // or, amend the OCI Runtime Spec to codify the implementation limitation.\n+\t\tconst (\n+\t\t\tminUserID  = 0\n+\t\t\tmaxUserID  = math.MaxInt32\n+\t\t\tminGroupID = 0\n+\t\t\tmaxGroupID = math.MaxInt32\n+\t\t)\n \n \t\t// For LCOW it's a bit harder to confirm that the user actually exists on the host as a rootfs isn't\n \t\t// mounted on the host and shared into the guest, but rather the rootfs is constructed entirely in the\n\n@@ -612,8 +627,8 @@\nfunc WithUser(userstr string) SpecOpts {\n \t\tswitch len(parts) {\n \t\tcase 1:\n \t\t\tv, err := strconv.Atoi(parts[0])\n-\t\t\tif err != nil {\n-\t\t\t\t// if we cannot parse as a uint they try to see if it is a username\n+\t\t\tif err != nil || v < minUserID || v > maxUserID {\n+\t\t\t\t// if we cannot parse as an int32 then try to see if it is a username\n \t\t\t\treturn WithUsername(userstr)(ctx, client, c, s)\n \t\t\t}\n \t\t\treturn WithUserID(uint32(v))(ctx, client, c, s)\n\n@@ -624,12 +639,13 @@\nfunc WithUser(userstr string) SpecOpts {\n \t\t\t)\n \t\t\tvar uid, gid uint32\n \t\t\tv, err := strconv.Atoi(parts[0])\n-\t\t\tif err != nil {\n+\t\t\tif err != nil || v < minUserID || v > maxUserID {\n \t\t\t\tusername = parts[0]\n \t\t\t} else {\n \t\t\t\tuid = uint32(v)\n \t\t\t}\n-\t\t\tif v, err = strconv.Atoi(parts[1]); err != nil {\n+\t\t\tv, err = strconv.Atoi(parts[1])\n+\t\t\tif err != nil || v < minGroupID || v > maxGroupID {\n \t\t\t\tgroupname = parts[1]\n \t\t\t} else {\n \t\t\t\tgid = uint32(v)\n```\n\nFilename: oci/spec_opts_linux_test.go:\n```\n@@ -33,6 +33,98 @@\nimport (\n \t\"golang.org/x/sys/unix\"\n )\n \n+//nolint:gosec\n+func TestWithUser(t *testing.T) {\n+\tt.Parallel()\n+\n+\texpectedPasswd := `root:x:0:0:root:/root:/bin/ash\n+guest:x:405:100:guest:/dev/null:/sbin/nologin\n+`\n+\texpectedGroup := `root:x:0:root\n+bin:x:1:root,bin,daemon\n+daemon:x:2:root,bin,daemon\n+sys:x:3:root,bin,adm\n+guest:x:100:guest\n+`\n+\ttd := t.TempDir()\n+\tapply := fstest.Apply(\n+\t\tfstest.CreateDir(\"/etc\", 0777),\n+\t\tfstest.CreateFile(\"/etc/passwd\", []byte(expectedPasswd), 0777),\n+\t\tfstest.CreateFile(\"/etc/group\", []byte(expectedGroup), 0777),\n+\t)\n+\tif err := apply.Apply(td); err != nil {\n+\t\tt.Fatalf(\"failed to apply: %v\", err)\n+\t}\n+\tc := containers.Container{ID: t.Name()}\n+\ttestCases := []struct {\n+\t\tuser        string\n+\t\texpectedUID uint32\n+\t\texpectedGID uint32\n+\t\terr         string\n+\t}{\n+\t\t{\n+\t\t\tuser:        \"0\",\n+\t\t\texpectedUID: 0,\n+\t\t\texpectedGID: 0,\n+\t\t},\n+\t\t{\n+\t\t\tuser:        \"root:root\",\n+\t\t\texpectedUID: 0,\n+\t\t\texpectedGID: 0,\n+\t\t},\n+\t\t{\n+\t\t\tuser:        \"guest\",\n+\t\t\texpectedUID: 405,\n+\t\t\texpectedGID: 100,\n+\t\t},\n+\t\t{\n+\t\t\tuser:        \"guest:guest\",\n+\t\t\texpectedUID: 405,\n+\t\t\texpectedGID: 100,\n+\t\t},\n+\t\t{\n+\t\t\tuser: \"guest:nobody\",\n+\t\t\terr:  \"no groups found\",\n+\t\t},\n+\t\t{\n+\t\t\tuser:        \"405:100\",\n+\t\t\texpectedUID: 405,\n+\t\t\texpectedGID: 100,\n+\t\t},\n+\t\t{\n+\t\t\tuser: \"405:2147483648\",\n+\t\t\terr:  \"no groups found\",\n+\t\t},\n+\t\t{\n+\t\t\tuser: \"-1000\",\n+\t\t\terr:  \"no users found\",\n+\t\t},\n+\t\t{\n+\t\t\tuser: \"2147483648\",\n+\t\t\terr:  \"no users found\",\n+\t\t},\n+\t}\n+\tfor _, testCase := range testCases {\n+\t\ttestCase := testCase\n+\t\tt.Run(testCase.user, func(t *testing.T) {\n+\t\t\tt.Parallel()\n+\t\t\ts := Spec{\n+\t\t\t\tVersion: specs.Version,\n+\t\t\t\tRoot: &specs.Root{\n+\t\t\t\t\tPath: td,\n+\t\t\t\t},\n+\t\t\t\tLinux: &specs.Linux{},\n+\t\t\t}\n+\t\t\terr := WithUser(testCase.user)(context.Background(), nil, &c, &s)\n+\t\t\tif err != nil {\n+\t\t\t\tassert.EqualError(t, err, testCase.err)\n+\t\t\t}\n+\t\t\tassert.Equal(t, testCase.expectedUID, s.Process.User.UID)\n+\t\t\tassert.Equal(t, testCase.expectedGID, s.Process.User.GID)\n+\t\t})\n+\t}\n+}\n+\n //nolint:gosec\n func TestWithUserID(t *testing.T) {\n \tt.Parallel()\n```"
            },
            {
                "url": "https://github.com/containerd/containerd/commit/1a43cb6a1035441f9aca8f5666a9b3ef9e70ab20",
                "content": "Merge commit from fork\n\n[release 2.0] validate uid/gid\n\nFilename: pkg/oci/spec_opts.go:\n```\n@@ -22,6 +22,7 @@\nimport (\n \t\"encoding/json\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"math\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"runtime\"\n\n@@ -593,6 +594,20 @@\nfunc WithUser(userstr string) SpecOpts {\n \t\tdefer ensureAdditionalGids(s)\n \t\tsetProcess(s)\n \t\ts.Process.User.AdditionalGids = nil\n+\t\t// While the Linux kernel allows the max UID to be MaxUint32 - 2,\n+                // and the OCI Runtime Spec has no definition about the max UID,\n+                // the runc implementation is known to require the UID to be <= MaxInt32.\n+                //\n+                // containerd follows runc's limitation here.\n+                //\n+                // In future we may relax this limitation to allow MaxUint32 - 2,\n+                // or, amend the OCI Runtime Spec to codify the implementation limitation.\n+\t\tconst (\n+\t\t\tminUserID  = 0\n+\t\t\tmaxUserID  = math.MaxInt32\n+\t\t\tminGroupID = 0\n+\t\t\tmaxGroupID = math.MaxInt32\n+\t\t)\n \n \t\t// For LCOW it's a bit harder to confirm that the user actually exists on the host as a rootfs isn't\n \t\t// mounted on the host and shared into the guest, but rather the rootfs is constructed entirely in the\n\n@@ -611,8 +626,8 @@\nfunc WithUser(userstr string) SpecOpts {\n \t\tswitch len(parts) {\n \t\tcase 1:\n \t\t\tv, err := strconv.Atoi(parts[0])\n-\t\t\tif err != nil {\n-\t\t\t\t// if we cannot parse as a uint they try to see if it is a username\n+\t\t\tif err != nil || v < minUserID || v > maxUserID {\n+\t\t\t\t// if we cannot parse as an int32 then try to see if it is a username\n \t\t\t\treturn WithUsername(userstr)(ctx, client, c, s)\n \t\t\t}\n \t\t\treturn WithUserID(uint32(v))(ctx, client, c, s)\n\n@@ -623,12 +638,13 @@\nfunc WithUser(userstr string) SpecOpts {\n \t\t\t)\n \t\t\tvar uid, gid uint32\n \t\t\tv, err := strconv.Atoi(parts[0])\n-\t\t\tif err != nil {\n+\t\t\tif err != nil || v < minUserID || v > maxUserID {\n \t\t\t\tusername = parts[0]\n \t\t\t} else {\n \t\t\t\tuid = uint32(v)\n \t\t\t}\n-\t\t\tif v, err = strconv.Atoi(parts[1]); err != nil {\n+\t\t\tv, err = strconv.Atoi(parts[1])\n+\t\t\tif err != nil || v < minGroupID || v > maxGroupID {\n \t\t\t\tgroupname = parts[1]\n \t\t\t} else {\n \t\t\t\tgid = uint32(v)\n```\n\nFilename: pkg/oci/spec_opts_linux_test.go:\n```\n@@ -33,6 +33,98 @@\nimport (\n \t\"golang.org/x/sys/unix\"\n )\n \n+//nolint:gosec\n+func TestWithUser(t *testing.T) {\n+\tt.Parallel()\n+\n+\texpectedPasswd := `root:x:0:0:root:/root:/bin/ash\n+guest:x:405:100:guest:/dev/null:/sbin/nologin\n+`\n+\texpectedGroup := `root:x:0:root\n+bin:x:1:root,bin,daemon\n+daemon:x:2:root,bin,daemon\n+sys:x:3:root,bin,adm\n+guest:x:100:guest\n+`\n+\ttd := t.TempDir()\n+\tapply := fstest.Apply(\n+\t\tfstest.CreateDir(\"/etc\", 0777),\n+\t\tfstest.CreateFile(\"/etc/passwd\", []byte(expectedPasswd), 0777),\n+\t\tfstest.CreateFile(\"/etc/group\", []byte(expectedGroup), 0777),\n+\t)\n+\tif err := apply.Apply(td); err != nil {\n+\t\tt.Fatalf(\"failed to apply: %v\", err)\n+\t}\n+\tc := containers.Container{ID: t.Name()}\n+\ttestCases := []struct {\n+\t\tuser        string\n+\t\texpectedUID uint32\n+\t\texpectedGID uint32\n+\t\terr         string\n+\t}{\n+\t\t{\n+\t\t\tuser:        \"0\",\n+\t\t\texpectedUID: 0,\n+\t\t\texpectedGID: 0,\n+\t\t},\n+\t\t{\n+\t\t\tuser:        \"root:root\",\n+\t\t\texpectedUID: 0,\n+\t\t\texpectedGID: 0,\n+\t\t},\n+\t\t{\n+\t\t\tuser:        \"guest\",\n+\t\t\texpectedUID: 405,\n+\t\t\texpectedGID: 100,\n+\t\t},\n+\t\t{\n+\t\t\tuser:        \"guest:guest\",\n+\t\t\texpectedUID: 405,\n+\t\t\texpectedGID: 100,\n+\t\t},\n+\t\t{\n+\t\t\tuser: \"guest:nobody\",\n+\t\t\terr:  \"no groups found\",\n+\t\t},\n+\t\t{\n+\t\t\tuser:        \"405:100\",\n+\t\t\texpectedUID: 405,\n+\t\t\texpectedGID: 100,\n+\t\t},\n+\t\t{\n+\t\t\tuser: \"405:2147483648\",\n+\t\t\terr:  \"no groups found\",\n+\t\t},\n+\t\t{\n+\t\t\tuser: \"-1000\",\n+\t\t\terr:  \"no users found\",\n+\t\t},\n+\t\t{\n+\t\t\tuser: \"2147483648\",\n+\t\t\terr:  \"no users found\",\n+\t\t},\n+\t}\n+\tfor _, testCase := range testCases {\n+\t\ttestCase := testCase\n+\t\tt.Run(testCase.user, func(t *testing.T) {\n+\t\t\tt.Parallel()\n+\t\t\ts := Spec{\n+\t\t\t\tVersion: specs.Version,\n+\t\t\t\tRoot: &specs.Root{\n+\t\t\t\t\tPath: td,\n+\t\t\t\t},\n+\t\t\t\tLinux: &specs.Linux{},\n+\t\t\t}\n+\t\t\terr := WithUser(testCase.user)(context.Background(), nil, &c, &s)\n+\t\t\tif err != nil {\n+\t\t\t\tassert.EqualError(t, err, testCase.err)\n+\t\t\t}\n+\t\t\tassert.Equal(t, testCase.expectedUID, s.Process.User.UID)\n+\t\t\tassert.Equal(t, testCase.expectedGID, s.Process.User.GID)\n+\t\t})\n+\t}\n+}\n+\n //nolint:gosec\n func TestWithUserID(t *testing.T) {\n \tt.Parallel()\n```"
            },
            {
                "url": "https://github.com/containerd/containerd/commit/cf158e884cfe4812a6c371b59e4ea9bc4c46e51a",
                "content": "Merge commit from fork\n\n[release 1.6] validate uid/gid\n\nFilename: oci/spec_opts.go:\n```\n@@ -22,6 +22,7 @@\nimport (\n \t\"encoding/json\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"math\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"runtime\"\n\n@@ -576,6 +577,20 @@\nfunc WithUser(userstr string) SpecOpts {\n \t\tdefer ensureAdditionalGids(s)\n \t\tsetProcess(s)\n \t\ts.Process.User.AdditionalGids = nil\n+\t\t// While the Linux kernel allows the max UID to be MaxUint32 - 2,\n+                // and the OCI Runtime Spec has no definition about the max UID,\n+                // the runc implementation is known to require the UID to be <= MaxInt32.\n+                //\n+                // containerd follows runc's limitation here.\n+                //\n+                // In future we may relax this limitation to allow MaxUint32 - 2,\n+                // or, amend the OCI Runtime Spec to codify the implementation limitation.\n+\t\tconst (\n+\t\t\tminUserID  = 0\n+\t\t\tmaxUserID  = math.MaxInt32\n+\t\t\tminGroupID = 0\n+\t\t\tmaxGroupID = math.MaxInt32\n+\t\t)\n \n \t\t// For LCOW it's a bit harder to confirm that the user actually exists on the host as a rootfs isn't\n \t\t// mounted on the host and shared into the guest, but rather the rootfs is constructed entirely in the\n\n@@ -592,8 +607,8 @@\nfunc WithUser(userstr string) SpecOpts {\n \t\tswitch len(parts) {\n \t\tcase 1:\n \t\t\tv, err := strconv.Atoi(parts[0])\n-\t\t\tif err != nil {\n-\t\t\t\t// if we cannot parse as a uint they try to see if it is a username\n+\t\t\tif err != nil || v < minUserID || v > maxUserID {\n+\t\t\t\t// if we cannot parse as an int32 then try to see if it is a username\n \t\t\t\treturn WithUsername(userstr)(ctx, client, c, s)\n \t\t\t}\n \t\t\treturn WithUserID(uint32(v))(ctx, client, c, s)\n\n@@ -604,12 +619,13 @@\nfunc WithUser(userstr string) SpecOpts {\n \t\t\t)\n \t\t\tvar uid, gid uint32\n \t\t\tv, err := strconv.Atoi(parts[0])\n-\t\t\tif err != nil {\n+\t\t\tif err != nil || v < minUserID || v > maxUserID {\n \t\t\t\tusername = parts[0]\n \t\t\t} else {\n \t\t\t\tuid = uint32(v)\n \t\t\t}\n-\t\t\tif v, err = strconv.Atoi(parts[1]); err != nil {\n+\t\t\tv, err = strconv.Atoi(parts[1])\n+\t\t\tif err != nil || v < minGroupID || v > maxGroupID {\n \t\t\t\tgroupname = parts[1]\n \t\t\t} else {\n \t\t\t\tgid = uint32(v)\n```\n\nFilename: oci/spec_opts_linux_test.go:\n```\n@@ -32,6 +32,98 @@\nimport (\n \t\"golang.org/x/sys/unix\"\n )\n \n+//nolint:gosec\n+func TestWithUser(t *testing.T) {\n+\tt.Parallel()\n+\n+\texpectedPasswd := `root:x:0:0:root:/root:/bin/ash\n+guest:x:405:100:guest:/dev/null:/sbin/nologin\n+`\n+\texpectedGroup := `root:x:0:root\n+bin:x:1:root,bin,daemon\n+daemon:x:2:root,bin,daemon\n+sys:x:3:root,bin,adm\n+guest:x:100:guest\n+`\n+\ttd := t.TempDir()\n+\tapply := fstest.Apply(\n+\t\tfstest.CreateDir(\"/etc\", 0777),\n+\t\tfstest.CreateFile(\"/etc/passwd\", []byte(expectedPasswd), 0777),\n+\t\tfstest.CreateFile(\"/etc/group\", []byte(expectedGroup), 0777),\n+\t)\n+\tif err := apply.Apply(td); err != nil {\n+\t\tt.Fatalf(\"failed to apply: %v\", err)\n+\t}\n+\tc := containers.Container{ID: t.Name()}\n+\ttestCases := []struct {\n+\t\tuser        string\n+\t\texpectedUID uint32\n+\t\texpectedGID uint32\n+\t\terr         string\n+\t}{\n+\t\t{\n+\t\t\tuser:        \"0\",\n+\t\t\texpectedUID: 0,\n+\t\t\texpectedGID: 0,\n+\t\t},\n+\t\t{\n+\t\t\tuser:        \"root:root\",\n+\t\t\texpectedUID: 0,\n+\t\t\texpectedGID: 0,\n+\t\t},\n+\t\t{\n+\t\t\tuser:        \"guest\",\n+\t\t\texpectedUID: 405,\n+\t\t\texpectedGID: 100,\n+\t\t},\n+\t\t{\n+\t\t\tuser:        \"guest:guest\",\n+\t\t\texpectedUID: 405,\n+\t\t\texpectedGID: 100,\n+\t\t},\n+\t\t{\n+\t\t\tuser: \"guest:nobody\",\n+\t\t\terr:  \"no groups found\",\n+\t\t},\n+\t\t{\n+\t\t\tuser:        \"405:100\",\n+\t\t\texpectedUID: 405,\n+\t\t\texpectedGID: 100,\n+\t\t},\n+\t\t{\n+\t\t\tuser: \"405:2147483648\",\n+\t\t\terr:  \"no groups found\",\n+\t\t},\n+\t\t{\n+\t\t\tuser: \"-1000\",\n+\t\t\terr:  \"no users found\",\n+\t\t},\n+\t\t{\n+\t\t\tuser: \"2147483648\",\n+\t\t\terr:  \"no users found\",\n+\t\t},\n+\t}\n+\tfor _, testCase := range testCases {\n+\t\ttestCase := testCase\n+\t\tt.Run(testCase.user, func(t *testing.T) {\n+\t\t\tt.Parallel()\n+\t\t\ts := Spec{\n+\t\t\t\tVersion: specs.Version,\n+\t\t\t\tRoot: &specs.Root{\n+\t\t\t\t\tPath: td,\n+\t\t\t\t},\n+\t\t\t\tLinux: &specs.Linux{},\n+\t\t\t}\n+\t\t\terr := WithUser(testCase.user)(context.Background(), nil, &c, &s)\n+\t\t\tif err != nil {\n+\t\t\t\tassert.EqualError(t, err, testCase.err)\n+\t\t\t}\n+\t\t\tassert.Equal(t, testCase.expectedUID, s.Process.User.UID)\n+\t\t\tassert.Equal(t, testCase.expectedGID, s.Process.User.GID)\n+\t\t})\n+\t}\n+}\n+\n //nolint:gosec\n func TestWithUserID(t *testing.T) {\n \tt.Parallel()\n```"
            }
        ],
        "sw_version": "v1.6.37",
        "sw_version_wget": "https://github.com/containerd/containerd/archive/refs/tags/v1.6.37.zip",
        "description": "containerd is an open-source container runtime. A bug was found in containerd prior to versions 1.6.38, 1.7.27, and 2.0.4 where containers launched with a User set as a `UID:GID` larger than the maximum 32-bit signed integer can cause an overflow condition where the container ultimately runs as root (UID 0). This could cause unexpected behavior for environments that require containers to run as a non-root user. This bug has been fixed in containerd 1.6.38, 1.7.27, and 2.04. As a workaround, ensure that only trusted images are used and that only trusted users have permissions to import images.",
        "sec_adv": [
            {
                "url": "https://github.com/containerd/containerd/security/advisories/GHSA-265r-hfxg-fhmg",
                "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\ncontainerd\n/\ncontainerd\nPublic\nNotifications You must be signed in to change notification settings\nFork 3.5k\nStar 18.6k\nCode\nIssues\n260\nPull requests\n167\nDiscussions\nActions\nProjects\n3\nSecurity\n15\nInsights\nAdditional navigation options\nInteger overflow in User ID handling\nModerate dmcgowan published GHSA-265r-hfxg-fhmg on Mar 17Mar 17, 2025\nPackage\nNo package listed\nAffected versions\n< 1.6.38, < 1.7.27, <2.0.4\nPatched versions\n1.6.38, 1.7.27, 2.0.4\nDescription\nImpact\nA bug was found in containerd where containers launched with a User set as a UID:GID larger than the maximum 32-bit signed integer can cause an overflow condition where the container ultimately runs as root (UID 0). This could cause unexpected behavior for environments that require containers to run as a non-root user.\nPatches\nThis bug has been fixed in the following containerd versions:\n2.0.4 (Fixed in 1a43cb6)\n1.7.27 (Fixed in 05044ec)\n1.6.38 (Fixed in cf158e8)\nUsers should update to these versions to resolve the issue.\nWorkarounds\nEnsure that only trusted images are used and that only trusted users have permissions to import images.\nCredits\nThe containerd project would like to thank Benjamin Koltermann and emxll for responsibly disclosing this issue in accordance with the containerd security policy.\nReferences\nhttps://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-40635\nFor more information\nIf you have any questions or comments about this advisory:\nOpen an issue in containerd\nEmail us at security@containerd.io\nTo report a security issue in containerd:\nReport a new vulnerability\nEmail us at security@containerd.io\nSeverity\nModerate\n4.6\n/ 10\nCVSS v3 base metrics\nAttack vector\nLocal\nAttack complexity\nLow\nPrivileges required\nHigh\nUser interaction\nNone\nScope\nChanged\nConfidentiality\nLow\nIntegrity\nLow\nAvailability\nNone\nLearn more about base metrics\nCVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:C/C:L/I:L/A:N\nCVE ID\nCVE-2024-40635\nWeaknesses\nNo CWEs\nCredits\np4ck3t0\nFinder\nFooter\nÂ© 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
                "effective": false,
                "effective_reason": "The advisory does not include a proof of concept of the vulnerability nor detailed steps to reproduce it; it primarily provides a description of the issue, impacted versions, and mitigation information."
            }
        ],
        "cwe": [
            {
                "id": "CWE-190",
                "value": "CWE-190: Integer Overflow or Wraparound"
            }
        ]
    }
}