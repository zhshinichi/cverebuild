{
    "CVE-2024-3219": {
        "published_date": "2024-07-29T21:54:05.830Z",
        "patch_commits": [
            {
                "url": "https://github.com/python/cpython/commit/06fa244666ec6335a3b9bf2367e31b42b9a89b20",
                "content": "[3.9] gh-122133: Authenticate socket connection for `socket.socketpair()` fallback (GH-122134) (#122428)\n\nAuthenticate socket connection for `socket.socketpair()` fallback when the platform does not have a native `socketpair` C API.  We authenticate in-process using `getsocketname` and `getpeername` (thanks to Nathaniel J Smith for that suggestion).\r\n\r\n(cherry picked from commit 78df1043dbdce5c989600616f9f87b4ee72944e5)\r\n\r\nCo-authored-by: Seth Michael Larson <seth@python.org>\r\nCo-authored-by: Gregory P. Smith <greg@krypto.org>\n\nFilename: Lib/socket.py:\n```\n@@ -646,6 +646,23 @@\ndef socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):\n                 raise\n         finally:\n             lsock.close()\n+\n+        # Authenticating avoids using a connection from something else\n+        # able to connect to {host}:{port} instead of us.\n+        # We expect only AF_INET and AF_INET6 families.\n+        try:\n+            if (\n+                ssock.getsockname() != csock.getpeername()\n+                or csock.getsockname() != ssock.getpeername()\n+            ):\n+                raise ConnectionError(\"Unexpected peer connection\")\n+        except:\n+            # getsockname() and getpeername() can fail\n+            # if either socket isn't connected.\n+            ssock.close()\n+            csock.close()\n+            raise\n+\n         return (ssock, csock)\n     __all__.append(\"socketpair\")\n```\n\nFilename: Lib/test/test_socket.py:\n```\n@@ -555,19 +555,27 @@\nclass SocketPairTest(unittest.TestCase, ThreadableTest):\n     def __init__(self, methodName='runTest'):\n         unittest.TestCase.__init__(self, methodName=methodName)\n         ThreadableTest.__init__(self)\n+        self.cli = None\n+        self.serv = None\n+\n+    def socketpair(self):\n+        # To be overridden by some child classes.\n+        return socket.socketpair()\n \n     def setUp(self):\n-        self.serv, self.cli = socket.socketpair()\n+        self.serv, self.cli = self.socketpair()\n \n     def tearDown(self):\n-        self.serv.close()\n+        if self.serv:\n+            self.serv.close()\n         self.serv = None\n \n     def clientSetUp(self):\n         pass\n \n     def clientTearDown(self):\n-        self.cli.close()\n+        if self.cli:\n+            self.cli.close()\n         self.cli = None\n         ThreadableTest.clientTearDown(self)\n\n@@ -4613,6 +4621,120 @@\ndef _testSend(self):\n         self.assertEqual(msg, MSG)\n \n \n+class PurePythonSocketPairTest(SocketPairTest):\n+\n+    # Explicitly use socketpair AF_INET or AF_INET6 to ensure that is the\n+    # code path we're using regardless platform is the pure python one where\n+    # `_socket.socketpair` does not exist.  (AF_INET does not work with\n+    # _socket.socketpair on many platforms).\n+    def socketpair(self):\n+        # called by super().setUp().\n+        try:\n+            return socket.socketpair(socket.AF_INET6)\n+        except OSError:\n+            return socket.socketpair(socket.AF_INET)\n+\n+    # Local imports in this class make for easy security fix backporting.\n+\n+    def setUp(self):\n+        import _socket\n+        self._orig_sp = getattr(_socket, 'socketpair', None)\n+        if self._orig_sp is not None:\n+            # This forces the version using the non-OS provided socketpair\n+            # emulation via an AF_INET socket in Lib/socket.py.\n+            del _socket.socketpair\n+            import importlib\n+            global socket\n+            socket = importlib.reload(socket)\n+        else:\n+            pass  # This platform already uses the non-OS provided version.\n+        super().setUp()\n+\n+    def tearDown(self):\n+        super().tearDown()\n+        import _socket\n+        if self._orig_sp is not None:\n+            # Restore the default socket.socketpair definition.\n+            _socket.socketpair = self._orig_sp\n+            import importlib\n+            global socket\n+            socket = importlib.reload(socket)\n+\n+    def test_recv(self):\n+        msg = self.serv.recv(1024)\n+        self.assertEqual(msg, MSG)\n+\n+    def _test_recv(self):\n+        self.cli.send(MSG)\n+\n+    def test_send(self):\n+        self.serv.send(MSG)\n+\n+    def _test_send(self):\n+        msg = self.cli.recv(1024)\n+        self.assertEqual(msg, MSG)\n+\n+    def test_ipv4(self):\n+        cli, srv = socket.socketpair(socket.AF_INET)\n+        cli.close()\n+        srv.close()\n+\n+    def _test_ipv4(self):\n+        pass\n+\n+    @unittest.skipIf(not hasattr(_socket, 'IPPROTO_IPV6') or\n+                     not hasattr(_socket, 'IPV6_V6ONLY'),\n+                     \"IPV6_V6ONLY option not supported\")\n+    @unittest.skipUnless(socket_helper.IPV6_ENABLED, 'IPv6 required for this test')\n+    def test_ipv6(self):\n+        cli, srv = socket.socketpair(socket.AF_INET6)\n+        cli.close()\n+        srv.close()\n+\n+    def _test_ipv6(self):\n+        pass\n+\n+    def test_injected_authentication_failure(self):\n+        orig_getsockname = socket.socket.getsockname\n+        inject_sock = None\n+\n+        def inject_getsocketname(self):\n+            nonlocal inject_sock\n+            sockname = orig_getsockname(self)\n+            # Connect to the listening socket ahead of the\n+            # client socket.\n+            if inject_sock is None:\n+                inject_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n+                inject_sock.setblocking(False)\n+                try:\n+                    inject_sock.connect(sockname[:2])\n+                except (BlockingIOError, InterruptedError):\n+                    pass\n+                inject_sock.setblocking(True)\n+            return sockname\n+\n+        sock1 = sock2 = None\n+        try:\n+            socket.socket.getsockname = inject_getsocketname\n+            with self.assertRaises(OSError):\n+                sock1, sock2 = socket.socketpair()\n+        finally:\n+            socket.socket.getsockname = orig_getsockname\n+            if inject_sock:\n+                inject_sock.close()\n+            if sock1:  # This cleanup isn't needed on a successful test.\n+                sock1.close()\n+            if sock2:\n+                sock2.close()\n+\n+    def _test_injected_authentication_failure(self):\n+        # No-op.  Exists for base class threading infrastructure to call.\n+        # We could refactor this test into its own lesser class along with the\n+        # setUp and tearDown code to construct an ideal; it is simpler to keep\n+        # it here and live with extra overhead one this _one_ failure test.\n+        pass\n+\n+\n class NonBlockingTCPTests(ThreadedTCPSocketTest):\n \n     def __init__(self, methodName='runTest'):\n```\n\nFilename: Misc/NEWS.d/next/Security/2024-07-22-13-11-28.gh-issue-122133.0mPeta.rst:\n```\n@@ -0,0 +1,5 @@\n+Authenticate the socket connection for the ``socket.socketpair()`` fallback\n+on platforms where ``AF_UNIX`` is not available like Windows.\n+\n+Patch by Gregory P. Smith <greg@krypto.org> and Seth Larson <seth@python.org>. Reported by Ellie\n+<el@horse64.org>\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/0b65c8bf5367625673eafb92f85046a1b31259f2",
                "content": "[3.10] gh-122133: Authenticate socket connection for `socket.socketpair()` fallback (GH-122134) (#122427)\n\nAuthenticate socket connection for `socket.socketpair()` fallback when the platform does not have a native `socketpair` C API.  We authenticate in-process using `getsocketname` and `getpeername` (thanks to Nathaniel J Smith for that suggestion).\r\n\r\n(cherry picked from commit 78df1043dbdce5c989600616f9f87b4ee72944e5)\r\n\r\nCo-authored-by: Seth Michael Larson <seth@python.org>\r\nCo-authored-by: Gregory P. Smith <greg@krypto.org>\n\nFilename: Lib/socket.py:\n```\n@@ -647,6 +647,23 @@\ndef socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):\n                 raise\n         finally:\n             lsock.close()\n+\n+        # Authenticating avoids using a connection from something else\n+        # able to connect to {host}:{port} instead of us.\n+        # We expect only AF_INET and AF_INET6 families.\n+        try:\n+            if (\n+                ssock.getsockname() != csock.getpeername()\n+                or csock.getsockname() != ssock.getpeername()\n+            ):\n+                raise ConnectionError(\"Unexpected peer connection\")\n+        except:\n+            # getsockname() and getpeername() can fail\n+            # if either socket isn't connected.\n+            ssock.close()\n+            csock.close()\n+            raise\n+\n         return (ssock, csock)\n     __all__.append(\"socketpair\")\n```\n\nFilename: Lib/test/test_socket.py:\n```\n@@ -557,19 +557,27 @@\nclass SocketPairTest(unittest.TestCase, ThreadableTest):\n     def __init__(self, methodName='runTest'):\n         unittest.TestCase.__init__(self, methodName=methodName)\n         ThreadableTest.__init__(self)\n+        self.cli = None\n+        self.serv = None\n+\n+    def socketpair(self):\n+        # To be overridden by some child classes.\n+        return socket.socketpair()\n \n     def setUp(self):\n-        self.serv, self.cli = socket.socketpair()\n+        self.serv, self.cli = self.socketpair()\n \n     def tearDown(self):\n-        self.serv.close()\n+        if self.serv:\n+            self.serv.close()\n         self.serv = None\n \n     def clientSetUp(self):\n         pass\n \n     def clientTearDown(self):\n-        self.cli.close()\n+        if self.cli:\n+            self.cli.close()\n         self.cli = None\n         ThreadableTest.clientTearDown(self)\n\n@@ -4630,6 +4638,120 @@\ndef _testSend(self):\n         self.assertEqual(msg, MSG)\n \n \n+class PurePythonSocketPairTest(SocketPairTest):\n+\n+    # Explicitly use socketpair AF_INET or AF_INET6 to ensure that is the\n+    # code path we're using regardless platform is the pure python one where\n+    # `_socket.socketpair` does not exist.  (AF_INET does not work with\n+    # _socket.socketpair on many platforms).\n+    def socketpair(self):\n+        # called by super().setUp().\n+        try:\n+            return socket.socketpair(socket.AF_INET6)\n+        except OSError:\n+            return socket.socketpair(socket.AF_INET)\n+\n+    # Local imports in this class make for easy security fix backporting.\n+\n+    def setUp(self):\n+        import _socket\n+        self._orig_sp = getattr(_socket, 'socketpair', None)\n+        if self._orig_sp is not None:\n+            # This forces the version using the non-OS provided socketpair\n+            # emulation via an AF_INET socket in Lib/socket.py.\n+            del _socket.socketpair\n+            import importlib\n+            global socket\n+            socket = importlib.reload(socket)\n+        else:\n+            pass  # This platform already uses the non-OS provided version.\n+        super().setUp()\n+\n+    def tearDown(self):\n+        super().tearDown()\n+        import _socket\n+        if self._orig_sp is not None:\n+            # Restore the default socket.socketpair definition.\n+            _socket.socketpair = self._orig_sp\n+            import importlib\n+            global socket\n+            socket = importlib.reload(socket)\n+\n+    def test_recv(self):\n+        msg = self.serv.recv(1024)\n+        self.assertEqual(msg, MSG)\n+\n+    def _test_recv(self):\n+        self.cli.send(MSG)\n+\n+    def test_send(self):\n+        self.serv.send(MSG)\n+\n+    def _test_send(self):\n+        msg = self.cli.recv(1024)\n+        self.assertEqual(msg, MSG)\n+\n+    def test_ipv4(self):\n+        cli, srv = socket.socketpair(socket.AF_INET)\n+        cli.close()\n+        srv.close()\n+\n+    def _test_ipv4(self):\n+        pass\n+\n+    @unittest.skipIf(not hasattr(_socket, 'IPPROTO_IPV6') or\n+                     not hasattr(_socket, 'IPV6_V6ONLY'),\n+                     \"IPV6_V6ONLY option not supported\")\n+    @unittest.skipUnless(socket_helper.IPV6_ENABLED, 'IPv6 required for this test')\n+    def test_ipv6(self):\n+        cli, srv = socket.socketpair(socket.AF_INET6)\n+        cli.close()\n+        srv.close()\n+\n+    def _test_ipv6(self):\n+        pass\n+\n+    def test_injected_authentication_failure(self):\n+        orig_getsockname = socket.socket.getsockname\n+        inject_sock = None\n+\n+        def inject_getsocketname(self):\n+            nonlocal inject_sock\n+            sockname = orig_getsockname(self)\n+            # Connect to the listening socket ahead of the\n+            # client socket.\n+            if inject_sock is None:\n+                inject_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n+                inject_sock.setblocking(False)\n+                try:\n+                    inject_sock.connect(sockname[:2])\n+                except (BlockingIOError, InterruptedError):\n+                    pass\n+                inject_sock.setblocking(True)\n+            return sockname\n+\n+        sock1 = sock2 = None\n+        try:\n+            socket.socket.getsockname = inject_getsocketname\n+            with self.assertRaises(OSError):\n+                sock1, sock2 = socket.socketpair()\n+        finally:\n+            socket.socket.getsockname = orig_getsockname\n+            if inject_sock:\n+                inject_sock.close()\n+            if sock1:  # This cleanup isn't needed on a successful test.\n+                sock1.close()\n+            if sock2:\n+                sock2.close()\n+\n+    def _test_injected_authentication_failure(self):\n+        # No-op.  Exists for base class threading infrastructure to call.\n+        # We could refactor this test into its own lesser class along with the\n+        # setUp and tearDown code to construct an ideal; it is simpler to keep\n+        # it here and live with extra overhead one this _one_ failure test.\n+        pass\n+\n+\n class NonBlockingTCPTests(ThreadedTCPSocketTest):\n \n     def __init__(self, methodName='runTest'):\n```\n\nFilename: Misc/NEWS.d/next/Security/2024-07-22-13-11-28.gh-issue-122133.0mPeta.rst:\n```\n@@ -0,0 +1,5 @@\n+Authenticate the socket connection for the ``socket.socketpair()`` fallback\n+on platforms where ``AF_UNIX`` is not available like Windows.\n+\n+Patch by Gregory P. Smith <greg@krypto.org> and Seth Larson <seth@python.org>. Reported by Ellie\n+<el@horse64.org>\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/220e31adeaaa8436c9ff234cba1398bc49e2bb6c",
                "content": "[3.12] gh-122133: Authenticate socket connection for `socket.socketpair()` fallback (GH-122134) (GH-122425)\n\nAuthenticate socket connection for `socket.socketpair()` fallback when the platform does not have a native `socketpair` C API.  We authenticate in-process using `getsocketname` and `getpeername` (thanks to Nathaniel J Smith for that suggestion).\r\n\r\n(cherry picked from commit 78df1043dbdce5c989600616f9f87b4ee72944e5)\r\n\r\nCo-authored-by: Seth Michael Larson <seth@python.org>\r\nCo-authored-by: Gregory P. Smith <greg@krypto.org>\n\nFilename: Lib/socket.py:\n```\n@@ -650,6 +650,23 @@\ndef socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):\n                 raise\n         finally:\n             lsock.close()\n+\n+        # Authenticating avoids using a connection from something else\n+        # able to connect to {host}:{port} instead of us.\n+        # We expect only AF_INET and AF_INET6 families.\n+        try:\n+            if (\n+                ssock.getsockname() != csock.getpeername()\n+                or csock.getsockname() != ssock.getpeername()\n+            ):\n+                raise ConnectionError(\"Unexpected peer connection\")\n+        except:\n+            # getsockname() and getpeername() can fail\n+            # if either socket isn't connected.\n+            ssock.close()\n+            csock.close()\n+            raise\n+\n         return (ssock, csock)\n     __all__.append(\"socketpair\")\n```\n\nFilename: Lib/test/test_socket.py:\n```\n@@ -558,19 +558,27 @@\nclass SocketPairTest(unittest.TestCase, ThreadableTest):\n     def __init__(self, methodName='runTest'):\n         unittest.TestCase.__init__(self, methodName=methodName)\n         ThreadableTest.__init__(self)\n+        self.cli = None\n+        self.serv = None\n+\n+    def socketpair(self):\n+        # To be overridden by some child classes.\n+        return socket.socketpair()\n \n     def setUp(self):\n-        self.serv, self.cli = socket.socketpair()\n+        self.serv, self.cli = self.socketpair()\n \n     def tearDown(self):\n-        self.serv.close()\n+        if self.serv:\n+            self.serv.close()\n         self.serv = None\n \n     def clientSetUp(self):\n         pass\n \n     def clientTearDown(self):\n-        self.cli.close()\n+        if self.cli:\n+            self.cli.close()\n         self.cli = None\n         ThreadableTest.clientTearDown(self)\n\n@@ -4786,6 +4794,120 @@\ndef _testSend(self):\n         self.assertEqual(msg, MSG)\n \n \n+class PurePythonSocketPairTest(SocketPairTest):\n+\n+    # Explicitly use socketpair AF_INET or AF_INET6 to ensure that is the\n+    # code path we're using regardless platform is the pure python one where\n+    # `_socket.socketpair` does not exist.  (AF_INET does not work with\n+    # _socket.socketpair on many platforms).\n+    def socketpair(self):\n+        # called by super().setUp().\n+        try:\n+            return socket.socketpair(socket.AF_INET6)\n+        except OSError:\n+            return socket.socketpair(socket.AF_INET)\n+\n+    # Local imports in this class make for easy security fix backporting.\n+\n+    def setUp(self):\n+        import _socket\n+        self._orig_sp = getattr(_socket, 'socketpair', None)\n+        if self._orig_sp is not None:\n+            # This forces the version using the non-OS provided socketpair\n+            # emulation via an AF_INET socket in Lib/socket.py.\n+            del _socket.socketpair\n+            import importlib\n+            global socket\n+            socket = importlib.reload(socket)\n+        else:\n+            pass  # This platform already uses the non-OS provided version.\n+        super().setUp()\n+\n+    def tearDown(self):\n+        super().tearDown()\n+        import _socket\n+        if self._orig_sp is not None:\n+            # Restore the default socket.socketpair definition.\n+            _socket.socketpair = self._orig_sp\n+            import importlib\n+            global socket\n+            socket = importlib.reload(socket)\n+\n+    def test_recv(self):\n+        msg = self.serv.recv(1024)\n+        self.assertEqual(msg, MSG)\n+\n+    def _test_recv(self):\n+        self.cli.send(MSG)\n+\n+    def test_send(self):\n+        self.serv.send(MSG)\n+\n+    def _test_send(self):\n+        msg = self.cli.recv(1024)\n+        self.assertEqual(msg, MSG)\n+\n+    def test_ipv4(self):\n+        cli, srv = socket.socketpair(socket.AF_INET)\n+        cli.close()\n+        srv.close()\n+\n+    def _test_ipv4(self):\n+        pass\n+\n+    @unittest.skipIf(not hasattr(_socket, 'IPPROTO_IPV6') or\n+                     not hasattr(_socket, 'IPV6_V6ONLY'),\n+                     \"IPV6_V6ONLY option not supported\")\n+    @unittest.skipUnless(socket_helper.IPV6_ENABLED, 'IPv6 required for this test')\n+    def test_ipv6(self):\n+        cli, srv = socket.socketpair(socket.AF_INET6)\n+        cli.close()\n+        srv.close()\n+\n+    def _test_ipv6(self):\n+        pass\n+\n+    def test_injected_authentication_failure(self):\n+        orig_getsockname = socket.socket.getsockname\n+        inject_sock = None\n+\n+        def inject_getsocketname(self):\n+            nonlocal inject_sock\n+            sockname = orig_getsockname(self)\n+            # Connect to the listening socket ahead of the\n+            # client socket.\n+            if inject_sock is None:\n+                inject_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n+                inject_sock.setblocking(False)\n+                try:\n+                    inject_sock.connect(sockname[:2])\n+                except (BlockingIOError, InterruptedError):\n+                    pass\n+                inject_sock.setblocking(True)\n+            return sockname\n+\n+        sock1 = sock2 = None\n+        try:\n+            socket.socket.getsockname = inject_getsocketname\n+            with self.assertRaises(OSError):\n+                sock1, sock2 = socket.socketpair()\n+        finally:\n+            socket.socket.getsockname = orig_getsockname\n+            if inject_sock:\n+                inject_sock.close()\n+            if sock1:  # This cleanup isn't needed on a successful test.\n+                sock1.close()\n+            if sock2:\n+                sock2.close()\n+\n+    def _test_injected_authentication_failure(self):\n+        # No-op.  Exists for base class threading infrastructure to call.\n+        # We could refactor this test into its own lesser class along with the\n+        # setUp and tearDown code to construct an ideal; it is simpler to keep\n+        # it here and live with extra overhead one this _one_ failure test.\n+        pass\n+\n+\n class NonBlockingTCPTests(ThreadedTCPSocketTest):\n \n     def __init__(self, methodName='runTest'):\n```\n\nFilename: Misc/NEWS.d/next/Security/2024-07-22-13-11-28.gh-issue-122133.0mPeta.rst:\n```\n@@ -0,0 +1,5 @@\n+Authenticate the socket connection for the ``socket.socketpair()`` fallback\n+on platforms where ``AF_UNIX`` is not available like Windows.\n+\n+Patch by Gregory P. Smith <greg@krypto.org> and Seth Larson <seth@python.org>. Reported by Ellie\n+<el@horse64.org>\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/5f90abaa786f994db3907fc31e2ee00ea2cf0929",
                "content": "[3.11] gh-122133: Authenticate socket connection for `socket.socketpair()` fallback (GH-122134) (#122426)\n\nAuthenticate socket connection for `socket.socketpair()` fallback when the platform does not have a native `socketpair` C API.  We authenticate in-process using `getsocketname` and `getpeername` (thanks to Nathaniel J Smith for that suggestion).\r\n\r\n(cherry picked from commit 78df1043dbdce5c989600616f9f87b4ee72944e5)\r\n\r\nCo-authored-by: Seth Michael Larson <seth@python.org>\r\nCo-authored-by: Gregory P. Smith <greg@krypto.org>\n\nFilename: Lib/socket.py:\n```\n@@ -648,6 +648,23 @@\ndef socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):\n                 raise\n         finally:\n             lsock.close()\n+\n+        # Authenticating avoids using a connection from something else\n+        # able to connect to {host}:{port} instead of us.\n+        # We expect only AF_INET and AF_INET6 families.\n+        try:\n+            if (\n+                ssock.getsockname() != csock.getpeername()\n+                or csock.getsockname() != ssock.getpeername()\n+            ):\n+                raise ConnectionError(\"Unexpected peer connection\")\n+        except:\n+            # getsockname() and getpeername() can fail\n+            # if either socket isn't connected.\n+            ssock.close()\n+            csock.close()\n+            raise\n+\n         return (ssock, csock)\n     __all__.append(\"socketpair\")\n```\n\nFilename: Lib/test/test_socket.py:\n```\n@@ -542,19 +542,27 @@\nclass SocketPairTest(unittest.TestCase, ThreadableTest):\n     def __init__(self, methodName='runTest'):\n         unittest.TestCase.__init__(self, methodName=methodName)\n         ThreadableTest.__init__(self)\n+        self.cli = None\n+        self.serv = None\n+\n+    def socketpair(self):\n+        # To be overridden by some child classes.\n+        return socket.socketpair()\n \n     def setUp(self):\n-        self.serv, self.cli = socket.socketpair()\n+        self.serv, self.cli = self.socketpair()\n \n     def tearDown(self):\n-        self.serv.close()\n+        if self.serv:\n+            self.serv.close()\n         self.serv = None\n \n     def clientSetUp(self):\n         pass\n \n     def clientTearDown(self):\n-        self.cli.close()\n+        if self.cli:\n+            self.cli.close()\n         self.cli = None\n         ThreadableTest.clientTearDown(self)\n\n@@ -4667,6 +4675,120 @@\ndef _testSend(self):\n         self.assertEqual(msg, MSG)\n \n \n+class PurePythonSocketPairTest(SocketPairTest):\n+\n+    # Explicitly use socketpair AF_INET or AF_INET6 to ensure that is the\n+    # code path we're using regardless platform is the pure python one where\n+    # `_socket.socketpair` does not exist.  (AF_INET does not work with\n+    # _socket.socketpair on many platforms).\n+    def socketpair(self):\n+        # called by super().setUp().\n+        try:\n+            return socket.socketpair(socket.AF_INET6)\n+        except OSError:\n+            return socket.socketpair(socket.AF_INET)\n+\n+    # Local imports in this class make for easy security fix backporting.\n+\n+    def setUp(self):\n+        import _socket\n+        self._orig_sp = getattr(_socket, 'socketpair', None)\n+        if self._orig_sp is not None:\n+            # This forces the version using the non-OS provided socketpair\n+            # emulation via an AF_INET socket in Lib/socket.py.\n+            del _socket.socketpair\n+            import importlib\n+            global socket\n+            socket = importlib.reload(socket)\n+        else:\n+            pass  # This platform already uses the non-OS provided version.\n+        super().setUp()\n+\n+    def tearDown(self):\n+        super().tearDown()\n+        import _socket\n+        if self._orig_sp is not None:\n+            # Restore the default socket.socketpair definition.\n+            _socket.socketpair = self._orig_sp\n+            import importlib\n+            global socket\n+            socket = importlib.reload(socket)\n+\n+    def test_recv(self):\n+        msg = self.serv.recv(1024)\n+        self.assertEqual(msg, MSG)\n+\n+    def _test_recv(self):\n+        self.cli.send(MSG)\n+\n+    def test_send(self):\n+        self.serv.send(MSG)\n+\n+    def _test_send(self):\n+        msg = self.cli.recv(1024)\n+        self.assertEqual(msg, MSG)\n+\n+    def test_ipv4(self):\n+        cli, srv = socket.socketpair(socket.AF_INET)\n+        cli.close()\n+        srv.close()\n+\n+    def _test_ipv4(self):\n+        pass\n+\n+    @unittest.skipIf(not hasattr(_socket, 'IPPROTO_IPV6') or\n+                     not hasattr(_socket, 'IPV6_V6ONLY'),\n+                     \"IPV6_V6ONLY option not supported\")\n+    @unittest.skipUnless(socket_helper.IPV6_ENABLED, 'IPv6 required for this test')\n+    def test_ipv6(self):\n+        cli, srv = socket.socketpair(socket.AF_INET6)\n+        cli.close()\n+        srv.close()\n+\n+    def _test_ipv6(self):\n+        pass\n+\n+    def test_injected_authentication_failure(self):\n+        orig_getsockname = socket.socket.getsockname\n+        inject_sock = None\n+\n+        def inject_getsocketname(self):\n+            nonlocal inject_sock\n+            sockname = orig_getsockname(self)\n+            # Connect to the listening socket ahead of the\n+            # client socket.\n+            if inject_sock is None:\n+                inject_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n+                inject_sock.setblocking(False)\n+                try:\n+                    inject_sock.connect(sockname[:2])\n+                except (BlockingIOError, InterruptedError):\n+                    pass\n+                inject_sock.setblocking(True)\n+            return sockname\n+\n+        sock1 = sock2 = None\n+        try:\n+            socket.socket.getsockname = inject_getsocketname\n+            with self.assertRaises(OSError):\n+                sock1, sock2 = socket.socketpair()\n+        finally:\n+            socket.socket.getsockname = orig_getsockname\n+            if inject_sock:\n+                inject_sock.close()\n+            if sock1:  # This cleanup isn't needed on a successful test.\n+                sock1.close()\n+            if sock2:\n+                sock2.close()\n+\n+    def _test_injected_authentication_failure(self):\n+        # No-op.  Exists for base class threading infrastructure to call.\n+        # We could refactor this test into its own lesser class along with the\n+        # setUp and tearDown code to construct an ideal; it is simpler to keep\n+        # it here and live with extra overhead one this _one_ failure test.\n+        pass\n+\n+\n class NonBlockingTCPTests(ThreadedTCPSocketTest):\n \n     def __init__(self, methodName='runTest'):\n```\n\nFilename: Misc/NEWS.d/next/Security/2024-07-22-13-11-28.gh-issue-122133.0mPeta.rst:\n```\n@@ -0,0 +1,5 @@\n+Authenticate the socket connection for the ``socket.socketpair()`` fallback\n+on platforms where ``AF_UNIX`` is not available like Windows.\n+\n+Patch by Gregory P. Smith <greg@krypto.org> and Seth Larson <seth@python.org>. Reported by Ellie\n+<el@horse64.org>\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/b252317956b7fc035bb3774ef6a177e227f9fc54",
                "content": "[3.13] gh-122133: Authenticate socket connection for `socket.socketpair()` fallback (GH-122134) (GH-122424)\n\nAuthenticate socket connection for `socket.socketpair()` fallback when the platform does not have a native `socketpair` C API.  We authenticate in-process using `getsocketname` and `getpeername` (thanks to Nathaniel J Smith for that suggestion).\r\n\r\n(cherry picked from commit 78df1043dbdce5c989600616f9f87b4ee72944e5)\r\n\r\nCo-authored-by: Seth Michael Larson <seth@python.org>\r\nCo-authored-by: Gregory P. Smith <greg@krypto.org>\n\nFilename: Lib/socket.py:\n```\n@@ -650,6 +650,23 @@\ndef socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):\n                 raise\n         finally:\n             lsock.close()\n+\n+        # Authenticating avoids using a connection from something else\n+        # able to connect to {host}:{port} instead of us.\n+        # We expect only AF_INET and AF_INET6 families.\n+        try:\n+            if (\n+                ssock.getsockname() != csock.getpeername()\n+                or csock.getsockname() != ssock.getpeername()\n+            ):\n+                raise ConnectionError(\"Unexpected peer connection\")\n+        except:\n+            # getsockname() and getpeername() can fail\n+            # if either socket isn't connected.\n+            ssock.close()\n+            csock.close()\n+            raise\n+\n         return (ssock, csock)\n     __all__.append(\"socketpair\")\n```\n\nFilename: Lib/test/test_socket.py:\n```\n@@ -593,19 +593,27 @@\nclass SocketPairTest(unittest.TestCase, ThreadableTest):\n     def __init__(self, methodName='runTest'):\n         unittest.TestCase.__init__(self, methodName=methodName)\n         ThreadableTest.__init__(self)\n+        self.cli = None\n+        self.serv = None\n+\n+    def socketpair(self):\n+        # To be overridden by some child classes.\n+        return socket.socketpair()\n \n     def setUp(self):\n-        self.serv, self.cli = socket.socketpair()\n+        self.serv, self.cli = self.socketpair()\n \n     def tearDown(self):\n-        self.serv.close()\n+        if self.serv:\n+            self.serv.close()\n         self.serv = None\n \n     def clientSetUp(self):\n         pass\n \n     def clientTearDown(self):\n-        self.cli.close()\n+        if self.cli:\n+            self.cli.close()\n         self.cli = None\n         ThreadableTest.clientTearDown(self)\n\n@@ -4852,6 +4860,120 @@\ndef _testSend(self):\n         self.assertEqual(msg, MSG)\n \n \n+class PurePythonSocketPairTest(SocketPairTest):\n+\n+    # Explicitly use socketpair AF_INET or AF_INET6 to ensure that is the\n+    # code path we're using regardless platform is the pure python one where\n+    # `_socket.socketpair` does not exist.  (AF_INET does not work with\n+    # _socket.socketpair on many platforms).\n+    def socketpair(self):\n+        # called by super().setUp().\n+        try:\n+            return socket.socketpair(socket.AF_INET6)\n+        except OSError:\n+            return socket.socketpair(socket.AF_INET)\n+\n+    # Local imports in this class make for easy security fix backporting.\n+\n+    def setUp(self):\n+        import _socket\n+        self._orig_sp = getattr(_socket, 'socketpair', None)\n+        if self._orig_sp is not None:\n+            # This forces the version using the non-OS provided socketpair\n+            # emulation via an AF_INET socket in Lib/socket.py.\n+            del _socket.socketpair\n+            import importlib\n+            global socket\n+            socket = importlib.reload(socket)\n+        else:\n+            pass  # This platform already uses the non-OS provided version.\n+        super().setUp()\n+\n+    def tearDown(self):\n+        super().tearDown()\n+        import _socket\n+        if self._orig_sp is not None:\n+            # Restore the default socket.socketpair definition.\n+            _socket.socketpair = self._orig_sp\n+            import importlib\n+            global socket\n+            socket = importlib.reload(socket)\n+\n+    def test_recv(self):\n+        msg = self.serv.recv(1024)\n+        self.assertEqual(msg, MSG)\n+\n+    def _test_recv(self):\n+        self.cli.send(MSG)\n+\n+    def test_send(self):\n+        self.serv.send(MSG)\n+\n+    def _test_send(self):\n+        msg = self.cli.recv(1024)\n+        self.assertEqual(msg, MSG)\n+\n+    def test_ipv4(self):\n+        cli, srv = socket.socketpair(socket.AF_INET)\n+        cli.close()\n+        srv.close()\n+\n+    def _test_ipv4(self):\n+        pass\n+\n+    @unittest.skipIf(not hasattr(_socket, 'IPPROTO_IPV6') or\n+                     not hasattr(_socket, 'IPV6_V6ONLY'),\n+                     \"IPV6_V6ONLY option not supported\")\n+    @unittest.skipUnless(socket_helper.IPV6_ENABLED, 'IPv6 required for this test')\n+    def test_ipv6(self):\n+        cli, srv = socket.socketpair(socket.AF_INET6)\n+        cli.close()\n+        srv.close()\n+\n+    def _test_ipv6(self):\n+        pass\n+\n+    def test_injected_authentication_failure(self):\n+        orig_getsockname = socket.socket.getsockname\n+        inject_sock = None\n+\n+        def inject_getsocketname(self):\n+            nonlocal inject_sock\n+            sockname = orig_getsockname(self)\n+            # Connect to the listening socket ahead of the\n+            # client socket.\n+            if inject_sock is None:\n+                inject_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n+                inject_sock.setblocking(False)\n+                try:\n+                    inject_sock.connect(sockname[:2])\n+                except (BlockingIOError, InterruptedError):\n+                    pass\n+                inject_sock.setblocking(True)\n+            return sockname\n+\n+        sock1 = sock2 = None\n+        try:\n+            socket.socket.getsockname = inject_getsocketname\n+            with self.assertRaises(OSError):\n+                sock1, sock2 = socket.socketpair()\n+        finally:\n+            socket.socket.getsockname = orig_getsockname\n+            if inject_sock:\n+                inject_sock.close()\n+            if sock1:  # This cleanup isn't needed on a successful test.\n+                sock1.close()\n+            if sock2:\n+                sock2.close()\n+\n+    def _test_injected_authentication_failure(self):\n+        # No-op.  Exists for base class threading infrastructure to call.\n+        # We could refactor this test into its own lesser class along with the\n+        # setUp and tearDown code to construct an ideal; it is simpler to keep\n+        # it here and live with extra overhead one this _one_ failure test.\n+        pass\n+\n+\n class NonBlockingTCPTests(ThreadedTCPSocketTest):\n \n     def __init__(self, methodName='runTest'):\n```\n\nFilename: Misc/NEWS.d/next/Security/2024-07-22-13-11-28.gh-issue-122133.0mPeta.rst:\n```\n@@ -0,0 +1,5 @@\n+Authenticate the socket connection for the ``socket.socketpair()`` fallback\n+on platforms where ``AF_UNIX`` is not available like Windows.\n+\n+Patch by Gregory P. Smith <greg@krypto.org> and Seth Larson <seth@python.org>. Reported by Ellie\n+<el@horse64.org>\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/2621a8a40ba4b2c68ca564671b7daa5da80a4508",
                "content": "[3.8] gh-122133: Authenticate socket connection for `socket.socketpair()` fallback (GH-122134) (GH-122429)\n\nAuthenticate socket connection for `socket.socketpair()` fallback when the platform does not have a native `socketpair` C API.  We authenticate in-process using `getsocketname` and `getpeername` (thanks to Nathaniel J Smith for that suggestion).\r\n\r\n(cherry picked from commit 78df1043dbdce5c989600616f9f87b4ee72944e5)\r\n\r\nCo-authored-by: Seth Michael Larson <seth@python.org>\r\nCo-authored-by: Gregory P. Smith <greg@krypto.org>\r\nCo-authored-by: ≈Åukasz Langa <lukasz@langa.pl>\n\nFilename: Lib/socket.py:\n```\n@@ -611,6 +611,23 @@\ndef socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):\n                 raise\n         finally:\n             lsock.close()\n+\n+        # Authenticating avoids using a connection from something else\n+        # able to connect to {host}:{port} instead of us.\n+        # We expect only AF_INET and AF_INET6 families.\n+        try:\n+            if (\n+                ssock.getsockname() != csock.getpeername()\n+                or csock.getsockname() != ssock.getpeername()\n+            ):\n+                raise ConnectionError(\"Unexpected peer connection\")\n+        except:\n+            # getsockname() and getpeername() can fail\n+            # if either socket isn't connected.\n+            ssock.close()\n+            csock.close()\n+            raise\n+\n         return (ssock, csock)\n     __all__.append(\"socketpair\")\n```\n\nFilename: Lib/test/test_socket.py:\n```\n@@ -508,19 +508,27 @@\nclass SocketPairTest(unittest.TestCase, ThreadableTest):\n     def __init__(self, methodName='runTest'):\n         unittest.TestCase.__init__(self, methodName=methodName)\n         ThreadableTest.__init__(self)\n+        self.cli = None\n+        self.serv = None\n+\n+    def socketpair(self):\n+        # To be overridden by some child classes.\n+        return socket.socketpair()\n \n     def setUp(self):\n-        self.serv, self.cli = socket.socketpair()\n+        self.serv, self.cli = self.socketpair()\n \n     def tearDown(self):\n-        self.serv.close()\n+        if self.serv:\n+            self.serv.close()\n         self.serv = None\n \n     def clientSetUp(self):\n         pass\n \n     def clientTearDown(self):\n-        self.cli.close()\n+        if self.cli:\n+            self.cli.close()\n         self.cli = None\n         ThreadableTest.clientTearDown(self)\n\n@@ -4307,6 +4315,120 @@\ndef _testSend(self):\n         self.assertEqual(msg, MSG)\n \n \n+class PurePythonSocketPairTest(SocketPairTest):\n+\n+    # Explicitly use socketpair AF_INET or AF_INET6 to ensure that is the\n+    # code path we're using regardless platform is the pure python one where\n+    # `_socket.socketpair` does not exist.  (AF_INET does not work with\n+    # _socket.socketpair on many platforms).\n+    def socketpair(self):\n+        # called by super().setUp().\n+        try:\n+            return socket.socketpair(socket.AF_INET6)\n+        except OSError:\n+            return socket.socketpair(socket.AF_INET)\n+\n+    # Local imports in this class make for easy security fix backporting.\n+\n+    def setUp(self):\n+        import _socket\n+        self._orig_sp = getattr(_socket, 'socketpair', None)\n+        if self._orig_sp is not None:\n+            # This forces the version using the non-OS provided socketpair\n+            # emulation via an AF_INET socket in Lib/socket.py.\n+            del _socket.socketpair\n+            import importlib\n+            global socket\n+            socket = importlib.reload(socket)\n+        else:\n+            pass  # This platform already uses the non-OS provided version.\n+        super().setUp()\n+\n+    def tearDown(self):\n+        super().tearDown()\n+        import _socket\n+        if self._orig_sp is not None:\n+            # Restore the default socket.socketpair definition.\n+            _socket.socketpair = self._orig_sp\n+            import importlib\n+            global socket\n+            socket = importlib.reload(socket)\n+\n+    def test_recv(self):\n+        msg = self.serv.recv(1024)\n+        self.assertEqual(msg, MSG)\n+\n+    def _test_recv(self):\n+        self.cli.send(MSG)\n+\n+    def test_send(self):\n+        self.serv.send(MSG)\n+\n+    def _test_send(self):\n+        msg = self.cli.recv(1024)\n+        self.assertEqual(msg, MSG)\n+\n+    def test_ipv4(self):\n+        cli, srv = socket.socketpair(socket.AF_INET)\n+        cli.close()\n+        srv.close()\n+\n+    def _test_ipv4(self):\n+        pass\n+\n+    @unittest.skipIf(not hasattr(_socket, 'IPPROTO_IPV6') or\n+                     not hasattr(_socket, 'IPV6_V6ONLY'),\n+                     \"IPV6_V6ONLY option not supported\")\n+    @unittest.skipUnless(support.IPV6_ENABLED, 'IPv6 required for this test')\n+    def test_ipv6(self):\n+        cli, srv = socket.socketpair(socket.AF_INET6)\n+        cli.close()\n+        srv.close()\n+\n+    def _test_ipv6(self):\n+        pass\n+\n+    def test_injected_authentication_failure(self):\n+        orig_getsockname = socket.socket.getsockname\n+        inject_sock = None\n+\n+        def inject_getsocketname(self):\n+            nonlocal inject_sock\n+            sockname = orig_getsockname(self)\n+            # Connect to the listening socket ahead of the\n+            # client socket.\n+            if inject_sock is None:\n+                inject_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n+                inject_sock.setblocking(False)\n+                try:\n+                    inject_sock.connect(sockname[:2])\n+                except (BlockingIOError, InterruptedError):\n+                    pass\n+                inject_sock.setblocking(True)\n+            return sockname\n+\n+        sock1 = sock2 = None\n+        try:\n+            socket.socket.getsockname = inject_getsocketname\n+            with self.assertRaises(OSError):\n+                sock1, sock2 = socket.socketpair()\n+        finally:\n+            socket.socket.getsockname = orig_getsockname\n+            if inject_sock:\n+                inject_sock.close()\n+            if sock1:  # This cleanup isn't needed on a successful test.\n+                sock1.close()\n+            if sock2:\n+                sock2.close()\n+\n+    def _test_injected_authentication_failure(self):\n+        # No-op.  Exists for base class threading infrastructure to call.\n+        # We could refactor this test into its own lesser class along with the\n+        # setUp and tearDown code to construct an ideal; it is simpler to keep\n+        # it here and live with extra overhead one this _one_ failure test.\n+        pass\n+\n+\n class NonBlockingTCPTests(ThreadedTCPSocketTest):\n \n     def __init__(self, methodName='runTest'):\n```\n\nFilename: Misc/NEWS.d/next/Security/2024-07-22-13-11-28.gh-issue-122133.0mPeta.rst:\n```\n@@ -0,0 +1,5 @@\n+Authenticate the socket connection for the ``socket.socketpair()`` fallback\n+on platforms where ``AF_UNIX`` is not available like Windows.\n+\n+Patch by Gregory P. Smith <greg@krypto.org> and Seth Larson <seth@python.org>. Reported by Ellie\n+<el@horse64.org>\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/5df322e91a40909e6904bbdbc0c3a6b6a9eead39",
                "content": "[3.12] gh-122133: Rework pure Python socketpair tests to avoid use of importlib.reload. (GH-122493) (GH-122505)\n\ngh-122133: Rework pure Python socketpair tests to avoid use of importlib.reload. (GH-122493)\r\n\r\n(cherry picked from commit f071f01b7b7e19d7d6b3a4b0ec62f820ecb14660)\r\n\r\nCo-authored-by: Russell Keith-Magee <russell@keith-magee.com>\r\nCo-authored-by: Gregory P. Smith <greg@krypto.org>\n\nFilename: Lib/socket.py:\n```\n@@ -592,16 +592,65 @@\ndef fromshare(info):\n         return socket(0, 0, 0, info)\n     __all__.append(\"fromshare\")\n \n-if hasattr(_socket, \"socketpair\"):\n+# Origin: https://gist.github.com/4325783, by Geert Jansen.  Public domain.\n+# This is used if _socket doesn't natively provide socketpair. It's\n+# always defined so that it can be patched in for testing purposes.\n+def _fallback_socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):\n+    if family == AF_INET:\n+        host = _LOCALHOST\n+    elif family == AF_INET6:\n+        host = _LOCALHOST_V6\n+    else:\n+        raise ValueError(\"Only AF_INET and AF_INET6 socket address families \"\n+                         \"are supported\")\n+    if type != SOCK_STREAM:\n+        raise ValueError(\"Only SOCK_STREAM socket type is supported\")\n+    if proto != 0:\n+        raise ValueError(\"Only protocol zero is supported\")\n+\n+    # We create a connected TCP socket. Note the trick with\n+    # setblocking(False) that prevents us from having to create a thread.\n+    lsock = socket(family, type, proto)\n+    try:\n+        lsock.bind((host, 0))\n+        lsock.listen()\n+        # On IPv6, ignore flow_info and scope_id\n+        addr, port = lsock.getsockname()[:2]\n+        csock = socket(family, type, proto)\n+        try:\n+            csock.setblocking(False)\n+            try:\n+                csock.connect((addr, port))\n+            except (BlockingIOError, InterruptedError):\n+                pass\n+            csock.setblocking(True)\n+            ssock, _ = lsock.accept()\n+        except:\n+            csock.close()\n+            raise\n+    finally:\n+        lsock.close()\n \n-    def socketpair(family=None, type=SOCK_STREAM, proto=0):\n-        \"\"\"socketpair([family[, type[, proto]]]) -> (socket object, socket object)\n+    # Authenticating avoids using a connection from something else\n+    # able to connect to {host}:{port} instead of us.\n+    # We expect only AF_INET and AF_INET6 families.\n+    try:\n+        if (\n+            ssock.getsockname() != csock.getpeername()\n+            or csock.getsockname() != ssock.getpeername()\n+        ):\n+            raise ConnectionError(\"Unexpected peer connection\")\n+    except:\n+        # getsockname() and getpeername() can fail\n+        # if either socket isn't connected.\n+        ssock.close()\n+        csock.close()\n+        raise\n \n-        Create a pair of socket objects from the sockets returned by the platform\n-        socketpair() function.\n-        The arguments are the same as for socket() except the default family is\n-        AF_UNIX if defined on the platform; otherwise, the default is AF_INET.\n-        \"\"\"\n+    return (ssock, csock)\n+\n+if hasattr(_socket, \"socketpair\"):\n+    def socketpair(family=None, type=SOCK_STREAM, proto=0):\n         if family is None:\n             try:\n                 family = AF_UNIX\n\n@@ -613,61 +662,7 @@\ndef socketpair(family=None, type=SOCK_STREAM, proto=0):\n         return a, b\n \n else:\n-\n-    # Origin: https://gist.github.com/4325783, by Geert Jansen.  Public domain.\n-    def socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):\n-        if family == AF_INET:\n-            host = _LOCALHOST\n-        elif family == AF_INET6:\n-            host = _LOCALHOST_V6\n-        else:\n-            raise ValueError(\"Only AF_INET and AF_INET6 socket address families \"\n-                             \"are supported\")\n-        if type != SOCK_STREAM:\n-            raise ValueError(\"Only SOCK_STREAM socket type is supported\")\n-        if proto != 0:\n-            raise ValueError(\"Only protocol zero is supported\")\n-\n-        # We create a connected TCP socket. Note the trick with\n-        # setblocking(False) that prevents us from having to create a thread.\n-        lsock = socket(family, type, proto)\n-        try:\n-            lsock.bind((host, 0))\n-            lsock.listen()\n-            # On IPv6, ignore flow_info and scope_id\n-            addr, port = lsock.getsockname()[:2]\n-            csock = socket(family, type, proto)\n-            try:\n-                csock.setblocking(False)\n-                try:\n-                    csock.connect((addr, port))\n-                except (BlockingIOError, InterruptedError):\n-                    pass\n-                csock.setblocking(True)\n-                ssock, _ = lsock.accept()\n-            except:\n-                csock.close()\n-                raise\n-        finally:\n-            lsock.close()\n-\n-        # Authenticating avoids using a connection from something else\n-        # able to connect to {host}:{port} instead of us.\n-        # We expect only AF_INET and AF_INET6 families.\n-        try:\n-            if (\n-                ssock.getsockname() != csock.getpeername()\n-                or csock.getsockname() != ssock.getpeername()\n-            ):\n-                raise ConnectionError(\"Unexpected peer connection\")\n-        except:\n-            # getsockname() and getpeername() can fail\n-            # if either socket isn't connected.\n-            ssock.close()\n-            csock.close()\n-            raise\n-\n-        return (ssock, csock)\n+    socketpair = _fallback_socketpair\n     __all__.append(\"socketpair\")\n \n socketpair.__doc__ = \"\"\"socketpair([family[, type[, proto]]]) -> (socket object, socket object)\n```\n\nFilename: Lib/test/test_socket.py:\n```\n@@ -4795,7 +4795,6 @@\ndef _testSend(self):\n \n \n class PurePythonSocketPairTest(SocketPairTest):\n-\n     # Explicitly use socketpair AF_INET or AF_INET6 to ensure that is the\n     # code path we're using regardless platform is the pure python one where\n     # `_socket.socketpair` does not exist.  (AF_INET does not work with\n\n@@ -4810,28 +4809,21 @@\ndef socketpair(self):\n     # Local imports in this class make for easy security fix backporting.\n \n     def setUp(self):\n-        import _socket\n-        self._orig_sp = getattr(_socket, 'socketpair', None)\n-        if self._orig_sp is not None:\n+        if hasattr(_socket, \"socketpair\"):\n+            self._orig_sp = socket.socketpair\n             # This forces the version using the non-OS provided socketpair\n             # emulation via an AF_INET socket in Lib/socket.py.\n-            del _socket.socketpair\n-            import importlib\n-            global socket\n-            socket = importlib.reload(socket)\n+            socket.socketpair = socket._fallback_socketpair\n         else:\n-            pass  # This platform already uses the non-OS provided version.\n+            # This platform already uses the non-OS provided version.\n+            self._orig_sp = None\n         super().setUp()\n \n     def tearDown(self):\n         super().tearDown()\n-        import _socket\n         if self._orig_sp is not None:\n             # Restore the default socket.socketpair definition.\n-            _socket.socketpair = self._orig_sp\n-            import importlib\n-            global socket\n-            socket = importlib.reload(socket)\n+            socket.socketpair = self._orig_sp\n \n     def test_recv(self):\n         msg = self.serv.recv(1024)\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/c21a36112a0028d7ac3cf8f480e0dc88dba5922c",
                "content": "[3.13] gh-122133: Rework pure Python socketpair tests to avoid use of importlib.reload. (GH-122493) (#122504)\n\ngh-122133: Rework pure Python socketpair tests to avoid use of importlib.reload. (GH-122493)\r\n\r\n(cherry picked from commit f071f01b7b7e19d7d6b3a4b0ec62f820ecb14660)\r\n\r\nCo-authored-by: Russell Keith-Magee <russell@keith-magee.com>\r\nCo-authored-by: Gregory P. Smith <greg@krypto.org>\n\nFilename: Lib/socket.py:\n```\n@@ -592,16 +592,65 @@\ndef fromshare(info):\n         return socket(0, 0, 0, info)\n     __all__.append(\"fromshare\")\n \n-if hasattr(_socket, \"socketpair\"):\n+# Origin: https://gist.github.com/4325783, by Geert Jansen.  Public domain.\n+# This is used if _socket doesn't natively provide socketpair. It's\n+# always defined so that it can be patched in for testing purposes.\n+def _fallback_socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):\n+    if family == AF_INET:\n+        host = _LOCALHOST\n+    elif family == AF_INET6:\n+        host = _LOCALHOST_V6\n+    else:\n+        raise ValueError(\"Only AF_INET and AF_INET6 socket address families \"\n+                         \"are supported\")\n+    if type != SOCK_STREAM:\n+        raise ValueError(\"Only SOCK_STREAM socket type is supported\")\n+    if proto != 0:\n+        raise ValueError(\"Only protocol zero is supported\")\n+\n+    # We create a connected TCP socket. Note the trick with\n+    # setblocking(False) that prevents us from having to create a thread.\n+    lsock = socket(family, type, proto)\n+    try:\n+        lsock.bind((host, 0))\n+        lsock.listen()\n+        # On IPv6, ignore flow_info and scope_id\n+        addr, port = lsock.getsockname()[:2]\n+        csock = socket(family, type, proto)\n+        try:\n+            csock.setblocking(False)\n+            try:\n+                csock.connect((addr, port))\n+            except (BlockingIOError, InterruptedError):\n+                pass\n+            csock.setblocking(True)\n+            ssock, _ = lsock.accept()\n+        except:\n+            csock.close()\n+            raise\n+    finally:\n+        lsock.close()\n \n-    def socketpair(family=None, type=SOCK_STREAM, proto=0):\n-        \"\"\"socketpair([family[, type[, proto]]]) -> (socket object, socket object)\n+    # Authenticating avoids using a connection from something else\n+    # able to connect to {host}:{port} instead of us.\n+    # We expect only AF_INET and AF_INET6 families.\n+    try:\n+        if (\n+            ssock.getsockname() != csock.getpeername()\n+            or csock.getsockname() != ssock.getpeername()\n+        ):\n+            raise ConnectionError(\"Unexpected peer connection\")\n+    except:\n+        # getsockname() and getpeername() can fail\n+        # if either socket isn't connected.\n+        ssock.close()\n+        csock.close()\n+        raise\n \n-        Create a pair of socket objects from the sockets returned by the platform\n-        socketpair() function.\n-        The arguments are the same as for socket() except the default family is\n-        AF_UNIX if defined on the platform; otherwise, the default is AF_INET.\n-        \"\"\"\n+    return (ssock, csock)\n+\n+if hasattr(_socket, \"socketpair\"):\n+    def socketpair(family=None, type=SOCK_STREAM, proto=0):\n         if family is None:\n             try:\n                 family = AF_UNIX\n\n@@ -613,61 +662,7 @@\ndef socketpair(family=None, type=SOCK_STREAM, proto=0):\n         return a, b\n \n else:\n-\n-    # Origin: https://gist.github.com/4325783, by Geert Jansen.  Public domain.\n-    def socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):\n-        if family == AF_INET:\n-            host = _LOCALHOST\n-        elif family == AF_INET6:\n-            host = _LOCALHOST_V6\n-        else:\n-            raise ValueError(\"Only AF_INET and AF_INET6 socket address families \"\n-                             \"are supported\")\n-        if type != SOCK_STREAM:\n-            raise ValueError(\"Only SOCK_STREAM socket type is supported\")\n-        if proto != 0:\n-            raise ValueError(\"Only protocol zero is supported\")\n-\n-        # We create a connected TCP socket. Note the trick with\n-        # setblocking(False) that prevents us from having to create a thread.\n-        lsock = socket(family, type, proto)\n-        try:\n-            lsock.bind((host, 0))\n-            lsock.listen()\n-            # On IPv6, ignore flow_info and scope_id\n-            addr, port = lsock.getsockname()[:2]\n-            csock = socket(family, type, proto)\n-            try:\n-                csock.setblocking(False)\n-                try:\n-                    csock.connect((addr, port))\n-                except (BlockingIOError, InterruptedError):\n-                    pass\n-                csock.setblocking(True)\n-                ssock, _ = lsock.accept()\n-            except:\n-                csock.close()\n-                raise\n-        finally:\n-            lsock.close()\n-\n-        # Authenticating avoids using a connection from something else\n-        # able to connect to {host}:{port} instead of us.\n-        # We expect only AF_INET and AF_INET6 families.\n-        try:\n-            if (\n-                ssock.getsockname() != csock.getpeername()\n-                or csock.getsockname() != ssock.getpeername()\n-            ):\n-                raise ConnectionError(\"Unexpected peer connection\")\n-        except:\n-            # getsockname() and getpeername() can fail\n-            # if either socket isn't connected.\n-            ssock.close()\n-            csock.close()\n-            raise\n-\n-        return (ssock, csock)\n+    socketpair = _fallback_socketpair\n     __all__.append(\"socketpair\")\n \n socketpair.__doc__ = \"\"\"socketpair([family[, type[, proto]]]) -> (socket object, socket object)\n```\n\nFilename: Lib/test/test_socket.py:\n```\n@@ -4861,7 +4861,6 @@\ndef _testSend(self):\n \n \n class PurePythonSocketPairTest(SocketPairTest):\n-\n     # Explicitly use socketpair AF_INET or AF_INET6 to ensure that is the\n     # code path we're using regardless platform is the pure python one where\n     # `_socket.socketpair` does not exist.  (AF_INET does not work with\n\n@@ -4876,28 +4875,21 @@\ndef socketpair(self):\n     # Local imports in this class make for easy security fix backporting.\n \n     def setUp(self):\n-        import _socket\n-        self._orig_sp = getattr(_socket, 'socketpair', None)\n-        if self._orig_sp is not None:\n+        if hasattr(_socket, \"socketpair\"):\n+            self._orig_sp = socket.socketpair\n             # This forces the version using the non-OS provided socketpair\n             # emulation via an AF_INET socket in Lib/socket.py.\n-            del _socket.socketpair\n-            import importlib\n-            global socket\n-            socket = importlib.reload(socket)\n+            socket.socketpair = socket._fallback_socketpair\n         else:\n-            pass  # This platform already uses the non-OS provided version.\n+            # This platform already uses the non-OS provided version.\n+            self._orig_sp = None\n         super().setUp()\n \n     def tearDown(self):\n         super().tearDown()\n-        import _socket\n         if self._orig_sp is not None:\n             # Restore the default socket.socketpair definition.\n-            _socket.socketpair = self._orig_sp\n-            import importlib\n-            global socket\n-            socket = importlib.reload(socket)\n+            socket.socketpair = self._orig_sp\n \n     def test_recv(self):\n         msg = self.serv.recv(1024)\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/f071f01b7b7e19d7d6b3a4b0ec62f820ecb14660",
                "content": "gh-122133: Rework pure Python socketpair tests to avoid use of importlib.reload. (#122493)\n\n\r\nCo-authored-by: Gregory P. Smith <greg@krypto.org>\n\nFilename: Lib/socket.py:\n```\n@@ -592,16 +592,65 @@\ndef fromshare(info):\n         return socket(0, 0, 0, info)\n     __all__.append(\"fromshare\")\n \n-if hasattr(_socket, \"socketpair\"):\n+# Origin: https://gist.github.com/4325783, by Geert Jansen.  Public domain.\n+# This is used if _socket doesn't natively provide socketpair. It's\n+# always defined so that it can be patched in for testing purposes.\n+def _fallback_socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):\n+    if family == AF_INET:\n+        host = _LOCALHOST\n+    elif family == AF_INET6:\n+        host = _LOCALHOST_V6\n+    else:\n+        raise ValueError(\"Only AF_INET and AF_INET6 socket address families \"\n+                         \"are supported\")\n+    if type != SOCK_STREAM:\n+        raise ValueError(\"Only SOCK_STREAM socket type is supported\")\n+    if proto != 0:\n+        raise ValueError(\"Only protocol zero is supported\")\n+\n+    # We create a connected TCP socket. Note the trick with\n+    # setblocking(False) that prevents us from having to create a thread.\n+    lsock = socket(family, type, proto)\n+    try:\n+        lsock.bind((host, 0))\n+        lsock.listen()\n+        # On IPv6, ignore flow_info and scope_id\n+        addr, port = lsock.getsockname()[:2]\n+        csock = socket(family, type, proto)\n+        try:\n+            csock.setblocking(False)\n+            try:\n+                csock.connect((addr, port))\n+            except (BlockingIOError, InterruptedError):\n+                pass\n+            csock.setblocking(True)\n+            ssock, _ = lsock.accept()\n+        except:\n+            csock.close()\n+            raise\n+    finally:\n+        lsock.close()\n \n-    def socketpair(family=None, type=SOCK_STREAM, proto=0):\n-        \"\"\"socketpair([family[, type[, proto]]]) -> (socket object, socket object)\n+    # Authenticating avoids using a connection from something else\n+    # able to connect to {host}:{port} instead of us.\n+    # We expect only AF_INET and AF_INET6 families.\n+    try:\n+        if (\n+            ssock.getsockname() != csock.getpeername()\n+            or csock.getsockname() != ssock.getpeername()\n+        ):\n+            raise ConnectionError(\"Unexpected peer connection\")\n+    except:\n+        # getsockname() and getpeername() can fail\n+        # if either socket isn't connected.\n+        ssock.close()\n+        csock.close()\n+        raise\n \n-        Create a pair of socket objects from the sockets returned by the platform\n-        socketpair() function.\n-        The arguments are the same as for socket() except the default family is\n-        AF_UNIX if defined on the platform; otherwise, the default is AF_INET.\n-        \"\"\"\n+    return (ssock, csock)\n+\n+if hasattr(_socket, \"socketpair\"):\n+    def socketpair(family=None, type=SOCK_STREAM, proto=0):\n         if family is None:\n             try:\n                 family = AF_UNIX\n\n@@ -613,61 +662,7 @@\ndef socketpair(family=None, type=SOCK_STREAM, proto=0):\n         return a, b\n \n else:\n-\n-    # Origin: https://gist.github.com/4325783, by Geert Jansen.  Public domain.\n-    def socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):\n-        if family == AF_INET:\n-            host = _LOCALHOST\n-        elif family == AF_INET6:\n-            host = _LOCALHOST_V6\n-        else:\n-            raise ValueError(\"Only AF_INET and AF_INET6 socket address families \"\n-                             \"are supported\")\n-        if type != SOCK_STREAM:\n-            raise ValueError(\"Only SOCK_STREAM socket type is supported\")\n-        if proto != 0:\n-            raise ValueError(\"Only protocol zero is supported\")\n-\n-        # We create a connected TCP socket. Note the trick with\n-        # setblocking(False) that prevents us from having to create a thread.\n-        lsock = socket(family, type, proto)\n-        try:\n-            lsock.bind((host, 0))\n-            lsock.listen()\n-            # On IPv6, ignore flow_info and scope_id\n-            addr, port = lsock.getsockname()[:2]\n-            csock = socket(family, type, proto)\n-            try:\n-                csock.setblocking(False)\n-                try:\n-                    csock.connect((addr, port))\n-                except (BlockingIOError, InterruptedError):\n-                    pass\n-                csock.setblocking(True)\n-                ssock, _ = lsock.accept()\n-            except:\n-                csock.close()\n-                raise\n-        finally:\n-            lsock.close()\n-\n-        # Authenticating avoids using a connection from something else\n-        # able to connect to {host}:{port} instead of us.\n-        # We expect only AF_INET and AF_INET6 families.\n-        try:\n-            if (\n-                ssock.getsockname() != csock.getpeername()\n-                or csock.getsockname() != ssock.getpeername()\n-            ):\n-                raise ConnectionError(\"Unexpected peer connection\")\n-        except:\n-            # getsockname() and getpeername() can fail\n-            # if either socket isn't connected.\n-            ssock.close()\n-            csock.close()\n-            raise\n-\n-        return (ssock, csock)\n+    socketpair = _fallback_socketpair\n     __all__.append(\"socketpair\")\n \n socketpair.__doc__ = \"\"\"socketpair([family[, type[, proto]]]) -> (socket object, socket object)\n```\n\nFilename: Lib/test/test_socket.py:\n```\n@@ -4861,7 +4861,6 @@\ndef _testSend(self):\n \n \n class PurePythonSocketPairTest(SocketPairTest):\n-\n     # Explicitly use socketpair AF_INET or AF_INET6 to ensure that is the\n     # code path we're using regardless platform is the pure python one where\n     # `_socket.socketpair` does not exist.  (AF_INET does not work with\n\n@@ -4876,28 +4875,21 @@\ndef socketpair(self):\n     # Local imports in this class make for easy security fix backporting.\n \n     def setUp(self):\n-        import _socket\n-        self._orig_sp = getattr(_socket, 'socketpair', None)\n-        if self._orig_sp is not None:\n+        if hasattr(_socket, \"socketpair\"):\n+            self._orig_sp = socket.socketpair\n             # This forces the version using the non-OS provided socketpair\n             # emulation via an AF_INET socket in Lib/socket.py.\n-            del _socket.socketpair\n-            import importlib\n-            global socket\n-            socket = importlib.reload(socket)\n+            socket.socketpair = socket._fallback_socketpair\n         else:\n-            pass  # This platform already uses the non-OS provided version.\n+            # This platform already uses the non-OS provided version.\n+            self._orig_sp = None\n         super().setUp()\n \n     def tearDown(self):\n         super().tearDown()\n-        import _socket\n         if self._orig_sp is not None:\n             # Restore the default socket.socketpair definition.\n-            _socket.socketpair = self._orig_sp\n-            import importlib\n-            global socket\n-            socket = importlib.reload(socket)\n+            socket.socketpair = self._orig_sp\n \n     def test_recv(self):\n         msg = self.serv.recv(1024)\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/31302f5fc24eecd693f0c8aaba7c2840b09b594d",
                "content": "[3.10] gh-122133: Rework pure Python socketpair tests to avoid use of importlib.reload. (GH-122493) (GH-122507)\n\n(cherry picked from commit f071f01b7b7e19d7d6b3a4b0ec62f820ecb14660)\r\n\r\nCo-authored-by: Russell Keith-Magee <russell@keith-magee.com>\r\nCo-authored-by: Gregory P. Smith <greg@krypto.org>\n\nFilename: Lib/socket.py:\n```\n@@ -589,16 +589,65 @@\ndef fromshare(info):\n         return socket(0, 0, 0, info)\n     __all__.append(\"fromshare\")\n \n-if hasattr(_socket, \"socketpair\"):\n+# Origin: https://gist.github.com/4325783, by Geert Jansen.  Public domain.\n+# This is used if _socket doesn't natively provide socketpair. It's\n+# always defined so that it can be patched in for testing purposes.\n+def _fallback_socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):\n+    if family == AF_INET:\n+        host = _LOCALHOST\n+    elif family == AF_INET6:\n+        host = _LOCALHOST_V6\n+    else:\n+        raise ValueError(\"Only AF_INET and AF_INET6 socket address families \"\n+                         \"are supported\")\n+    if type != SOCK_STREAM:\n+        raise ValueError(\"Only SOCK_STREAM socket type is supported\")\n+    if proto != 0:\n+        raise ValueError(\"Only protocol zero is supported\")\n+\n+    # We create a connected TCP socket. Note the trick with\n+    # setblocking(False) that prevents us from having to create a thread.\n+    lsock = socket(family, type, proto)\n+    try:\n+        lsock.bind((host, 0))\n+        lsock.listen()\n+        # On IPv6, ignore flow_info and scope_id\n+        addr, port = lsock.getsockname()[:2]\n+        csock = socket(family, type, proto)\n+        try:\n+            csock.setblocking(False)\n+            try:\n+                csock.connect((addr, port))\n+            except (BlockingIOError, InterruptedError):\n+                pass\n+            csock.setblocking(True)\n+            ssock, _ = lsock.accept()\n+        except:\n+            csock.close()\n+            raise\n+    finally:\n+        lsock.close()\n \n-    def socketpair(family=None, type=SOCK_STREAM, proto=0):\n-        \"\"\"socketpair([family[, type[, proto]]]) -> (socket object, socket object)\n+    # Authenticating avoids using a connection from something else\n+    # able to connect to {host}:{port} instead of us.\n+    # We expect only AF_INET and AF_INET6 families.\n+    try:\n+        if (\n+            ssock.getsockname() != csock.getpeername()\n+            or csock.getsockname() != ssock.getpeername()\n+        ):\n+            raise ConnectionError(\"Unexpected peer connection\")\n+    except:\n+        # getsockname() and getpeername() can fail\n+        # if either socket isn't connected.\n+        ssock.close()\n+        csock.close()\n+        raise\n \n-        Create a pair of socket objects from the sockets returned by the platform\n-        socketpair() function.\n-        The arguments are the same as for socket() except the default family is\n-        AF_UNIX if defined on the platform; otherwise, the default is AF_INET.\n-        \"\"\"\n+    return (ssock, csock)\n+\n+if hasattr(_socket, \"socketpair\"):\n+    def socketpair(family=None, type=SOCK_STREAM, proto=0):\n         if family is None:\n             try:\n                 family = AF_UNIX\n\n@@ -610,61 +659,7 @@\ndef socketpair(family=None, type=SOCK_STREAM, proto=0):\n         return a, b\n \n else:\n-\n-    # Origin: https://gist.github.com/4325783, by Geert Jansen.  Public domain.\n-    def socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):\n-        if family == AF_INET:\n-            host = _LOCALHOST\n-        elif family == AF_INET6:\n-            host = _LOCALHOST_V6\n-        else:\n-            raise ValueError(\"Only AF_INET and AF_INET6 socket address families \"\n-                             \"are supported\")\n-        if type != SOCK_STREAM:\n-            raise ValueError(\"Only SOCK_STREAM socket type is supported\")\n-        if proto != 0:\n-            raise ValueError(\"Only protocol zero is supported\")\n-\n-        # We create a connected TCP socket. Note the trick with\n-        # setblocking(False) that prevents us from having to create a thread.\n-        lsock = socket(family, type, proto)\n-        try:\n-            lsock.bind((host, 0))\n-            lsock.listen()\n-            # On IPv6, ignore flow_info and scope_id\n-            addr, port = lsock.getsockname()[:2]\n-            csock = socket(family, type, proto)\n-            try:\n-                csock.setblocking(False)\n-                try:\n-                    csock.connect((addr, port))\n-                except (BlockingIOError, InterruptedError):\n-                    pass\n-                csock.setblocking(True)\n-                ssock, _ = lsock.accept()\n-            except:\n-                csock.close()\n-                raise\n-        finally:\n-            lsock.close()\n-\n-        # Authenticating avoids using a connection from something else\n-        # able to connect to {host}:{port} instead of us.\n-        # We expect only AF_INET and AF_INET6 families.\n-        try:\n-            if (\n-                ssock.getsockname() != csock.getpeername()\n-                or csock.getsockname() != ssock.getpeername()\n-            ):\n-                raise ConnectionError(\"Unexpected peer connection\")\n-        except:\n-            # getsockname() and getpeername() can fail\n-            # if either socket isn't connected.\n-            ssock.close()\n-            csock.close()\n-            raise\n-\n-        return (ssock, csock)\n+    socketpair = _fallback_socketpair\n     __all__.append(\"socketpair\")\n \n socketpair.__doc__ = \"\"\"socketpair([family[, type[, proto]]]) -> (socket object, socket object)\n```\n\nFilename: Lib/test/test_socket.py:\n```\n@@ -4639,7 +4639,6 @@\ndef _testSend(self):\n \n \n class PurePythonSocketPairTest(SocketPairTest):\n-\n     # Explicitly use socketpair AF_INET or AF_INET6 to ensure that is the\n     # code path we're using regardless platform is the pure python one where\n     # `_socket.socketpair` does not exist.  (AF_INET does not work with\n\n@@ -4654,28 +4653,21 @@\ndef socketpair(self):\n     # Local imports in this class make for easy security fix backporting.\n \n     def setUp(self):\n-        import _socket\n-        self._orig_sp = getattr(_socket, 'socketpair', None)\n-        if self._orig_sp is not None:\n+        if hasattr(_socket, \"socketpair\"):\n+            self._orig_sp = socket.socketpair\n             # This forces the version using the non-OS provided socketpair\n             # emulation via an AF_INET socket in Lib/socket.py.\n-            del _socket.socketpair\n-            import importlib\n-            global socket\n-            socket = importlib.reload(socket)\n+            socket.socketpair = socket._fallback_socketpair\n         else:\n-            pass  # This platform already uses the non-OS provided version.\n+            # This platform already uses the non-OS provided version.\n+            self._orig_sp = None\n         super().setUp()\n \n     def tearDown(self):\n         super().tearDown()\n-        import _socket\n         if self._orig_sp is not None:\n             # Restore the default socket.socketpair definition.\n-            _socket.socketpair = self._orig_sp\n-            import importlib\n-            global socket\n-            socket = importlib.reload(socket)\n+            socket.socketpair = self._orig_sp\n \n     def test_recv(self):\n         msg = self.serv.recv(1024)\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/3f5d9d12c74787fbf3f5891835c85cc15526c86d",
                "content": "[3.9] gh-122133: Rework pure Python socketpair tests to avoid use of importlib.reload. (GH-122493) (GH-122508)\n\n(cherry picked from commit f071f01b7b7e19d7d6b3a4b0ec62f820ecb14660)\r\n\r\nCo-authored-by: Russell Keith-Magee <russell@keith-magee.com>\r\nCo-authored-by: Gregory P. Smith <greg@krypto.org>\n\nFilename: Lib/socket.py:\n```\n@@ -588,16 +588,65 @@\ndef fromshare(info):\n         return socket(0, 0, 0, info)\n     __all__.append(\"fromshare\")\n \n-if hasattr(_socket, \"socketpair\"):\n+# Origin: https://gist.github.com/4325783, by Geert Jansen.  Public domain.\n+# This is used if _socket doesn't natively provide socketpair. It's\n+# always defined so that it can be patched in for testing purposes.\n+def _fallback_socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):\n+    if family == AF_INET:\n+        host = _LOCALHOST\n+    elif family == AF_INET6:\n+        host = _LOCALHOST_V6\n+    else:\n+        raise ValueError(\"Only AF_INET and AF_INET6 socket address families \"\n+                         \"are supported\")\n+    if type != SOCK_STREAM:\n+        raise ValueError(\"Only SOCK_STREAM socket type is supported\")\n+    if proto != 0:\n+        raise ValueError(\"Only protocol zero is supported\")\n+\n+    # We create a connected TCP socket. Note the trick with\n+    # setblocking(False) that prevents us from having to create a thread.\n+    lsock = socket(family, type, proto)\n+    try:\n+        lsock.bind((host, 0))\n+        lsock.listen()\n+        # On IPv6, ignore flow_info and scope_id\n+        addr, port = lsock.getsockname()[:2]\n+        csock = socket(family, type, proto)\n+        try:\n+            csock.setblocking(False)\n+            try:\n+                csock.connect((addr, port))\n+            except (BlockingIOError, InterruptedError):\n+                pass\n+            csock.setblocking(True)\n+            ssock, _ = lsock.accept()\n+        except:\n+            csock.close()\n+            raise\n+    finally:\n+        lsock.close()\n \n-    def socketpair(family=None, type=SOCK_STREAM, proto=0):\n-        \"\"\"socketpair([family[, type[, proto]]]) -> (socket object, socket object)\n+    # Authenticating avoids using a connection from something else\n+    # able to connect to {host}:{port} instead of us.\n+    # We expect only AF_INET and AF_INET6 families.\n+    try:\n+        if (\n+            ssock.getsockname() != csock.getpeername()\n+            or csock.getsockname() != ssock.getpeername()\n+        ):\n+            raise ConnectionError(\"Unexpected peer connection\")\n+    except:\n+        # getsockname() and getpeername() can fail\n+        # if either socket isn't connected.\n+        ssock.close()\n+        csock.close()\n+        raise\n \n-        Create a pair of socket objects from the sockets returned by the platform\n-        socketpair() function.\n-        The arguments are the same as for socket() except the default family is\n-        AF_UNIX if defined on the platform; otherwise, the default is AF_INET.\n-        \"\"\"\n+    return (ssock, csock)\n+\n+if hasattr(_socket, \"socketpair\"):\n+    def socketpair(family=None, type=SOCK_STREAM, proto=0):\n         if family is None:\n             try:\n                 family = AF_UNIX\n\n@@ -609,61 +658,7 @@\ndef socketpair(family=None, type=SOCK_STREAM, proto=0):\n         return a, b\n \n else:\n-\n-    # Origin: https://gist.github.com/4325783, by Geert Jansen.  Public domain.\n-    def socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):\n-        if family == AF_INET:\n-            host = _LOCALHOST\n-        elif family == AF_INET6:\n-            host = _LOCALHOST_V6\n-        else:\n-            raise ValueError(\"Only AF_INET and AF_INET6 socket address families \"\n-                             \"are supported\")\n-        if type != SOCK_STREAM:\n-            raise ValueError(\"Only SOCK_STREAM socket type is supported\")\n-        if proto != 0:\n-            raise ValueError(\"Only protocol zero is supported\")\n-\n-        # We create a connected TCP socket. Note the trick with\n-        # setblocking(False) that prevents us from having to create a thread.\n-        lsock = socket(family, type, proto)\n-        try:\n-            lsock.bind((host, 0))\n-            lsock.listen()\n-            # On IPv6, ignore flow_info and scope_id\n-            addr, port = lsock.getsockname()[:2]\n-            csock = socket(family, type, proto)\n-            try:\n-                csock.setblocking(False)\n-                try:\n-                    csock.connect((addr, port))\n-                except (BlockingIOError, InterruptedError):\n-                    pass\n-                csock.setblocking(True)\n-                ssock, _ = lsock.accept()\n-            except:\n-                csock.close()\n-                raise\n-        finally:\n-            lsock.close()\n-\n-        # Authenticating avoids using a connection from something else\n-        # able to connect to {host}:{port} instead of us.\n-        # We expect only AF_INET and AF_INET6 families.\n-        try:\n-            if (\n-                ssock.getsockname() != csock.getpeername()\n-                or csock.getsockname() != ssock.getpeername()\n-            ):\n-                raise ConnectionError(\"Unexpected peer connection\")\n-        except:\n-            # getsockname() and getpeername() can fail\n-            # if either socket isn't connected.\n-            ssock.close()\n-            csock.close()\n-            raise\n-\n-        return (ssock, csock)\n+    socketpair = _fallback_socketpair\n     __all__.append(\"socketpair\")\n \n socketpair.__doc__ = \"\"\"socketpair([family[, type[, proto]]]) -> (socket object, socket object)\n```\n\nFilename: Lib/test/test_socket.py:\n```\n@@ -4622,7 +4622,6 @@\ndef _testSend(self):\n \n \n class PurePythonSocketPairTest(SocketPairTest):\n-\n     # Explicitly use socketpair AF_INET or AF_INET6 to ensure that is the\n     # code path we're using regardless platform is the pure python one where\n     # `_socket.socketpair` does not exist.  (AF_INET does not work with\n\n@@ -4637,28 +4636,21 @@\ndef socketpair(self):\n     # Local imports in this class make for easy security fix backporting.\n \n     def setUp(self):\n-        import _socket\n-        self._orig_sp = getattr(_socket, 'socketpair', None)\n-        if self._orig_sp is not None:\n+        if hasattr(_socket, \"socketpair\"):\n+            self._orig_sp = socket.socketpair\n             # This forces the version using the non-OS provided socketpair\n             # emulation via an AF_INET socket in Lib/socket.py.\n-            del _socket.socketpair\n-            import importlib\n-            global socket\n-            socket = importlib.reload(socket)\n+            socket.socketpair = socket._fallback_socketpair\n         else:\n-            pass  # This platform already uses the non-OS provided version.\n+            # This platform already uses the non-OS provided version.\n+            self._orig_sp = None\n         super().setUp()\n \n     def tearDown(self):\n         super().tearDown()\n-        import _socket\n         if self._orig_sp is not None:\n             # Restore the default socket.socketpair definition.\n-            _socket.socketpair = self._orig_sp\n-            import importlib\n-            global socket\n-            socket = importlib.reload(socket)\n+            socket.socketpair = self._orig_sp\n \n     def test_recv(self):\n         msg = self.serv.recv(1024)\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/c5655aa6ad120d2ed7f255bebd6e8b71a9c07dde",
                "content": "[3.11] gh-122133: Rework pure Python socketpair tests to avoid use of importlib.reload. (GH-122493) (GH-122506)\n\n(cherry picked from commit f071f01b7b7e19d7d6b3a4b0ec62f820ecb14660)\r\n\r\nCo-authored-by: Russell Keith-Magee <russell@keith-magee.com>\r\nCo-authored-by: Gregory P. Smith <greg@krypto.org>\n\nFilename: Lib/socket.py:\n```\n@@ -590,16 +590,65 @@\ndef fromshare(info):\n         return socket(0, 0, 0, info)\n     __all__.append(\"fromshare\")\n \n-if hasattr(_socket, \"socketpair\"):\n+# Origin: https://gist.github.com/4325783, by Geert Jansen.  Public domain.\n+# This is used if _socket doesn't natively provide socketpair. It's\n+# always defined so that it can be patched in for testing purposes.\n+def _fallback_socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):\n+    if family == AF_INET:\n+        host = _LOCALHOST\n+    elif family == AF_INET6:\n+        host = _LOCALHOST_V6\n+    else:\n+        raise ValueError(\"Only AF_INET and AF_INET6 socket address families \"\n+                         \"are supported\")\n+    if type != SOCK_STREAM:\n+        raise ValueError(\"Only SOCK_STREAM socket type is supported\")\n+    if proto != 0:\n+        raise ValueError(\"Only protocol zero is supported\")\n+\n+    # We create a connected TCP socket. Note the trick with\n+    # setblocking(False) that prevents us from having to create a thread.\n+    lsock = socket(family, type, proto)\n+    try:\n+        lsock.bind((host, 0))\n+        lsock.listen()\n+        # On IPv6, ignore flow_info and scope_id\n+        addr, port = lsock.getsockname()[:2]\n+        csock = socket(family, type, proto)\n+        try:\n+            csock.setblocking(False)\n+            try:\n+                csock.connect((addr, port))\n+            except (BlockingIOError, InterruptedError):\n+                pass\n+            csock.setblocking(True)\n+            ssock, _ = lsock.accept()\n+        except:\n+            csock.close()\n+            raise\n+    finally:\n+        lsock.close()\n \n-    def socketpair(family=None, type=SOCK_STREAM, proto=0):\n-        \"\"\"socketpair([family[, type[, proto]]]) -> (socket object, socket object)\n+    # Authenticating avoids using a connection from something else\n+    # able to connect to {host}:{port} instead of us.\n+    # We expect only AF_INET and AF_INET6 families.\n+    try:\n+        if (\n+            ssock.getsockname() != csock.getpeername()\n+            or csock.getsockname() != ssock.getpeername()\n+        ):\n+            raise ConnectionError(\"Unexpected peer connection\")\n+    except:\n+        # getsockname() and getpeername() can fail\n+        # if either socket isn't connected.\n+        ssock.close()\n+        csock.close()\n+        raise\n \n-        Create a pair of socket objects from the sockets returned by the platform\n-        socketpair() function.\n-        The arguments are the same as for socket() except the default family is\n-        AF_UNIX if defined on the platform; otherwise, the default is AF_INET.\n-        \"\"\"\n+    return (ssock, csock)\n+\n+if hasattr(_socket, \"socketpair\"):\n+    def socketpair(family=None, type=SOCK_STREAM, proto=0):\n         if family is None:\n             try:\n                 family = AF_UNIX\n\n@@ -611,61 +660,7 @@\ndef socketpair(family=None, type=SOCK_STREAM, proto=0):\n         return a, b\n \n else:\n-\n-    # Origin: https://gist.github.com/4325783, by Geert Jansen.  Public domain.\n-    def socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):\n-        if family == AF_INET:\n-            host = _LOCALHOST\n-        elif family == AF_INET6:\n-            host = _LOCALHOST_V6\n-        else:\n-            raise ValueError(\"Only AF_INET and AF_INET6 socket address families \"\n-                             \"are supported\")\n-        if type != SOCK_STREAM:\n-            raise ValueError(\"Only SOCK_STREAM socket type is supported\")\n-        if proto != 0:\n-            raise ValueError(\"Only protocol zero is supported\")\n-\n-        # We create a connected TCP socket. Note the trick with\n-        # setblocking(False) that prevents us from having to create a thread.\n-        lsock = socket(family, type, proto)\n-        try:\n-            lsock.bind((host, 0))\n-            lsock.listen()\n-            # On IPv6, ignore flow_info and scope_id\n-            addr, port = lsock.getsockname()[:2]\n-            csock = socket(family, type, proto)\n-            try:\n-                csock.setblocking(False)\n-                try:\n-                    csock.connect((addr, port))\n-                except (BlockingIOError, InterruptedError):\n-                    pass\n-                csock.setblocking(True)\n-                ssock, _ = lsock.accept()\n-            except:\n-                csock.close()\n-                raise\n-        finally:\n-            lsock.close()\n-\n-        # Authenticating avoids using a connection from something else\n-        # able to connect to {host}:{port} instead of us.\n-        # We expect only AF_INET and AF_INET6 families.\n-        try:\n-            if (\n-                ssock.getsockname() != csock.getpeername()\n-                or csock.getsockname() != ssock.getpeername()\n-            ):\n-                raise ConnectionError(\"Unexpected peer connection\")\n-        except:\n-            # getsockname() and getpeername() can fail\n-            # if either socket isn't connected.\n-            ssock.close()\n-            csock.close()\n-            raise\n-\n-        return (ssock, csock)\n+    socketpair = _fallback_socketpair\n     __all__.append(\"socketpair\")\n \n socketpair.__doc__ = \"\"\"socketpair([family[, type[, proto]]]) -> (socket object, socket object)\n```\n\nFilename: Lib/test/test_socket.py:\n```\n@@ -4676,7 +4676,6 @@\ndef _testSend(self):\n \n \n class PurePythonSocketPairTest(SocketPairTest):\n-\n     # Explicitly use socketpair AF_INET or AF_INET6 to ensure that is the\n     # code path we're using regardless platform is the pure python one where\n     # `_socket.socketpair` does not exist.  (AF_INET does not work with\n\n@@ -4691,28 +4690,21 @@\ndef socketpair(self):\n     # Local imports in this class make for easy security fix backporting.\n \n     def setUp(self):\n-        import _socket\n-        self._orig_sp = getattr(_socket, 'socketpair', None)\n-        if self._orig_sp is not None:\n+        if hasattr(_socket, \"socketpair\"):\n+            self._orig_sp = socket.socketpair\n             # This forces the version using the non-OS provided socketpair\n             # emulation via an AF_INET socket in Lib/socket.py.\n-            del _socket.socketpair\n-            import importlib\n-            global socket\n-            socket = importlib.reload(socket)\n+            socket.socketpair = socket._fallback_socketpair\n         else:\n-            pass  # This platform already uses the non-OS provided version.\n+            # This platform already uses the non-OS provided version.\n+            self._orig_sp = None\n         super().setUp()\n \n     def tearDown(self):\n         super().tearDown()\n-        import _socket\n         if self._orig_sp is not None:\n             # Restore the default socket.socketpair definition.\n-            _socket.socketpair = self._orig_sp\n-            import importlib\n-            global socket\n-            socket = importlib.reload(socket)\n+            socket.socketpair = self._orig_sp\n \n     def test_recv(self):\n         msg = self.serv.recv(1024)\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/e319f774f9e766a2b92949444a2d46081df3363a",
                "content": "[3.8] gh-122133: Rework pure Python socketpair tests to avoid use of importlib.reload. (GH-122493) (GH-122509)\n\n(cherry picked from commit f071f01b7b7e19d7d6b3a4b0ec62f820ecb14660)\r\n\r\nCo-authored-by: Russell Keith-Magee <russell@keith-magee.com>\r\nCo-authored-by: Gregory P. Smith <greg@krypto.org>\n\nFilename: Lib/socket.py:\n```\n@@ -553,16 +553,65 @@\ndef fromshare(info):\n         return socket(0, 0, 0, info)\n     __all__.append(\"fromshare\")\n \n-if hasattr(_socket, \"socketpair\"):\n+# Origin: https://gist.github.com/4325783, by Geert Jansen.  Public domain.\n+# This is used if _socket doesn't natively provide socketpair. It's\n+# always defined so that it can be patched in for testing purposes.\n+def _fallback_socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):\n+    if family == AF_INET:\n+        host = _LOCALHOST\n+    elif family == AF_INET6:\n+        host = _LOCALHOST_V6\n+    else:\n+        raise ValueError(\"Only AF_INET and AF_INET6 socket address families \"\n+                         \"are supported\")\n+    if type != SOCK_STREAM:\n+        raise ValueError(\"Only SOCK_STREAM socket type is supported\")\n+    if proto != 0:\n+        raise ValueError(\"Only protocol zero is supported\")\n+\n+    # We create a connected TCP socket. Note the trick with\n+    # setblocking(False) that prevents us from having to create a thread.\n+    lsock = socket(family, type, proto)\n+    try:\n+        lsock.bind((host, 0))\n+        lsock.listen()\n+        # On IPv6, ignore flow_info and scope_id\n+        addr, port = lsock.getsockname()[:2]\n+        csock = socket(family, type, proto)\n+        try:\n+            csock.setblocking(False)\n+            try:\n+                csock.connect((addr, port))\n+            except (BlockingIOError, InterruptedError):\n+                pass\n+            csock.setblocking(True)\n+            ssock, _ = lsock.accept()\n+        except:\n+            csock.close()\n+            raise\n+    finally:\n+        lsock.close()\n \n-    def socketpair(family=None, type=SOCK_STREAM, proto=0):\n-        \"\"\"socketpair([family[, type[, proto]]]) -> (socket object, socket object)\n+    # Authenticating avoids using a connection from something else\n+    # able to connect to {host}:{port} instead of us.\n+    # We expect only AF_INET and AF_INET6 families.\n+    try:\n+        if (\n+            ssock.getsockname() != csock.getpeername()\n+            or csock.getsockname() != ssock.getpeername()\n+        ):\n+            raise ConnectionError(\"Unexpected peer connection\")\n+    except:\n+        # getsockname() and getpeername() can fail\n+        # if either socket isn't connected.\n+        ssock.close()\n+        csock.close()\n+        raise\n \n-        Create a pair of socket objects from the sockets returned by the platform\n-        socketpair() function.\n-        The arguments are the same as for socket() except the default family is\n-        AF_UNIX if defined on the platform; otherwise, the default is AF_INET.\n-        \"\"\"\n+    return (ssock, csock)\n+\n+if hasattr(_socket, \"socketpair\"):\n+    def socketpair(family=None, type=SOCK_STREAM, proto=0):\n         if family is None:\n             try:\n                 family = AF_UNIX\n\n@@ -574,61 +623,7 @@\ndef socketpair(family=None, type=SOCK_STREAM, proto=0):\n         return a, b\n \n else:\n-\n-    # Origin: https://gist.github.com/4325783, by Geert Jansen.  Public domain.\n-    def socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):\n-        if family == AF_INET:\n-            host = _LOCALHOST\n-        elif family == AF_INET6:\n-            host = _LOCALHOST_V6\n-        else:\n-            raise ValueError(\"Only AF_INET and AF_INET6 socket address families \"\n-                             \"are supported\")\n-        if type != SOCK_STREAM:\n-            raise ValueError(\"Only SOCK_STREAM socket type is supported\")\n-        if proto != 0:\n-            raise ValueError(\"Only protocol zero is supported\")\n-\n-        # We create a connected TCP socket. Note the trick with\n-        # setblocking(False) that prevents us from having to create a thread.\n-        lsock = socket(family, type, proto)\n-        try:\n-            lsock.bind((host, 0))\n-            lsock.listen()\n-            # On IPv6, ignore flow_info and scope_id\n-            addr, port = lsock.getsockname()[:2]\n-            csock = socket(family, type, proto)\n-            try:\n-                csock.setblocking(False)\n-                try:\n-                    csock.connect((addr, port))\n-                except (BlockingIOError, InterruptedError):\n-                    pass\n-                csock.setblocking(True)\n-                ssock, _ = lsock.accept()\n-            except:\n-                csock.close()\n-                raise\n-        finally:\n-            lsock.close()\n-\n-        # Authenticating avoids using a connection from something else\n-        # able to connect to {host}:{port} instead of us.\n-        # We expect only AF_INET and AF_INET6 families.\n-        try:\n-            if (\n-                ssock.getsockname() != csock.getpeername()\n-                or csock.getsockname() != ssock.getpeername()\n-            ):\n-                raise ConnectionError(\"Unexpected peer connection\")\n-        except:\n-            # getsockname() and getpeername() can fail\n-            # if either socket isn't connected.\n-            ssock.close()\n-            csock.close()\n-            raise\n-\n-        return (ssock, csock)\n+    socketpair = _fallback_socketpair\n     __all__.append(\"socketpair\")\n \n socketpair.__doc__ = \"\"\"socketpair([family[, type[, proto]]]) -> (socket object, socket object)\n```\n\nFilename: Lib/test/test_socket.py:\n```\n@@ -4316,7 +4316,6 @@\ndef _testSend(self):\n \n \n class PurePythonSocketPairTest(SocketPairTest):\n-\n     # Explicitly use socketpair AF_INET or AF_INET6 to ensure that is the\n     # code path we're using regardless platform is the pure python one where\n     # `_socket.socketpair` does not exist.  (AF_INET does not work with\n\n@@ -4331,28 +4330,21 @@\ndef socketpair(self):\n     # Local imports in this class make for easy security fix backporting.\n \n     def setUp(self):\n-        import _socket\n-        self._orig_sp = getattr(_socket, 'socketpair', None)\n-        if self._orig_sp is not None:\n+        if hasattr(_socket, \"socketpair\"):\n+            self._orig_sp = socket.socketpair\n             # This forces the version using the non-OS provided socketpair\n             # emulation via an AF_INET socket in Lib/socket.py.\n-            del _socket.socketpair\n-            import importlib\n-            global socket\n-            socket = importlib.reload(socket)\n+            socket.socketpair = socket._fallback_socketpair\n         else:\n-            pass  # This platform already uses the non-OS provided version.\n+            # This platform already uses the non-OS provided version.\n+            self._orig_sp = None\n         super().setUp()\n \n     def tearDown(self):\n         super().tearDown()\n-        import _socket\n         if self._orig_sp is not None:\n             # Restore the default socket.socketpair definition.\n-            _socket.socketpair = self._orig_sp\n-            import importlib\n-            global socket\n-            socket = importlib.reload(socket)\n+            socket.socketpair = self._orig_sp\n \n     def test_recv(self):\n         msg = self.serv.recv(1024)\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/78df1043dbdce5c989600616f9f87b4ee72944e5",
                "content": "gh-122133: Authenticate socket connection for `socket.socketpair()` fallback (GH-122134)\n\n* Authenticate socket connection for `socket.socketpair()` fallback when the platform does not have a native `socketpair` C API.  We authenticate in-process using `getsocketname` and `getpeername` (thanks to Nathaniel J Smith for that suggestion).\r\n\r\nCo-authored-by: Gregory P. Smith <greg@krypto.org>\n\nFilename: Lib/socket.py:\n```\n@@ -650,6 +650,23 @@\ndef socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):\n                 raise\n         finally:\n             lsock.close()\n+\n+        # Authenticating avoids using a connection from something else\n+        # able to connect to {host}:{port} instead of us.\n+        # We expect only AF_INET and AF_INET6 families.\n+        try:\n+            if (\n+                ssock.getsockname() != csock.getpeername()\n+                or csock.getsockname() != ssock.getpeername()\n+            ):\n+                raise ConnectionError(\"Unexpected peer connection\")\n+        except:\n+            # getsockname() and getpeername() can fail\n+            # if either socket isn't connected.\n+            ssock.close()\n+            csock.close()\n+            raise\n+\n         return (ssock, csock)\n     __all__.append(\"socketpair\")\n```\n\nFilename: Lib/test/test_socket.py:\n```\n@@ -592,19 +592,27 @@\nclass SocketPairTest(unittest.TestCase, ThreadableTest):\n     def __init__(self, methodName='runTest'):\n         unittest.TestCase.__init__(self, methodName=methodName)\n         ThreadableTest.__init__(self)\n+        self.cli = None\n+        self.serv = None\n+\n+    def socketpair(self):\n+        # To be overridden by some child classes.\n+        return socket.socketpair()\n \n     def setUp(self):\n-        self.serv, self.cli = socket.socketpair()\n+        self.serv, self.cli = self.socketpair()\n \n     def tearDown(self):\n-        self.serv.close()\n+        if self.serv:\n+            self.serv.close()\n         self.serv = None\n \n     def clientSetUp(self):\n         pass\n \n     def clientTearDown(self):\n-        self.cli.close()\n+        if self.cli:\n+            self.cli.close()\n         self.cli = None\n         ThreadableTest.clientTearDown(self)\n\n@@ -4852,6 +4860,120 @@\ndef _testSend(self):\n         self.assertEqual(msg, MSG)\n \n \n+class PurePythonSocketPairTest(SocketPairTest):\n+\n+    # Explicitly use socketpair AF_INET or AF_INET6 to ensure that is the\n+    # code path we're using regardless platform is the pure python one where\n+    # `_socket.socketpair` does not exist.  (AF_INET does not work with\n+    # _socket.socketpair on many platforms).\n+    def socketpair(self):\n+        # called by super().setUp().\n+        try:\n+            return socket.socketpair(socket.AF_INET6)\n+        except OSError:\n+            return socket.socketpair(socket.AF_INET)\n+\n+    # Local imports in this class make for easy security fix backporting.\n+\n+    def setUp(self):\n+        import _socket\n+        self._orig_sp = getattr(_socket, 'socketpair', None)\n+        if self._orig_sp is not None:\n+            # This forces the version using the non-OS provided socketpair\n+            # emulation via an AF_INET socket in Lib/socket.py.\n+            del _socket.socketpair\n+            import importlib\n+            global socket\n+            socket = importlib.reload(socket)\n+        else:\n+            pass  # This platform already uses the non-OS provided version.\n+        super().setUp()\n+\n+    def tearDown(self):\n+        super().tearDown()\n+        import _socket\n+        if self._orig_sp is not None:\n+            # Restore the default socket.socketpair definition.\n+            _socket.socketpair = self._orig_sp\n+            import importlib\n+            global socket\n+            socket = importlib.reload(socket)\n+\n+    def test_recv(self):\n+        msg = self.serv.recv(1024)\n+        self.assertEqual(msg, MSG)\n+\n+    def _test_recv(self):\n+        self.cli.send(MSG)\n+\n+    def test_send(self):\n+        self.serv.send(MSG)\n+\n+    def _test_send(self):\n+        msg = self.cli.recv(1024)\n+        self.assertEqual(msg, MSG)\n+\n+    def test_ipv4(self):\n+        cli, srv = socket.socketpair(socket.AF_INET)\n+        cli.close()\n+        srv.close()\n+\n+    def _test_ipv4(self):\n+        pass\n+\n+    @unittest.skipIf(not hasattr(_socket, 'IPPROTO_IPV6') or\n+                     not hasattr(_socket, 'IPV6_V6ONLY'),\n+                     \"IPV6_V6ONLY option not supported\")\n+    @unittest.skipUnless(socket_helper.IPV6_ENABLED, 'IPv6 required for this test')\n+    def test_ipv6(self):\n+        cli, srv = socket.socketpair(socket.AF_INET6)\n+        cli.close()\n+        srv.close()\n+\n+    def _test_ipv6(self):\n+        pass\n+\n+    def test_injected_authentication_failure(self):\n+        orig_getsockname = socket.socket.getsockname\n+        inject_sock = None\n+\n+        def inject_getsocketname(self):\n+            nonlocal inject_sock\n+            sockname = orig_getsockname(self)\n+            # Connect to the listening socket ahead of the\n+            # client socket.\n+            if inject_sock is None:\n+                inject_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n+                inject_sock.setblocking(False)\n+                try:\n+                    inject_sock.connect(sockname[:2])\n+                except (BlockingIOError, InterruptedError):\n+                    pass\n+                inject_sock.setblocking(True)\n+            return sockname\n+\n+        sock1 = sock2 = None\n+        try:\n+            socket.socket.getsockname = inject_getsocketname\n+            with self.assertRaises(OSError):\n+                sock1, sock2 = socket.socketpair()\n+        finally:\n+            socket.socket.getsockname = orig_getsockname\n+            if inject_sock:\n+                inject_sock.close()\n+            if sock1:  # This cleanup isn't needed on a successful test.\n+                sock1.close()\n+            if sock2:\n+                sock2.close()\n+\n+    def _test_injected_authentication_failure(self):\n+        # No-op.  Exists for base class threading infrastructure to call.\n+        # We could refactor this test into its own lesser class along with the\n+        # setUp and tearDown code to construct an ideal; it is simpler to keep\n+        # it here and live with extra overhead one this _one_ failure test.\n+        pass\n+\n+\n class NonBlockingTCPTests(ThreadedTCPSocketTest):\n \n     def __init__(self, methodName='runTest'):\n```\n\nFilename: Misc/NEWS.d/next/Security/2024-07-22-13-11-28.gh-issue-122133.0mPeta.rst:\n```\n@@ -0,0 +1,5 @@\n+Authenticate the socket connection for the ``socket.socketpair()`` fallback\n+on platforms where ``AF_UNIX`` is not available like Windows.\n+\n+Patch by Gregory P. Smith <greg@krypto.org> and Seth Larson <seth@python.org>. Reported by Ellie\n+<el@horse64.org>\n```"
            }
        ],
        "sw_version": "v3.8.19",
        "sw_version_wget": "https://github.com/python/cpython/archive/refs/tags/v3.8.19.zip",
        "description": "The\n ‚Äúsocket‚Äù module provides a pure-Python fallback to the \nsocket.socketpair() function for platforms that don‚Äôt support AF_UNIX, \nsuch as Windows. This pure-Python implementation uses AF_INET or \nAF_INET6 to create a local connected pair of sockets. The connection \nbetween the two sockets was not verified before passing the two sockets \nback to the user, which leaves the server socket vulnerable to a \nconnection race from a malicious local peer.\n\nPlatforms that support AF_UNIX such as Linux and macOS are not affected by this vulnerability. Versions prior to CPython 3.5 are not affected due to the vulnerable API not being included.",
        "sec_adv": [],
        "cwe": [
            {
                "id": "n/a",
                "value": "n/a"
            }
        ]
    }
}