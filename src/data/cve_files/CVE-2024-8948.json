{
    "CVE-2024-8948": {
        "published_date": "2024-09-17T18:50:17.599Z",
        "patch_commits": [
            {
                "url": "https://github.com/micropython/micropython/commit/908ab1ceca15ee6fd0ef82ca4cba770a3ec41894",
                "content": "py/objint: Fix int.to_bytes() buffer size checks.\n\nFixes and improvements to `int.to_bytes()` are:\n- No longer overflows if byte size is 0 (closes #13041).\n- Raises OverflowError in any case where number won't fit into byte length\n  (now matches CPython, previously MicroPython would return a truncated\n  bytes object).\n- Document that `micropython int.to_bytes()` doesn't implement the optional\n  signed kwarg, but will behave as if `signed=True` when the integer is\n  negative (this is the current behaviour).  Add tests for this also.\n\nRequires changes for small ints, MPZ large ints, and \"long long\" large\nints.\n\nAdds a new set of unit tests for ints between 32 and 64 bits to increase\ncoverage of \"long long\" large ints, which are otherwise untested.\n\nTested on unix port (64 bit small ints, MPZ long ints) and Zephyr STM32WB\nboard (32 bit small ints, long long large ints).\n\nThis work was funded through GitHub Sponsors.\n\nSigned-off-by: Angus Gratton <angus@redyak.com.au>\n\nFilename: docs/library/builtins.rst:\n```\n@@ -82,6 +82,10 @@\nFunctions and types\n       In MicroPython, `byteorder` parameter must be positional (this is\n       compatible with CPython).\n \n+      .. note:: The optional ``signed`` kwarg from CPython is not supported.\n+                MicroPython currently converts negative integers as signed,\n+                and positive as unsigned. (:ref:`Details <cpydiff_types_int_to_bytes>`.)\n+\n .. function:: isinstance()\n \n .. function:: issubclass()\n```\n\nFilename: py/misc.h:\n```\n@@ -343,13 +343,46 @@\nstatic uint32_t mp_clz(uint32_t x) {\n     return _BitScanReverse(&lz, x) ? (sizeof(x) * 8 - 1) - lz : 0;\n }\n \n+static uint32_t mp_clzl(unsigned long x) {\n+    unsigned long lz = 0;\n+    return _BitScanReverse(&lz, x) ? (sizeof(x) * 8 - 1) - lz : 0;\n+}\n+\n+#ifdef _WIN64\n+static uint32_t mp_clzll(unsigned long long x) {\n+    unsigned long lz = 0;\n+    return _BitScanReverse64(&lz, x) ? (sizeof(x) * 8 - 1) - lz : 0;\n+}\n+#else\n+// Microsoft don't ship _BitScanReverse64 on Win32, so emulate it\n+static uint32_t mp_clzll(unsigned long long x) {\n+    unsigned long h = x >> 32;\n+    return h ? mp_clzl(h) : (mp_clzl(x) + 32);\n+}\n+#endif\n+\n static uint32_t mp_ctz(uint32_t x) {\n     unsigned long tz = 0;\n     return _BitScanForward(&tz, x) ? tz : 0;\n }\n #else\n #define mp_clz(x) __builtin_clz(x)\n+#define mp_clzl(x) __builtin_clzl(x)\n+#define mp_clzll(x) __builtin_clzll(x)\n #define mp_ctz(x) __builtin_ctz(x)\n #endif\n \n+// mp_int_t can be larger than long, i.e. Windows 64-bit, nan-box variants\n+static inline uint32_t mp_clz_mpi(mp_int_t x) {\n+    MP_STATIC_ASSERT(sizeof(mp_int_t) == sizeof(long long)\n+        || sizeof(mp_int_t) == sizeof(long));\n+\n+    // ugly, but should compile to single intrinsic unless O0 is set\n+    if (sizeof(mp_int_t) == sizeof(long)) {\n+        return mp_clzl(x);\n+    } else {\n+        return mp_clzll(x);\n+    }\n+}\n+\n #endif // MICROPY_INCLUDED_PY_MISC_H\n```\n\nFilename: py/mpz.c:\n```\n@@ -1589,7 +1589,7 @@\nbool mpz_as_uint_checked(const mpz_t *i, mp_uint_t *value) {\n     return true;\n }\n \n-void mpz_as_bytes(const mpz_t *z, bool big_endian, size_t len, byte *buf) {\n+bool mpz_as_bytes(const mpz_t *z, bool big_endian, bool as_signed, size_t len, byte *buf) {\n     byte *b = buf;\n     if (big_endian) {\n         b += len;\n\n@@ -1598,6 +1598,8 @@\nvoid mpz_as_bytes(const mpz_t *z, bool big_endian, size_t len, byte *buf) {\n     int bits = 0;\n     mpz_dbl_dig_t d = 0;\n     mpz_dbl_dig_t carry = 1;\n+    size_t olen = len; // bytes in output buffer\n+    bool ok = true;\n     for (size_t zlen = z->len; zlen > 0; --zlen) {\n         bits += DIG_SIZE;\n         d = (d << DIG_SIZE) | *zdig++;\n\n@@ -1607,28 +1609,32 @@\nvoid mpz_as_bytes(const mpz_t *z, bool big_endian, size_t len, byte *buf) {\n                 val = (~val & 0xff) + carry;\n                 carry = val >> 8;\n             }\n+\n+            if (!olen) {\n+                // Buffer is full, only OK if all remaining bytes are zeroes\n+                ok = ok && ((byte)val == 0);\n+                continue;\n+            }\n+\n             if (big_endian) {\n                 *--b = val;\n-                if (b == buf) {\n-                    return;\n-                }\n             } else {\n                 *b++ = val;\n-                if (b == buf + len) {\n-                    return;\n-                }\n             }\n+            olen--;\n         }\n     }\n \n-    // fill remainder of buf with zero/sign extension of the integer\n-    if (big_endian) {\n-        len = b - buf;\n+    if (as_signed && olen == 0 && len > 0) {\n+        // If output exhausted then ensure there was enough space for the sign bit\n+        byte most_sig = big_endian ? buf[0] : buf[len - 1];\n+        ok = ok && (bool)(most_sig & 0x80) == (bool)z->neg;\n     } else {\n-        len = buf + len - b;\n-        buf = b;\n+        // fill remainder of buf with zero/sign extension of the integer\n+        memset(big_endian ? buf : b, z->neg ? 0xff : 0x00, olen);\n     }\n-    memset(buf, z->neg ? 0xff : 0x00, len);\n+\n+    return ok;\n }\n \n #if MICROPY_PY_BUILTINS_FLOAT\n```\n\nFilename: py/mpz.h:\n```\n@@ -93,9 +93,9 @@\ntypedef int8_t mpz_dbl_dig_signed_t;\n typedef struct _mpz_t {\n     // Zero has neg=0, len=0.  Negative zero is not allowed.\n     size_t neg : 1;\n-    size_t fixed_dig : 1;\n-    size_t alloc : (8 * sizeof(size_t) - 2);\n-    size_t len;\n+    size_t fixed_dig : 1; // flag, 'dig' buffer cannot be reallocated\n+    size_t alloc : (8 * sizeof(size_t) - 2); // number of entries allocated in 'dig'\n+    size_t len; // number of entries used in 'dig'\n     mpz_dig_t *dig;\n } mpz_t;\n\n@@ -145,7 +145,8 @@\nstatic inline size_t mpz_max_num_bits(const mpz_t *z) {\n mp_int_t mpz_hash(const mpz_t *z);\n bool mpz_as_int_checked(const mpz_t *z, mp_int_t *value);\n bool mpz_as_uint_checked(const mpz_t *z, mp_uint_t *value);\n-void mpz_as_bytes(const mpz_t *z, bool big_endian, size_t len, byte *buf);\n+// Returns true if 'z' fit into 'len' bytes of 'buf' without overflowing, 'buf' is truncated otherwise.\n+bool mpz_as_bytes(const mpz_t *z, bool big_endian, bool as_signed, size_t len, byte *buf);\n #if MICROPY_PY_BUILTINS_FLOAT\n mp_float_t mpz_as_float(const mpz_t *z);\n #endif\n```\n\nFilename: py/objint.c:\n```\n@@ -421,29 +421,50 @@\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(int_from_bytes_fun_obj, 3, 4, int_fro\n static MP_DEFINE_CONST_CLASSMETHOD_OBJ(int_from_bytes_obj, MP_ROM_PTR(&int_from_bytes_fun_obj));\n \n static mp_obj_t int_to_bytes(size_t n_args, const mp_obj_t *args) {\n-    // TODO: Support signed param (assumes signed=False)\n+    // TODO: Support signed (currently behaves as if signed=(val < 0))\n     (void)n_args;\n+    bool overflow;\n \n-    mp_int_t len = mp_obj_get_int(args[1]);\n-    if (len < 0) {\n+    mp_int_t dlen = mp_obj_get_int(args[1]);\n+    if (dlen < 0) {\n         mp_raise_ValueError(NULL);\n     }\n     bool big_endian = args[2] != MP_OBJ_NEW_QSTR(MP_QSTR_little);\n \n     vstr_t vstr;\n-    vstr_init_len(&vstr, len);\n+    vstr_init_len(&vstr, dlen);\n     byte *data = (byte *)vstr.buf;\n-    memset(data, 0, len);\n \n     #if MICROPY_LONGINT_IMPL != MICROPY_LONGINT_IMPL_NONE\n     if (!mp_obj_is_small_int(args[0])) {\n-        mp_obj_int_to_bytes_impl(args[0], big_endian, len, data);\n+        overflow = !mp_obj_int_to_bytes_impl(args[0], big_endian, dlen, data);\n     } else\n     #endif\n     {\n         mp_int_t val = MP_OBJ_SMALL_INT_VALUE(args[0]);\n-        size_t l = MIN((size_t)len, sizeof(val));\n-        mp_binary_set_int(l, big_endian, data + (big_endian ? (len - l) : 0), val);\n+        int slen = 0;  // Number of bytes to represent val\n+\n+        // This logic has a twin in objint_longlong.c\n+        if (val > 0) {\n+            slen = (sizeof(mp_int_t) * 8 - mp_clz_mpi(val) + 7) / 8;\n+        } else if (val < -1) {\n+            slen = (sizeof(mp_int_t) * 8 - mp_clz_mpi(~val) + 8) / 8;\n+        } else {\n+            // clz of 0 is defined, so 0 and -1 map to 0 and 1\n+            slen = -val;\n+        }\n+\n+        if (slen <= dlen) {\n+            memset(data, val < 0 ? 0xFF : 0x00, dlen);\n+            mp_binary_set_int(slen, big_endian, data + (big_endian ? (dlen - slen) : 0), val);\n+            overflow = false;\n+        } else {\n+            overflow = true;\n+        }\n+    }\n+\n+    if (overflow) {\n+        mp_raise_msg(&mp_type_OverflowError, MP_ERROR_TEXT(\"buffer too small\"));\n     }\n \n     return mp_obj_new_bytes_from_vstr(&vstr);\n```\n\nFilename: py/objint.h:\n```\n@@ -55,7 +55,8 @@\nchar *mp_obj_int_formatted_impl(char **buf, size_t *buf_size, size_t *fmt_size,\n     int base, const char *prefix, char base_char, char comma);\n mp_int_t mp_obj_int_hash(mp_obj_t self_in);\n mp_obj_t mp_obj_int_from_bytes_impl(bool big_endian, size_t len, const byte *buf);\n-void mp_obj_int_to_bytes_impl(mp_obj_t self_in, bool big_endian, size_t len, byte *buf);\n+// Returns true if 'self_in' fit into 'len' bytes of 'buf' without overflowing, 'buf' is truncated otherwise.\n+bool mp_obj_int_to_bytes_impl(mp_obj_t self_in, bool big_endian, size_t len, byte *buf);\n int mp_obj_int_sign(mp_obj_t self_in);\n mp_obj_t mp_obj_int_unary_op(mp_unary_op_t op, mp_obj_t o_in);\n mp_obj_t mp_obj_int_binary_op(mp_binary_op_t op, mp_obj_t lhs_in, mp_obj_t rhs_in);\n```\n\nFilename: py/objint_longlong.c:\n```\n@@ -57,10 +57,27 @@\nmp_obj_t mp_obj_int_from_bytes_impl(bool big_endian, size_t len, const byte *buf\n     return mp_obj_new_int_from_ll(value);\n }\n \n-void mp_obj_int_to_bytes_impl(mp_obj_t self_in, bool big_endian, size_t len, byte *buf) {\n+bool mp_obj_int_to_bytes_impl(mp_obj_t self_in, bool big_endian, size_t len, byte *buf) {\n     assert(mp_obj_is_exact_type(self_in, &mp_type_int));\n     mp_obj_int_t *self = self_in;\n     long long val = self->val;\n+    size_t slen; // Number of bytes to represent val\n+\n+    // This logic has a twin in objint.c\n+    if (val > 0) {\n+        slen = (sizeof(long long) * 8 - mp_clzll(val) + 7) / 8;\n+    } else if (val < -1) {\n+        slen = (sizeof(long long) * 8 - mp_clzll(~val) + 8) / 8;\n+    } else {\n+        // clz of 0 is defined, so 0 and -1 map to 0 and 1\n+        slen = -val;\n+    }\n+\n+    if (slen > len) {\n+        return false; // Would overflow\n+        // TODO: Determine whether to copy and truncate, as some callers probably expect this...?\n+    }\n+\n     if (big_endian) {\n         byte *b = buf + len;\n         while (b > buf) {\n\n@@ -73,6 +90,7 @@\nvoid mp_obj_int_to_bytes_impl(mp_obj_t self_in, bool big_endian, size_t len, byt\n             val >>= 8;\n         }\n     }\n+    return true;\n }\n \n int mp_obj_int_sign(mp_obj_t self_in) {\n```\n\nFilename: py/objint_mpz.c:\n```\n@@ -112,10 +112,10 @@\nmp_obj_t mp_obj_int_from_bytes_impl(bool big_endian, size_t len, const byte *buf\n     return MP_OBJ_FROM_PTR(o);\n }\n \n-void mp_obj_int_to_bytes_impl(mp_obj_t self_in, bool big_endian, size_t len, byte *buf) {\n+bool mp_obj_int_to_bytes_impl(mp_obj_t self_in, bool big_endian, size_t len, byte *buf) {\n     assert(mp_obj_is_exact_type(self_in, &mp_type_int));\n     mp_obj_int_t *self = MP_OBJ_TO_PTR(self_in);\n-    mpz_as_bytes(&self->mpz, big_endian, len, buf);\n+    return mpz_as_bytes(&self->mpz, big_endian, self->mpz.neg, len, buf);\n }\n \n int mp_obj_int_sign(mp_obj_t self_in) {\n```\n\nFilename: tests/basics/int_bytes.py:\n```\n@@ -1,3 +1,5 @@\n+import sys\n+\n print((10).to_bytes(1, \"little\"))\n print((111111).to_bytes(4, \"little\"))\n print((100).to_bytes(10, \"little\"))\n\n@@ -20,3 +22,74 @@\n(1).to_bytes(-1, \"little\")\n except ValueError:\n     print(\"ValueError\")\n+\n+# zero byte destination should also raise an error\n+try:\n+    (1).to_bytes(0, \"little\")\n+except OverflowError:\n+    print(\"OverflowError\")\n+\n+# except for converting 0 to a zero-length byte array\n+print((0).to_bytes(0, \"big\"))\n+\n+# byte length can fit the integer directly\n+print((0xFF).to_bytes(1, \"little\"))\n+print((0xFF).to_bytes(1, \"big\"))\n+print((0xEFF).to_bytes(2, \"little\"))\n+print((0xEFF).to_bytes(2, \"big\"))\n+print((0xCDEFF).to_bytes(3, \"little\"))\n+print((0xCDEFF).to_bytes(3, \"big\"))\n+\n+# OverFlowError if not big enough\n+\n+try:\n+    (0x123).to_bytes(1, \"big\")\n+except OverflowError:\n+    print(\"OverflowError\")\n+\n+try:\n+    (0x12345).to_bytes(2, \"big\")\n+except OverflowError:\n+    print(\"OverflowError\")\n+\n+try:\n+    (0x1234567).to_bytes(3, \"big\")\n+except OverflowError:\n+    print(\"OverflowError\")\n+\n+\n+# negative representations\n+\n+# MicroPython int.to_bytes() behaves as if signed=True for negative numbers\n+if \"micropython\" in repr(sys.implementation):\n+\n+    def to_bytes_compat(i, l, e):\n+        return i.to_bytes(l, e)\n+else:\n+    # Implement MicroPython compatible behaviour for CPython\n+    def to_bytes_compat(i, l, e):\n+        return i.to_bytes(l, e, signed=i < 0)\n+\n+\n+print(to_bytes_compat(-1, 1, \"little\"))\n+print(to_bytes_compat(-1, 3, \"little\"))\n+print(to_bytes_compat(-1, 1, \"big\"))\n+print(to_bytes_compat(-1, 3, \"big\"))\n+print(to_bytes_compat(-128, 1, \"big\"))\n+print(to_bytes_compat(-32768, 2, \"big\"))\n+print(to_bytes_compat(-(1 << 23), 3, \"big\"))\n+\n+try:\n+    print(to_bytes_compat(-129, 1, \"big\"))\n+except OverflowError:\n+    print(\"OverflowError\")\n+\n+try:\n+    print(to_bytes_compat(-32769, 2, \"big\"))\n+except OverflowError:\n+    print(\"OverflowError\")\n+\n+try:\n+    print(to_bytes_compat(-(1 << 23) - 1, 2, \"big\"))\n+except OverflowError:\n+    print(\"OverflowError\")\n```\n\nFilename: tests/basics/int_bytes_int64.py:\n```\n@@ -0,0 +1,52 @@\n+import sys\n+\n+# Depending on the port, the numbers in this test may be implemented as \"small\"\n+# native 64 bit ints, arbitrary precision large ints, or large integers using 64-bit\n+# long longs.\n+\n+try:\n+    x = int.from_bytes(b\"\\x6F\\xAB\\xCD\\x12\\x34\\x56\\x78\\xFB\", \"big\")\n+except OverflowError:\n+    print(\"SKIP\")  # Port can't represent this size of integer at all\n+    raise SystemExit\n+\n+print(hex(x))\n+b = x.to_bytes(8, \"little\")\n+print(b)\n+print(x.to_bytes(8, \"big\"))\n+\n+# padding in output\n+print(x.to_bytes(20, \"little\"))\n+print(x.to_bytes(20, \"big\"))\n+\n+# check that extra zero bytes don't change the internal int value\n+print(int.from_bytes(b + bytes(10), \"little\") == x)\n+\n+# can't write to a zero-length bytes object\n+try:\n+    x.to_bytes(0, \"little\")\n+except OverflowError:\n+    print(\"OverflowError\")\n+\n+# or one that it too short\n+try:\n+    x.to_bytes(7, \"big\")\n+except OverflowError:\n+    print(\"OverflowError\")\n+\n+# negative representations\n+\n+# MicroPython int.to_bytes() behaves as if signed=True for negative numbers\n+if \"micropython\" in repr(sys.implementation):\n+\n+    def to_bytes_compat(i, l, e):\n+        return i.to_bytes(l, e)\n+else:\n+    # Implement MicroPython compatible behaviour for CPython\n+    def to_bytes_compat(i, l, e):\n+        return i.to_bytes(l, e, signed=i < 0)\n+\n+\n+print(to_bytes_compat(-x, 8, \"little\"))\n+print(to_bytes_compat(-x, 20, \"big\"))\n+print(to_bytes_compat(-x, 20, \"little\"))\n```\n\nFilename: tests/basics/int_bytes_intbig.py:\n```\n@@ -1,3 +1,5 @@\n+import sys\n+\n print((2**64).to_bytes(9, \"little\"))\n print((2**64).to_bytes(9, \"big\"))\n\n@@ -10,5 +12,51 @@\nprint(il.to_bytes(20, \"little\"))\n print(ib.to_bytes(20, \"big\"))\n \n+# check padding comes out correctly\n+print(il.to_bytes(40, \"little\"))\n+print(ib.to_bytes(40, \"big\"))\n+\n # check that extra zero bytes don't change the internal int value\n print(int.from_bytes(b + bytes(10), \"little\") == int.from_bytes(b, \"little\"))\n+\n+# can't write to a zero-length bytes object\n+try:\n+    ib.to_bytes(0, \"little\")\n+except OverflowError:\n+    print(\"OverflowError\")\n+\n+# or one that it too short\n+try:\n+    ib.to_bytes(18, \"big\")\n+except OverflowError:\n+    print(\"OverflowError\")\n+\n+# negative representations\n+\n+# MicroPython int.to_bytes() behaves as if signed=True for negative numbers\n+if \"micropython\" in repr(sys.implementation):\n+\n+    def to_bytes_compat(i, l, e):\n+        return i.to_bytes(l, e)\n+else:\n+    # Implement MicroPython compatible behaviour for CPython\n+    def to_bytes_compat(i, l, e):\n+        return i.to_bytes(l, e, signed=i < 0)\n+\n+\n+print(to_bytes_compat(-ib, 20, \"big\"))\n+print(to_bytes_compat(ib * -ib, 40, \"big\"))\n+\n+# case where an additional byte is needed for sign bit\n+ib = (2**64) - 1\n+print(ib.to_bytes(8, \"little\"))\n+\n+ib *= -1\n+\n+try:\n+    print(to_bytes_compat(ib, 8, \"little\"))\n+except OverflowError:\n+    print(\"OverflowError\")\n+\n+print(to_bytes_compat(ib, 9, \"little\"))\n+print(to_bytes_compat(ib, 9, \"big\"))\n```\n\nFilename: tests/cpydiff/types_int_to_bytes.py:\n```\n@@ -0,0 +1,16 @@\n+\"\"\"\n+categories: Types,int\n+description: ``to_bytes`` method doesn't implement signed parameter.\n+cause: The ``signed`` keyword-only parameter is not implemented for ``int.to_bytes()``.\n+\n+When the integer is negative, MicroPython behaves the same as CPython ``int.to_bytes(..., signed=True)``\n+\n+When the integer is non-negative, MicroPython behaves the same as CPython ``int.to_bytes(..., signed=False)``.\n+\n+(The difference is subtle, but in CPython a positive integer converted with ``signed=True`` may require one byte more in the output length, in order to fit the 0 sign bit.)\n+\n+workaround: Take care when calling ``to_bytes()`` on an integer value which may be negative.\n+\"\"\"\n+\n+x = -1\n+print(x.to_bytes(1, \"big\"))\n```"
            }
        ],
        "sw_version": "v1.23.0",
        "sw_version_wget": "https://github.com/micropython/micropython/archive/refs/tags/v1.23.0.zip",
        "description": "A vulnerability was found in MicroPython 1.23.0. It has been rated as critical. Affected by this issue is the function mpz_as_bytes of the file py/objint.c. The manipulation leads to heap-based buffer overflow. The attack may be launched remotely. The exploit has been disclosed to the public and may be used. The patch is identified as 908ab1ceca15ee6fd0ef82ca4cba770a3ec41894. It is recommended to apply a patch to fix this issue. In micropython objint component, converting zero from int to bytes leads to heap buffer-overflow-write at mpz_as_bytes.",
        "sec_adv": [],
        "cwe": [
            {
                "id": "CWE-122",
                "value": "Heap-based Buffer Overflow"
            }
        ]
    }
}