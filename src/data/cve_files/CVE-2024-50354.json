{
    "CVE-2024-50354": {
        "published_date": "2024-10-31T15:59:30.063Z",
        "patch_commits": [
            {
                "url": "https://github.com/Consensys/gnark/commit/47ae846339add2bdf9983e499342bfdfe195191d",
                "content": "fix: sanitize groth16 verification key reading (#1307)\n\nFilename: backend/groth16/bls12-377/marshal.go:\n```\n@@ -22,6 +22,8 @@\nimport (\n \t\"github.com/consensys/gnark-crypto/ecc/bls12-377/fr/pedersen\"\n \t\"github.com/consensys/gnark-crypto/utils/unsafe\"\n \t\"github.com/consensys/gnark/internal/utils\"\n+\n+\t\"fmt\"\n \t\"io\"\n )\n\n@@ -196,35 +198,39 @@\nfunc (vk *VerifyingKey) readFrom(r io.Reader, raw bool) (int64, error) {\n \t\t&nbCommitments,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn dec.BytesRead(), err\n+\t\t\treturn dec.BytesRead(), fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \n \tvk.PublicAndCommitmentCommitted = utils.Uint64SliceSliceToIntSliceSlice(publicCommitted)\n \n-\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, nbCommitments)\n \tvar n int64\n-\tfor i := range vk.CommitmentKeys {\n+\tfor i := 0; i < int(nbCommitments); i++ {\n \t\tvar (\n \t\t\tm   int64\n \t\t\terr error\n \t\t)\n+\t\tcommitmentKey := pedersen.VerifyingKey{}\n \t\tif raw {\n-\t\t\tm, err = vk.CommitmentKeys[i].UnsafeReadFrom(r)\n+\t\t\tm, err = commitmentKey.UnsafeReadFrom(r)\n \t\t} else {\n-\t\t\tm, err = vk.CommitmentKeys[i].ReadFrom(r)\n+\t\t\tm, err = commitmentKey.ReadFrom(r)\n \t\t}\n \t\tn += m\n \t\tif err != nil {\n-\t\t\treturn n + dec.BytesRead(), err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read commitment key %d: %w\", i, err)\n \t\t}\n+\t\tvk.CommitmentKeys = append(vk.CommitmentKeys, commitmentKey)\n+\t}\n+\tif len(vk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(vk.CommitmentKeys))\n \t}\n \n \t// recompute vk.e (e(α, β)) and  -[δ]2, -[γ]2\n \tif err := vk.Precompute(); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"precompute: %w\", err)\n \t}\n \n \treturn n + dec.BytesRead(), nil\n\n@@ -320,7 +326,7 @@\nfunc (pk *ProvingKey) UnsafeReadFrom(r io.Reader) (int64, error) {\n func (pk *ProvingKey) readFrom(r io.Reader, decOptions ...func(*curve.Decoder)) (int64, error) {\n \tn, err := pk.Domain.ReadFrom(r)\n \tif err != nil {\n-\t\treturn n, err\n+\t\treturn n, fmt.Errorf(\"read domain: %w\", err)\n \t}\n \n \tdec := curve.NewDecoder(r, decOptions...)\n\n@@ -344,31 +350,34 @@\nfunc (pk *ProvingKey) readFrom(r io.Reader, decOptions ...func(*curve.Decoder))\n \t\t&pk.NbInfinityB,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn n + dec.BytesRead(), err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \tpk.InfinityA = make([]bool, nbWires)\n \tpk.InfinityB = make([]bool, nbWires)\n \n \tif err := dec.Decode(&pk.InfinityA); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read InfinityA: %w\", err)\n \t}\n \tif err := dec.Decode(&pk.InfinityB); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read InfinityB: %w\", err)\n \t}\n \tif err := dec.Decode(&nbCommitments); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read nbCommitments: %w\", err)\n \t}\n-\n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitments)\n-\tfor i := range pk.CommitmentKeys {\n-\t\tn2, err := pk.CommitmentKeys[i].ReadFrom(r)\n+\tfor i := 0; i < int(nbCommitments); i++ {\n+\t\tcpkey := pedersen.ProvingKey{}\n+\t\tn2, err := cpkey.ReadFrom(r)\n \t\tn += n2\n \t\tif err != nil {\n-\t\t\treturn n, err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read commitment key %d: %w\", i, err)\n \t\t}\n+\t\tpk.CommitmentKeys = append(pk.CommitmentKeys, cpkey)\n+\t}\n+\tif len(pk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(pk.CommitmentKeys))\n \t}\n \n \treturn n + dec.BytesRead(), nil\n\n@@ -451,11 +460,11 @@\nfunc (pk *ProvingKey) WriteDump(w io.Writer) error {\n func (pk *ProvingKey) ReadDump(r io.Reader) error {\n \t// read the marker to fail early in case of malformed input\n \tif err := unsafe.ReadMarker(r); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read marker: %w\", err)\n \t}\n \n \tif _, err := pk.Domain.ReadFrom(r); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read domain: %w\", err)\n \t}\n \n \tdec := curve.NewDecoder(r, curve.NoSubgroupChecks())\n\n@@ -479,57 +488,61 @@\nfunc (pk *ProvingKey) ReadDump(r io.Reader) error {\n \t\t&pk.NbInfinityB,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \tpk.InfinityA = make([]bool, nbWires)\n \tpk.InfinityB = make([]bool, nbWires)\n \n \tif err := dec.Decode(&pk.InfinityA); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read InfinityA: %w\", err)\n \t}\n \tif err := dec.Decode(&pk.InfinityB); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read InfinityB: %w\", err)\n \t}\n \tif err := dec.Decode(&nbCommitments); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read nbCommitments: %w\", err)\n \t}\n \n \t// read slices of points\n \tvar err error\n \tpk.G1.A, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.A: %w\", err)\n \t}\n \tpk.G1.B, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.B: %w\", err)\n \t}\n \tpk.G1.Z, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.Z: %w\", err)\n \t}\n \tpk.G1.K, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.K: %w\", err)\n \t}\n \tpk.G2.B, _, err = unsafe.ReadSlice[[]curve.G2Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G2.B: %w\", err)\n \t}\n \n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitments)\n-\tfor i := range pk.CommitmentKeys {\n-\t\tpk.CommitmentKeys[i].Basis, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n+\tfor i := 0; i < int(nbCommitments); i++ {\n+\t\tcpkey := pedersen.ProvingKey{}\n+\t\tcpkey.Basis, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \t\tif err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read commitment basis %d: %w\", i, err)\n \t\t}\n-\t\tpk.CommitmentKeys[i].BasisExpSigma, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n+\t\tcpkey.BasisExpSigma, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \t\tif err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read commitment basisExpSigma %d: %w\", i, err)\n \t\t}\n+\t\tpk.CommitmentKeys = append(pk.CommitmentKeys, cpkey)\n+\t}\n+\tif len(pk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(pk.CommitmentKeys))\n \t}\n \n \treturn nil\n```\n\nFilename: backend/groth16/bls12-377/marshal_test.go:\n```\n@@ -98,7 +98,6 @@\nfunc TestVerifyingKeySerialization(t *testing.T) {\n \t\t\t\tvk.G1.K[i] = p1\n \t\t\t}\n \n-\t\t\tvk.CommitmentKeys = []pedersen.VerifyingKey{}\n \t\t\tif withCommitment {\n \t\t\t\tvk.PublicAndCommitmentCommitted = test_utils.Random2DIntSlice(5, 10) // TODO: Use gopter randomization\n \t\t\t\tbases := make([][]curve.G1Affine, len(vk.PublicAndCommitmentCommitted))\n\n@@ -175,17 +174,18 @@\nfunc TestProvingKeySerialization(t *testing.T) {\n \t\t\tpk.InfinityB = make([]bool, nbWires)\n \t\t\tpk.InfinityA[2] = true\n \n-\t\t\tpedersenBasis := make([]curve.G1Affine, nbCommitment)\n-\t\t\tpedersenBases := make([][]curve.G1Affine, nbCommitment)\n-\t\t\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitment)\n-\t\t\tfor i := range pedersenBasis {\n-\t\t\t\tpedersenBasis[i] = p1\n-\t\t\t\tpedersenBases[i] = pedersenBasis[:i+1]\n-\t\t\t}\n-\t\t\t{\n-\t\t\t\tvar err error\n-\t\t\t\tpk.CommitmentKeys, _, err = pedersen.Setup(pedersenBases)\n-\t\t\t\trequire.NoError(t, err)\n+\t\t\tif nbCommitment > 0 {\n+\t\t\t\tpedersenBasis := make([]curve.G1Affine, nbCommitment)\n+\t\t\t\tpedersenBases := make([][]curve.G1Affine, nbCommitment)\n+\t\t\t\tfor i := range pedersenBasis {\n+\t\t\t\t\tpedersenBasis[i] = p1\n+\t\t\t\t\tpedersenBases[i] = pedersenBasis[:i+1]\n+\t\t\t\t}\n+\t\t\t\t{\n+\t\t\t\t\tvar err error\n+\t\t\t\t\tpk.CommitmentKeys, _, err = pedersen.Setup(pedersenBases)\n+\t\t\t\t\trequire.NoError(t, err)\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tif err := io.RoundTripCheck(&pk, func() any { return new(ProvingKey) }); err != nil {\n```\n\nFilename: backend/groth16/bls12-377/setup.go:\n```\n@@ -291,8 +291,10 @@\nfunc Setup(r1cs *cs.R1CS, pk *ProvingKey, vk *VerifyingKey) error {\n \tif err != nil {\n \t\treturn err\n \t}\n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, len(commitmentBases))\n-\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, len(commitmentBases))\n+\tif len(commitmentBases) > 0 {\n+\t\tpk.CommitmentKeys = make([]pedersen.ProvingKey, len(commitmentBases))\n+\t\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, len(commitmentBases))\n+\t}\n \tfor i := range commitmentBases {\n \t\tcomPKey, comVKey, err := pedersen.Setup(commitmentBases[i:i+1], pedersen.WithG2Point(cG2))\n \t\tif err != nil {\n```\n\nFilename: backend/groth16/bls12-381/marshal.go:\n```\n@@ -22,6 +22,8 @@\nimport (\n \t\"github.com/consensys/gnark-crypto/ecc/bls12-381/fr/pedersen\"\n \t\"github.com/consensys/gnark-crypto/utils/unsafe\"\n \t\"github.com/consensys/gnark/internal/utils\"\n+\n+\t\"fmt\"\n \t\"io\"\n )\n\n@@ -196,35 +198,39 @@\nfunc (vk *VerifyingKey) readFrom(r io.Reader, raw bool) (int64, error) {\n \t\t&nbCommitments,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn dec.BytesRead(), err\n+\t\t\treturn dec.BytesRead(), fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \n \tvk.PublicAndCommitmentCommitted = utils.Uint64SliceSliceToIntSliceSlice(publicCommitted)\n \n-\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, nbCommitments)\n \tvar n int64\n-\tfor i := range vk.CommitmentKeys {\n+\tfor i := 0; i < int(nbCommitments); i++ {\n \t\tvar (\n \t\t\tm   int64\n \t\t\terr error\n \t\t)\n+\t\tcommitmentKey := pedersen.VerifyingKey{}\n \t\tif raw {\n-\t\t\tm, err = vk.CommitmentKeys[i].UnsafeReadFrom(r)\n+\t\t\tm, err = commitmentKey.UnsafeReadFrom(r)\n \t\t} else {\n-\t\t\tm, err = vk.CommitmentKeys[i].ReadFrom(r)\n+\t\t\tm, err = commitmentKey.ReadFrom(r)\n \t\t}\n \t\tn += m\n \t\tif err != nil {\n-\t\t\treturn n + dec.BytesRead(), err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read commitment key %d: %w\", i, err)\n \t\t}\n+\t\tvk.CommitmentKeys = append(vk.CommitmentKeys, commitmentKey)\n+\t}\n+\tif len(vk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(vk.CommitmentKeys))\n \t}\n \n \t// recompute vk.e (e(α, β)) and  -[δ]2, -[γ]2\n \tif err := vk.Precompute(); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"precompute: %w\", err)\n \t}\n \n \treturn n + dec.BytesRead(), nil\n\n@@ -320,7 +326,7 @@\nfunc (pk *ProvingKey) UnsafeReadFrom(r io.Reader) (int64, error) {\n func (pk *ProvingKey) readFrom(r io.Reader, decOptions ...func(*curve.Decoder)) (int64, error) {\n \tn, err := pk.Domain.ReadFrom(r)\n \tif err != nil {\n-\t\treturn n, err\n+\t\treturn n, fmt.Errorf(\"read domain: %w\", err)\n \t}\n \n \tdec := curve.NewDecoder(r, decOptions...)\n\n@@ -344,31 +350,34 @@\nfunc (pk *ProvingKey) readFrom(r io.Reader, decOptions ...func(*curve.Decoder))\n \t\t&pk.NbInfinityB,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn n + dec.BytesRead(), err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \tpk.InfinityA = make([]bool, nbWires)\n \tpk.InfinityB = make([]bool, nbWires)\n \n \tif err := dec.Decode(&pk.InfinityA); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read InfinityA: %w\", err)\n \t}\n \tif err := dec.Decode(&pk.InfinityB); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read InfinityB: %w\", err)\n \t}\n \tif err := dec.Decode(&nbCommitments); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read nbCommitments: %w\", err)\n \t}\n-\n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitments)\n-\tfor i := range pk.CommitmentKeys {\n-\t\tn2, err := pk.CommitmentKeys[i].ReadFrom(r)\n+\tfor i := 0; i < int(nbCommitments); i++ {\n+\t\tcpkey := pedersen.ProvingKey{}\n+\t\tn2, err := cpkey.ReadFrom(r)\n \t\tn += n2\n \t\tif err != nil {\n-\t\t\treturn n, err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read commitment key %d: %w\", i, err)\n \t\t}\n+\t\tpk.CommitmentKeys = append(pk.CommitmentKeys, cpkey)\n+\t}\n+\tif len(pk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(pk.CommitmentKeys))\n \t}\n \n \treturn n + dec.BytesRead(), nil\n\n@@ -451,11 +460,11 @@\nfunc (pk *ProvingKey) WriteDump(w io.Writer) error {\n func (pk *ProvingKey) ReadDump(r io.Reader) error {\n \t// read the marker to fail early in case of malformed input\n \tif err := unsafe.ReadMarker(r); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read marker: %w\", err)\n \t}\n \n \tif _, err := pk.Domain.ReadFrom(r); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read domain: %w\", err)\n \t}\n \n \tdec := curve.NewDecoder(r, curve.NoSubgroupChecks())\n\n@@ -479,57 +488,61 @@\nfunc (pk *ProvingKey) ReadDump(r io.Reader) error {\n \t\t&pk.NbInfinityB,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \tpk.InfinityA = make([]bool, nbWires)\n \tpk.InfinityB = make([]bool, nbWires)\n \n \tif err := dec.Decode(&pk.InfinityA); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read InfinityA: %w\", err)\n \t}\n \tif err := dec.Decode(&pk.InfinityB); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read InfinityB: %w\", err)\n \t}\n \tif err := dec.Decode(&nbCommitments); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read nbCommitments: %w\", err)\n \t}\n \n \t// read slices of points\n \tvar err error\n \tpk.G1.A, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.A: %w\", err)\n \t}\n \tpk.G1.B, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.B: %w\", err)\n \t}\n \tpk.G1.Z, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.Z: %w\", err)\n \t}\n \tpk.G1.K, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.K: %w\", err)\n \t}\n \tpk.G2.B, _, err = unsafe.ReadSlice[[]curve.G2Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G2.B: %w\", err)\n \t}\n \n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitments)\n-\tfor i := range pk.CommitmentKeys {\n-\t\tpk.CommitmentKeys[i].Basis, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n+\tfor i := 0; i < int(nbCommitments); i++ {\n+\t\tcpkey := pedersen.ProvingKey{}\n+\t\tcpkey.Basis, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \t\tif err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read commitment basis %d: %w\", i, err)\n \t\t}\n-\t\tpk.CommitmentKeys[i].BasisExpSigma, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n+\t\tcpkey.BasisExpSigma, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \t\tif err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read commitment basisExpSigma %d: %w\", i, err)\n \t\t}\n+\t\tpk.CommitmentKeys = append(pk.CommitmentKeys, cpkey)\n+\t}\n+\tif len(pk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(pk.CommitmentKeys))\n \t}\n \n \treturn nil\n```\n\nFilename: backend/groth16/bls12-381/marshal_test.go:\n```\n@@ -98,7 +98,6 @@\nfunc TestVerifyingKeySerialization(t *testing.T) {\n \t\t\t\tvk.G1.K[i] = p1\n \t\t\t}\n \n-\t\t\tvk.CommitmentKeys = []pedersen.VerifyingKey{}\n \t\t\tif withCommitment {\n \t\t\t\tvk.PublicAndCommitmentCommitted = test_utils.Random2DIntSlice(5, 10) // TODO: Use gopter randomization\n \t\t\t\tbases := make([][]curve.G1Affine, len(vk.PublicAndCommitmentCommitted))\n\n@@ -175,17 +174,18 @@\nfunc TestProvingKeySerialization(t *testing.T) {\n \t\t\tpk.InfinityB = make([]bool, nbWires)\n \t\t\tpk.InfinityA[2] = true\n \n-\t\t\tpedersenBasis := make([]curve.G1Affine, nbCommitment)\n-\t\t\tpedersenBases := make([][]curve.G1Affine, nbCommitment)\n-\t\t\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitment)\n-\t\t\tfor i := range pedersenBasis {\n-\t\t\t\tpedersenBasis[i] = p1\n-\t\t\t\tpedersenBases[i] = pedersenBasis[:i+1]\n-\t\t\t}\n-\t\t\t{\n-\t\t\t\tvar err error\n-\t\t\t\tpk.CommitmentKeys, _, err = pedersen.Setup(pedersenBases)\n-\t\t\t\trequire.NoError(t, err)\n+\t\t\tif nbCommitment > 0 {\n+\t\t\t\tpedersenBasis := make([]curve.G1Affine, nbCommitment)\n+\t\t\t\tpedersenBases := make([][]curve.G1Affine, nbCommitment)\n+\t\t\t\tfor i := range pedersenBasis {\n+\t\t\t\t\tpedersenBasis[i] = p1\n+\t\t\t\t\tpedersenBases[i] = pedersenBasis[:i+1]\n+\t\t\t\t}\n+\t\t\t\t{\n+\t\t\t\t\tvar err error\n+\t\t\t\t\tpk.CommitmentKeys, _, err = pedersen.Setup(pedersenBases)\n+\t\t\t\t\trequire.NoError(t, err)\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tif err := io.RoundTripCheck(&pk, func() any { return new(ProvingKey) }); err != nil {\n```\n\nFilename: backend/groth16/bls12-381/setup.go:\n```\n@@ -291,8 +291,10 @@\nfunc Setup(r1cs *cs.R1CS, pk *ProvingKey, vk *VerifyingKey) error {\n \tif err != nil {\n \t\treturn err\n \t}\n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, len(commitmentBases))\n-\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, len(commitmentBases))\n+\tif len(commitmentBases) > 0 {\n+\t\tpk.CommitmentKeys = make([]pedersen.ProvingKey, len(commitmentBases))\n+\t\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, len(commitmentBases))\n+\t}\n \tfor i := range commitmentBases {\n \t\tcomPKey, comVKey, err := pedersen.Setup(commitmentBases[i:i+1], pedersen.WithG2Point(cG2))\n \t\tif err != nil {\n```\n\nFilename: backend/groth16/bls24-315/marshal.go:\n```\n@@ -22,6 +22,8 @@\nimport (\n \t\"github.com/consensys/gnark-crypto/ecc/bls24-315/fr/pedersen\"\n \t\"github.com/consensys/gnark-crypto/utils/unsafe\"\n \t\"github.com/consensys/gnark/internal/utils\"\n+\n+\t\"fmt\"\n \t\"io\"\n )\n\n@@ -196,35 +198,39 @@\nfunc (vk *VerifyingKey) readFrom(r io.Reader, raw bool) (int64, error) {\n \t\t&nbCommitments,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn dec.BytesRead(), err\n+\t\t\treturn dec.BytesRead(), fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \n \tvk.PublicAndCommitmentCommitted = utils.Uint64SliceSliceToIntSliceSlice(publicCommitted)\n \n-\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, nbCommitments)\n \tvar n int64\n-\tfor i := range vk.CommitmentKeys {\n+\tfor i := 0; i < int(nbCommitments); i++ {\n \t\tvar (\n \t\t\tm   int64\n \t\t\terr error\n \t\t)\n+\t\tcommitmentKey := pedersen.VerifyingKey{}\n \t\tif raw {\n-\t\t\tm, err = vk.CommitmentKeys[i].UnsafeReadFrom(r)\n+\t\t\tm, err = commitmentKey.UnsafeReadFrom(r)\n \t\t} else {\n-\t\t\tm, err = vk.CommitmentKeys[i].ReadFrom(r)\n+\t\t\tm, err = commitmentKey.ReadFrom(r)\n \t\t}\n \t\tn += m\n \t\tif err != nil {\n-\t\t\treturn n + dec.BytesRead(), err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read commitment key %d: %w\", i, err)\n \t\t}\n+\t\tvk.CommitmentKeys = append(vk.CommitmentKeys, commitmentKey)\n+\t}\n+\tif len(vk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(vk.CommitmentKeys))\n \t}\n \n \t// recompute vk.e (e(α, β)) and  -[δ]2, -[γ]2\n \tif err := vk.Precompute(); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"precompute: %w\", err)\n \t}\n \n \treturn n + dec.BytesRead(), nil\n\n@@ -320,7 +326,7 @@\nfunc (pk *ProvingKey) UnsafeReadFrom(r io.Reader) (int64, error) {\n func (pk *ProvingKey) readFrom(r io.Reader, decOptions ...func(*curve.Decoder)) (int64, error) {\n \tn, err := pk.Domain.ReadFrom(r)\n \tif err != nil {\n-\t\treturn n, err\n+\t\treturn n, fmt.Errorf(\"read domain: %w\", err)\n \t}\n \n \tdec := curve.NewDecoder(r, decOptions...)\n\n@@ -344,31 +350,34 @@\nfunc (pk *ProvingKey) readFrom(r io.Reader, decOptions ...func(*curve.Decoder))\n \t\t&pk.NbInfinityB,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn n + dec.BytesRead(), err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \tpk.InfinityA = make([]bool, nbWires)\n \tpk.InfinityB = make([]bool, nbWires)\n \n \tif err := dec.Decode(&pk.InfinityA); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read InfinityA: %w\", err)\n \t}\n \tif err := dec.Decode(&pk.InfinityB); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read InfinityB: %w\", err)\n \t}\n \tif err := dec.Decode(&nbCommitments); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read nbCommitments: %w\", err)\n \t}\n-\n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitments)\n-\tfor i := range pk.CommitmentKeys {\n-\t\tn2, err := pk.CommitmentKeys[i].ReadFrom(r)\n+\tfor i := 0; i < int(nbCommitments); i++ {\n+\t\tcpkey := pedersen.ProvingKey{}\n+\t\tn2, err := cpkey.ReadFrom(r)\n \t\tn += n2\n \t\tif err != nil {\n-\t\t\treturn n, err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read commitment key %d: %w\", i, err)\n \t\t}\n+\t\tpk.CommitmentKeys = append(pk.CommitmentKeys, cpkey)\n+\t}\n+\tif len(pk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(pk.CommitmentKeys))\n \t}\n \n \treturn n + dec.BytesRead(), nil\n\n@@ -451,11 +460,11 @@\nfunc (pk *ProvingKey) WriteDump(w io.Writer) error {\n func (pk *ProvingKey) ReadDump(r io.Reader) error {\n \t// read the marker to fail early in case of malformed input\n \tif err := unsafe.ReadMarker(r); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read marker: %w\", err)\n \t}\n \n \tif _, err := pk.Domain.ReadFrom(r); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read domain: %w\", err)\n \t}\n \n \tdec := curve.NewDecoder(r, curve.NoSubgroupChecks())\n\n@@ -479,57 +488,61 @@\nfunc (pk *ProvingKey) ReadDump(r io.Reader) error {\n \t\t&pk.NbInfinityB,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \tpk.InfinityA = make([]bool, nbWires)\n \tpk.InfinityB = make([]bool, nbWires)\n \n \tif err := dec.Decode(&pk.InfinityA); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read InfinityA: %w\", err)\n \t}\n \tif err := dec.Decode(&pk.InfinityB); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read InfinityB: %w\", err)\n \t}\n \tif err := dec.Decode(&nbCommitments); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read nbCommitments: %w\", err)\n \t}\n \n \t// read slices of points\n \tvar err error\n \tpk.G1.A, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.A: %w\", err)\n \t}\n \tpk.G1.B, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.B: %w\", err)\n \t}\n \tpk.G1.Z, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.Z: %w\", err)\n \t}\n \tpk.G1.K, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.K: %w\", err)\n \t}\n \tpk.G2.B, _, err = unsafe.ReadSlice[[]curve.G2Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G2.B: %w\", err)\n \t}\n \n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitments)\n-\tfor i := range pk.CommitmentKeys {\n-\t\tpk.CommitmentKeys[i].Basis, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n+\tfor i := 0; i < int(nbCommitments); i++ {\n+\t\tcpkey := pedersen.ProvingKey{}\n+\t\tcpkey.Basis, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \t\tif err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read commitment basis %d: %w\", i, err)\n \t\t}\n-\t\tpk.CommitmentKeys[i].BasisExpSigma, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n+\t\tcpkey.BasisExpSigma, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \t\tif err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read commitment basisExpSigma %d: %w\", i, err)\n \t\t}\n+\t\tpk.CommitmentKeys = append(pk.CommitmentKeys, cpkey)\n+\t}\n+\tif len(pk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(pk.CommitmentKeys))\n \t}\n \n \treturn nil\n```\n\nFilename: backend/groth16/bls24-315/marshal_test.go:\n```\n@@ -98,7 +98,6 @@\nfunc TestVerifyingKeySerialization(t *testing.T) {\n \t\t\t\tvk.G1.K[i] = p1\n \t\t\t}\n \n-\t\t\tvk.CommitmentKeys = []pedersen.VerifyingKey{}\n \t\t\tif withCommitment {\n \t\t\t\tvk.PublicAndCommitmentCommitted = test_utils.Random2DIntSlice(5, 10) // TODO: Use gopter randomization\n \t\t\t\tbases := make([][]curve.G1Affine, len(vk.PublicAndCommitmentCommitted))\n\n@@ -175,17 +174,18 @@\nfunc TestProvingKeySerialization(t *testing.T) {\n \t\t\tpk.InfinityB = make([]bool, nbWires)\n \t\t\tpk.InfinityA[2] = true\n \n-\t\t\tpedersenBasis := make([]curve.G1Affine, nbCommitment)\n-\t\t\tpedersenBases := make([][]curve.G1Affine, nbCommitment)\n-\t\t\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitment)\n-\t\t\tfor i := range pedersenBasis {\n-\t\t\t\tpedersenBasis[i] = p1\n-\t\t\t\tpedersenBases[i] = pedersenBasis[:i+1]\n-\t\t\t}\n-\t\t\t{\n-\t\t\t\tvar err error\n-\t\t\t\tpk.CommitmentKeys, _, err = pedersen.Setup(pedersenBases)\n-\t\t\t\trequire.NoError(t, err)\n+\t\t\tif nbCommitment > 0 {\n+\t\t\t\tpedersenBasis := make([]curve.G1Affine, nbCommitment)\n+\t\t\t\tpedersenBases := make([][]curve.G1Affine, nbCommitment)\n+\t\t\t\tfor i := range pedersenBasis {\n+\t\t\t\t\tpedersenBasis[i] = p1\n+\t\t\t\t\tpedersenBases[i] = pedersenBasis[:i+1]\n+\t\t\t\t}\n+\t\t\t\t{\n+\t\t\t\t\tvar err error\n+\t\t\t\t\tpk.CommitmentKeys, _, err = pedersen.Setup(pedersenBases)\n+\t\t\t\t\trequire.NoError(t, err)\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tif err := io.RoundTripCheck(&pk, func() any { return new(ProvingKey) }); err != nil {\n```\n\nFilename: backend/groth16/bls24-315/setup.go:\n```\n@@ -291,8 +291,10 @@\nfunc Setup(r1cs *cs.R1CS, pk *ProvingKey, vk *VerifyingKey) error {\n \tif err != nil {\n \t\treturn err\n \t}\n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, len(commitmentBases))\n-\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, len(commitmentBases))\n+\tif len(commitmentBases) > 0 {\n+\t\tpk.CommitmentKeys = make([]pedersen.ProvingKey, len(commitmentBases))\n+\t\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, len(commitmentBases))\n+\t}\n \tfor i := range commitmentBases {\n \t\tcomPKey, comVKey, err := pedersen.Setup(commitmentBases[i:i+1], pedersen.WithG2Point(cG2))\n \t\tif err != nil {\n```\n\nFilename: backend/groth16/bls24-317/marshal.go:\n```\n@@ -22,6 +22,8 @@\nimport (\n \t\"github.com/consensys/gnark-crypto/ecc/bls24-317/fr/pedersen\"\n \t\"github.com/consensys/gnark-crypto/utils/unsafe\"\n \t\"github.com/consensys/gnark/internal/utils\"\n+\n+\t\"fmt\"\n \t\"io\"\n )\n\n@@ -196,35 +198,39 @@\nfunc (vk *VerifyingKey) readFrom(r io.Reader, raw bool) (int64, error) {\n \t\t&nbCommitments,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn dec.BytesRead(), err\n+\t\t\treturn dec.BytesRead(), fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \n \tvk.PublicAndCommitmentCommitted = utils.Uint64SliceSliceToIntSliceSlice(publicCommitted)\n \n-\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, nbCommitments)\n \tvar n int64\n-\tfor i := range vk.CommitmentKeys {\n+\tfor i := 0; i < int(nbCommitments); i++ {\n \t\tvar (\n \t\t\tm   int64\n \t\t\terr error\n \t\t)\n+\t\tcommitmentKey := pedersen.VerifyingKey{}\n \t\tif raw {\n-\t\t\tm, err = vk.CommitmentKeys[i].UnsafeReadFrom(r)\n+\t\t\tm, err = commitmentKey.UnsafeReadFrom(r)\n \t\t} else {\n-\t\t\tm, err = vk.CommitmentKeys[i].ReadFrom(r)\n+\t\t\tm, err = commitmentKey.ReadFrom(r)\n \t\t}\n \t\tn += m\n \t\tif err != nil {\n-\t\t\treturn n + dec.BytesRead(), err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read commitment key %d: %w\", i, err)\n \t\t}\n+\t\tvk.CommitmentKeys = append(vk.CommitmentKeys, commitmentKey)\n+\t}\n+\tif len(vk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(vk.CommitmentKeys))\n \t}\n \n \t// recompute vk.e (e(α, β)) and  -[δ]2, -[γ]2\n \tif err := vk.Precompute(); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"precompute: %w\", err)\n \t}\n \n \treturn n + dec.BytesRead(), nil\n\n@@ -320,7 +326,7 @@\nfunc (pk *ProvingKey) UnsafeReadFrom(r io.Reader) (int64, error) {\n func (pk *ProvingKey) readFrom(r io.Reader, decOptions ...func(*curve.Decoder)) (int64, error) {\n \tn, err := pk.Domain.ReadFrom(r)\n \tif err != nil {\n-\t\treturn n, err\n+\t\treturn n, fmt.Errorf(\"read domain: %w\", err)\n \t}\n \n \tdec := curve.NewDecoder(r, decOptions...)\n\n@@ -344,31 +350,34 @@\nfunc (pk *ProvingKey) readFrom(r io.Reader, decOptions ...func(*curve.Decoder))\n \t\t&pk.NbInfinityB,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn n + dec.BytesRead(), err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \tpk.InfinityA = make([]bool, nbWires)\n \tpk.InfinityB = make([]bool, nbWires)\n \n \tif err := dec.Decode(&pk.InfinityA); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read InfinityA: %w\", err)\n \t}\n \tif err := dec.Decode(&pk.InfinityB); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read InfinityB: %w\", err)\n \t}\n \tif err := dec.Decode(&nbCommitments); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read nbCommitments: %w\", err)\n \t}\n-\n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitments)\n-\tfor i := range pk.CommitmentKeys {\n-\t\tn2, err := pk.CommitmentKeys[i].ReadFrom(r)\n+\tfor i := 0; i < int(nbCommitments); i++ {\n+\t\tcpkey := pedersen.ProvingKey{}\n+\t\tn2, err := cpkey.ReadFrom(r)\n \t\tn += n2\n \t\tif err != nil {\n-\t\t\treturn n, err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read commitment key %d: %w\", i, err)\n \t\t}\n+\t\tpk.CommitmentKeys = append(pk.CommitmentKeys, cpkey)\n+\t}\n+\tif len(pk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(pk.CommitmentKeys))\n \t}\n \n \treturn n + dec.BytesRead(), nil\n\n@@ -451,11 +460,11 @@\nfunc (pk *ProvingKey) WriteDump(w io.Writer) error {\n func (pk *ProvingKey) ReadDump(r io.Reader) error {\n \t// read the marker to fail early in case of malformed input\n \tif err := unsafe.ReadMarker(r); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read marker: %w\", err)\n \t}\n \n \tif _, err := pk.Domain.ReadFrom(r); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read domain: %w\", err)\n \t}\n \n \tdec := curve.NewDecoder(r, curve.NoSubgroupChecks())\n\n@@ -479,57 +488,61 @@\nfunc (pk *ProvingKey) ReadDump(r io.Reader) error {\n \t\t&pk.NbInfinityB,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \tpk.InfinityA = make([]bool, nbWires)\n \tpk.InfinityB = make([]bool, nbWires)\n \n \tif err := dec.Decode(&pk.InfinityA); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read InfinityA: %w\", err)\n \t}\n \tif err := dec.Decode(&pk.InfinityB); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read InfinityB: %w\", err)\n \t}\n \tif err := dec.Decode(&nbCommitments); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read nbCommitments: %w\", err)\n \t}\n \n \t// read slices of points\n \tvar err error\n \tpk.G1.A, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.A: %w\", err)\n \t}\n \tpk.G1.B, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.B: %w\", err)\n \t}\n \tpk.G1.Z, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.Z: %w\", err)\n \t}\n \tpk.G1.K, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.K: %w\", err)\n \t}\n \tpk.G2.B, _, err = unsafe.ReadSlice[[]curve.G2Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G2.B: %w\", err)\n \t}\n \n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitments)\n-\tfor i := range pk.CommitmentKeys {\n-\t\tpk.CommitmentKeys[i].Basis, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n+\tfor i := 0; i < int(nbCommitments); i++ {\n+\t\tcpkey := pedersen.ProvingKey{}\n+\t\tcpkey.Basis, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \t\tif err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read commitment basis %d: %w\", i, err)\n \t\t}\n-\t\tpk.CommitmentKeys[i].BasisExpSigma, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n+\t\tcpkey.BasisExpSigma, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \t\tif err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read commitment basisExpSigma %d: %w\", i, err)\n \t\t}\n+\t\tpk.CommitmentKeys = append(pk.CommitmentKeys, cpkey)\n+\t}\n+\tif len(pk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(pk.CommitmentKeys))\n \t}\n \n \treturn nil\n```\n\nFilename: backend/groth16/bls24-317/marshal_test.go:\n```\n@@ -98,7 +98,6 @@\nfunc TestVerifyingKeySerialization(t *testing.T) {\n \t\t\t\tvk.G1.K[i] = p1\n \t\t\t}\n \n-\t\t\tvk.CommitmentKeys = []pedersen.VerifyingKey{}\n \t\t\tif withCommitment {\n \t\t\t\tvk.PublicAndCommitmentCommitted = test_utils.Random2DIntSlice(5, 10) // TODO: Use gopter randomization\n \t\t\t\tbases := make([][]curve.G1Affine, len(vk.PublicAndCommitmentCommitted))\n\n@@ -175,17 +174,18 @@\nfunc TestProvingKeySerialization(t *testing.T) {\n \t\t\tpk.InfinityB = make([]bool, nbWires)\n \t\t\tpk.InfinityA[2] = true\n \n-\t\t\tpedersenBasis := make([]curve.G1Affine, nbCommitment)\n-\t\t\tpedersenBases := make([][]curve.G1Affine, nbCommitment)\n-\t\t\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitment)\n-\t\t\tfor i := range pedersenBasis {\n-\t\t\t\tpedersenBasis[i] = p1\n-\t\t\t\tpedersenBases[i] = pedersenBasis[:i+1]\n-\t\t\t}\n-\t\t\t{\n-\t\t\t\tvar err error\n-\t\t\t\tpk.CommitmentKeys, _, err = pedersen.Setup(pedersenBases)\n-\t\t\t\trequire.NoError(t, err)\n+\t\t\tif nbCommitment > 0 {\n+\t\t\t\tpedersenBasis := make([]curve.G1Affine, nbCommitment)\n+\t\t\t\tpedersenBases := make([][]curve.G1Affine, nbCommitment)\n+\t\t\t\tfor i := range pedersenBasis {\n+\t\t\t\t\tpedersenBasis[i] = p1\n+\t\t\t\t\tpedersenBases[i] = pedersenBasis[:i+1]\n+\t\t\t\t}\n+\t\t\t\t{\n+\t\t\t\t\tvar err error\n+\t\t\t\t\tpk.CommitmentKeys, _, err = pedersen.Setup(pedersenBases)\n+\t\t\t\t\trequire.NoError(t, err)\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tif err := io.RoundTripCheck(&pk, func() any { return new(ProvingKey) }); err != nil {\n```\n\nFilename: backend/groth16/bls24-317/setup.go:\n```\n@@ -291,8 +291,10 @@\nfunc Setup(r1cs *cs.R1CS, pk *ProvingKey, vk *VerifyingKey) error {\n \tif err != nil {\n \t\treturn err\n \t}\n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, len(commitmentBases))\n-\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, len(commitmentBases))\n+\tif len(commitmentBases) > 0 {\n+\t\tpk.CommitmentKeys = make([]pedersen.ProvingKey, len(commitmentBases))\n+\t\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, len(commitmentBases))\n+\t}\n \tfor i := range commitmentBases {\n \t\tcomPKey, comVKey, err := pedersen.Setup(commitmentBases[i:i+1], pedersen.WithG2Point(cG2))\n \t\tif err != nil {\n```\n\nFilename: backend/groth16/bn254/marshal.go:\n```\n@@ -22,6 +22,8 @@\nimport (\n \t\"github.com/consensys/gnark-crypto/ecc/bn254/fr/pedersen\"\n \t\"github.com/consensys/gnark-crypto/utils/unsafe\"\n \t\"github.com/consensys/gnark/internal/utils\"\n+\n+\t\"fmt\"\n \t\"io\"\n )\n\n@@ -196,35 +198,39 @@\nfunc (vk *VerifyingKey) readFrom(r io.Reader, raw bool) (int64, error) {\n \t\t&nbCommitments,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn dec.BytesRead(), err\n+\t\t\treturn dec.BytesRead(), fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \n \tvk.PublicAndCommitmentCommitted = utils.Uint64SliceSliceToIntSliceSlice(publicCommitted)\n \n-\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, nbCommitments)\n \tvar n int64\n-\tfor i := range vk.CommitmentKeys {\n+\tfor i := 0; i < int(nbCommitments); i++ {\n \t\tvar (\n \t\t\tm   int64\n \t\t\terr error\n \t\t)\n+\t\tcommitmentKey := pedersen.VerifyingKey{}\n \t\tif raw {\n-\t\t\tm, err = vk.CommitmentKeys[i].UnsafeReadFrom(r)\n+\t\t\tm, err = commitmentKey.UnsafeReadFrom(r)\n \t\t} else {\n-\t\t\tm, err = vk.CommitmentKeys[i].ReadFrom(r)\n+\t\t\tm, err = commitmentKey.ReadFrom(r)\n \t\t}\n \t\tn += m\n \t\tif err != nil {\n-\t\t\treturn n + dec.BytesRead(), err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read commitment key %d: %w\", i, err)\n \t\t}\n+\t\tvk.CommitmentKeys = append(vk.CommitmentKeys, commitmentKey)\n+\t}\n+\tif len(vk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(vk.CommitmentKeys))\n \t}\n \n \t// recompute vk.e (e(α, β)) and  -[δ]2, -[γ]2\n \tif err := vk.Precompute(); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"precompute: %w\", err)\n \t}\n \n \treturn n + dec.BytesRead(), nil\n\n@@ -320,7 +326,7 @@\nfunc (pk *ProvingKey) UnsafeReadFrom(r io.Reader) (int64, error) {\n func (pk *ProvingKey) readFrom(r io.Reader, decOptions ...func(*curve.Decoder)) (int64, error) {\n \tn, err := pk.Domain.ReadFrom(r)\n \tif err != nil {\n-\t\treturn n, err\n+\t\treturn n, fmt.Errorf(\"read domain: %w\", err)\n \t}\n \n \tdec := curve.NewDecoder(r, decOptions...)\n\n@@ -344,31 +350,34 @@\nfunc (pk *ProvingKey) readFrom(r io.Reader, decOptions ...func(*curve.Decoder))\n \t\t&pk.NbInfinityB,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn n + dec.BytesRead(), err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \tpk.InfinityA = make([]bool, nbWires)\n \tpk.InfinityB = make([]bool, nbWires)\n \n \tif err := dec.Decode(&pk.InfinityA); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read InfinityA: %w\", err)\n \t}\n \tif err := dec.Decode(&pk.InfinityB); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read InfinityB: %w\", err)\n \t}\n \tif err := dec.Decode(&nbCommitments); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read nbCommitments: %w\", err)\n \t}\n-\n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitments)\n-\tfor i := range pk.CommitmentKeys {\n-\t\tn2, err := pk.CommitmentKeys[i].ReadFrom(r)\n+\tfor i := 0; i < int(nbCommitments); i++ {\n+\t\tcpkey := pedersen.ProvingKey{}\n+\t\tn2, err := cpkey.ReadFrom(r)\n \t\tn += n2\n \t\tif err != nil {\n-\t\t\treturn n, err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read commitment key %d: %w\", i, err)\n \t\t}\n+\t\tpk.CommitmentKeys = append(pk.CommitmentKeys, cpkey)\n+\t}\n+\tif len(pk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(pk.CommitmentKeys))\n \t}\n \n \treturn n + dec.BytesRead(), nil\n\n@@ -451,11 +460,11 @@\nfunc (pk *ProvingKey) WriteDump(w io.Writer) error {\n func (pk *ProvingKey) ReadDump(r io.Reader) error {\n \t// read the marker to fail early in case of malformed input\n \tif err := unsafe.ReadMarker(r); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read marker: %w\", err)\n \t}\n \n \tif _, err := pk.Domain.ReadFrom(r); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read domain: %w\", err)\n \t}\n \n \tdec := curve.NewDecoder(r, curve.NoSubgroupChecks())\n\n@@ -479,57 +488,61 @@\nfunc (pk *ProvingKey) ReadDump(r io.Reader) error {\n \t\t&pk.NbInfinityB,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \tpk.InfinityA = make([]bool, nbWires)\n \tpk.InfinityB = make([]bool, nbWires)\n \n \tif err := dec.Decode(&pk.InfinityA); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read InfinityA: %w\", err)\n \t}\n \tif err := dec.Decode(&pk.InfinityB); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read InfinityB: %w\", err)\n \t}\n \tif err := dec.Decode(&nbCommitments); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read nbCommitments: %w\", err)\n \t}\n \n \t// read slices of points\n \tvar err error\n \tpk.G1.A, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.A: %w\", err)\n \t}\n \tpk.G1.B, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.B: %w\", err)\n \t}\n \tpk.G1.Z, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.Z: %w\", err)\n \t}\n \tpk.G1.K, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.K: %w\", err)\n \t}\n \tpk.G2.B, _, err = unsafe.ReadSlice[[]curve.G2Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G2.B: %w\", err)\n \t}\n \n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitments)\n-\tfor i := range pk.CommitmentKeys {\n-\t\tpk.CommitmentKeys[i].Basis, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n+\tfor i := 0; i < int(nbCommitments); i++ {\n+\t\tcpkey := pedersen.ProvingKey{}\n+\t\tcpkey.Basis, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \t\tif err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read commitment basis %d: %w\", i, err)\n \t\t}\n-\t\tpk.CommitmentKeys[i].BasisExpSigma, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n+\t\tcpkey.BasisExpSigma, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \t\tif err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read commitment basisExpSigma %d: %w\", i, err)\n \t\t}\n+\t\tpk.CommitmentKeys = append(pk.CommitmentKeys, cpkey)\n+\t}\n+\tif len(pk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(pk.CommitmentKeys))\n \t}\n \n \treturn nil\n```\n\nFilename: backend/groth16/bn254/marshal_test.go:\n```\n@@ -98,7 +98,6 @@\nfunc TestVerifyingKeySerialization(t *testing.T) {\n \t\t\t\tvk.G1.K[i] = p1\n \t\t\t}\n \n-\t\t\tvk.CommitmentKeys = []pedersen.VerifyingKey{}\n \t\t\tif withCommitment {\n \t\t\t\tvk.PublicAndCommitmentCommitted = test_utils.Random2DIntSlice(5, 10) // TODO: Use gopter randomization\n \t\t\t\tbases := make([][]curve.G1Affine, len(vk.PublicAndCommitmentCommitted))\n\n@@ -175,17 +174,18 @@\nfunc TestProvingKeySerialization(t *testing.T) {\n \t\t\tpk.InfinityB = make([]bool, nbWires)\n \t\t\tpk.InfinityA[2] = true\n \n-\t\t\tpedersenBasis := make([]curve.G1Affine, nbCommitment)\n-\t\t\tpedersenBases := make([][]curve.G1Affine, nbCommitment)\n-\t\t\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitment)\n-\t\t\tfor i := range pedersenBasis {\n-\t\t\t\tpedersenBasis[i] = p1\n-\t\t\t\tpedersenBases[i] = pedersenBasis[:i+1]\n-\t\t\t}\n-\t\t\t{\n-\t\t\t\tvar err error\n-\t\t\t\tpk.CommitmentKeys, _, err = pedersen.Setup(pedersenBases)\n-\t\t\t\trequire.NoError(t, err)\n+\t\t\tif nbCommitment > 0 {\n+\t\t\t\tpedersenBasis := make([]curve.G1Affine, nbCommitment)\n+\t\t\t\tpedersenBases := make([][]curve.G1Affine, nbCommitment)\n+\t\t\t\tfor i := range pedersenBasis {\n+\t\t\t\t\tpedersenBasis[i] = p1\n+\t\t\t\t\tpedersenBases[i] = pedersenBasis[:i+1]\n+\t\t\t\t}\n+\t\t\t\t{\n+\t\t\t\t\tvar err error\n+\t\t\t\t\tpk.CommitmentKeys, _, err = pedersen.Setup(pedersenBases)\n+\t\t\t\t\trequire.NoError(t, err)\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tif err := io.RoundTripCheck(&pk, func() any { return new(ProvingKey) }); err != nil {\n```\n\nFilename: backend/groth16/bn254/setup.go:\n```\n@@ -291,8 +291,10 @@\nfunc Setup(r1cs *cs.R1CS, pk *ProvingKey, vk *VerifyingKey) error {\n \tif err != nil {\n \t\treturn err\n \t}\n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, len(commitmentBases))\n-\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, len(commitmentBases))\n+\tif len(commitmentBases) > 0 {\n+\t\tpk.CommitmentKeys = make([]pedersen.ProvingKey, len(commitmentBases))\n+\t\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, len(commitmentBases))\n+\t}\n \tfor i := range commitmentBases {\n \t\tcomPKey, comVKey, err := pedersen.Setup(commitmentBases[i:i+1], pedersen.WithG2Point(cG2))\n \t\tif err != nil {\n```\n\nFilename: backend/groth16/bw6-633/marshal.go:\n```\n@@ -22,6 +22,8 @@\nimport (\n \t\"github.com/consensys/gnark-crypto/ecc/bw6-633/fr/pedersen\"\n \t\"github.com/consensys/gnark-crypto/utils/unsafe\"\n \t\"github.com/consensys/gnark/internal/utils\"\n+\n+\t\"fmt\"\n \t\"io\"\n )\n\n@@ -196,35 +198,39 @@\nfunc (vk *VerifyingKey) readFrom(r io.Reader, raw bool) (int64, error) {\n \t\t&nbCommitments,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn dec.BytesRead(), err\n+\t\t\treturn dec.BytesRead(), fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \n \tvk.PublicAndCommitmentCommitted = utils.Uint64SliceSliceToIntSliceSlice(publicCommitted)\n \n-\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, nbCommitments)\n \tvar n int64\n-\tfor i := range vk.CommitmentKeys {\n+\tfor i := 0; i < int(nbCommitments); i++ {\n \t\tvar (\n \t\t\tm   int64\n \t\t\terr error\n \t\t)\n+\t\tcommitmentKey := pedersen.VerifyingKey{}\n \t\tif raw {\n-\t\t\tm, err = vk.CommitmentKeys[i].UnsafeReadFrom(r)\n+\t\t\tm, err = commitmentKey.UnsafeReadFrom(r)\n \t\t} else {\n-\t\t\tm, err = vk.CommitmentKeys[i].ReadFrom(r)\n+\t\t\tm, err = commitmentKey.ReadFrom(r)\n \t\t}\n \t\tn += m\n \t\tif err != nil {\n-\t\t\treturn n + dec.BytesRead(), err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read commitment key %d: %w\", i, err)\n \t\t}\n+\t\tvk.CommitmentKeys = append(vk.CommitmentKeys, commitmentKey)\n+\t}\n+\tif len(vk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(vk.CommitmentKeys))\n \t}\n \n \t// recompute vk.e (e(α, β)) and  -[δ]2, -[γ]2\n \tif err := vk.Precompute(); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"precompute: %w\", err)\n \t}\n \n \treturn n + dec.BytesRead(), nil\n\n@@ -320,7 +326,7 @@\nfunc (pk *ProvingKey) UnsafeReadFrom(r io.Reader) (int64, error) {\n func (pk *ProvingKey) readFrom(r io.Reader, decOptions ...func(*curve.Decoder)) (int64, error) {\n \tn, err := pk.Domain.ReadFrom(r)\n \tif err != nil {\n-\t\treturn n, err\n+\t\treturn n, fmt.Errorf(\"read domain: %w\", err)\n \t}\n \n \tdec := curve.NewDecoder(r, decOptions...)\n\n@@ -344,31 +350,34 @@\nfunc (pk *ProvingKey) readFrom(r io.Reader, decOptions ...func(*curve.Decoder))\n \t\t&pk.NbInfinityB,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn n + dec.BytesRead(), err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \tpk.InfinityA = make([]bool, nbWires)\n \tpk.InfinityB = make([]bool, nbWires)\n \n \tif err := dec.Decode(&pk.InfinityA); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read InfinityA: %w\", err)\n \t}\n \tif err := dec.Decode(&pk.InfinityB); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read InfinityB: %w\", err)\n \t}\n \tif err := dec.Decode(&nbCommitments); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read nbCommitments: %w\", err)\n \t}\n-\n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitments)\n-\tfor i := range pk.CommitmentKeys {\n-\t\tn2, err := pk.CommitmentKeys[i].ReadFrom(r)\n+\tfor i := 0; i < int(nbCommitments); i++ {\n+\t\tcpkey := pedersen.ProvingKey{}\n+\t\tn2, err := cpkey.ReadFrom(r)\n \t\tn += n2\n \t\tif err != nil {\n-\t\t\treturn n, err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read commitment key %d: %w\", i, err)\n \t\t}\n+\t\tpk.CommitmentKeys = append(pk.CommitmentKeys, cpkey)\n+\t}\n+\tif len(pk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(pk.CommitmentKeys))\n \t}\n \n \treturn n + dec.BytesRead(), nil\n\n@@ -451,11 +460,11 @@\nfunc (pk *ProvingKey) WriteDump(w io.Writer) error {\n func (pk *ProvingKey) ReadDump(r io.Reader) error {\n \t// read the marker to fail early in case of malformed input\n \tif err := unsafe.ReadMarker(r); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read marker: %w\", err)\n \t}\n \n \tif _, err := pk.Domain.ReadFrom(r); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read domain: %w\", err)\n \t}\n \n \tdec := curve.NewDecoder(r, curve.NoSubgroupChecks())\n\n@@ -479,57 +488,61 @@\nfunc (pk *ProvingKey) ReadDump(r io.Reader) error {\n \t\t&pk.NbInfinityB,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \tpk.InfinityA = make([]bool, nbWires)\n \tpk.InfinityB = make([]bool, nbWires)\n \n \tif err := dec.Decode(&pk.InfinityA); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read InfinityA: %w\", err)\n \t}\n \tif err := dec.Decode(&pk.InfinityB); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read InfinityB: %w\", err)\n \t}\n \tif err := dec.Decode(&nbCommitments); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read nbCommitments: %w\", err)\n \t}\n \n \t// read slices of points\n \tvar err error\n \tpk.G1.A, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.A: %w\", err)\n \t}\n \tpk.G1.B, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.B: %w\", err)\n \t}\n \tpk.G1.Z, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.Z: %w\", err)\n \t}\n \tpk.G1.K, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.K: %w\", err)\n \t}\n \tpk.G2.B, _, err = unsafe.ReadSlice[[]curve.G2Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G2.B: %w\", err)\n \t}\n \n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitments)\n-\tfor i := range pk.CommitmentKeys {\n-\t\tpk.CommitmentKeys[i].Basis, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n+\tfor i := 0; i < int(nbCommitments); i++ {\n+\t\tcpkey := pedersen.ProvingKey{}\n+\t\tcpkey.Basis, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \t\tif err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read commitment basis %d: %w\", i, err)\n \t\t}\n-\t\tpk.CommitmentKeys[i].BasisExpSigma, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n+\t\tcpkey.BasisExpSigma, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \t\tif err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read commitment basisExpSigma %d: %w\", i, err)\n \t\t}\n+\t\tpk.CommitmentKeys = append(pk.CommitmentKeys, cpkey)\n+\t}\n+\tif len(pk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(pk.CommitmentKeys))\n \t}\n \n \treturn nil\n```\n\nFilename: backend/groth16/bw6-633/marshal_test.go:\n```\n@@ -98,7 +98,6 @@\nfunc TestVerifyingKeySerialization(t *testing.T) {\n \t\t\t\tvk.G1.K[i] = p1\n \t\t\t}\n \n-\t\t\tvk.CommitmentKeys = []pedersen.VerifyingKey{}\n \t\t\tif withCommitment {\n \t\t\t\tvk.PublicAndCommitmentCommitted = test_utils.Random2DIntSlice(5, 10) // TODO: Use gopter randomization\n \t\t\t\tbases := make([][]curve.G1Affine, len(vk.PublicAndCommitmentCommitted))\n\n@@ -175,17 +174,18 @@\nfunc TestProvingKeySerialization(t *testing.T) {\n \t\t\tpk.InfinityB = make([]bool, nbWires)\n \t\t\tpk.InfinityA[2] = true\n \n-\t\t\tpedersenBasis := make([]curve.G1Affine, nbCommitment)\n-\t\t\tpedersenBases := make([][]curve.G1Affine, nbCommitment)\n-\t\t\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitment)\n-\t\t\tfor i := range pedersenBasis {\n-\t\t\t\tpedersenBasis[i] = p1\n-\t\t\t\tpedersenBases[i] = pedersenBasis[:i+1]\n-\t\t\t}\n-\t\t\t{\n-\t\t\t\tvar err error\n-\t\t\t\tpk.CommitmentKeys, _, err = pedersen.Setup(pedersenBases)\n-\t\t\t\trequire.NoError(t, err)\n+\t\t\tif nbCommitment > 0 {\n+\t\t\t\tpedersenBasis := make([]curve.G1Affine, nbCommitment)\n+\t\t\t\tpedersenBases := make([][]curve.G1Affine, nbCommitment)\n+\t\t\t\tfor i := range pedersenBasis {\n+\t\t\t\t\tpedersenBasis[i] = p1\n+\t\t\t\t\tpedersenBases[i] = pedersenBasis[:i+1]\n+\t\t\t\t}\n+\t\t\t\t{\n+\t\t\t\t\tvar err error\n+\t\t\t\t\tpk.CommitmentKeys, _, err = pedersen.Setup(pedersenBases)\n+\t\t\t\t\trequire.NoError(t, err)\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tif err := io.RoundTripCheck(&pk, func() any { return new(ProvingKey) }); err != nil {\n```\n\nFilename: backend/groth16/bw6-633/setup.go:\n```\n@@ -291,8 +291,10 @@\nfunc Setup(r1cs *cs.R1CS, pk *ProvingKey, vk *VerifyingKey) error {\n \tif err != nil {\n \t\treturn err\n \t}\n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, len(commitmentBases))\n-\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, len(commitmentBases))\n+\tif len(commitmentBases) > 0 {\n+\t\tpk.CommitmentKeys = make([]pedersen.ProvingKey, len(commitmentBases))\n+\t\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, len(commitmentBases))\n+\t}\n \tfor i := range commitmentBases {\n \t\tcomPKey, comVKey, err := pedersen.Setup(commitmentBases[i:i+1], pedersen.WithG2Point(cG2))\n \t\tif err != nil {\n```\n\nFilename: backend/groth16/bw6-761/marshal.go:\n```\n@@ -22,6 +22,8 @@\nimport (\n \t\"github.com/consensys/gnark-crypto/ecc/bw6-761/fr/pedersen\"\n \t\"github.com/consensys/gnark-crypto/utils/unsafe\"\n \t\"github.com/consensys/gnark/internal/utils\"\n+\n+\t\"fmt\"\n \t\"io\"\n )\n\n@@ -196,35 +198,39 @@\nfunc (vk *VerifyingKey) readFrom(r io.Reader, raw bool) (int64, error) {\n \t\t&nbCommitments,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn dec.BytesRead(), err\n+\t\t\treturn dec.BytesRead(), fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \n \tvk.PublicAndCommitmentCommitted = utils.Uint64SliceSliceToIntSliceSlice(publicCommitted)\n \n-\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, nbCommitments)\n \tvar n int64\n-\tfor i := range vk.CommitmentKeys {\n+\tfor i := 0; i < int(nbCommitments); i++ {\n \t\tvar (\n \t\t\tm   int64\n \t\t\terr error\n \t\t)\n+\t\tcommitmentKey := pedersen.VerifyingKey{}\n \t\tif raw {\n-\t\t\tm, err = vk.CommitmentKeys[i].UnsafeReadFrom(r)\n+\t\t\tm, err = commitmentKey.UnsafeReadFrom(r)\n \t\t} else {\n-\t\t\tm, err = vk.CommitmentKeys[i].ReadFrom(r)\n+\t\t\tm, err = commitmentKey.ReadFrom(r)\n \t\t}\n \t\tn += m\n \t\tif err != nil {\n-\t\t\treturn n + dec.BytesRead(), err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read commitment key %d: %w\", i, err)\n \t\t}\n+\t\tvk.CommitmentKeys = append(vk.CommitmentKeys, commitmentKey)\n+\t}\n+\tif len(vk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(vk.CommitmentKeys))\n \t}\n \n \t// recompute vk.e (e(α, β)) and  -[δ]2, -[γ]2\n \tif err := vk.Precompute(); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"precompute: %w\", err)\n \t}\n \n \treturn n + dec.BytesRead(), nil\n\n@@ -320,7 +326,7 @@\nfunc (pk *ProvingKey) UnsafeReadFrom(r io.Reader) (int64, error) {\n func (pk *ProvingKey) readFrom(r io.Reader, decOptions ...func(*curve.Decoder)) (int64, error) {\n \tn, err := pk.Domain.ReadFrom(r)\n \tif err != nil {\n-\t\treturn n, err\n+\t\treturn n, fmt.Errorf(\"read domain: %w\", err)\n \t}\n \n \tdec := curve.NewDecoder(r, decOptions...)\n\n@@ -344,31 +350,34 @@\nfunc (pk *ProvingKey) readFrom(r io.Reader, decOptions ...func(*curve.Decoder))\n \t\t&pk.NbInfinityB,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn n + dec.BytesRead(), err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \tpk.InfinityA = make([]bool, nbWires)\n \tpk.InfinityB = make([]bool, nbWires)\n \n \tif err := dec.Decode(&pk.InfinityA); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read InfinityA: %w\", err)\n \t}\n \tif err := dec.Decode(&pk.InfinityB); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read InfinityB: %w\", err)\n \t}\n \tif err := dec.Decode(&nbCommitments); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read nbCommitments: %w\", err)\n \t}\n-\n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitments)\n-\tfor i := range pk.CommitmentKeys {\n-\t\tn2, err := pk.CommitmentKeys[i].ReadFrom(r)\n+\tfor i := 0; i < int(nbCommitments); i++ {\n+\t\tcpkey := pedersen.ProvingKey{}\n+\t\tn2, err := cpkey.ReadFrom(r)\n \t\tn += n2\n \t\tif err != nil {\n-\t\t\treturn n, err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read commitment key %d: %w\", i, err)\n \t\t}\n+\t\tpk.CommitmentKeys = append(pk.CommitmentKeys, cpkey)\n+\t}\n+\tif len(pk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(pk.CommitmentKeys))\n \t}\n \n \treturn n + dec.BytesRead(), nil\n\n@@ -451,11 +460,11 @@\nfunc (pk *ProvingKey) WriteDump(w io.Writer) error {\n func (pk *ProvingKey) ReadDump(r io.Reader) error {\n \t// read the marker to fail early in case of malformed input\n \tif err := unsafe.ReadMarker(r); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read marker: %w\", err)\n \t}\n \n \tif _, err := pk.Domain.ReadFrom(r); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read domain: %w\", err)\n \t}\n \n \tdec := curve.NewDecoder(r, curve.NoSubgroupChecks())\n\n@@ -479,57 +488,61 @@\nfunc (pk *ProvingKey) ReadDump(r io.Reader) error {\n \t\t&pk.NbInfinityB,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \tpk.InfinityA = make([]bool, nbWires)\n \tpk.InfinityB = make([]bool, nbWires)\n \n \tif err := dec.Decode(&pk.InfinityA); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read InfinityA: %w\", err)\n \t}\n \tif err := dec.Decode(&pk.InfinityB); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read InfinityB: %w\", err)\n \t}\n \tif err := dec.Decode(&nbCommitments); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read nbCommitments: %w\", err)\n \t}\n \n \t// read slices of points\n \tvar err error\n \tpk.G1.A, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.A: %w\", err)\n \t}\n \tpk.G1.B, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.B: %w\", err)\n \t}\n \tpk.G1.Z, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.Z: %w\", err)\n \t}\n \tpk.G1.K, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.K: %w\", err)\n \t}\n \tpk.G2.B, _, err = unsafe.ReadSlice[[]curve.G2Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G2.B: %w\", err)\n \t}\n \n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitments)\n-\tfor i := range pk.CommitmentKeys {\n-\t\tpk.CommitmentKeys[i].Basis, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n+\tfor i := 0; i < int(nbCommitments); i++ {\n+\t\tcpkey := pedersen.ProvingKey{}\n+\t\tcpkey.Basis, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \t\tif err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read commitment basis %d: %w\", i, err)\n \t\t}\n-\t\tpk.CommitmentKeys[i].BasisExpSigma, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n+\t\tcpkey.BasisExpSigma, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \t\tif err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read commitment basisExpSigma %d: %w\", i, err)\n \t\t}\n+\t\tpk.CommitmentKeys = append(pk.CommitmentKeys, cpkey)\n+\t}\n+\tif len(pk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(pk.CommitmentKeys))\n \t}\n \n \treturn nil\n```\n\nFilename: backend/groth16/bw6-761/marshal_test.go:\n```\n@@ -98,7 +98,6 @@\nfunc TestVerifyingKeySerialization(t *testing.T) {\n \t\t\t\tvk.G1.K[i] = p1\n \t\t\t}\n \n-\t\t\tvk.CommitmentKeys = []pedersen.VerifyingKey{}\n \t\t\tif withCommitment {\n \t\t\t\tvk.PublicAndCommitmentCommitted = test_utils.Random2DIntSlice(5, 10) // TODO: Use gopter randomization\n \t\t\t\tbases := make([][]curve.G1Affine, len(vk.PublicAndCommitmentCommitted))\n\n@@ -175,17 +174,18 @@\nfunc TestProvingKeySerialization(t *testing.T) {\n \t\t\tpk.InfinityB = make([]bool, nbWires)\n \t\t\tpk.InfinityA[2] = true\n \n-\t\t\tpedersenBasis := make([]curve.G1Affine, nbCommitment)\n-\t\t\tpedersenBases := make([][]curve.G1Affine, nbCommitment)\n-\t\t\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitment)\n-\t\t\tfor i := range pedersenBasis {\n-\t\t\t\tpedersenBasis[i] = p1\n-\t\t\t\tpedersenBases[i] = pedersenBasis[:i+1]\n-\t\t\t}\n-\t\t\t{\n-\t\t\t\tvar err error\n-\t\t\t\tpk.CommitmentKeys, _, err = pedersen.Setup(pedersenBases)\n-\t\t\t\trequire.NoError(t, err)\n+\t\t\tif nbCommitment > 0 {\n+\t\t\t\tpedersenBasis := make([]curve.G1Affine, nbCommitment)\n+\t\t\t\tpedersenBases := make([][]curve.G1Affine, nbCommitment)\n+\t\t\t\tfor i := range pedersenBasis {\n+\t\t\t\t\tpedersenBasis[i] = p1\n+\t\t\t\t\tpedersenBases[i] = pedersenBasis[:i+1]\n+\t\t\t\t}\n+\t\t\t\t{\n+\t\t\t\t\tvar err error\n+\t\t\t\t\tpk.CommitmentKeys, _, err = pedersen.Setup(pedersenBases)\n+\t\t\t\t\trequire.NoError(t, err)\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tif err := io.RoundTripCheck(&pk, func() any { return new(ProvingKey) }); err != nil {\n```\n\nFilename: backend/groth16/bw6-761/setup.go:\n```\n@@ -291,8 +291,10 @@\nfunc Setup(r1cs *cs.R1CS, pk *ProvingKey, vk *VerifyingKey) error {\n \tif err != nil {\n \t\treturn err\n \t}\n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, len(commitmentBases))\n-\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, len(commitmentBases))\n+\tif len(commitmentBases) > 0 {\n+\t\tpk.CommitmentKeys = make([]pedersen.ProvingKey, len(commitmentBases))\n+\t\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, len(commitmentBases))\n+\t}\n \tfor i := range commitmentBases {\n \t\tcomPKey, comVKey, err := pedersen.Setup(commitmentBases[i:i+1], pedersen.WithG2Point(cG2))\n \t\tif err != nil {\n```\n\nFilename: internal/generator/backend/template/zkpschemes/groth16/groth16.marshal.go.tmpl:\n```\n@@ -3,6 +3,8 @@\nimport (\n \t{{ template \"import_pedersen\" . }}\n \t\"github.com/consensys/gnark/internal/utils\"\n \t\"github.com/consensys/gnark-crypto/utils/unsafe\"\n+\n+\t\"fmt\"\n \t\"io\"\n )\n\n@@ -178,35 +180,39 @@\nfunc (vk *VerifyingKey) readFrom(r io.Reader, raw bool) (int64, error) {\n \t\t&nbCommitments,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn dec.BytesRead(), err\n+\t\t\treturn dec.BytesRead(), fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \n \tvk.PublicAndCommitmentCommitted = utils.Uint64SliceSliceToIntSliceSlice(publicCommitted)\n \t\n-\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, nbCommitments)\n \tvar n int64\n-\tfor i := range vk.CommitmentKeys {\n+\tfor i := 0; i < int(nbCommitments); i++ {\n \t\tvar (\n \t\t\tm   int64\n \t\t\terr error\n \t\t)\n+\t\tcommitmentKey := pedersen.VerifyingKey{}\n \t\tif raw {\n-\t\t\tm, err = vk.CommitmentKeys[i].UnsafeReadFrom(r)\n+\t\t\tm, err = commitmentKey.UnsafeReadFrom(r)\n \t\t} else {\n-\t\t\tm, err = vk.CommitmentKeys[i].ReadFrom(r)\n+\t\t\tm, err = commitmentKey.ReadFrom(r)\n \t\t}\n \t\tn += m\n \t\tif err != nil {\n-\t\t\treturn n + dec.BytesRead(), err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read commitment key %d: %w\", i, err)\n \t\t}\n+\t\tvk.CommitmentKeys = append(vk.CommitmentKeys, commitmentKey)\n+\t}\n+\tif len(vk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(vk.CommitmentKeys))\n \t}\n \n \t// recompute vk.e (e(α, β)) and  -[δ]2, -[γ]2\n \tif err := vk.Precompute(); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"precompute: %w\", err)\n \t}\n \n \treturn n + dec.BytesRead(), nil\n\n@@ -306,7 +312,7 @@\nfunc (pk *ProvingKey) UnsafeReadFrom(r io.Reader) (int64, error) {\n func (pk *ProvingKey) readFrom(r io.Reader, decOptions ...func(*curve.Decoder)) (int64, error) {\n \tn, err := pk.Domain.ReadFrom(r)\n \tif err != nil {\n-\t\treturn n, err\n+\t\treturn n, fmt.Errorf(\"read domain: %w\", err)\n \t}\n \n \tdec := curve.NewDecoder(r, decOptions...)\n\n@@ -330,31 +336,34 @@\nfunc (pk *ProvingKey) readFrom(r io.Reader, decOptions ...func(*curve.Decoder))\n \t\t&pk.NbInfinityB,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn n + dec.BytesRead(), err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \tpk.InfinityA = make([]bool, nbWires)\n \tpk.InfinityB = make([]bool, nbWires)\n \n \tif err := dec.Decode(&pk.InfinityA); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read InfinityA: %w\", err)\n \t}\n \tif err := dec.Decode(&pk.InfinityB); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read InfinityB: %w\", err)\n \t}\n \tif err := dec.Decode(&nbCommitments); err != nil {\n-\t\treturn n + dec.BytesRead(), err\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read nbCommitments: %w\", err)\n \t}\n-\n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitments)\n-\tfor i := range pk.CommitmentKeys {\n-\t\tn2, err := pk.CommitmentKeys[i].ReadFrom(r)\n+\tfor i := 0; i < int(nbCommitments); i++ {\n+\t\tcpkey := pedersen.ProvingKey{}\n+\t\tn2, err := cpkey.ReadFrom(r)\n \t\tn += n2\n \t\tif err != nil {\n-\t\t\treturn n, err\n+\t\t\treturn n + dec.BytesRead(), fmt.Errorf(\"read commitment key %d: %w\", i, err)\n \t\t}\n+\t\tpk.CommitmentKeys = append(pk.CommitmentKeys, cpkey)\n+\t}\n+\tif len(pk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn n + dec.BytesRead(), fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(pk.CommitmentKeys))\n \t}\n \n \treturn n + dec.BytesRead(), nil\n\n@@ -438,11 +447,11 @@\nfunc (pk *ProvingKey) WriteDump(w io.Writer) error {\n func (pk *ProvingKey) ReadDump(r io.Reader) error {\n \t// read the marker to fail early in case of malformed input\n \tif err := unsafe.ReadMarker(r); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read marker: %w\", err)\n \t}\n \n \tif _, err := pk.Domain.ReadFrom(r); err != nil {\n-\t\treturn err \n+\t\treturn fmt.Errorf(\"read domain: %w\", err)\n \t}\n \n \tdec := curve.NewDecoder(r, curve.NoSubgroupChecks())\n\n@@ -466,57 +475,61 @@\nfunc (pk *ProvingKey) ReadDump(r io.Reader) error {\n \t\t&pk.NbInfinityB,\n \t}\n \n-\tfor _, v := range toDecode {\n+\tfor i, v := range toDecode {\n \t\tif err := dec.Decode(v); err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read field %d: %w\", i, err)\n \t\t}\n \t}\n \tpk.InfinityA = make([]bool, nbWires)\n \tpk.InfinityB = make([]bool, nbWires)\n \n \tif err := dec.Decode(&pk.InfinityA); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read InfinityA: %w\", err)\n \t}\n \tif err := dec.Decode(&pk.InfinityB); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read InfinityB: %w\", err)\n \t}\n \tif err := dec.Decode(&nbCommitments); err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read nbCommitments: %w\", err)\n \t}\n \n \t// read slices of points\n \tvar err error\n \tpk.G1.A, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.A: %w\", err)\n \t}\n \tpk.G1.B, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.B: %w\", err)\n \t}\n \tpk.G1.Z, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.Z: %w\", err)\n \t}\n \tpk.G1.K, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G1.K: %w\", err)\n \t}\n \tpk.G2.B, _, err = unsafe.ReadSlice[[]curve.G2Affine](r)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"read G2.B: %w\", err)\n \t}\n \n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitments)\n-\tfor i := range pk.CommitmentKeys {\n-\t\tpk.CommitmentKeys[i].Basis, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n+\tfor i := 0; i < int(nbCommitments); i++{\n+\t\tcpkey := pedersen.ProvingKey{}\n+\t\tcpkey.Basis, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \t\tif err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read commitment basis %d: %w\", i, err)\n \t\t}\n-\t\tpk.CommitmentKeys[i].BasisExpSigma, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n+\t\tcpkey.BasisExpSigma, _, err = unsafe.ReadSlice[[]curve.G1Affine](r)\n \t\tif err != nil {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"read commitment basisExpSigma %d: %w\", i, err)\n \t\t}\n+\t\tpk.CommitmentKeys = append(pk.CommitmentKeys, cpkey)\n+\t}\n+\tif len(pk.CommitmentKeys) != int(nbCommitments) {\n+\t\treturn fmt.Errorf(\"invalid number of commitment keys. Expected %d got %d\", nbCommitments, len(pk.CommitmentKeys))\n \t}\n \n \treturn nil\n```\n\nFilename: internal/generator/backend/template/zkpschemes/groth16/groth16.setup.go.tmpl:\n```\n@@ -273,8 +273,10 @@\nfunc Setup(r1cs *cs.R1CS, pk *ProvingKey, vk *VerifyingKey) error {\n \tif err != nil {\n \t\treturn err\n \t}\n-\tpk.CommitmentKeys = make([]pedersen.ProvingKey, len(commitmentBases))\n-\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, len(commitmentBases))\n+\tif len(commitmentBases) > 0 {\n+\t\tpk.CommitmentKeys = make([]pedersen.ProvingKey, len(commitmentBases))\n+\t\tvk.CommitmentKeys = make([]pedersen.VerifyingKey, len(commitmentBases))\n+\t}\n \tfor i := range commitmentBases {\n \t\tcomPKey, comVKey, err := pedersen.Setup(commitmentBases[i:i+1], pedersen.WithG2Point(cG2))\n \t\tif err != nil {\n```\n\nFilename: internal/generator/backend/template/zkpschemes/groth16/tests/groth16.marshal.go.tmpl:\n```\n@@ -82,7 +82,6 @@\nfunc TestVerifyingKeySerialization(t *testing.T) {\n \t\t\t\tvk.G1.K[i] = p1\n \t\t\t}\n \n-\t\t\tvk.CommitmentKeys = []pedersen.VerifyingKey{}\n \t\t\tif withCommitment {\n \t\t\t\tvk.PublicAndCommitmentCommitted = test_utils.Random2DIntSlice(5, 10) // TODO: Use gopter randomization\n \t\t\t\tbases := make([][]curve.G1Affine, len(vk.PublicAndCommitmentCommitted))\n\n@@ -161,17 +160,18 @@\nfunc TestProvingKeySerialization(t *testing.T) {\n \t\t\tpk.InfinityB = make([]bool, nbWires)\n \t\t\tpk.InfinityA[2] = true\n \n-\t\t\tpedersenBasis := make([]curve.G1Affine, nbCommitment)\n-\t\t\tpedersenBases := make([][]curve.G1Affine, nbCommitment)\n-\t\t\tpk.CommitmentKeys = make([]pedersen.ProvingKey, nbCommitment)\n-\t\t\tfor i := range pedersenBasis {\n-\t\t\t\tpedersenBasis[i] = p1\n-\t\t\t\tpedersenBases[i] = pedersenBasis[:i+1]\n-\t\t\t}\n-\t\t\t{\n-\t\t\tvar err error\n-\t\t\t\tpk.CommitmentKeys, _, err = pedersen.Setup(pedersenBases)\n-\t\t\t\trequire.NoError(t, err)\n+\t\t\tif nbCommitment > 0 {\n+\t\t\t\tpedersenBasis := make([]curve.G1Affine, nbCommitment)\n+\t\t\t\tpedersenBases := make([][]curve.G1Affine, nbCommitment)\n+\t\t\t\tfor i := range pedersenBasis {\n+\t\t\t\t\tpedersenBasis[i] = p1\n+\t\t\t\t\tpedersenBases[i] = pedersenBasis[:i+1]\n+\t\t\t\t}\n+\t\t\t\t{\n+\t\t\t\t\tvar err error\n+\t\t\t\t\tpk.CommitmentKeys, _, err = pedersen.Setup(pedersenBases)\n+\t\t\t\t\trequire.NoError(t, err)\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tif err := io.RoundTripCheck(&pk, func() any {return new(ProvingKey)}); err != nil {\n```"
            }
        ],
        "sw_version": "v0.11.0",
        "sw_version_wget": "https://github.com/Consensys/gnark/archive/refs/tags/v0.11.0.zip",
        "description": "gnark is a fast zk-SNARK library that offers a high-level API to design circuits. In gnark 0.11.0 and earlier, deserialization of Groth16 verification keys allocate excessive memory, consuming a lot of resources and triggering a crash with the error fatal error: runtime: out of memory.",
        "sec_adv": [
            {
                "url": "https://github.com/Consensys/gnark/security/advisories/GHSA-cph5-3pgr-c82g",
                "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\nConsensys\n/\ngnark\nPublic\nNotifications You must be signed in to change notification settings\nFork 433\nStar 1.5k\nCode\nIssues\n101\nPull requests\n35\nDiscussions\nActions\nSecurity\n6\nInsights\nAdditional navigation options\nOut-of-memory during deserialization with crafted inputs\nModerate ivokub published GHSA-cph5-3pgr-c82g on Oct 31, 2024Oct 31, 2024\nPackage\ngomod github.com/consensys/gnark\n(\nGo\n)\nAffected versions\n<=v0.11.0\nPatched versions\n>v0.11.0\nDescription\nThanks @pventuzelo for reporting.\nFrom the correspondence:\nHi,\nWe (Fuzzinglabs & Lambdaclass) found that during deserialization of certain files representing a VerifyingKey, an excessive memory allocation is happening consuming a lot of resources and even triggering a crash with the error fatal error: runtime: out of memory.\nPlease find the details below:\nVulnerability Details\nSeverity: Critical -> DoS\nAffected Component: Deserialization\nEnvironment\nCompiler Version: go version go1.22.2 linux/amd64\nDistro Version: Ubuntu 24.04.1 LTS\nAdditional Environment Details:\n[github.com/consensys/gnark](http://github.com/consensys/gnark) v0.11.0\n[github.com/consensys/gnark-crypto](http://github.com/consensys/gnark-crypto) v0.14.1-0.20240909142611-e6b99e74cec1\nSteps to Reproduce\nYou can download the needed files here: https://drive.google.com/drive/folders/1KQ5I3vv4bUllvqbatGappwbAkIcR2NI_?usp=sharing\nYou have to run\ngo run gnark_poc.go\nin a terminal.\nRunning the provided code will result in a memory crash or an extremely large memory allocation, which can be observed using the following command:\ngo tool pprof -web mem.pprof\nRoot Cause Analysis\nThe provided code loads a VerifyingKey from old.vk by calling the ReadFrom function. This function is implemented in backend/groth16/bn254/marshal.go within the gnark library.\nThe provided example uses the elliptic curve BN-254, so the code resides in the backend/groth16/bn254/ repertory. However, the same error exists in other repertories, such as backend/groth16/bls12-377/.\nAt line 207, a slice is allocated with a length of nbCommitments. This variable is directly extracted from the deserialized file, which, in our case, has a value of 2,327,186,600. This large value may be too big for some configurations, leading to memory allocations of approximately ±1 TB, as observed with pprof.\nDetailed Behavior\ngo run gnark_poc.go\nfatal error: runtime: out of memory\n\nruntime stack:\nruntime.throw({0x5fe946?, 0x2052ae?})\n/usr/lib/go-1.22/src/runtime/panic.go:1023 +0x5c fp=0x7ffd65b321a0 sp=0x7ffd65b32170 pc=0x438a9c\nruntime.sysMapOS(0xc000400000, 0x8ab6400000)\n/usr/lib/go-1.22/src/runtime/mem_linux.go:167 +0x11b fp=0x7ffd65b321e0 sp=0x7ffd65b321a0 pc=0x418bbb\nruntime.sysMap(0xc000400000, 0x8ab6400000, 0x7b19c8?)\n/usr/lib/go-1.22/src/runtime/mem.go:155 +0x34 fp=0x7ffd65b32200 sp=0x7ffd65b321e0 pc=0x418634\nruntime.(*mheap).grow(0x7a17c0, 0x455b066?)\n/usr/lib/go-1.22/src/runtime/mheap.go:1534 +0x236 fp=0x7ffd65b32270 sp=0x7ffd65b32200 pc=0x42b176\nruntime.(*mheap).allocSpan(0x7a17c0, 0x455b066, 0x0, 0x1)\n/usr/lib/go-1.22/src/runtime/mheap.go:1246 +0x1b0 fp=0x7ffd65b32310 sp=0x7ffd65b32270 pc=0x42a850\nruntime.(*mheap).alloc.func1()\n/usr/lib/go-1.22/src/runtime/mheap.go:964 +0x5c fp=0x7ffd65b32358 sp=0x7ffd65b32310 pc=0x42a2fc\nruntime.systemstack(0x46d79f)\n/usr/lib/go-1.22/src/runtime/asm_amd64.s:509 +0x4a fp=0x7ffd65b32368 sp=0x7ffd65b32358 pc=0x46912a\n\ngoroutine 1 gp=0xc0000061c0 m=0 mp=0x798ca0 [running]:\nruntime.systemstack_switch()\n/usr/lib/go-1.22/src/runtime/asm_amd64.s:474 +0x8 fp=0xc000031b68 sp=0xc000031b58 pc=0x4690c8\nruntime.(*mheap).alloc(0x5bc040?, 0xc00012bb08?, 0xa0?)\n/usr/lib/go-1.22/src/runtime/mheap.go:958 +0x5b fp=0xc000031bb0 sp=0xc000031b68 pc=0x42a25b\nruntime.(*mcache).allocLarge(0xc000126510?, 0x8ab60ca800, 0x1)\n/usr/lib/go-1.22/src/runtime/mcache.go:234 +0x87 fp=0xc000031c00 sp=0xc000031bb0 pc=0x4176e7\nruntime.mallocgc(0x8ab60ca800, 0x5d92a0, 0x1)\n/usr/lib/go-1.22/src/runtime/malloc.go:1165 +0x597 fp=0xc000031c88 sp=0xc000031c00 pc=0x40ef97\nruntime.makeslice(0xc00011c180?, 0x0?, 0x2?)\n/usr/lib/go-1.22/src/runtime/slice.go:107 +0x49 fp=0xc000031cb0 sp=0xc000031c88 pc=0x4500c9\n[github.com/consensys/gnark/backend/groth16/bn254.(*VerifyingKey).readFrom(0xc0001b7088](http://github.com/consensys/gnark/backend/groth16/bn254.(*VerifyingKey).readFrom(0xc0001b7088), {0x6598a0, 0xc00011dc50}, 0x0)\n/home/raunan/go/pkg/mod/[github.com/!ronan!thoraval/gnark@v0.0.0-20241007163125-4c0a7511c3d1/backend/groth16/bn254/marshal.go:214](http://github.com/!ronan!thoraval/gnark@v0.0.0-20241007163125-4c0a7511c3d1/backend/groth16/bn254/marshal.go:214) +0x765 fp=0xc000031ea8 sp=0xc000031cb0 pc=0x59b205\n[github.com/consensys/gnark/backend/groth16/bn254.(*VerifyingKey).ReadFrom(0x100469020](http://github.com/consensys/gnark/backend/groth16/bn254.(*VerifyingKey).ReadFrom(0x100469020)?, {0x6598a0?, 0xc00011dc50?})\n/home/raunan/go/pkg/mod/[github.com/!ronan!thoraval/gnark@v0.0.0-20241007163125-4c0a7511c3d1/backend/groth16/bn254/marshal.go:166](http://github.com/!ronan!thoraval/gnark@v0.0.0-20241007163125-4c0a7511c3d1/backend/groth16/bn254/marshal.go:166) +0x1f fp=0xc000031ed8 sp=0xc000031ea8 pc=0x59aa5f\nmain.main()\n/home/raunan/gnark_poc/gnark_poc/gnark_poc.go:19 +0xba fp=0xc000031f50 sp=0xc000031ed8 pc=0x5addda\nruntime.main()\n/usr/lib/go-1.22/src/runtime/proc.go:271 +0x29d fp=0xc000031fe0 sp=0xc000031f50 pc=0x43b55d\nruntime.goexit({})\n/usr/lib/go-1.22/src/runtime/asm_amd64.s:1695 +0x1 fp=0xc000031fe8 sp=0xc000031fe0 pc=0x46b0e1\n\ngoroutine 2 gp=0xc000006c40 m=nil [force gc (idle)]:\nruntime.gopark(0x0?, 0x0?, 0x0?, 0x0?, 0x0?)\n/usr/lib/go-1.22/src/runtime/proc.go:402 +0xce fp=0xc000074fa8 sp=0xc000074f88 pc=0x43b98e\nruntime.goparkunlock(...)\n/usr/lib/go-1.22/src/runtime/proc.go:408\nruntime.forcegchelper()\n/usr/lib/go-1.22/src/runtime/proc.go:326 +0xb3 fp=0xc000074fe0 sp=0xc000074fa8 pc=0x43b813\nruntime.goexit({})\n/usr/lib/go-1.22/src/runtime/asm_amd64.s:1695 +0x1 fp=0xc000074fe8 sp=0xc000074fe0 pc=0x46b0e1\ncreated by runtime.init.6 in goroutine 1\n/usr/lib/go-1.22/src/runtime/proc.go:314 +0x1a\n\ngoroutine 3 gp=0xc000007180 m=nil [GC sweep wait]:\nruntime.gopark(0x0?, 0x0?, 0x0?, 0x0?, 0x0?)\n/usr/lib/go-1.22/src/runtime/proc.go:402 +0xce fp=0xc000075780 sp=0xc000075760 pc=0x43b98e\nruntime.goparkunlock(...)\n/usr/lib/go-1.22/src/runtime/proc.go:408\nruntime.bgsweep(0xc0000240e0)\n/usr/lib/go-1.22/src/runtime/mgcsweep.go:278 +0x94 fp=0xc0000757c8 sp=0xc000075780 pc=0x426cf4\nruntime.gcenable.gowrap1()\n/usr/lib/go-1.22/src/runtime/mgc.go:203 +0x25 fp=0xc0000757e0 sp=0xc0000757c8 pc=0x41b845\nruntime.goexit({})\n/usr/lib/go-1.22/src/runtime/asm_amd64.s:1695 +0x1 fp=0xc0000757e8 sp=0xc0000757e0 pc=0x46b0e1\ncreated by runtime.gcenable in goroutine 1\n/usr/lib/go-1.22/src/runtime/mgc.go:203 +0x66\n\ngoroutine 4 gp=0xc000007340 m=nil [GC scavenge wait]:\nruntime.gopark(0xc0000240e0?, 0x657100?, 0x1?, 0x0?, 0xc000007340?)\n/usr/lib/go-1.22/src/runtime/proc.go:402 +0xce fp=0xc000075f78 sp=0xc000075f58 pc=0x43b98e\nruntime.goparkunlock(...)\n/usr/lib/go-1.22/src/runtime/proc.go:408\nruntime.(*scavengerState).park(0x797520)\n/usr/lib/go-1.22/src/runtime/mgcscavenge.go:425 +0x49 fp=0xc000075fa8 sp=0xc000075f78 pc=0x4246e9\nruntime.bgscavenge(0xc0000240e0)\n/usr/lib/go-1.22/src/runtime/mgcscavenge.go:653 +0x3c fp=0xc000075fc8 sp=0xc000075fa8 pc=0x424c7c\nruntime.gcenable.gowrap2()\n/usr/lib/go-1.22/src/runtime/mgc.go:204 +0x25 fp=0xc000075fe0 sp=0xc000075fc8 pc=0x41b7e5\nruntime.goexit({})\n/usr/lib/go-1.22/src/runtime/asm_amd64.s:1695 +0x1 fp=0xc000075fe8 sp=0xc000075fe0 pc=0x46b0e1\ncreated by runtime.gcenable in goroutine 1\n/usr/lib/go-1.22/src/runtime/mgc.go:204 +0xa5\n\ngoroutine 18 gp=0xc000102700 m=nil [finalizer wait]:\nruntime.gopark(0xc000074648?, 0x40f445?, 0xa8?, 0x1?, 0xc0000061c0?)\n/usr/lib/go-1.22/src/runtime/proc.go:402 +0xce fp=0xc000074620 sp=0xc000074600 pc=0x43b98e\nruntime.runfinq()\n/usr/lib/go-1.22/src/runtime/mfinal.go:194 +0x107 fp=0xc0000747e0 sp=0xc000074620 pc=0x41a887\nruntime.goexit({})\n/usr/lib/go-1.22/src/runtime/asm_amd64.s:1695 +0x1 fp=0xc0000747e8 sp=0xc0000747e0 pc=0x46b0e1\ncreated by runtime.createfing in goroutine 1\n/usr/lib/go-1.22/src/runtime/mfinal.go:164 +0x3d\nexit status 2\nAppendices\nThis problem can also happen with ProvingKey.\nImpact\nProver and verifier denial of service in case of maliciously crafted inputs (public key, verification key).\nPatches\nThe issue is patched in #1307. It was merged to gnark master at 47ae846. The fix will be incorporated in the next minor release of gnark (v0.11.1).\nWorkarounds\nThere are no convenient work-arounds currently. The best approach currently is to run key verification as a separate service which halts the verification pipeline in case of OOM when verification keys come from untrusted sources.\nSeverity\nModerate\n5.5\n/ 10\nCVSS v3 base metrics\nAttack vector\nLocal\nAttack complexity\nLow\nPrivileges required\nLow\nUser interaction\nNone\nScope\nUnchanged\nConfidentiality\nNone\nIntegrity\nNone\nAvailability\nHigh\nLearn more about base metrics\nCVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H\nCVE ID\nCVE-2024-50354\nWeaknesses\nNo CWEs\nCredits\npventuzelo\nReporter\nFooter\n© 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
                "effective": true,
                "effective_reason": "The advisory includes a step-by-step \"Steps to Reproduce\" section along with references to example files and commands."
            }
        ],
        "cwe": [
            {
                "id": "CWE-400",
                "value": "CWE-400: Uncontrolled Resource Consumption"
            }
        ]
    }
}