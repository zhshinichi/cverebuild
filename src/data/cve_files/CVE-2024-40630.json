{
    "CVE-2024-40630": {
        "published_date": "2024-07-15T19:15:06.310Z",
        "patch_commits": [
            {
                "url": "https://github.com/AcademySoftwareFoundation/OpenImageIO/commit/0a2dcb4cf2c3fd4825a146cd3ad929d9d8305ce3",
                "content": "fix(heic): Correctly set imagespec size for heif images\n\nSigned-off-by: Gerrard Tai <42868323+flyyee@users.noreply.github.com>\n\nFilename: src/heif.imageio/heifinput.cpp:\n```\n@@ -247,8 +247,9 @@\nHeifInput::seek_subimage(int subimage, int miplevel)\n #endif\n \n     int bits = m_himage.get_bits_per_pixel(heif_channel_interleaved);\n-    m_spec = ImageSpec(m_ihandle.get_width(), m_ihandle.get_height(), bits / 8,\n-                       TypeUInt8);\n+    m_spec   = ImageSpec(m_himage.get_width(heif_channel_interleaved),\n+                         m_himage.get_height(heif_channel_interleaved), bits / 8,\n+                         TypeUInt8);\n \n     m_spec.attribute(\"oiio:ColorSpace\", \"sRGB\");\n```"
            }
        ],
        "sw_version": "v2.5.13.0",
        "sw_version_wget": "https://github.com/AcademySoftwareFoundation/OpenImageIO/archive/refs/tags/v2.5.13.0.zip",
        "description": "OpenImageIO is a toolset for reading, writing, and manipulating image files of any image file format relevant to VFX / animation via a format-agnostic API with a feature set, scalability, and robustness needed for feature film production. In affected versions there is a bug in the heif input functionality of OpenImageIO. Specifically, in `HeifInput::seek_subimage()`.  In the worst case, this can lead to an information disclosure vulnerability, particularly for programs that directly use the `ImageInput` APIs. This bug has been addressed in commit `0a2dcb4c` which is included in the 2.5.13.1 release. Users are advised to upgrade. There are no known workarounds for this issue.",
        "sec_adv": [
            {
                "url": "https://github.com/AcademySoftwareFoundation/OpenImageIO/security/advisories/GHSA-jjm9-9m4m-c8p2",
                "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\nAcademySoftwareFoundation\n/\nOpenImageIO\nPublic\nNotifications You must be signed in to change notification settings\nFork 627\nStar 2.1k\nCode\nIssues\n152\nPull requests\n34\nDiscussions\nActions\nProjects\n1\nWiki\nSecurity\n1\nInsights\nAdditional navigation options\nHEIF Heap OOB Read\nModerate lgritz published GHSA-jjm9-9m4m-c8p2 on Jul 15, 2024Jul 15, 2024\nPackage\nOpenImageIO\nAffected versions\n< 2.5.13.0\nPatched versions\n>= 2.5.13.1\nDescription\nBug class: Heap OOB read\nReproduction steps:\noiiotool poc.heic -o /tmp/out.jpeg\npoc (download from google drive)\nEnvironment:\nOS: Ubuntu 22.04\nOIIO version: master\nThere is a bug in the heif input functionality of OpenImageIO. Specifically, in HeifInput::seek_subimage() (src). A ImageSpec m_spec is constructed with width and height obtained as follows:\nm_spec = ImageSpec(m_ihandle.get_width(), m_ihandle.get_height(), bits / 8,\n                   TypeUInt8);\nThis uses the libheif ImageHandle::get_width/height() method, which returns the dimension of the heif image handle. These dimensions are later used in calls to HeifInput::read_native_scanline() to read the decoded image's plane buffers:\n    const uint8_t* hdata = m_himage.get_plane(heif_channel_interleaved,\n                                              &ystride);\n    if (!hdata) {\n        errorfmt(\"Unknown read error\");\n        return false;\n    }\n    hdata += (y - m_spec.y) * ystride;\n    memcpy(data, hdata, m_spec.width * m_spec.pixel_bytes());\nHowever, there is no guarantee that the dimensions returned by ImageHandle::get_width/height() match the size of the decoded image's planes. Instead, the decoded image's dimensions should be obtained with Image::get_width/height(channel) (src). The original intention of this usage pattern is to accommodate transformations in the heif file -- the dimensions from the ImageHandle are that of the untransformed image, while the dimensions from the Image are that of the transformed image. However, since the dimensions returned from ImageHandle are obtained by parsing the ispe (Image spatial Extents), it is possible for an attacker to forge the ispe values, which would create an ImageSpec with incorrect dimensions. In such a case, there would be an OOB read on the decoded plane data if the incorrect dimensions in the ImageSpec are trusted.\nThis is indeed the case in ImageInput::read_image(). Using this C++ example, I triggered an ASan fault with this poc. I crafted this poc by using a regular heic file and forging the values of its ispe dimensions from (1440, 960) to (14400, 9600). It is possible to get arbitrary OOB reads by specially crafting the heif file. This poc also crashes oiiotool. This specific command will crash it: oiiotool poc.heic -o out.jpeg (but really any operation that reads the entire image will work).\nIn the worst case, this can lead to an information disclosure vulnerability, particularly for programs that directly use the ImageInput APIs.\nThe fix should be quite simple: Create the ImageSpec as follows, using the Image::get_width/height() methods as mentioned earlier.\nm_spec = ImageSpec(m_himage.get_width(heif_channel_interleaved),\n                   m_himage.get_height(heif_channel_interleaved),\n                   bits / 8, TypeUInt8);\nSeverity\nModerate\nCVE ID\nCVE-2024-40630\nWeaknesses\nCWE-125\nCredits\nflyyee\nReporter\nFooter\nÂ© 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
                "effective": true,
                "effective_reason": "The advisory provides a clear proof of concept (PoC), as it includes a simplified way to reproduce the out-of-bounds read using an example command and explains the crafted input required."
            }
        ],
        "cwe": [
            {
                "id": "CWE-125",
                "value": "CWE-125: Out-of-bounds Read"
            }
        ]
    }
}