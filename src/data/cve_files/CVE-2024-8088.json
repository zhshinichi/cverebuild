{
    "CVE-2024-8088": {
        "published_date": "2024-08-22T18:45:31.807Z",
        "patch_commits": [
            {
                "url": "https://github.com/python/cpython/commit/795f2597a4be988e2bb19b69ff9958e981cb894e",
                "content": "[3.11] gh-122905: Sanitize names in zipfile.Path. (GH-122906) (#122925)\n\n* gh-122905: Sanitize names in zipfile.Path. (#122906)\r\n\r\nPorted from zipp 3.19.1; ref jaraco/zipp#119.\r\n\r\n(cherry picked from commit 9cd03263100ddb1657826cc4a71470786cab3932)\r\n\r\n* [3.11] gh-122905: Sanitize names in zipfile.Path. (GH-122906)\r\n\r\nPorted from zipp 3.19.1; ref jaraco/zippGH-119.\r\n(cherry picked from commit 9cd03263100ddb1657826cc4a71470786cab3932)\r\n\r\nCo-authored-by: Jason R. Coombs <jaraco@jaraco.com>\n\nFilename: Lib/test/test_zipfile.py:\n```\n@@ -3651,6 +3651,23 @@\ndef test_extract_orig_with_implied_dirs(self, alpharep):\n         zipfile.Path(zf)\n         zf.extractall(source_path.parent)\n \n+    def test_malformed_paths(self):\n+        \"\"\"\n+        Path should handle malformed paths.\n+        \"\"\"\n+        data = io.BytesIO()\n+        zf = zipfile.ZipFile(data, \"w\")\n+        zf.writestr(\"/one-slash.txt\", b\"content\")\n+        zf.writestr(\"//two-slash.txt\", b\"content\")\n+        zf.writestr(\"../parent.txt\", b\"content\")\n+        zf.filename = ''\n+        root = zipfile.Path(zf)\n+        assert list(map(str, root.iterdir())) == [\n+            'one-slash.txt',\n+            'two-slash.txt',\n+            'parent.txt',\n+        ]\n+\n \n class EncodedMetadataTests(unittest.TestCase):\n     file_names = ['\\u4e00', '\\u4e8c', '\\u4e09']  # Han 'one', 'two', 'three'\n```\n\nFilename: Lib/zipfile.py:\n```\n@@ -9,6 +9,7 @@\nimport itertools\n import os\n import posixpath\n+import re\n import shutil\n import stat\n import struct\n\n@@ -2243,7 +2244,65 @@\ndef _difference(minuend, subtrahend):\n     return itertools.filterfalse(set(subtrahend).__contains__, minuend)\n \n \n-class CompleteDirs(ZipFile):\n+class SanitizedNames:\n+    \"\"\"\n+    ZipFile mix-in to ensure names are sanitized.\n+    \"\"\"\n+\n+    def namelist(self):\n+        return list(map(self._sanitize, super().namelist()))\n+\n+    @staticmethod\n+    def _sanitize(name):\n+        r\"\"\"\n+        Ensure a relative path with posix separators and no dot names.\n+        Modeled after\n+        https://github.com/python/cpython/blob/bcc1be39cb1d04ad9fc0bd1b9193d3972835a57c/Lib/zipfile/__init__.py#L1799-L1813\n+        but provides consistent cross-platform behavior.\n+        >>> san = SanitizedNames._sanitize\n+        >>> san('/foo/bar')\n+        'foo/bar'\n+        >>> san('//foo.txt')\n+        'foo.txt'\n+        >>> san('foo/.././bar.txt')\n+        'foo/bar.txt'\n+        >>> san('foo../.bar.txt')\n+        'foo../.bar.txt'\n+        >>> san('\\\\foo\\\\bar.txt')\n+        'foo/bar.txt'\n+        >>> san('D:\\\\foo.txt')\n+        'D/foo.txt'\n+        >>> san('\\\\\\\\server\\\\share\\\\file.txt')\n+        'server/share/file.txt'\n+        >>> san('\\\\\\\\?\\\\GLOBALROOT\\\\Volume3')\n+        '?/GLOBALROOT/Volume3'\n+        >>> san('\\\\\\\\.\\\\PhysicalDrive1\\\\root')\n+        'PhysicalDrive1/root'\n+        Retain any trailing slash.\n+        >>> san('abc/')\n+        'abc/'\n+        Raises a ValueError if the result is empty.\n+        >>> san('../..')\n+        Traceback (most recent call last):\n+        ...\n+        ValueError: Empty filename\n+        \"\"\"\n+\n+        def allowed(part):\n+            return part and part not in {'..', '.'}\n+\n+        # Remove the drive letter.\n+        # Don't use ntpath.splitdrive, because that also strips UNC paths\n+        bare = re.sub('^([A-Z]):', r'\\1', name, flags=re.IGNORECASE)\n+        clean = bare.replace('\\\\', '/')\n+        parts = clean.split('/')\n+        joined = '/'.join(filter(allowed, parts))\n+        if not joined:\n+            raise ValueError(\"Empty filename\")\n+        return joined + '/' * name.endswith('/')\n+\n+\n+class CompleteDirs(SanitizedNames, ZipFile):\n     \"\"\"\n     A ZipFile subclass that ensures that implied directories\n     are always included in the namelist.\n```\n\nFilename: Misc/NEWS.d/next/Library/2024-08-11-14-08-04.gh-issue-122905.7tDsxA.rst:\n```\n@@ -0,0 +1 @@\n+:class:`zipfile.Path` objects now sanitize names from the zipfile.\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/8c7348939d8a3ecd79d630075f6be1b0c5b41f64",
                "content": "[3.13] gh-122905: Sanitize names in zipfile.Path. (GH-122906) (#122922)\n\nFilename: Lib/test/test_zipfile/_path/test_path.py:\n```\n@@ -577,3 +577,20 @@\ndef test_getinfo_missing(self, alpharep):\n         zipfile.Path(alpharep)\n         with self.assertRaises(KeyError):\n             alpharep.getinfo('does-not-exist')\n+\n+    def test_malformed_paths(self):\n+        \"\"\"\n+        Path should handle malformed paths.\n+        \"\"\"\n+        data = io.BytesIO()\n+        zf = zipfile.ZipFile(data, \"w\")\n+        zf.writestr(\"/one-slash.txt\", b\"content\")\n+        zf.writestr(\"//two-slash.txt\", b\"content\")\n+        zf.writestr(\"../parent.txt\", b\"content\")\n+        zf.filename = ''\n+        root = zipfile.Path(zf)\n+        assert list(map(str, root.iterdir())) == [\n+            'one-slash.txt',\n+            'two-slash.txt',\n+            'parent.txt',\n+        ]\n```\n\nFilename: Lib/zipfile/_path/__init__.py:\n```\n@@ -85,7 +85,69 @@\ndef __setstate__(self, state):\n         super().__init__(*args, **kwargs)\n \n \n-class CompleteDirs(InitializedState, zipfile.ZipFile):\n+class SanitizedNames:\n+    \"\"\"\n+    ZipFile mix-in to ensure names are sanitized.\n+    \"\"\"\n+\n+    def namelist(self):\n+        return list(map(self._sanitize, super().namelist()))\n+\n+    @staticmethod\n+    def _sanitize(name):\n+        r\"\"\"\n+        Ensure a relative path with posix separators and no dot names.\n+\n+        Modeled after\n+        https://github.com/python/cpython/blob/bcc1be39cb1d04ad9fc0bd1b9193d3972835a57c/Lib/zipfile/__init__.py#L1799-L1813\n+        but provides consistent cross-platform behavior.\n+\n+        >>> san = SanitizedNames._sanitize\n+        >>> san('/foo/bar')\n+        'foo/bar'\n+        >>> san('//foo.txt')\n+        'foo.txt'\n+        >>> san('foo/.././bar.txt')\n+        'foo/bar.txt'\n+        >>> san('foo../.bar.txt')\n+        'foo../.bar.txt'\n+        >>> san('\\\\foo\\\\bar.txt')\n+        'foo/bar.txt'\n+        >>> san('D:\\\\foo.txt')\n+        'D/foo.txt'\n+        >>> san('\\\\\\\\server\\\\share\\\\file.txt')\n+        'server/share/file.txt'\n+        >>> san('\\\\\\\\?\\\\GLOBALROOT\\\\Volume3')\n+        '?/GLOBALROOT/Volume3'\n+        >>> san('\\\\\\\\.\\\\PhysicalDrive1\\\\root')\n+        'PhysicalDrive1/root'\n+\n+        Retain any trailing slash.\n+        >>> san('abc/')\n+        'abc/'\n+\n+        Raises a ValueError if the result is empty.\n+        >>> san('../..')\n+        Traceback (most recent call last):\n+        ...\n+        ValueError: Empty filename\n+        \"\"\"\n+\n+        def allowed(part):\n+            return part and part not in {'..', '.'}\n+\n+        # Remove the drive letter.\n+        # Don't use ntpath.splitdrive, because that also strips UNC paths\n+        bare = re.sub('^([A-Z]):', r'\\1', name, flags=re.IGNORECASE)\n+        clean = bare.replace('\\\\', '/')\n+        parts = clean.split('/')\n+        joined = '/'.join(filter(allowed, parts))\n+        if not joined:\n+            raise ValueError(\"Empty filename\")\n+        return joined + '/' * name.endswith('/')\n+\n+\n+class CompleteDirs(InitializedState, SanitizedNames, zipfile.ZipFile):\n     \"\"\"\n     A ZipFile subclass that ensures that implied directories\n     are always included in the namelist.\n```\n\nFilename: Misc/NEWS.d/next/Library/2024-08-11-14-08-04.gh-issue-122905.7tDsxA.rst:\n```\n@@ -0,0 +1 @@\n+:class:`zipfile.Path` objects now sanitize names from the zipfile.\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/dcc5182f27c1500006a1ef78e10613bb45788dea",
                "content": "[3.12] gh-122905: Sanitize names in zipfile.Path. (GH-122906) (#122923)\n\nFilename: Lib/test/test_zipfile/_path/test_path.py:\n```\n@@ -577,3 +577,20 @@\ndef test_getinfo_missing(self, alpharep):\n         zipfile.Path(alpharep)\n         with self.assertRaises(KeyError):\n             alpharep.getinfo('does-not-exist')\n+\n+    def test_malformed_paths(self):\n+        \"\"\"\n+        Path should handle malformed paths.\n+        \"\"\"\n+        data = io.BytesIO()\n+        zf = zipfile.ZipFile(data, \"w\")\n+        zf.writestr(\"/one-slash.txt\", b\"content\")\n+        zf.writestr(\"//two-slash.txt\", b\"content\")\n+        zf.writestr(\"../parent.txt\", b\"content\")\n+        zf.filename = ''\n+        root = zipfile.Path(zf)\n+        assert list(map(str, root.iterdir())) == [\n+            'one-slash.txt',\n+            'two-slash.txt',\n+            'parent.txt',\n+        ]\n```\n\nFilename: Lib/zipfile/_path/__init__.py:\n```\n@@ -83,7 +83,69 @@\ndef __setstate__(self, state):\n         super().__init__(*args, **kwargs)\n \n \n-class CompleteDirs(InitializedState, zipfile.ZipFile):\n+class SanitizedNames:\n+    \"\"\"\n+    ZipFile mix-in to ensure names are sanitized.\n+    \"\"\"\n+\n+    def namelist(self):\n+        return list(map(self._sanitize, super().namelist()))\n+\n+    @staticmethod\n+    def _sanitize(name):\n+        r\"\"\"\n+        Ensure a relative path with posix separators and no dot names.\n+\n+        Modeled after\n+        https://github.com/python/cpython/blob/bcc1be39cb1d04ad9fc0bd1b9193d3972835a57c/Lib/zipfile/__init__.py#L1799-L1813\n+        but provides consistent cross-platform behavior.\n+\n+        >>> san = SanitizedNames._sanitize\n+        >>> san('/foo/bar')\n+        'foo/bar'\n+        >>> san('//foo.txt')\n+        'foo.txt'\n+        >>> san('foo/.././bar.txt')\n+        'foo/bar.txt'\n+        >>> san('foo../.bar.txt')\n+        'foo../.bar.txt'\n+        >>> san('\\\\foo\\\\bar.txt')\n+        'foo/bar.txt'\n+        >>> san('D:\\\\foo.txt')\n+        'D/foo.txt'\n+        >>> san('\\\\\\\\server\\\\share\\\\file.txt')\n+        'server/share/file.txt'\n+        >>> san('\\\\\\\\?\\\\GLOBALROOT\\\\Volume3')\n+        '?/GLOBALROOT/Volume3'\n+        >>> san('\\\\\\\\.\\\\PhysicalDrive1\\\\root')\n+        'PhysicalDrive1/root'\n+\n+        Retain any trailing slash.\n+        >>> san('abc/')\n+        'abc/'\n+\n+        Raises a ValueError if the result is empty.\n+        >>> san('../..')\n+        Traceback (most recent call last):\n+        ...\n+        ValueError: Empty filename\n+        \"\"\"\n+\n+        def allowed(part):\n+            return part and part not in {'..', '.'}\n+\n+        # Remove the drive letter.\n+        # Don't use ntpath.splitdrive, because that also strips UNC paths\n+        bare = re.sub('^([A-Z]):', r'\\1', name, flags=re.IGNORECASE)\n+        clean = bare.replace('\\\\', '/')\n+        parts = clean.split('/')\n+        joined = '/'.join(filter(allowed, parts))\n+        if not joined:\n+            raise ValueError(\"Empty filename\")\n+        return joined + '/' * name.endswith('/')\n+\n+\n+class CompleteDirs(InitializedState, SanitizedNames, zipfile.ZipFile):\n     \"\"\"\n     A ZipFile subclass that ensures that implied directories\n     are always included in the namelist.\n```\n\nFilename: Misc/NEWS.d/next/Library/2024-08-11-14-08-04.gh-issue-122905.7tDsxA.rst:\n```\n@@ -0,0 +1 @@\n+:class:`zipfile.Path` objects now sanitize names from the zipfile.\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/e0264a61119d551658d9445af38323ba94fc16db",
                "content": "[3.10] gh-122905: Sanitize names in zipfile.Path. (GH-122906) (#123160)\n\n[3.10] [3.11] gh-122905: Sanitize names in zipfile.Path. (GH-122906) (GH-122925)\r\n\r\n* gh-122905: Sanitize names in zipfile.Path. (GH-122906)\r\n\r\nPorted from zipp 3.19.1; ref jaraco/zippGH-119.\r\n\r\n(cherry picked from commit 9cd03263100ddb1657826cc4a71470786cab3932)\r\n\r\n* [3.11] gh-122905: Sanitize names in zipfile.Path. (GH-122906)\r\n\r\nPorted from zipp 3.19.1; ref jaraco/zippGH-119.\r\n(cherry picked from commit 9cd03263100ddb1657826cc4a71470786cab3932)\r\n\r\n(cherry picked from commit 795f2597a4be988e2bb19b69ff9958e981cb894e)\n\nFilename: Lib/test/test_zipfile.py:\n```\n@@ -3280,6 +3280,23 @@\ndef test_extract_orig_with_implied_dirs(self, alpharep):\n         zipfile.Path(zf)\n         zf.extractall(source_path.parent)\n \n+    def test_malformed_paths(self):\n+        \"\"\"\n+        Path should handle malformed paths.\n+        \"\"\"\n+        data = io.BytesIO()\n+        zf = zipfile.ZipFile(data, \"w\")\n+        zf.writestr(\"/one-slash.txt\", b\"content\")\n+        zf.writestr(\"//two-slash.txt\", b\"content\")\n+        zf.writestr(\"../parent.txt\", b\"content\")\n+        zf.filename = ''\n+        root = zipfile.Path(zf)\n+        assert list(map(str, root.iterdir())) == [\n+            'one-slash.txt',\n+            'two-slash.txt',\n+            'parent.txt',\n+        ]\n+\n \n class StripExtraTests(unittest.TestCase):\n     # Note: all of the \"z\" characters are technically invalid, but up\n```\n\nFilename: Lib/zipfile.py:\n```\n@@ -9,6 +9,7 @@\nimport itertools\n import os\n import posixpath\n+import re\n import shutil\n import stat\n import struct\n\n@@ -2182,7 +2183,65 @@\ndef _difference(minuend, subtrahend):\n     return itertools.filterfalse(set(subtrahend).__contains__, minuend)\n \n \n-class CompleteDirs(ZipFile):\n+class SanitizedNames:\n+    \"\"\"\n+    ZipFile mix-in to ensure names are sanitized.\n+    \"\"\"\n+\n+    def namelist(self):\n+        return list(map(self._sanitize, super().namelist()))\n+\n+    @staticmethod\n+    def _sanitize(name):\n+        r\"\"\"\n+        Ensure a relative path with posix separators and no dot names.\n+        Modeled after\n+        https://github.com/python/cpython/blob/bcc1be39cb1d04ad9fc0bd1b9193d3972835a57c/Lib/zipfile/__init__.py#L1799-L1813\n+        but provides consistent cross-platform behavior.\n+        >>> san = SanitizedNames._sanitize\n+        >>> san('/foo/bar')\n+        'foo/bar'\n+        >>> san('//foo.txt')\n+        'foo.txt'\n+        >>> san('foo/.././bar.txt')\n+        'foo/bar.txt'\n+        >>> san('foo../.bar.txt')\n+        'foo../.bar.txt'\n+        >>> san('\\\\foo\\\\bar.txt')\n+        'foo/bar.txt'\n+        >>> san('D:\\\\foo.txt')\n+        'D/foo.txt'\n+        >>> san('\\\\\\\\server\\\\share\\\\file.txt')\n+        'server/share/file.txt'\n+        >>> san('\\\\\\\\?\\\\GLOBALROOT\\\\Volume3')\n+        '?/GLOBALROOT/Volume3'\n+        >>> san('\\\\\\\\.\\\\PhysicalDrive1\\\\root')\n+        'PhysicalDrive1/root'\n+        Retain any trailing slash.\n+        >>> san('abc/')\n+        'abc/'\n+        Raises a ValueError if the result is empty.\n+        >>> san('../..')\n+        Traceback (most recent call last):\n+        ...\n+        ValueError: Empty filename\n+        \"\"\"\n+\n+        def allowed(part):\n+            return part and part not in {'..', '.'}\n+\n+        # Remove the drive letter.\n+        # Don't use ntpath.splitdrive, because that also strips UNC paths\n+        bare = re.sub('^([A-Z]):', r'\\1', name, flags=re.IGNORECASE)\n+        clean = bare.replace('\\\\', '/')\n+        parts = clean.split('/')\n+        joined = '/'.join(filter(allowed, parts))\n+        if not joined:\n+            raise ValueError(\"Empty filename\")\n+        return joined + '/' * name.endswith('/')\n+\n+\n+class CompleteDirs(SanitizedNames, ZipFile):\n     \"\"\"\n     A ZipFile subclass that ensures that implied directories\n     are always included in the namelist.\n```\n\nFilename: Misc/NEWS.d/next/Library/2024-08-11-14-08-04.gh-issue-122905.7tDsxA.rst:\n```\n@@ -0,0 +1 @@\n+:class:`zipfile.Path` objects now sanitize names from the zipfile.\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/2231286d78d328c2f575e0b05b16fe447d1656d6",
                "content": "gh-123270: Replaced SanitizedNames with a more surgical fix. (#123354)\n\nApplies changes from zipp 3.20.1 and jaraco/zipp#124\n\nFilename: Lib/test/test_zipfile/_path/test_path.py:\n```\n@@ -5,6 +5,7 @@\nimport pickle\n import stat\n import sys\n+import time\n import unittest\n import zipfile\n import zipfile._path\n\n@@ -592,7 +593,11 @@\ndef test_getinfo_missing(self, alpharep):\n \n     def test_malformed_paths(self):\n         \"\"\"\n-        Path should handle malformed paths.\n+        Path should handle malformed paths gracefully.\n+\n+        Paths with leading slashes are not visible.\n+\n+        Paths with dots are treated like regular files.\n         \"\"\"\n         data = io.BytesIO()\n         zf = zipfile.ZipFile(data, \"w\")\n\n@@ -601,15 +606,71 @@\ndef test_malformed_paths(self):\n         zf.writestr(\"../parent.txt\", b\"content\")\n         zf.filename = ''\n         root = zipfile.Path(zf)\n-        assert list(map(str, root.iterdir())) == [\n-            'one-slash.txt',\n-            'two-slash.txt',\n-            'parent.txt',\n-        ]\n+        assert list(map(str, root.iterdir())) == ['../']\n+        assert root.joinpath('..').joinpath('parent.txt').read_bytes() == b'content'\n+\n+    def test_unsupported_names(self):\n+        \"\"\"\n+        Path segments with special characters are readable.\n+\n+        On some platforms or file systems, characters like\n+        ``:`` and ``?`` are not allowed, but they are valid\n+        in the zip file.\n+        \"\"\"\n+        data = io.BytesIO()\n+        zf = zipfile.ZipFile(data, \"w\")\n+        zf.writestr(\"path?\", b\"content\")\n+        zf.writestr(\"V: NMS.flac\", b\"fLaC...\")\n+        zf.filename = ''\n+        root = zipfile.Path(zf)\n+        contents = root.iterdir()\n+        assert next(contents).name == 'path?'\n+        assert next(contents).name == 'V: NMS.flac'\n+        assert root.joinpath('V: NMS.flac').read_bytes() == b\"fLaC...\"\n+\n+    def test_backslash_not_separator(self):\n+        \"\"\"\n+        In a zip file, backslashes are not separators.\n+        \"\"\"\n+        data = io.BytesIO()\n+        zf = zipfile.ZipFile(data, \"w\")\n+        zf.writestr(DirtyZipInfo.for_name(\"foo\\\\bar\", zf), b\"content\")\n+        zf.filename = ''\n+        root = zipfile.Path(zf)\n+        (first,) = root.iterdir()\n+        assert not first.is_dir()\n+        assert first.name == 'foo\\\\bar'\n \n     @pass_alpharep\n     def test_interface(self, alpharep):\n         from importlib.resources.abc import Traversable\n \n         zf = zipfile.Path(alpharep)\n         assert isinstance(zf, Traversable)\n+\n+\n+class DirtyZipInfo(zipfile.ZipInfo):\n+    \"\"\"\n+    Bypass name sanitization.\n+    \"\"\"\n+\n+    def __init__(self, filename, *args, **kwargs):\n+        super().__init__(filename, *args, **kwargs)\n+        self.filename = filename\n+\n+    @classmethod\n+    def for_name(cls, name, archive):\n+        \"\"\"\n+        Construct the same way that ZipFile.writestr does.\n+\n+        TODO: extract this functionality and re-use\n+        \"\"\"\n+        self = cls(filename=name, date_time=time.localtime(time.time())[:6])\n+        self.compress_type = archive.compression\n+        self.compress_level = archive.compresslevel\n+        if self.filename.endswith('/'):  # pragma: no cover\n+            self.external_attr = 0o40775 << 16  # drwxrwxr-x\n+            self.external_attr |= 0x10  # MS-DOS directory flag\n+        else:\n+            self.external_attr = 0o600 << 16  # ?rw-------\n+        return self\n```\n\nFilename: Lib/zipfile/_path/__init__.py:\n```\n@@ -1,3 +1,12 @@\n+\"\"\"\n+A Path-like interface for zipfiles.\n+\n+This codebase is shared between zipfile.Path in the stdlib\n+and zipp in PyPI. See\n+https://github.com/python/importlib_metadata/wiki/Development-Methodology\n+for more detail.\n+\"\"\"\n+\n import io\n import posixpath\n import zipfile\n\n@@ -36,7 +45,7 @@\ndef _parents(path):\n def _ancestry(path):\n     \"\"\"\n     Given a path with elements separated by\n-    posixpath.sep, generate all elements of that path\n+    posixpath.sep, generate all elements of that path.\n \n     >>> list(_ancestry('b/d'))\n     ['b/d', 'b']\n\n@@ -48,9 +57,14 @@\ndef _ancestry(path):\n     ['b']\n     >>> list(_ancestry(''))\n     []\n+\n+    Multiple separators are treated like a single.\n+\n+    >>> list(_ancestry('//b//d///f//'))\n+    ['//b//d///f', '//b//d', '//b']\n     \"\"\"\n     path = path.rstrip(posixpath.sep)\n-    while path and path != posixpath.sep:\n+    while path.rstrip(posixpath.sep):\n         yield path\n         path, tail = posixpath.split(path)\n\n@@ -85,69 +99,7 @@\ndef __setstate__(self, state):\n         super().__init__(*args, **kwargs)\n \n \n-class SanitizedNames:\n-    \"\"\"\n-    ZipFile mix-in to ensure names are sanitized.\n-    \"\"\"\n-\n-    def namelist(self):\n-        return list(map(self._sanitize, super().namelist()))\n-\n-    @staticmethod\n-    def _sanitize(name):\n-        r\"\"\"\n-        Ensure a relative path with posix separators and no dot names.\n-\n-        Modeled after\n-        https://github.com/python/cpython/blob/bcc1be39cb1d04ad9fc0bd1b9193d3972835a57c/Lib/zipfile/__init__.py#L1799-L1813\n-        but provides consistent cross-platform behavior.\n-\n-        >>> san = SanitizedNames._sanitize\n-        >>> san('/foo/bar')\n-        'foo/bar'\n-        >>> san('//foo.txt')\n-        'foo.txt'\n-        >>> san('foo/.././bar.txt')\n-        'foo/bar.txt'\n-        >>> san('foo../.bar.txt')\n-        'foo../.bar.txt'\n-        >>> san('\\\\foo\\\\bar.txt')\n-        'foo/bar.txt'\n-        >>> san('D:\\\\foo.txt')\n-        'D/foo.txt'\n-        >>> san('\\\\\\\\server\\\\share\\\\file.txt')\n-        'server/share/file.txt'\n-        >>> san('\\\\\\\\?\\\\GLOBALROOT\\\\Volume3')\n-        '?/GLOBALROOT/Volume3'\n-        >>> san('\\\\\\\\.\\\\PhysicalDrive1\\\\root')\n-        'PhysicalDrive1/root'\n-\n-        Retain any trailing slash.\n-        >>> san('abc/')\n-        'abc/'\n-\n-        Raises a ValueError if the result is empty.\n-        >>> san('../..')\n-        Traceback (most recent call last):\n-        ...\n-        ValueError: Empty filename\n-        \"\"\"\n-\n-        def allowed(part):\n-            return part and part not in {'..', '.'}\n-\n-        # Remove the drive letter.\n-        # Don't use ntpath.splitdrive, because that also strips UNC paths\n-        bare = re.sub('^([A-Z]):', r'\\1', name, flags=re.IGNORECASE)\n-        clean = bare.replace('\\\\', '/')\n-        parts = clean.split('/')\n-        joined = '/'.join(filter(allowed, parts))\n-        if not joined:\n-            raise ValueError(\"Empty filename\")\n-        return joined + '/' * name.endswith('/')\n-\n-\n-class CompleteDirs(InitializedState, SanitizedNames, zipfile.ZipFile):\n+class CompleteDirs(InitializedState, zipfile.ZipFile):\n     \"\"\"\n     A ZipFile subclass that ensures that implied directories\n     are always included in the namelist.\n```\n\nFilename: Misc/NEWS.d/next/Library/2024-08-26-13-45-20.gh-issue-123270.gXHvNJ.rst:\n```\n@@ -0,0 +1,3 @@\n+Applied a more surgical fix for malformed payloads in :class:`zipfile.Path`\n+causing infinite loops (gh-122905) without breaking contents using\n+legitimate characters.\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/7e8883a3f04d308302361aeffc73e0e9837f19d4",
                "content": "[3.13] gh-123270: Replaced SanitizedNames with a more surgical fix. (GH-123354) (#123410)\n\ngh-123270: Replaced SanitizedNames with a more surgical fix. (GH-123354)\r\n\r\nApplies changes from zipp 3.20.1 and jaraco/zippGH-124\r\n(cherry picked from commit 2231286d78d328c2f575e0b05b16fe447d1656d6)\r\n\r\nCo-authored-by: Jason R. Coombs <jaraco@jaraco.com>\n\nFilename: Lib/test/test_zipfile/_path/test_path.py:\n```\n@@ -5,6 +5,7 @@\nimport pickle\n import stat\n import sys\n+import time\n import unittest\n import zipfile\n import zipfile._path\n\n@@ -592,7 +593,11 @@\ndef test_getinfo_missing(self, alpharep):\n \n     def test_malformed_paths(self):\n         \"\"\"\n-        Path should handle malformed paths.\n+        Path should handle malformed paths gracefully.\n+\n+        Paths with leading slashes are not visible.\n+\n+        Paths with dots are treated like regular files.\n         \"\"\"\n         data = io.BytesIO()\n         zf = zipfile.ZipFile(data, \"w\")\n\n@@ -601,15 +606,71 @@\ndef test_malformed_paths(self):\n         zf.writestr(\"../parent.txt\", b\"content\")\n         zf.filename = ''\n         root = zipfile.Path(zf)\n-        assert list(map(str, root.iterdir())) == [\n-            'one-slash.txt',\n-            'two-slash.txt',\n-            'parent.txt',\n-        ]\n+        assert list(map(str, root.iterdir())) == ['../']\n+        assert root.joinpath('..').joinpath('parent.txt').read_bytes() == b'content'\n+\n+    def test_unsupported_names(self):\n+        \"\"\"\n+        Path segments with special characters are readable.\n+\n+        On some platforms or file systems, characters like\n+        ``:`` and ``?`` are not allowed, but they are valid\n+        in the zip file.\n+        \"\"\"\n+        data = io.BytesIO()\n+        zf = zipfile.ZipFile(data, \"w\")\n+        zf.writestr(\"path?\", b\"content\")\n+        zf.writestr(\"V: NMS.flac\", b\"fLaC...\")\n+        zf.filename = ''\n+        root = zipfile.Path(zf)\n+        contents = root.iterdir()\n+        assert next(contents).name == 'path?'\n+        assert next(contents).name == 'V: NMS.flac'\n+        assert root.joinpath('V: NMS.flac').read_bytes() == b\"fLaC...\"\n+\n+    def test_backslash_not_separator(self):\n+        \"\"\"\n+        In a zip file, backslashes are not separators.\n+        \"\"\"\n+        data = io.BytesIO()\n+        zf = zipfile.ZipFile(data, \"w\")\n+        zf.writestr(DirtyZipInfo.for_name(\"foo\\\\bar\", zf), b\"content\")\n+        zf.filename = ''\n+        root = zipfile.Path(zf)\n+        (first,) = root.iterdir()\n+        assert not first.is_dir()\n+        assert first.name == 'foo\\\\bar'\n \n     @pass_alpharep\n     def test_interface(self, alpharep):\n         from importlib.resources.abc import Traversable\n \n         zf = zipfile.Path(alpharep)\n         assert isinstance(zf, Traversable)\n+\n+\n+class DirtyZipInfo(zipfile.ZipInfo):\n+    \"\"\"\n+    Bypass name sanitization.\n+    \"\"\"\n+\n+    def __init__(self, filename, *args, **kwargs):\n+        super().__init__(filename, *args, **kwargs)\n+        self.filename = filename\n+\n+    @classmethod\n+    def for_name(cls, name, archive):\n+        \"\"\"\n+        Construct the same way that ZipFile.writestr does.\n+\n+        TODO: extract this functionality and re-use\n+        \"\"\"\n+        self = cls(filename=name, date_time=time.localtime(time.time())[:6])\n+        self.compress_type = archive.compression\n+        self.compress_level = archive.compresslevel\n+        if self.filename.endswith('/'):  # pragma: no cover\n+            self.external_attr = 0o40775 << 16  # drwxrwxr-x\n+            self.external_attr |= 0x10  # MS-DOS directory flag\n+        else:\n+            self.external_attr = 0o600 << 16  # ?rw-------\n+        return self\n```\n\nFilename: Lib/zipfile/_path/__init__.py:\n```\n@@ -1,3 +1,12 @@\n+\"\"\"\n+A Path-like interface for zipfiles.\n+\n+This codebase is shared between zipfile.Path in the stdlib\n+and zipp in PyPI. See\n+https://github.com/python/importlib_metadata/wiki/Development-Methodology\n+for more detail.\n+\"\"\"\n+\n import io\n import posixpath\n import zipfile\n\n@@ -36,7 +45,7 @@\ndef _parents(path):\n def _ancestry(path):\n     \"\"\"\n     Given a path with elements separated by\n-    posixpath.sep, generate all elements of that path\n+    posixpath.sep, generate all elements of that path.\n \n     >>> list(_ancestry('b/d'))\n     ['b/d', 'b']\n\n@@ -48,9 +57,14 @@\ndef _ancestry(path):\n     ['b']\n     >>> list(_ancestry(''))\n     []\n+\n+    Multiple separators are treated like a single.\n+\n+    >>> list(_ancestry('//b//d///f//'))\n+    ['//b//d///f', '//b//d', '//b']\n     \"\"\"\n     path = path.rstrip(posixpath.sep)\n-    while path and path != posixpath.sep:\n+    while path.rstrip(posixpath.sep):\n         yield path\n         path, tail = posixpath.split(path)\n\n@@ -85,69 +99,7 @@\ndef __setstate__(self, state):\n         super().__init__(*args, **kwargs)\n \n \n-class SanitizedNames:\n-    \"\"\"\n-    ZipFile mix-in to ensure names are sanitized.\n-    \"\"\"\n-\n-    def namelist(self):\n-        return list(map(self._sanitize, super().namelist()))\n-\n-    @staticmethod\n-    def _sanitize(name):\n-        r\"\"\"\n-        Ensure a relative path with posix separators and no dot names.\n-\n-        Modeled after\n-        https://github.com/python/cpython/blob/bcc1be39cb1d04ad9fc0bd1b9193d3972835a57c/Lib/zipfile/__init__.py#L1799-L1813\n-        but provides consistent cross-platform behavior.\n-\n-        >>> san = SanitizedNames._sanitize\n-        >>> san('/foo/bar')\n-        'foo/bar'\n-        >>> san('//foo.txt')\n-        'foo.txt'\n-        >>> san('foo/.././bar.txt')\n-        'foo/bar.txt'\n-        >>> san('foo../.bar.txt')\n-        'foo../.bar.txt'\n-        >>> san('\\\\foo\\\\bar.txt')\n-        'foo/bar.txt'\n-        >>> san('D:\\\\foo.txt')\n-        'D/foo.txt'\n-        >>> san('\\\\\\\\server\\\\share\\\\file.txt')\n-        'server/share/file.txt'\n-        >>> san('\\\\\\\\?\\\\GLOBALROOT\\\\Volume3')\n-        '?/GLOBALROOT/Volume3'\n-        >>> san('\\\\\\\\.\\\\PhysicalDrive1\\\\root')\n-        'PhysicalDrive1/root'\n-\n-        Retain any trailing slash.\n-        >>> san('abc/')\n-        'abc/'\n-\n-        Raises a ValueError if the result is empty.\n-        >>> san('../..')\n-        Traceback (most recent call last):\n-        ...\n-        ValueError: Empty filename\n-        \"\"\"\n-\n-        def allowed(part):\n-            return part and part not in {'..', '.'}\n-\n-        # Remove the drive letter.\n-        # Don't use ntpath.splitdrive, because that also strips UNC paths\n-        bare = re.sub('^([A-Z]):', r'\\1', name, flags=re.IGNORECASE)\n-        clean = bare.replace('\\\\', '/')\n-        parts = clean.split('/')\n-        joined = '/'.join(filter(allowed, parts))\n-        if not joined:\n-            raise ValueError(\"Empty filename\")\n-        return joined + '/' * name.endswith('/')\n-\n-\n-class CompleteDirs(InitializedState, SanitizedNames, zipfile.ZipFile):\n+class CompleteDirs(InitializedState, zipfile.ZipFile):\n     \"\"\"\n     A ZipFile subclass that ensures that implied directories\n     are always included in the namelist.\n```\n\nFilename: Misc/NEWS.d/next/Library/2024-08-26-13-45-20.gh-issue-123270.gXHvNJ.rst:\n```\n@@ -0,0 +1,3 @@\n+Applied a more surgical fix for malformed payloads in :class:`zipfile.Path`\n+causing infinite loops (gh-122905) without breaking contents using\n+legitimate characters.\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/95b073bddefa6243effa08e131e297c0383e7f6a",
                "content": "[3.12] gh-123270: Replaced SanitizedNames with a more surgical fix. (GH-123354) (#123411)\n\ngh-123270: Replaced SanitizedNames with a more surgical fix. (GH-123354)\r\n\r\nApplies changes from zipp 3.20.1 and jaraco/zippGH-124\r\n(cherry picked from commit 2231286d78d328c2f575e0b05b16fe447d1656d6)\r\n\r\nCo-authored-by: Jason R. Coombs <jaraco@jaraco.com>\n\nFilename: Lib/test/test_zipfile/_path/test_path.py:\n```\n@@ -4,6 +4,7 @@\nimport pathlib\n import pickle\n import sys\n+import time\n import unittest\n import zipfile\n\n@@ -592,7 +593,11 @@\ndef test_getinfo_missing(self, alpharep):\n \n     def test_malformed_paths(self):\n         \"\"\"\n-        Path should handle malformed paths.\n+        Path should handle malformed paths gracefully.\n+\n+        Paths with leading slashes are not visible.\n+\n+        Paths with dots are treated like regular files.\n         \"\"\"\n         data = io.BytesIO()\n         zf = zipfile.ZipFile(data, \"w\")\n\n@@ -601,15 +606,71 @@\ndef test_malformed_paths(self):\n         zf.writestr(\"../parent.txt\", b\"content\")\n         zf.filename = ''\n         root = zipfile.Path(zf)\n-        assert list(map(str, root.iterdir())) == [\n-            'one-slash.txt',\n-            'two-slash.txt',\n-            'parent.txt',\n-        ]\n+        assert list(map(str, root.iterdir())) == ['../']\n+        assert root.joinpath('..').joinpath('parent.txt').read_bytes() == b'content'\n+\n+    def test_unsupported_names(self):\n+        \"\"\"\n+        Path segments with special characters are readable.\n+\n+        On some platforms or file systems, characters like\n+        ``:`` and ``?`` are not allowed, but they are valid\n+        in the zip file.\n+        \"\"\"\n+        data = io.BytesIO()\n+        zf = zipfile.ZipFile(data, \"w\")\n+        zf.writestr(\"path?\", b\"content\")\n+        zf.writestr(\"V: NMS.flac\", b\"fLaC...\")\n+        zf.filename = ''\n+        root = zipfile.Path(zf)\n+        contents = root.iterdir()\n+        assert next(contents).name == 'path?'\n+        assert next(contents).name == 'V: NMS.flac'\n+        assert root.joinpath('V: NMS.flac').read_bytes() == b\"fLaC...\"\n+\n+    def test_backslash_not_separator(self):\n+        \"\"\"\n+        In a zip file, backslashes are not separators.\n+        \"\"\"\n+        data = io.BytesIO()\n+        zf = zipfile.ZipFile(data, \"w\")\n+        zf.writestr(DirtyZipInfo.for_name(\"foo\\\\bar\", zf), b\"content\")\n+        zf.filename = ''\n+        root = zipfile.Path(zf)\n+        (first,) = root.iterdir()\n+        assert not first.is_dir()\n+        assert first.name == 'foo\\\\bar'\n \n     @pass_alpharep\n     def test_interface(self, alpharep):\n         from importlib.resources.abc import Traversable\n \n         zf = zipfile.Path(alpharep)\n         assert isinstance(zf, Traversable)\n+\n+\n+class DirtyZipInfo(zipfile.ZipInfo):\n+    \"\"\"\n+    Bypass name sanitization.\n+    \"\"\"\n+\n+    def __init__(self, filename, *args, **kwargs):\n+        super().__init__(filename, *args, **kwargs)\n+        self.filename = filename\n+\n+    @classmethod\n+    def for_name(cls, name, archive):\n+        \"\"\"\n+        Construct the same way that ZipFile.writestr does.\n+\n+        TODO: extract this functionality and re-use\n+        \"\"\"\n+        self = cls(filename=name, date_time=time.localtime(time.time())[:6])\n+        self.compress_type = archive.compression\n+        self.compress_level = archive.compresslevel\n+        if self.filename.endswith('/'):  # pragma: no cover\n+            self.external_attr = 0o40775 << 16  # drwxrwxr-x\n+            self.external_attr |= 0x10  # MS-DOS directory flag\n+        else:\n+            self.external_attr = 0o600 << 16  # ?rw-------\n+        return self\n```\n\nFilename: Lib/zipfile/_path/__init__.py:\n```\n@@ -1,3 +1,12 @@\n+\"\"\"\n+A Path-like interface for zipfiles.\n+\n+This codebase is shared between zipfile.Path in the stdlib\n+and zipp in PyPI. See\n+https://github.com/python/importlib_metadata/wiki/Development-Methodology\n+for more detail.\n+\"\"\"\n+\n import io\n import posixpath\n import zipfile\n\n@@ -34,7 +43,7 @@\ndef _parents(path):\n def _ancestry(path):\n     \"\"\"\n     Given a path with elements separated by\n-    posixpath.sep, generate all elements of that path\n+    posixpath.sep, generate all elements of that path.\n \n     >>> list(_ancestry('b/d'))\n     ['b/d', 'b']\n\n@@ -46,9 +55,14 @@\ndef _ancestry(path):\n     ['b']\n     >>> list(_ancestry(''))\n     []\n+\n+    Multiple separators are treated like a single.\n+\n+    >>> list(_ancestry('//b//d///f//'))\n+    ['//b//d///f', '//b//d', '//b']\n     \"\"\"\n     path = path.rstrip(posixpath.sep)\n-    while path and path != posixpath.sep:\n+    while path.rstrip(posixpath.sep):\n         yield path\n         path, tail = posixpath.split(path)\n\n@@ -83,69 +97,7 @@\ndef __setstate__(self, state):\n         super().__init__(*args, **kwargs)\n \n \n-class SanitizedNames:\n-    \"\"\"\n-    ZipFile mix-in to ensure names are sanitized.\n-    \"\"\"\n-\n-    def namelist(self):\n-        return list(map(self._sanitize, super().namelist()))\n-\n-    @staticmethod\n-    def _sanitize(name):\n-        r\"\"\"\n-        Ensure a relative path with posix separators and no dot names.\n-\n-        Modeled after\n-        https://github.com/python/cpython/blob/bcc1be39cb1d04ad9fc0bd1b9193d3972835a57c/Lib/zipfile/__init__.py#L1799-L1813\n-        but provides consistent cross-platform behavior.\n-\n-        >>> san = SanitizedNames._sanitize\n-        >>> san('/foo/bar')\n-        'foo/bar'\n-        >>> san('//foo.txt')\n-        'foo.txt'\n-        >>> san('foo/.././bar.txt')\n-        'foo/bar.txt'\n-        >>> san('foo../.bar.txt')\n-        'foo../.bar.txt'\n-        >>> san('\\\\foo\\\\bar.txt')\n-        'foo/bar.txt'\n-        >>> san('D:\\\\foo.txt')\n-        'D/foo.txt'\n-        >>> san('\\\\\\\\server\\\\share\\\\file.txt')\n-        'server/share/file.txt'\n-        >>> san('\\\\\\\\?\\\\GLOBALROOT\\\\Volume3')\n-        '?/GLOBALROOT/Volume3'\n-        >>> san('\\\\\\\\.\\\\PhysicalDrive1\\\\root')\n-        'PhysicalDrive1/root'\n-\n-        Retain any trailing slash.\n-        >>> san('abc/')\n-        'abc/'\n-\n-        Raises a ValueError if the result is empty.\n-        >>> san('../..')\n-        Traceback (most recent call last):\n-        ...\n-        ValueError: Empty filename\n-        \"\"\"\n-\n-        def allowed(part):\n-            return part and part not in {'..', '.'}\n-\n-        # Remove the drive letter.\n-        # Don't use ntpath.splitdrive, because that also strips UNC paths\n-        bare = re.sub('^([A-Z]):', r'\\1', name, flags=re.IGNORECASE)\n-        clean = bare.replace('\\\\', '/')\n-        parts = clean.split('/')\n-        joined = '/'.join(filter(allowed, parts))\n-        if not joined:\n-            raise ValueError(\"Empty filename\")\n-        return joined + '/' * name.endswith('/')\n-\n-\n-class CompleteDirs(InitializedState, SanitizedNames, zipfile.ZipFile):\n+class CompleteDirs(InitializedState, zipfile.ZipFile):\n     \"\"\"\n     A ZipFile subclass that ensures that implied directories\n     are always included in the namelist.\n```\n\nFilename: Misc/NEWS.d/next/Library/2024-08-26-13-45-20.gh-issue-123270.gXHvNJ.rst:\n```\n@@ -0,0 +1,3 @@\n+Applied a more surgical fix for malformed payloads in :class:`zipfile.Path`\n+causing infinite loops (gh-122905) without breaking contents using\n+legitimate characters.\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/7bc367e464ce50b956dd232c1dfa1cad4e7fb814",
                "content": "[3.8] gh-123270: Replaced SanitizedNames with a more surgical fix. (GH-123354) (#123433)\n\nApplies changes from zipp 3.20.1 and jaraco/zippGH-124\r\n(cherry picked from commit 2231286d78d328c2f575e0b05b16fe447d1656d6)\r\n(cherry picked from commit 17b77bb41409259bad1cd6c74761c18b6ab1e860)\r\n(cherry picked from commit 66d3383)\r\n\r\nCo-authored-by: Jason R. Coombs <jaraco@jaraco.com>\n\nFilename: Lib/test/test_zipfile.py:\n```\n@@ -3007,6 +3007,83 @@\ndef test_implied_dirs_performance(self):\n         data = ['/'.join(string.ascii_lowercase + str(n)) for n in range(10000)]\n         zipfile.CompleteDirs._implied_dirs(data)\n \n+    def test_malformed_paths(self):\n+        \"\"\"\n+        Path should handle malformed paths gracefully.\n+\n+        Paths with leading slashes are not visible.\n+\n+        Paths with dots are treated like regular files.\n+        \"\"\"\n+        data = io.BytesIO()\n+        zf = zipfile.ZipFile(data, \"w\")\n+        zf.writestr(\"/one-slash.txt\", b\"content\")\n+        zf.writestr(\"//two-slash.txt\", b\"content\")\n+        zf.writestr(\"../parent.txt\", b\"content\")\n+        zf.filename = ''\n+        root = zipfile.Path(zf)\n+        assert list(map(str, root.iterdir())) == ['../']\n+        assert root.joinpath('..').joinpath('parent.txt').read_bytes() == b'content'\n+\n+    def test_unsupported_names(self):\n+        \"\"\"\n+        Path segments with special characters are readable.\n+\n+        On some platforms or file systems, characters like\n+        ``:`` and ``?`` are not allowed, but they are valid\n+        in the zip file.\n+        \"\"\"\n+        data = io.BytesIO()\n+        zf = zipfile.ZipFile(data, \"w\")\n+        zf.writestr(\"path?\", b\"content\")\n+        zf.writestr(\"V: NMS.flac\", b\"fLaC...\")\n+        zf.filename = ''\n+        root = zipfile.Path(zf)\n+        contents = root.iterdir()\n+        assert next(contents).name == 'path?'\n+        assert next(contents).name == 'V: NMS.flac'\n+        assert root.joinpath('V: NMS.flac').read_bytes() == b\"fLaC...\"\n+\n+    def test_backslash_not_separator(self):\n+        \"\"\"\n+        In a zip file, backslashes are not separators.\n+        \"\"\"\n+        data = io.BytesIO()\n+        zf = zipfile.ZipFile(data, \"w\")\n+        zf.writestr(DirtyZipInfo.for_name(\"foo\\\\bar\", zf), b\"content\")\n+        zf.filename = ''\n+        root = zipfile.Path(zf)\n+        (first,) = root.iterdir()\n+        assert not first.is_dir()\n+        assert first.name == 'foo\\\\bar'\n+\n+\n+class DirtyZipInfo(zipfile.ZipInfo):\n+    \"\"\"\n+    Bypass name sanitization.\n+    \"\"\"\n+\n+    def __init__(self, filename, *args, **kwargs):\n+        super().__init__(filename, *args, **kwargs)\n+        self.filename = filename\n+\n+    @classmethod\n+    def for_name(cls, name, archive):\n+        \"\"\"\n+        Construct the same way that ZipFile.writestr does.\n+\n+        TODO: extract this functionality and re-use\n+        \"\"\"\n+        self = cls(filename=name, date_time=time.localtime(time.time())[:6])\n+        self.compress_type = archive.compression\n+        self.compress_level = archive.compresslevel\n+        if self.filename.endswith('/'):  # pragma: no cover\n+            self.external_attr = 0o40775 << 16  # drwxrwxr-x\n+            self.external_attr |= 0x10  # MS-DOS directory flag\n+        else:\n+            self.external_attr = 0o600 << 16  # ?rw-------\n+        return self\n+\n \n if __name__ == \"__main__\":\n     unittest.main()\n```\n\nFilename: Lib/zipfile.py:\n```\n@@ -2161,7 +2161,7 @@\ndef _parents(path):\n def _ancestry(path):\n     \"\"\"\n     Given a path with elements separated by\n-    posixpath.sep, generate all elements of that path\n+    posixpath.sep, generate all elements of that path.\n \n     >>> list(_ancestry('b/d'))\n     ['b/d', 'b']\n\n@@ -2173,9 +2173,14 @@\ndef _ancestry(path):\n     ['b']\n     >>> list(_ancestry(''))\n     []\n+\n+    Multiple separators are treated like a single.\n+\n+    >>> list(_ancestry('//b//d///f//'))\n+    ['//b//d///f', '//b//d', '//b']\n     \"\"\"\n     path = path.rstrip(posixpath.sep)\n-    while path and path != posixpath.sep:\n+    while path.rstrip(posixpath.sep):\n         yield path\n         path, tail = posixpath.split(path)\n```\n\nFilename: Misc/NEWS.d/next/Library/2024-08-26-13-45-20.gh-issue-123270.gXHvNJ.rst:\n```\n@@ -0,0 +1,3 @@\n+Applied a more surgical fix for malformed payloads in :class:`zipfile.Path`\n+causing infinite loops (gh-122905) without breaking contents using\n+legitimate characters.\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/962055268ed4f2ca1d717bfc8b6385de50a23ab7",
                "content": "[3.9] gh-123270: Replaced SanitizedNames with a more surgical fix. (GH-123354) (#123432)\n\nApplies changes from zipp 3.20.1 and jaraco/zippGH-124\r\n(cherry picked from commit 2231286d78d328c2f575e0b05b16fe447d1656d6)\r\n(cherry picked from commit 17b77bb41409259bad1cd6c74761c18b6ab1e860)\r\n\r\nCo-authored-by: Jason R. Coombs <jaraco@jaraco.com>\n\nFilename: Lib/test/test_zipfile.py:\n```\n@@ -3054,6 +3054,83 @@\ndef test_implied_dirs_performance(self):\n         data = ['/'.join(string.ascii_lowercase + str(n)) for n in range(10000)]\n         zipfile.CompleteDirs._implied_dirs(data)\n \n+    def test_malformed_paths(self):\n+        \"\"\"\n+        Path should handle malformed paths gracefully.\n+\n+        Paths with leading slashes are not visible.\n+\n+        Paths with dots are treated like regular files.\n+        \"\"\"\n+        data = io.BytesIO()\n+        zf = zipfile.ZipFile(data, \"w\")\n+        zf.writestr(\"/one-slash.txt\", b\"content\")\n+        zf.writestr(\"//two-slash.txt\", b\"content\")\n+        zf.writestr(\"../parent.txt\", b\"content\")\n+        zf.filename = ''\n+        root = zipfile.Path(zf)\n+        assert list(map(str, root.iterdir())) == ['../']\n+        assert root.joinpath('..').joinpath('parent.txt').read_bytes() == b'content'\n+\n+    def test_unsupported_names(self):\n+        \"\"\"\n+        Path segments with special characters are readable.\n+\n+        On some platforms or file systems, characters like\n+        ``:`` and ``?`` are not allowed, but they are valid\n+        in the zip file.\n+        \"\"\"\n+        data = io.BytesIO()\n+        zf = zipfile.ZipFile(data, \"w\")\n+        zf.writestr(\"path?\", b\"content\")\n+        zf.writestr(\"V: NMS.flac\", b\"fLaC...\")\n+        zf.filename = ''\n+        root = zipfile.Path(zf)\n+        contents = root.iterdir()\n+        assert next(contents).name == 'path?'\n+        assert next(contents).name == 'V: NMS.flac'\n+        assert root.joinpath('V: NMS.flac').read_bytes() == b\"fLaC...\"\n+\n+    def test_backslash_not_separator(self):\n+        \"\"\"\n+        In a zip file, backslashes are not separators.\n+        \"\"\"\n+        data = io.BytesIO()\n+        zf = zipfile.ZipFile(data, \"w\")\n+        zf.writestr(DirtyZipInfo.for_name(\"foo\\\\bar\", zf), b\"content\")\n+        zf.filename = ''\n+        root = zipfile.Path(zf)\n+        (first,) = root.iterdir()\n+        assert not first.is_dir()\n+        assert first.name == 'foo\\\\bar'\n+\n+\n+class DirtyZipInfo(zipfile.ZipInfo):\n+    \"\"\"\n+    Bypass name sanitization.\n+    \"\"\"\n+\n+    def __init__(self, filename, *args, **kwargs):\n+        super().__init__(filename, *args, **kwargs)\n+        self.filename = filename\n+\n+    @classmethod\n+    def for_name(cls, name, archive):\n+        \"\"\"\n+        Construct the same way that ZipFile.writestr does.\n+\n+        TODO: extract this functionality and re-use\n+        \"\"\"\n+        self = cls(filename=name, date_time=time.localtime(time.time())[:6])\n+        self.compress_type = archive.compression\n+        self.compress_level = archive.compresslevel\n+        if self.filename.endswith('/'):  # pragma: no cover\n+            self.external_attr = 0o40775 << 16  # drwxrwxr-x\n+            self.external_attr |= 0x10  # MS-DOS directory flag\n+        else:\n+            self.external_attr = 0o600 << 16  # ?rw-------\n+        return self\n+\n \n if __name__ == \"__main__\":\n     unittest.main()\n```\n\nFilename: Lib/zipfile.py:\n```\n@@ -2146,7 +2146,7 @@\ndef _parents(path):\n def _ancestry(path):\n     \"\"\"\n     Given a path with elements separated by\n-    posixpath.sep, generate all elements of that path\n+    posixpath.sep, generate all elements of that path.\n \n     >>> list(_ancestry('b/d'))\n     ['b/d', 'b']\n\n@@ -2158,9 +2158,14 @@\ndef _ancestry(path):\n     ['b']\n     >>> list(_ancestry(''))\n     []\n+\n+    Multiple separators are treated like a single.\n+\n+    >>> list(_ancestry('//b//d///f//'))\n+    ['//b//d///f', '//b//d', '//b']\n     \"\"\"\n     path = path.rstrip(posixpath.sep)\n-    while path and path != posixpath.sep:\n+    while path.rstrip(posixpath.sep):\n         yield path\n         path, tail = posixpath.split(path)\n```\n\nFilename: Misc/NEWS.d/next/Library/2024-08-26-13-45-20.gh-issue-123270.gXHvNJ.rst:\n```\n@@ -0,0 +1,3 @@\n+Applied a more surgical fix for malformed payloads in :class:`zipfile.Path`\n+causing infinite loops (gh-122905) without breaking contents using\n+legitimate characters.\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/fc0b8259e693caa8400fa8b6ac1e494e47ea7798",
                "content": "[3.11] gh-123270: Replaced SanitizedNames with a more surgical fix. (GH-123354) (#123425)\n\nApplies changes from zipp 3.20.1 and jaraco/zippGH-124\r\n(cherry picked from commit 2231286d78d328c2f575e0b05b16fe447d1656d6)\r\n\r\nCo-authored-by: Jason R. Coombs <jaraco@jaraco.com>\r\n\r\n* Restore the slash-prefixed paths in the malformed_paths test.\n\nFilename: Lib/test/test_zipfile.py:\n```\n@@ -3653,7 +3653,11 @@\ndef test_extract_orig_with_implied_dirs(self, alpharep):\n \n     def test_malformed_paths(self):\n         \"\"\"\n-        Path should handle malformed paths.\n+        Path should handle malformed paths gracefully.\n+\n+        Paths with leading slashes are not visible.\n+\n+        Paths with dots are treated like regular files.\n         \"\"\"\n         data = io.BytesIO()\n         zf = zipfile.ZipFile(data, \"w\")\n\n@@ -3662,11 +3666,67 @@\ndef test_malformed_paths(self):\n         zf.writestr(\"../parent.txt\", b\"content\")\n         zf.filename = ''\n         root = zipfile.Path(zf)\n-        assert list(map(str, root.iterdir())) == [\n-            'one-slash.txt',\n-            'two-slash.txt',\n-            'parent.txt',\n-        ]\n+        assert list(map(str, root.iterdir())) == ['../']\n+        assert root.joinpath('..').joinpath('parent.txt').read_bytes() == b'content'\n+\n+    def test_unsupported_names(self):\n+        \"\"\"\n+        Path segments with special characters are readable.\n+\n+        On some platforms or file systems, characters like\n+        ``:`` and ``?`` are not allowed, but they are valid\n+        in the zip file.\n+        \"\"\"\n+        data = io.BytesIO()\n+        zf = zipfile.ZipFile(data, \"w\")\n+        zf.writestr(\"path?\", b\"content\")\n+        zf.writestr(\"V: NMS.flac\", b\"fLaC...\")\n+        zf.filename = ''\n+        root = zipfile.Path(zf)\n+        contents = root.iterdir()\n+        assert next(contents).name == 'path?'\n+        assert next(contents).name == 'V: NMS.flac'\n+        assert root.joinpath('V: NMS.flac').read_bytes() == b\"fLaC...\"\n+\n+    def test_backslash_not_separator(self):\n+        \"\"\"\n+        In a zip file, backslashes are not separators.\n+        \"\"\"\n+        data = io.BytesIO()\n+        zf = zipfile.ZipFile(data, \"w\")\n+        zf.writestr(DirtyZipInfo.for_name(\"foo\\\\bar\", zf), b\"content\")\n+        zf.filename = ''\n+        root = zipfile.Path(zf)\n+        (first,) = root.iterdir()\n+        assert not first.is_dir()\n+        assert first.name == 'foo\\\\bar'\n+\n+\n+class DirtyZipInfo(zipfile.ZipInfo):\n+    \"\"\"\n+    Bypass name sanitization.\n+    \"\"\"\n+\n+    def __init__(self, filename, *args, **kwargs):\n+        super().__init__(filename, *args, **kwargs)\n+        self.filename = filename\n+\n+    @classmethod\n+    def for_name(cls, name, archive):\n+        \"\"\"\n+        Construct the same way that ZipFile.writestr does.\n+\n+        TODO: extract this functionality and re-use\n+        \"\"\"\n+        self = cls(filename=name, date_time=time.localtime(time.time())[:6])\n+        self.compress_type = archive.compression\n+        self.compress_level = archive.compresslevel\n+        if self.filename.endswith('/'):  # pragma: no cover\n+            self.external_attr = 0o40775 << 16  # drwxrwxr-x\n+            self.external_attr |= 0x10  # MS-DOS directory flag\n+        else:\n+            self.external_attr = 0o600 << 16  # ?rw-------\n+        return self\n \n \n class EncodedMetadataTests(unittest.TestCase):\n```\n\nFilename: Lib/zipfile.py:\n```\n@@ -2213,7 +2213,7 @@\ndef _parents(path):\n def _ancestry(path):\n     \"\"\"\n     Given a path with elements separated by\n-    posixpath.sep, generate all elements of that path\n+    posixpath.sep, generate all elements of that path.\n \n     >>> list(_ancestry('b/d'))\n     ['b/d', 'b']\n\n@@ -2225,9 +2225,14 @@\ndef _ancestry(path):\n     ['b']\n     >>> list(_ancestry(''))\n     []\n+\n+    Multiple separators are treated like a single.\n+\n+    >>> list(_ancestry('//b//d///f//'))\n+    ['//b//d///f', '//b//d', '//b']\n     \"\"\"\n     path = path.rstrip(posixpath.sep)\n-    while path and path != posixpath.sep:\n+    while path.rstrip(posixpath.sep):\n         yield path\n         path, tail = posixpath.split(path)\n\n@@ -2244,65 +2249,7 @@\ndef _difference(minuend, subtrahend):\n     return itertools.filterfalse(set(subtrahend).__contains__, minuend)\n \n \n-class SanitizedNames:\n-    \"\"\"\n-    ZipFile mix-in to ensure names are sanitized.\n-    \"\"\"\n-\n-    def namelist(self):\n-        return list(map(self._sanitize, super().namelist()))\n-\n-    @staticmethod\n-    def _sanitize(name):\n-        r\"\"\"\n-        Ensure a relative path with posix separators and no dot names.\n-        Modeled after\n-        https://github.com/python/cpython/blob/bcc1be39cb1d04ad9fc0bd1b9193d3972835a57c/Lib/zipfile/__init__.py#L1799-L1813\n-        but provides consistent cross-platform behavior.\n-        >>> san = SanitizedNames._sanitize\n-        >>> san('/foo/bar')\n-        'foo/bar'\n-        >>> san('//foo.txt')\n-        'foo.txt'\n-        >>> san('foo/.././bar.txt')\n-        'foo/bar.txt'\n-        >>> san('foo../.bar.txt')\n-        'foo../.bar.txt'\n-        >>> san('\\\\foo\\\\bar.txt')\n-        'foo/bar.txt'\n-        >>> san('D:\\\\foo.txt')\n-        'D/foo.txt'\n-        >>> san('\\\\\\\\server\\\\share\\\\file.txt')\n-        'server/share/file.txt'\n-        >>> san('\\\\\\\\?\\\\GLOBALROOT\\\\Volume3')\n-        '?/GLOBALROOT/Volume3'\n-        >>> san('\\\\\\\\.\\\\PhysicalDrive1\\\\root')\n-        'PhysicalDrive1/root'\n-        Retain any trailing slash.\n-        >>> san('abc/')\n-        'abc/'\n-        Raises a ValueError if the result is empty.\n-        >>> san('../..')\n-        Traceback (most recent call last):\n-        ...\n-        ValueError: Empty filename\n-        \"\"\"\n-\n-        def allowed(part):\n-            return part and part not in {'..', '.'}\n-\n-        # Remove the drive letter.\n-        # Don't use ntpath.splitdrive, because that also strips UNC paths\n-        bare = re.sub('^([A-Z]):', r'\\1', name, flags=re.IGNORECASE)\n-        clean = bare.replace('\\\\', '/')\n-        parts = clean.split('/')\n-        joined = '/'.join(filter(allowed, parts))\n-        if not joined:\n-            raise ValueError(\"Empty filename\")\n-        return joined + '/' * name.endswith('/')\n-\n-\n-class CompleteDirs(SanitizedNames, ZipFile):\n+class CompleteDirs(ZipFile):\n     \"\"\"\n     A ZipFile subclass that ensures that implied directories\n     are always included in the namelist.\n```\n\nFilename: Misc/NEWS.d/next/Library/2024-08-26-13-45-20.gh-issue-123270.gXHvNJ.rst:\n```\n@@ -0,0 +1,3 @@\n+Applied a more surgical fix for malformed payloads in :class:`zipfile.Path`\n+causing infinite loops (gh-122905) without breaking contents using\n+legitimate characters.\n```"
            },
            {
                "url": "https://github.com/python/cpython/commit/0aa1ee22ab6e204e9d3d0e9dd63ea648ed691ef1",
                "content": "[3.10] gh-123270: Replaced SanitizedNames with a more surgical fix. (GH-123354) (#123426)\n\nApplies changes from zipp 3.20.1 and jaraco/zippGH-124\r\n(cherry picked from commit 2231286d78d328c2f575e0b05b16fe447d1656d6)\r\n(cherry picked from commit 17b77bb)\r\n\r\nCo-authored-by: Jason R. Coombs <jaraco@jaraco.com>\n\nFilename: Lib/test/test_zipfile.py:\n```\n@@ -5,6 +5,7 @@\nimport itertools\n import os\n import pathlib\n+import platform\n import posixpath\n import string\n import struct\n\n@@ -3282,7 +3283,11 @@\ndef test_extract_orig_with_implied_dirs(self, alpharep):\n \n     def test_malformed_paths(self):\n         \"\"\"\n-        Path should handle malformed paths.\n+        Path should handle malformed paths gracefully.\n+\n+        Paths with leading slashes are not visible.\n+\n+        Paths with dots are treated like regular files.\n         \"\"\"\n         data = io.BytesIO()\n         zf = zipfile.ZipFile(data, \"w\")\n\n@@ -3291,11 +3296,70 @@\ndef test_malformed_paths(self):\n         zf.writestr(\"../parent.txt\", b\"content\")\n         zf.filename = ''\n         root = zipfile.Path(zf)\n-        assert list(map(str, root.iterdir())) == [\n-            'one-slash.txt',\n-            'two-slash.txt',\n-            'parent.txt',\n-        ]\n+        assert list(map(str, root.iterdir())) == ['../']\n+        assert root.joinpath('..').joinpath('parent.txt').read_bytes() == b'content'\n+\n+    @unittest.skipIf(platform.system() == \"Windows\", \"GH-123693\")\n+    def test_unsupported_names(self):\n+        \"\"\"\n+        Path segments with special characters are readable.\n+\n+        On some platforms or file systems, characters like\n+        ``:`` and ``?`` are not allowed, but they are valid\n+        in the zip file.\n+        \"\"\"\n+        data = io.BytesIO()\n+        zf = zipfile.ZipFile(data, \"w\")\n+        zf.writestr(\"path?\", b\"content\")\n+        zf.writestr(\"V: NMS.flac\", b\"fLaC...\")\n+        zf.filename = ''\n+        root = zipfile.Path(zf)\n+        contents = root.iterdir()\n+        assert next(contents).name == 'path?'\n+        item = next(contents)\n+        assert item.name == 'V: NMS.flac', item.name\n+        assert root.joinpath('V: NMS.flac').read_bytes() == b\"fLaC...\"\n+\n+    @unittest.skipIf(platform.system() == \"Windows\", \"GH-123693\")\n+    def test_backslash_not_separator(self):\n+        \"\"\"\n+        In a zip file, backslashes are not separators.\n+        \"\"\"\n+        data = io.BytesIO()\n+        zf = zipfile.ZipFile(data, \"w\")\n+        zf.writestr(DirtyZipInfo.for_name(\"foo\\\\bar\", zf), b\"content\")\n+        zf.filename = ''\n+        root = zipfile.Path(zf)\n+        (first,) = root.iterdir()\n+        assert not first.is_dir()\n+        assert first.name == 'foo\\\\bar', first.name\n+\n+\n+class DirtyZipInfo(zipfile.ZipInfo):\n+    \"\"\"\n+    Bypass name sanitization.\n+    \"\"\"\n+\n+    def __init__(self, filename, *args, **kwargs):\n+        super().__init__(filename, *args, **kwargs)\n+        self.filename = filename\n+\n+    @classmethod\n+    def for_name(cls, name, archive):\n+        \"\"\"\n+        Construct the same way that ZipFile.writestr does.\n+\n+        TODO: extract this functionality and re-use\n+        \"\"\"\n+        self = cls(filename=name, date_time=time.localtime(time.time())[:6])\n+        self.compress_type = archive.compression\n+        self.compress_level = archive.compresslevel\n+        if self.filename.endswith('/'):  # pragma: no cover\n+            self.external_attr = 0o40775 << 16  # drwxrwxr-x\n+            self.external_attr |= 0x10  # MS-DOS directory flag\n+        else:\n+            self.external_attr = 0o600 << 16  # ?rw-------\n+        return self\n \n \n class StripExtraTests(unittest.TestCase):\n```\n\nFilename: Lib/zipfile.py:\n```\n@@ -2152,7 +2152,7 @@\ndef _parents(path):\n def _ancestry(path):\n     \"\"\"\n     Given a path with elements separated by\n-    posixpath.sep, generate all elements of that path\n+    posixpath.sep, generate all elements of that path.\n \n     >>> list(_ancestry('b/d'))\n     ['b/d', 'b']\n\n@@ -2164,9 +2164,14 @@\ndef _ancestry(path):\n     ['b']\n     >>> list(_ancestry(''))\n     []\n+\n+    Multiple separators are treated like a single.\n+\n+    >>> list(_ancestry('//b//d///f//'))\n+    ['//b//d///f', '//b//d', '//b']\n     \"\"\"\n     path = path.rstrip(posixpath.sep)\n-    while path and path != posixpath.sep:\n+    while path.rstrip(posixpath.sep):\n         yield path\n         path, tail = posixpath.split(path)\n\n@@ -2183,65 +2188,7 @@\ndef _difference(minuend, subtrahend):\n     return itertools.filterfalse(set(subtrahend).__contains__, minuend)\n \n \n-class SanitizedNames:\n-    \"\"\"\n-    ZipFile mix-in to ensure names are sanitized.\n-    \"\"\"\n-\n-    def namelist(self):\n-        return list(map(self._sanitize, super().namelist()))\n-\n-    @staticmethod\n-    def _sanitize(name):\n-        r\"\"\"\n-        Ensure a relative path with posix separators and no dot names.\n-        Modeled after\n-        https://github.com/python/cpython/blob/bcc1be39cb1d04ad9fc0bd1b9193d3972835a57c/Lib/zipfile/__init__.py#L1799-L1813\n-        but provides consistent cross-platform behavior.\n-        >>> san = SanitizedNames._sanitize\n-        >>> san('/foo/bar')\n-        'foo/bar'\n-        >>> san('//foo.txt')\n-        'foo.txt'\n-        >>> san('foo/.././bar.txt')\n-        'foo/bar.txt'\n-        >>> san('foo../.bar.txt')\n-        'foo../.bar.txt'\n-        >>> san('\\\\foo\\\\bar.txt')\n-        'foo/bar.txt'\n-        >>> san('D:\\\\foo.txt')\n-        'D/foo.txt'\n-        >>> san('\\\\\\\\server\\\\share\\\\file.txt')\n-        'server/share/file.txt'\n-        >>> san('\\\\\\\\?\\\\GLOBALROOT\\\\Volume3')\n-        '?/GLOBALROOT/Volume3'\n-        >>> san('\\\\\\\\.\\\\PhysicalDrive1\\\\root')\n-        'PhysicalDrive1/root'\n-        Retain any trailing slash.\n-        >>> san('abc/')\n-        'abc/'\n-        Raises a ValueError if the result is empty.\n-        >>> san('../..')\n-        Traceback (most recent call last):\n-        ...\n-        ValueError: Empty filename\n-        \"\"\"\n-\n-        def allowed(part):\n-            return part and part not in {'..', '.'}\n-\n-        # Remove the drive letter.\n-        # Don't use ntpath.splitdrive, because that also strips UNC paths\n-        bare = re.sub('^([A-Z]):', r'\\1', name, flags=re.IGNORECASE)\n-        clean = bare.replace('\\\\', '/')\n-        parts = clean.split('/')\n-        joined = '/'.join(filter(allowed, parts))\n-        if not joined:\n-            raise ValueError(\"Empty filename\")\n-        return joined + '/' * name.endswith('/')\n-\n-\n-class CompleteDirs(SanitizedNames, ZipFile):\n+class CompleteDirs(ZipFile):\n     \"\"\"\n     A ZipFile subclass that ensures that implied directories\n     are always included in the namelist.\n```\n\nFilename: Misc/NEWS.d/next/Library/2024-08-26-13-45-20.gh-issue-123270.gXHvNJ.rst:\n```\n@@ -0,0 +1,3 @@\n+Applied a more surgical fix for malformed payloads in :class:`zipfile.Path`\n+causing infinite loops (gh-122905) without breaking contents using\n+legitimate characters.\n```"
            }
        ],
        "sw_version": "v3.8.19",
        "sw_version_wget": "https://github.com/python/cpython/archive/refs/tags/v3.8.19.zip",
        "description": "There is a HIGH severity vulnerability affecting the CPython \"zipfile\"\nmodule affecting \"zipfile.Path\". Note that the more common API \"zipfile.ZipFile\" class is unaffected.\n\n\n\n\n\nWhen iterating over names of entries in a zip archive (for example, methods\nof \"zipfile.Path\" like \"namelist()\", \"iterdir()\", etc)\nthe process can be put into an infinite loop with a maliciously crafted\nzip archive. This defect applies when reading only metadata or extracting\nthe contents of the zip archive. Programs that are not handling\nuser-controlled zip archives are not affected.",
        "sec_adv": [],
        "cwe": [
            {
                "id": "CWE-835",
                "value": "CWE-835 Loop with Unreachable Exit Condition ('Infinite Loop')"
            }
        ]
    }
}