{
    "overview": "This repository is the Calibre codebase (content server + library back-end). The CVE (CVE-2024-7009) is an SQL-injection in the full-text-search snippet/highlight machinery: user-supplied `highlight_start` / `highlight_end` values are embedded directly into dynamically-built SQLite SQL in the FTS code paths, allowing an attacker with \u201cfull-text search\u201d rights to inject arbitrary SQL (read other .sqlite files, ATTACH/CREATE TABLE, etc.).  \n\nKey relevance for reproducing the CVE:\n- Vulnerable code lives under `src/calibre/db/fts` (connect code that builds `snippet()` calls) and also related spots in `src/calibre/db/backend.py` (search_annotations) and `src/calibre/db/notes/connect.py`.  \n- The content server that exposes the HTTP endpoint `/fts/snippets/{book_ids}` is part of the source tree under `src/calibre/srv` (the server code routes/handlers call into the DB FTS functions).  \n- A local SQLite-based Calibre library and the server-users database (e.g. `server-users.sqlite`) are required to observe the impact: the vulnerable SQL is executed on the same SQLite connection and can ATTACH other .sqlite files on disk.\n\nThis report assumes you will run everything from the provided source tree (no containers) and reproduce the CVE in an isolated lab environment.",
    "files": "Essential files / places the next agent must inspect or use (paths are relative to repo root):\n\n- `README.md` (root) and `run-local`  \n  - Why: quick start / scripts for running the server from source. Use `run-local` first to see how the repo expects the content server to be launched and what environment variables / defaults it sets.\n\n- `pyproject.toml` and `setup.py`  \n  - Why: lists Python version constraints and third-party dependencies needed to run the content server. Install exact deps into a virtualenv.\n\n- `src/calibre/srv/` (server code)  \n  - Why: contains the HTTP handlers / routing for the content server (look for the handler that implements `/fts/snippets/{book_ids}` or any `fts`-named route). The reproduction will exercise this endpoint.\n\n- `src/calibre/db/fts/connect.py`  \n  - Why: primary vulnerable code that builds the `snippet(...)` SQL and executes it. Confirm whether the repository copy contains the vulnerable interpolation (f-strings inserting `highlight_start`/`highlight_end`) or the patched parameterized version.\n\n- `src/calibre/db/backend.py` (search_annotations)  \n  - Why: contains another call site where `highlight_start`/`highlight_end` may be interpolated into SQL \u2014 required to verify all relevant vulnerable locations.\n\n- `src/calibre/db/notes/connect.py`  \n  - Why: similar FTS highlights for notes \u2014 check for same unsafe interpolation.\n\n- `src/calibre/db/cli/` and `src/calibre/db/tests/`  \n  - Why: DB CLI/tools and tests may include helper scripts to create/populate a Calibre library which speeds reproduction.\n\n- Any sample or existing Calibre library in your environment (not in repo): `metadata.db` / `library.db` / `books` folder  \n  - Why: reproduction needs a real library (books and FTS indices) to call `/fts/snippets`. If none exists, create a minimal library (see notes below).\n\nNotes for the next agent:\n- Verify the exact lines in the three DB files above \u2014 the vulnerability is trivial to spot: look for `f'''snippet(... '{highlight_start}', '{highlight_end}', ... )'''` (vulnerable) vs `snippet(... ?, ?, ...)` plus binding (patched). If the repo already contains the patched code, check out a commit/tag <= `7.15.0` or the commit prior to the patch (the advisory references commit id `d5657428...` opposite the fix).\n- If the repository includes tests that set up FTS or snippet usage in `src/calibre/db/tests` or `src/calibre/srv/tests`, reuse those to build the minimal library and FTS tables.",
    "services": "Minimal services and runtime required to run and reproduce the issue (no external DB or network services required):\n\n- **Python runtime**  \n  - Required: a CPython interpreter matching the project requirements (see `pyproject.toml` / `setup.py`). Create an isolated virtualenv and install exact dependencies from the project (use `pip install -r` if a requirements file is present, or `pip install .` in editable mode after running `python setup.py develop` / `pip install -e .`).  \n  - Why: content server and DB code are Python.\n\n- **SQLite (builtin)**  \n  - Required: the OS-shipped SQLite library accessed via Python's `sqlite3` module. No external DB server \u2014 Calibre uses SQLite files on disk.  \n  - Why: vulnerability exploits the fact that the server executes arbitrary SQLite SQL on the same connection.\n\n- **Filesystem with writable locations for server and library**  \n  - Required: create a test Calibre library directory (a folder containing Calibre sqlite DBs and `books` subdir) and ensure the user running the server has read/write access to the data directory if you want to test file-write via ATTACH/CREATE TABLE. On Windows-style paths, `server-users.sqlite` often lives in the Calibre data dir \u2014 when reproducing, create a `server-users.sqlite` in a known path you can refer to.  \n  - Why: attacker can ATTACH and read/CREATE SQLite files on disk.\n\n- **Content server runner (local)**  \n  - Required: use the `run-local` script or the documented `calibre-server` entry point provided in the repo to start the content server from source. Configure server options (library path, data dir, port) so you can send HTTP requests to it.  \n  - Recommended configuration for reproducing CVE:\n    - Run on loopback only (e.g., `127.0.0.1`) and a non-privileged port (e.g., `8080`) to keep the experiment isolated.\n    - Use a dedicated OS user with access only to the test directories.\n    - Point the server to a test Calibre library folder and to a test `server-users.sqlite` file you create (so reading that file is safe and isolated).\n    - Ensure a test account exists with **full-text search** rights (create via the server admin or the server-users DB) \u2014 this account is needed to reach the vulnerable code path.\n\nWhat *not* to spin up:\n- No external RDBMS (Postgres/MySQL) is needed \u2014 Calibre uses SQLite.\n- No containers are required by instructions \u2014 run locally from source.\n\nOptional helpful tools:\n- An HTTP client (curl, httpie, or a small Python script) to exercise `/fts/snippets/{book_ids}` with crafted query parameters. (Do not run experiments on production data.)",
    "output": "Expected final state and how the next agent will interact with it:\n\n- Final state when setup is correct:\n  - The Calibre content server is running from source (using the repo's `run-local` or server entry point), listening on the configured loopback address and port.\n  - The server is pointed at a test library containing at least one book with FTS enabled (so `books_text` / `books_fts_*` tables exist), and the `server-users.sqlite` test file exists at a known filesystem path accessible to the server process.\n  - A test user exists with **full-text search** privileges.\n\n- How to validate the setup (high-level, non-exploitative):\n  - Send a normal full-text search / snippets request to the server\u2019s `/fts/snippets/{book_ids}` endpoint with safe `highlight_start`/`highlight_end` values and confirm you receive JSON with snippet(s). This proves the end-to-end plumbing (HTTP \u2192 handler \u2192 FTS query \u2192 SQLite) is working.\n  - Inspect the server logs / stdout for any errors while serving FTS requests.\n\n- What the reproducer should observe when the vulnerable code is present:\n  - When the HTTP endpoint is exercised with specially crafted `highlight_start` or `highlight_end` that break out of the snippet literal, the server executes the injected SQL on the same SQLite connection. The response for `/fts/snippets/...` may then contain data rows derived from the injected SELECTs (for example, rows read from an attached `server-users.sqlite` file), or the file system may receive new SQLite files written via CREATE TABLE AS SELECT. In short: **arbitrary read (and limited write) via SQLite ATTACH / CREATE TABLE** becomes possible from that endpoint.\n  - If the repository already contains the patched code (parameterized `snippet(... ?, ? , ...)` with bindings), you will *not* be able to reproduce the injection; in that case check out a tag/commit \u2264 v7.15.0 or the commit immediately before the referenced fix (`d5657428...`) to obtain the vulnerable code.\n\nSafety & operational notes:\n- Perform all reproduction on isolated test data and an isolated machine or VM. Do not run these tests against any production library or user data. Use a dedicated data directory and a disposable `server-users.sqlite` for testing.\n- The output that demonstrates successful reproduction will be either (a) HTTP JSON responses containing rows that originate from another SQLite file attached by the injected SQL or (b) the presence of new .sqlite files created by an injected CREATE TABLE on disk in a writable folder."
}