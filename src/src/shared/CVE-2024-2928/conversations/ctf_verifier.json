{
    "verifier": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCTF Verifier / Sanitizer for CVE-2024-2928 (MLflow 2.9.2 LFI via fragment traversal)\n\nStructure:\n  - Pre-setup:\n      * Ensure the MLflow tracking server is reachable at http://127.0.0.1:9600/.\n      * If it's not up and the port is free, start it. If the port is already in use, assume it's the correct server.\n      * NOTE: No special data preparation is needed because we read a well-known host file (/etc/passwd) to verify.\n  - Exploit:\n      * If './exploit.py' exists, attempt to run it (best-effort; we continue either way).\n  - Post-exploit:\n      * Download /etc/passwd via: /model-versions/get-artifact?path=passwd&name=<model>&version=<ver>\n      * If content looks like passwd (e.g., contains 'root:'), print the flag: 3xploit66full\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport json\nimport socket\nimport subprocess\nimport urllib.request\nimport urllib.error\n\nMLFLOW_HOST = os.environ.get(\"MLFLOW_HOST\", \"127.0.0.1\")\nMLFLOW_PORT = int(os.environ.get(\"MLFLOW_PORT\", \"9600\"))\nBASE = f\"http://{MLFLOW_HOST}:{MLFLOW_PORT}\"\n\n# ---------- Utilities ----------\n\ndef _http_get(url, timeout=5):\n    req = urllib.request.Request(url, method=\"GET\")\n    with urllib.request.urlopen(req, timeout=timeout) as resp:\n        return resp.getcode(), resp.read()\n\ndef port_in_use(port, host=\"127.0.0.1\"):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.settimeout(0.5)\n        return s.connect_ex((host, port)) == 0\n\ndef wait_for_server(timeout=20):\n    \"\"\"Wait until the MLflow server responds to HTTP within 'timeout' seconds.\"\"\"\n    deadline = time.time() + timeout\n    last_err = None\n    while time.time() < deadline:\n        try:\n            code, _ = _http_get(BASE + \"/\")\n            if 200 <= code < 500:\n                return True\n        except Exception as e:\n            last_err = e\n        time.sleep(0.5)\n    if last_err:\n        print(f\"[!] Server not reachable within timeout: {last_err}\", file=sys.stderr)\n    return False\n\ndef start_server_if_needed():\n    \"\"\"\n    Start mlflow UI on 127.0.0.1:9600 only if it's not already responding.\n    If the port is busy, assume the proper server is already running.\n    \"\"\"\n    # Already reachable? Nothing to do.\n    try:\n        if wait_for_server(timeout=3):\n            print(\"[i] MLflow server already responding at\", BASE)\n            return None\n    except Exception:\n        pass\n\n    # If port is busy, assume existing MLflow server (do NOT start another).\n    if port_in_use(MLFLOW_PORT, MLFLOW_HOST):\n        print(\"[i] Port in use; assuming MLflow server is already running at\", BASE)\n        # Still give it a moment and verify reachability.\n        if not wait_for_server(timeout=10):\n            print(\"[!] Port is in use but server is not responding. Proceeding anyway (requests may fail).\", file=sys.stderr)\n        return None\n\n    # Try to start server ourselves.\n    print(\"[i] Starting MLflow server on\", BASE)\n    proc = subprocess.Popen(\n        [\"mlflow\", \"ui\", \"--host\", MLFLOW_HOST, \"--port\", str(MLFLOW_PORT)],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT,\n        text=True,\n        bufsize=1,\n        env={**os.environ},\n    )\n    # Wait for it to accept connections.\n    if not wait_for_server(timeout=25):\n        print(\"[!] Failed to confirm MLflow server startup; logs follow:\", file=sys.stderr)\n        try:\n            # Drain a bit of output for context (non-fatal).\n            for _ in range(20):\n                line = proc.stdout.readline()\n                if not line:\n                    break\n                sys.stderr.write(line)\n        except Exception:\n            pass\n    return proc\n\ndef run_exploit_py_if_present():\n    \"\"\"Best-effort attempt to run local exploit.py. We do not assume its interface.\"\"\"\n    if os.path.isfile(\"exploit.py\"):\n        print(\"[i] Found exploit.py; attempting to run it (best-effort).\")\n        try:\n            result = subprocess.run(\n                [sys.executable, \"exploit.py\"],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                text=True,\n                timeout=120,\n            )\n            print(\"[i] exploit.py exited with code\", result.returncode)\n            if result.stdout:\n                print(\"[exploit.py stdout]\\n\" + result.stdout[:2000])\n            if result.stderr:\n                print(\"[exploit.py stderr]\\n\" + result.stderr[:2000], file=sys.stderr)\n        except subprocess.TimeoutExpired:\n            print(\"[!] exploit.py timed out; continuing with built-in verifier steps.\", file=sys.stderr)\n        except Exception as e:\n            print(f\"[!] exploit.py execution failed ({e}); continuing.\", file=sys.stderr)\n    else:\n        print(\"[i] No exploit.py found; proceeding with built-in verifier steps.\")\n\n# ---------- Post-exploit check ----------\n\ndef fetch_sensitive_file_via_artifact(name, version, path=\"passwd\"):\n    # Example: /model-versions/get-artifact?path=passwd&name=poc&version=1\n    url = f\"{BASE}/model-versions/get-artifact?path={path}&name={name}&version={version}\"\n    code, body = _http_get(url)\n    content = body.decode(\"latin-1\", errors=\"ignore\")\n    return code, content\n\n# ---------- Verifier flow ----------\n\ndef main():\n    # --- Pre-setup ---\n    server_proc = start_server_if_needed()\n\n    if not wait_for_server(timeout=20):\n        print(\"[!] MLflow server not reachable; aborting.\", file=sys.stderr)\n        sys.exit(2)\n\n    # --- Exploit (run provided exploit.py if present) ---\n    run_exploit_py_if_present()\n\n    # --- Post-exploit check ---\n    try:\n        # The exploit should create the artifact location and provide access to sensitive file\n        code, content = fetch_sensitive_file_via_artifact(\"poc\", \"1\", path=\"passwd\")\n        print(f\"[i] GET artifact HTTP {code}\")\n        # Quick heuristic for /etc/passwd content\n        if \"root:\" in content and \"/bin\" in content:\n            print(\"3xploit66full\")  # <-- required flag output on success\n            return\n        print(\"[!] Exploit did not yield expected file contents. Verification failed.\", file=sys.stderr)\n        sys.exit(3)\n    except Exception as e:\n        print(f\"[!] Error during post-exploit check: {e}\", file=sys.stderr)\n        sys.exit(3)\n\nif __name__ == \"__main__\":\n    main()"
}