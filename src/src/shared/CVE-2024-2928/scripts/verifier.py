#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CTF Verifier / Sanitizer for CVE-2024-2928 (MLflow 2.9.2 LFI via fragment traversal)

Structure:
  - Pre-setup:
      * Ensure the MLflow tracking server is reachable at http://127.0.0.1:9600/.
      * If it's not up and the port is free, start it. If the port is already in use, assume it's the correct server.
      * NOTE: No special data preparation is needed because we read a well-known host file (/etc/passwd) to verify.
  - Exploit:
      * If './exploit.py' exists, attempt to run it (best-effort; we continue either way).
  - Post-exploit:
      * Download /etc/passwd via: /model-versions/get-artifact?path=passwd&name=<model>&version=<ver>
      * If content looks like passwd (e.g., contains 'root:'), print the flag: 3xploit66full
"""

import os
import sys
import time
import json
import socket
import subprocess
import urllib.request
import urllib.error

MLFLOW_HOST = os.environ.get("MLFLOW_HOST", "127.0.0.1")
MLFLOW_PORT = int(os.environ.get("MLFLOW_PORT", "9600"))
BASE = f"http://{MLFLOW_HOST}:{MLFLOW_PORT}"

# ---------- Utilities ----------

def _http_get(url, timeout=5):
    req = urllib.request.Request(url, method="GET")
    with urllib.request.urlopen(req, timeout=timeout) as resp:
        return resp.getcode(), resp.read()

def port_in_use(port, host="127.0.0.1"):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.settimeout(0.5)
        return s.connect_ex((host, port)) == 0

def wait_for_server(timeout=20):
    """Wait until the MLflow server responds to HTTP within 'timeout' seconds."""
    deadline = time.time() + timeout
    last_err = None
    while time.time() < deadline:
        try:
            code, _ = _http_get(BASE + "/")
            if 200 <= code < 500:
                return True
        except Exception as e:
            last_err = e
        time.sleep(0.5)
    if last_err:
        print(f"[!] Server not reachable within timeout: {last_err}", file=sys.stderr)
    return False

def start_server_if_needed():
    """
    Start mlflow UI on 127.0.0.1:9600 only if it's not already responding.
    If the port is busy, assume the proper server is already running.
    """
    # Already reachable? Nothing to do.
    try:
        if wait_for_server(timeout=3):
            print("[i] MLflow server already responding at", BASE)
            return None
    except Exception:
        pass

    # If port is busy, assume existing MLflow server (do NOT start another).
    if port_in_use(MLFLOW_PORT, MLFLOW_HOST):
        print("[i] Port in use; assuming MLflow server is already running at", BASE)
        # Still give it a moment and verify reachability.
        if not wait_for_server(timeout=10):
            print("[!] Port is in use but server is not responding. Proceeding anyway (requests may fail).", file=sys.stderr)
        return None

    # Try to start server ourselves.
    print("[i] Starting MLflow server on", BASE)
    proc = subprocess.Popen(
        ["mlflow", "ui", "--host", MLFLOW_HOST, "--port", str(MLFLOW_PORT)],
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
        bufsize=1,
        env={**os.environ},
    )
    # Wait for it to accept connections.
    if not wait_for_server(timeout=25):
        print("[!] Failed to confirm MLflow server startup; logs follow:", file=sys.stderr)
        try:
            # Drain a bit of output for context (non-fatal).
            for _ in range(20):
                line = proc.stdout.readline()
                if not line:
                    break
                sys.stderr.write(line)
        except Exception:
            pass
    return proc

def run_exploit_py_if_present():
    """Best-effort attempt to run local exploit.py. We do not assume its interface."""
    if os.path.isfile("exploit.py"):
        print("[i] Found exploit.py; attempting to run it (best-effort).")
        try:
            result = subprocess.run(
                [sys.executable, "exploit.py"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                timeout=120,
            )
            print("[i] exploit.py exited with code", result.returncode)
            if result.stdout:
                print("[exploit.py stdout]\n" + result.stdout[:2000])
            if result.stderr:
                print("[exploit.py stderr]\n" + result.stderr[:2000], file=sys.stderr)
        except subprocess.TimeoutExpired:
            print("[!] exploit.py timed out; continuing with built-in verifier steps.", file=sys.stderr)
        except Exception as e:
            print(f"[!] exploit.py execution failed ({e}); continuing.", file=sys.stderr)
    else:
        print("[i] No exploit.py found; proceeding with built-in verifier steps.")

# ---------- Post-exploit check ----------

def fetch_sensitive_file_via_artifact(name, version, path="passwd"):
    # Example: /model-versions/get-artifact?path=passwd&name=poc&version=1
    url = f"{BASE}/model-versions/get-artifact?path={path}&name={name}&version={version}"
    code, body = _http_get(url)
    content = body.decode("latin-1", errors="ignore")
    return code, content

# ---------- Verifier flow ----------

def main():
    # --- Pre-setup ---
    server_proc = start_server_if_needed()

    if not wait_for_server(timeout=20):
        print("[!] MLflow server not reachable; aborting.", file=sys.stderr)
        sys.exit(2)

    # --- Exploit (run provided exploit.py if present) ---
    run_exploit_py_if_present()

    # --- Post-exploit check ---
    try:
        # The exploit should create the artifact location and provide access to sensitive file
        code, content = fetch_sensitive_file_via_artifact("poc", "1", path="passwd")
        print(f"[i] GET artifact HTTP {code}")
        # Quick heuristic for /etc/passwd content
        if "root:" in content and "/bin" in content:
            print("3xploit66full")  # <-- required flag output on success
            return
        print("[!] Exploit did not yield expected file contents. Verification failed.", file=sys.stderr)
        sys.exit(3)
    except Exception as e:
        print(f"[!] Error during post-exploit check: {e}", file=sys.stderr)
        sys.exit(3)

if __name__ == "__main__":
    main()