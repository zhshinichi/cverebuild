#!/usr/bin/env python3
"""
Verifier / Sanitizer for CVE-2024-0520 PoC (exploit.py)

This script performs three phases:

1. Pre-setup
   • Ensures the vulnerable version of mlflow (2.8.1) and its run-time
     dependencies are installed (Flask & pandas).
   • Chooses a unique, attacker-controlled absolute path inside the system’s
     temporary directory that the exploit should overwrite.  If the file
     already exists it is removed.

2. Exploit
   • Executes the supplied exploit.py, passing the chosen target path.

3. Post-exploit
   • Checks whether the file was created and contains the exact payload
     “owned-by-cve-2024-0520\n”.
   • If so, prints the flag “3xploit66full”; otherwise exits with an error.

Usage:
    python verifier.py
"""

import os
import sys
import subprocess
import tempfile
import uuid
from pathlib import Path

FLAG = "3xploit66full"
PAYLOAD = b"owned-by-cve-2024-0520\n"
EXPLOIT_SCRIPT = "exploit.py"


def ensure_vulnerable_mlflow():
    """
    Guarantee that mlflow==2.8.1 (vulnerable) and required deps are present.
    Installs them silently if missing / wrong version.
    """
    try:
        import importlib.metadata as importlib_metadata  # Python 3.8+
    except ImportError:  # pragma: no cover
        import importlib_metadata  # type: ignore

    def pkg_version(name):
        try:
            return importlib_metadata.version(name)
        except importlib_metadata.PackageNotFoundError:
            return None

    required = {"mlflow": "2.8.1", "flask": None, "pandas": None}
    to_install = []
    for pkg, ver in required.items():
        cur_ver = pkg_version(pkg)
        if cur_ver is None or (ver and cur_ver != ver):
            to_install.append(f"{pkg}=={ver}" if ver else pkg)

    if to_install:
        print(f"[*] Installing/upgrading packages: {' '.join(to_install)}")
        subprocess.check_call(
            [sys.executable, "-m", "pip", "install", "--quiet", "--disable-pip-version-check", *to_install]
        )


def pre_setup() -> str:
    """
    Create a unique absolute path in a writable directory (/tmp) that the
    exploit should overwrite. Returns that path.
    """
    tmp_dir = tempfile.gettempdir()
    target_path = os.path.join(tmp_dir, f"ctf_cve_0520_{uuid.uuid4().hex}.txt")

    # Remove pre-existing file if any
    try:
        os.remove(target_path)
    except FileNotFoundError:
        pass

    return target_path


def run_exploit(target_path: str):
    """
    Execute exploit.py with the chosen target path.
    """
    if not Path(EXPLOIT_SCRIPT).is_file():
        print(f"[!] {EXPLOIT_SCRIPT} not found in current directory.", file=sys.stderr)
        sys.exit(1)

    print(f"[*] Launching exploit against target path: {target_path}")
    result = subprocess.run(
        [sys.executable, EXPLOIT_SCRIPT, target_path],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
    )
    if result.returncode != 0:
        print("[!] exploit.py exited with a non-zero status.")
        print("STDOUT:", result.stdout)
        print("STDERR:", result.stderr, file=sys.stderr)
        sys.exit(1)


def verify_success(target_path: str) -> bool:
    """
    Verify that the exploit succeeded by ensuring the file exists and contains
    the expected payload.
    """
    if not os.path.exists(target_path):
        return False

    try:
        with open(target_path, "rb") as fp:
            data = fp.read()
    except Exception:
        return False

    return data == PAYLOAD


def main():
    # ------------- Pre-setup -------------
    ensure_vulnerable_mlflow()
    target_path = pre_setup()

    # ------------- Exploit --------------
    run_exploit(target_path)

    # ---------- Post-exploit ------------
    if verify_success(target_path):
        print(FLAG)
    else:
        print("[!] Exploit did NOT succeed – flag withheld.", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()