import re
from agentlib import Agent
from agentlib.lib.common.parsers import BaseParser
from typing import Optional

OUTPUT_DESCRIPTION = '''
在完成分析后，你必须按照以下格式输出报告：
```
<report>
<analysis>...</analysis>
<decision>...</decision>
<possible>...</possible>
<feedback>...</feedback>
</report>
```
在 <analysis></analysis> 中，分析 Web 漏洞复现的过程和结果
在 <decision></decision> 中，判断复现是否成功。只能使用 "yes"（成功）或 "no"（失败）
在 <possible></possible> 中，如果失败，判断是否可以改进。只能使用 "yes" 或 "no"（如果成功则填 "n/a"）
在 <feedback></feedback> 中，如果失败且可以改进，提供改进建议（如果成功或无法改进则填 "n/a"）
'''

class MyParser(BaseParser):
    MAX_FIX_FORMAT_TRIES = 3
    
    def parse(self, text: str) -> dict:
        report_pattern = r'<report>(.*?)</report>'
        report_match = re.search(report_pattern, text, re.DOTALL)
        
        if not report_match:
            raise ValueError("未找到 <report> 标签")
        
        report_content = report_match.group(1)
        
        # 提取各个字段
        analysis_match = re.search(r'<analysis>(.*?)</analysis>', report_content, re.DOTALL)
        decision_match = re.search(r'<decision>(.*?)</decision>', report_content, re.DOTALL)
        possible_match = re.search(r'<possible>(.*?)</possible>', report_content, re.DOTALL)
        feedback_match = re.search(r'<feedback>(.*?)</feedback>', report_content, re.DOTALL)
        
        if not all([analysis_match, decision_match, possible_match, feedback_match]):
            raise ValueError("报告格式不完整，缺少必要字段")
        
        result = {
            'analysis': analysis_match.group(1).strip(),
            'decision': decision_match.group(1).strip().lower(),
            'possible': possible_match.group(1).strip().lower(),
            'feedback': feedback_match.group(1).strip()
        }
        
        # 验证 decision 和 possible 的值
        if result['decision'] not in ['yes', 'no']:
            raise ValueError(f"decision 必须是 'yes' 或 'no'，当前值: {result['decision']}")
        
        if result['possible'] not in ['yes', 'no', 'n/a']:
            raise ValueError(f"possible 必须是 'yes', 'no' 或 'n/a'，当前值: {result['possible']}")
        
        return result
    
    def get_format_instructions(self) -> str:
        return OUTPUT_DESCRIPTION

class WebExploitCritic(Agent[dict, str]):
    """
    Critic agent for validating web-based vulnerability exploitation
    Analyzes browser automation logs and verifies if the exploit was successful
    """
    __LLM_MODEL__ = 'gpt-5'
    __SYSTEM_PROMPT_TEMPLATE__ = 'webExploitCritic/webExploitCritic.system.j2'
    __USER_PROMPT_TEMPLATE__ = 'webExploitCritic/webExploitCritic.user.j2'
    __OUTPUT_PARSER__ = MyParser()
    
    EXPLOIT_LOGS: Optional[str]
    CVE_KNOWLEDGE: Optional[str]
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.EXPLOIT_LOGS = kwargs.get('exploit_logs')
        self.CVE_KNOWLEDGE = kwargs.get('cve_knowledge')
    
    def get_input_vars(self, *args, **kwargs) -> dict:
        vars = super().get_input_vars(*args, **kwargs)
        vars.update(
            EXPLOIT_LOGS = self.EXPLOIT_LOGS,
            CVE_KNOWLEDGE = self.CVE_KNOWLEDGE,
            OUTPUT_FORMAT = OUTPUT_DESCRIPTION
        )
        return vars
    
    def get_cost(self, *args, **kw) -> float:
        total_cost = 0
        for model_name, token_usage in self.token_usage.items():
            total_cost += token_usage.get_costs(model_name)['total_cost']
        return total_cost
